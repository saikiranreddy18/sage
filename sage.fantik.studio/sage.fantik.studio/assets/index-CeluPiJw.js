var HF = Object.defineProperty;
var VF = (r, e, t) => e in r ? HF(r, e, {
    enumerable: !0,
    configurable: !0,
    writable: !0,
    value: t
}) : r[e] = t;
var ss = (r, e, t) => VF(r, typeof e != "symbol" ? e + "" : e, t);
import {
    r as N,
    a as WF,
    g as aS,
    R as ga
} from "./vendor-C_gYsUBP.js";
(function() {
    const e = document.createElement("link").relList;
    if (e && e.supports && e.supports("modulepreload")) return;
    for (const i of document.querySelectorAll('link[rel="modulepreload"]')) n(i);
    new MutationObserver(i => {
        for (const s of i)
            if (s.type === "childList")
                for (const o of s.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && n(o)
    }).observe(document, {
        childList: !0,
        subtree: !0
    });

    function t(i) {
        const s = {};
        return i.integrity && (s.integrity = i.integrity), i.referrerPolicy && (s.referrerPolicy = i.referrerPolicy), i.crossOrigin === "use-credentials" ? s.credentials = "include" : i.crossOrigin === "anonymous" ? s.credentials = "omit" : s.credentials = "same-origin", s
    }

    function n(i) {
        if (i.ep) return;
        i.ep = !0;
        const s = t(i);
        fetch(i.href, s)
    }
})();
var k2 = {
        exports: {}
    },
    Zv = {};
/**
 * @license React
 * react-jsx-runtime.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var jF = N,
    XF = Symbol.for("react.element"),
    YF = Symbol.for("react.fragment"),
    JF = Object.prototype.hasOwnProperty,
    KF = jF.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,
    qF = {
        key: !0,
        ref: !0,
        __self: !0,
        __source: !0
    };

function z2(r, e, t) {
    var n, i = {},
        s = null,
        o = null;
    t !== void 0 && (s = "" + t), e.key !== void 0 && (s = "" + e.key), e.ref !== void 0 && (o = e.ref);
    for (n in e) JF.call(e, n) && !qF.hasOwnProperty(n) && (i[n] = e[n]);
    if (r && r.defaultProps)
        for (n in e = r.defaultProps, e) i[n] === void 0 && (i[n] = e[n]);
    return {
        $$typeof: XF,
        type: r,
        key: s,
        ref: o,
        props: i,
        _owner: KF.current
    }
}
Zv.Fragment = YF;
Zv.jsx = z2;
Zv.jsxs = z2;
k2.exports = Zv;
var G = k2.exports,
    D1 = {},
    G2, tT = WF;
G2 = D1.createRoot = tT.createRoot, D1.hydrateRoot = tT.hydrateRoot;

function ra(r) {
    if (r === void 0) throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    return r
}

function H2(r, e) {
    r.prototype = Object.create(e.prototype), r.prototype.constructor = r, r.__proto__ = e
}
/*!
 * GSAP 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var vs = {
        autoSleep: 120,
        force3D: "auto",
        nullTargetWarn: 1,
        units: {
            lineHeight: ""
        }
    },
    Hf = {
        duration: .5,
        overwrite: !1,
        delay: 0
    },
    lS, pr, Kn, js = 1e8,
    Gn = 1 / js,
    L1 = Math.PI * 2,
    ZF = L1 / 4,
    QF = 0,
    V2 = Math.sqrt,
    $F = Math.cos,
    eU = Math.sin,
    Xi = function(e) {
        return typeof e == "string"
    },
    hi = function(e) {
        return typeof e == "function"
    },
    wa = function(e) {
        return typeof e == "number"
    },
    cS = function(e) {
        return typeof e > "u"
    },
    No = function(e) {
        return typeof e == "object"
    },
    Xr = function(e) {
        return e !== !1
    },
    uS = function() {
        return typeof window < "u"
    },
    ng = function(e) {
        return hi(e) || Xi(e)
    },
    W2 = typeof ArrayBuffer == "function" && ArrayBuffer.isView || function() {},
    mr = Array.isArray,
    F1 = /(?:-?\.?\d|\.)+/gi,
    j2 = /[-+=.]*\d+[.e\-+]*\d*[e\-+]*\d*/g,
    hf = /[-+=.]*\d+[.e-]*\d*[a-z%]*/g,
    H_ = /[-+=.]*\d+\.?\d*(?:e-|e\+)?\d*/gi,
    X2 = /[+-]=-?[.\d]+/,
    Y2 = /[^,'"\[\]\s]+/gi,
    tU = /^[+\-=e\s\d]*\d+[.\d]*([a-z]*|%)\s*$/i,
    ii, bo, U1, fS, xs = {},
    N0 = {},
    J2, K2 = function(e) {
        return (N0 = eu(e, xs)) && Zr
    },
    hS = function(e, t) {
        return console.warn("Invalid property", e, "set to", t, "Missing plugin? gsap.registerPlugin()")
    },
    rp = function(e, t) {
        return !t && console.warn(e)
    },
    q2 = function(e, t) {
        return e && (xs[e] = t) && N0 && (N0[e] = t) || xs
    },
    sp = function() {
        return 0
    },
    nU = {
        suppressEvents: !0,
        isStart: !0,
        kill: !1
    },
    A0 = {
        suppressEvents: !0,
        kill: !1
    },
    iU = {
        suppressEvents: !0
    },
    dS = {},
    ul = [],
    O1 = {},
    Z2, fs = {},
    V_ = {},
    nT = 30,
    S0 = [],
    pS = "",
    mS = function(e) {
        var t = e[0],
            n, i;
        if (No(t) || hi(t) || (e = [e]), !(n = (t._gsap || {}).harness)) {
            for (i = S0.length; i-- && !S0[i].targetTest(t););
            n = S0[i]
        }
        for (i = e.length; i--;) e[i] && (e[i]._gsap || (e[i]._gsap = new AP(e[i], n))) || e.splice(i, 1);
        return e
    },
    kc = function(e) {
        return e._gsap || mS(Xs(e))[0]._gsap
    },
    Q2 = function(e, t, n) {
        return (n = e[t]) && hi(n) ? e[t]() : cS(n) && e.getAttribute && e.getAttribute(t) || n
    },
    Yr = function(e, t) {
        return (e = e.split(",")).forEach(t) || e
    },
    Ai = function(e) {
        return Math.round(e * 1e5) / 1e5 || 0
    },
    Vi = function(e) {
        return Math.round(e * 1e7) / 1e7 || 0
    },
    bf = function(e, t) {
        var n = t.charAt(0),
            i = parseFloat(t.substr(2));
        return e = parseFloat(e), n === "+" ? e + i : n === "-" ? e - i : n === "*" ? e * i : e / i
    },
    rU = function(e, t) {
        for (var n = t.length, i = 0; e.indexOf(t[i]) < 0 && ++i < n;);
        return i < n
    },
    k0 = function() {
        var e = ul.length,
            t = ul.slice(0),
            n, i;
        for (O1 = {}, ul.length = 0, n = 0; n < e; n++) i = t[n], i && i._lazy && (i.render(i._lazy[0], i._lazy[1], !0)._lazy = 0)
    },
    $2 = function(e, t, n, i) {
        ul.length && !pr && k0(), e.render(t, n, pr && t < 0 && (e._initted || e._startAt)), ul.length && !pr && k0()
    },
    eP = function(e) {
        var t = parseFloat(e);
        return (t || t === 0) && (e + "").match(Y2).length < 2 ? t : Xi(e) ? e.trim() : e
    },
    tP = function(e) {
        return e
    },
    qs = function(e, t) {
        for (var n in t) n in e || (e[n] = t[n]);
        return e
    },
    sU = function(e) {
        return function(t, n) {
            for (var i in n) i in t || i === "duration" && e || i === "ease" || (t[i] = n[i])
        }
    },
    eu = function(e, t) {
        for (var n in t) e[n] = t[n];
        return e
    },
    iT = function r(e, t) {
        for (var n in t) n !== "__proto__" && n !== "constructor" && n !== "prototype" && (e[n] = No(t[n]) ? r(e[n] || (e[n] = {}), t[n]) : t[n]);
        return e
    },
    z0 = function(e, t) {
        var n = {},
            i;
        for (i in e) i in t || (n[i] = e[i]);
        return n
    },
    Cd = function(e) {
        var t = e.parent || ii,
            n = e.keyframes ? sU(mr(e.keyframes)) : qs;
        if (Xr(e.inherit))
            for (; t;) n(e, t.vars.defaults), t = t.parent || t._dp;
        return e
    },
    oU = function(e, t) {
        for (var n = e.length, i = n === t.length; i && n-- && e[n] === t[n];);
        return n < 0
    },
    nP = function(e, t, n, i, s) {
        var o = e[i],
            a;
        if (s)
            for (a = t[s]; o && o[s] > a;) o = o._prev;
        return o ? (t._next = o._next, o._next = t) : (t._next = e[n], e[n] = t), t._next ? t._next._prev = t : e[i] = t, t._prev = o, t.parent = t._dp = e, t
    },
    Qv = function(e, t, n, i) {
        n === void 0 && (n = "_first"), i === void 0 && (i = "_last");
        var s = t._prev,
            o = t._next;
        s ? s._next = o : e[n] === t && (e[n] = o), o ? o._prev = s : e[i] === t && (e[i] = s), t._next = t._prev = t.parent = null
    },
    vl = function(e, t) {
        e.parent && (!t || e.parent.autoRemoveChildren) && e.parent.remove && e.parent.remove(e), e._act = 0
    },
    zc = function(e, t) {
        if (e && (!t || t._end > e._dur || t._start < 0))
            for (var n = e; n;) n._dirty = 1, n = n.parent;
        return e
    },
    aU = function(e) {
        for (var t = e.parent; t && t.parent;) t._dirty = 1, t.totalDuration(), t = t.parent;
        return e
    },
    N1 = function(e, t, n, i) {
        return e._startAt && (pr ? e._startAt.revert(A0) : e.vars.immediateRender && !e.vars.autoRevert || e._startAt.render(t, !0, i))
    },
    lU = function r(e) {
        return !e || e._ts && r(e.parent)
    },
    rT = function(e) {
        return e._repeat ? Vf(e._tTime, e = e.duration() + e._rDelay) * e : 0
    },
    Vf = function(e, t) {
        var n = Math.floor(e /= t);
        return e && n === e ? n - 1 : n
    },
    G0 = function(e, t) {
        return (e - t._start) * t._ts + (t._ts >= 0 ? 0 : t._dirty ? t.totalDuration() : t._tDur)
    },
    $v = function(e) {
        return e._end = Vi(e._start + (e._tDur / Math.abs(e._ts || e._rts || Gn) || 0))
    },
    ey = function(e, t) {
        var n = e._dp;
        return n && n.smoothChildTiming && e._ts && (e._start = Vi(n._time - (e._ts > 0 ? t / e._ts : ((e._dirty ? e.totalDuration() : e._tDur) - t) / -e._ts)), $v(e), n._dirty || zc(n, e)), e
    },
    iP = function(e, t) {
        var n;
        if ((t._time || !t._dur && t._initted || t._start < e._time && (t._dur || !t.add)) && (n = G0(e.rawTime(), t), (!t._dur || kp(0, t.totalDuration(), n) - t._tTime > Gn) && t.render(n, !0)), zc(e, t)._dp && e._initted && e._time >= e._dur && e._ts) {
            if (e._dur < e.duration())
                for (n = e; n._dp;) n.rawTime() >= 0 && n.totalTime(n._tTime), n = n._dp;
            e._zTime = -Gn
        }
    },
    Eo = function(e, t, n, i) {
        return t.parent && vl(t), t._start = Vi((wa(n) ? n : n || e !== ii ? Ns(e, n, t) : e._time) + t._delay), t._end = Vi(t._start + (t.totalDuration() / Math.abs(t.timeScale()) || 0)), nP(e, t, "_first", "_last", e._sort ? "_start" : 0), k1(t) || (e._recent = t), i || iP(e, t), e._ts < 0 && ey(e, e._tTime), e
    },
    rP = function(e, t) {
        return (xs.ScrollTrigger || hS("scrollTrigger", t)) && xs.ScrollTrigger.create(t, e)
    },
    sP = function(e, t, n, i, s) {
        if (vS(e, t, s), !e._initted) return 1;
        if (!n && e._pt && !pr && (e._dur && e.vars.lazy !== !1 || !e._dur && e.vars.lazy) && Z2 !== ds.frame) return ul.push(e), e._lazy = [s, i], 1
    },
    cU = function r(e) {
        var t = e.parent;
        return t && t._ts && t._initted && !t._lock && (t.rawTime() < 0 || r(t))
    },
    k1 = function(e) {
        var t = e.data;
        return t === "isFromStart" || t === "isStart"
    },
    uU = function(e, t, n, i) {
        var s = e.ratio,
            o = t < 0 || !t && (!e._start && cU(e) && !(!e._initted && k1(e)) || (e._ts < 0 || e._dp._ts < 0) && !k1(e)) ? 0 : 1,
            a = e._rDelay,
            l = 0,
            c, u, f;
        if (a && e._repeat && (l = kp(0, e._tDur, t), u = Vf(l, a), e._yoyo && u & 1 && (o = 1 - o), u !== Vf(e._tTime, a) && (s = 1 - o, e.vars.repeatRefresh && e._initted && e.invalidate())), o !== s || pr || i || e._zTime === Gn || !t && e._zTime) {
            if (!e._initted && sP(e, t, i, n, l)) return;
            for (f = e._zTime, e._zTime = t || (n ? Gn : 0), n || (n = t && !f), e.ratio = o, e._from && (o = 1 - o), e._time = 0, e._tTime = l, c = e._pt; c;) c.r(o, c.d), c = c._next;
            t < 0 && N1(e, t, n, !0), e._onUpdate && !n && ms(e, "onUpdate"), l && e._repeat && !n && e.parent && ms(e, "onRepeat"), (t >= e._tDur || t < 0) && e.ratio === o && (o && vl(e, 1), !n && !pr && (ms(e, o ? "onComplete" : "onReverseComplete", !0), e._prom && e._prom()))
        } else e._zTime || (e._zTime = t)
    },
    fU = function(e, t, n) {
        var i;
        if (n > t)
            for (i = e._first; i && i._start <= n;) {
                if (i.data === "isPause" && i._start > t) return i;
                i = i._next
            } else
                for (i = e._last; i && i._start >= n;) {
                    if (i.data === "isPause" && i._start < t) return i;
                    i = i._prev
                }
    },
    Wf = function(e, t, n, i) {
        var s = e._repeat,
            o = Vi(t) || 0,
            a = e._tTime / e._tDur;
        return a && !i && (e._time *= o / e._dur), e._dur = o, e._tDur = s ? s < 0 ? 1e10 : Vi(o * (s + 1) + e._rDelay * s) : o, a > 0 && !i && ey(e, e._tTime = e._tDur * a), e.parent && $v(e), n || zc(e.parent, e), e
    },
    sT = function(e) {
        return e instanceof Dr ? zc(e) : Wf(e, e._dur)
    },
    hU = {
        _start: 0,
        endTime: sp,
        totalDuration: sp
    },
    Ns = function r(e, t, n) {
        var i = e.labels,
            s = e._recent || hU,
            o = e.duration() >= js ? s.endTime(!1) : e._dur,
            a, l, c;
        return Xi(t) && (isNaN(t) || t in i) ? (l = t.charAt(0), c = t.substr(-1) === "%", a = t.indexOf("="), l === "<" || l === ">" ? (a >= 0 && (t = t.replace(/=/, "")), (l === "<" ? s._start : s.endTime(s._repeat >= 0)) + (parseFloat(t.substr(1)) || 0) * (c ? (a < 0 ? s : n).totalDuration() / 100 : 1)) : a < 0 ? (t in i || (i[t] = o), i[t]) : (l = parseFloat(t.charAt(a - 1) + t.substr(a + 1)), c && n && (l = l / 100 * (mr(n) ? n[0] : n).totalDuration()), a > 1 ? r(e, t.substr(0, a - 1), n) + l : o + l)) : t == null ? o : +t
    },
    Rd = function(e, t, n) {
        var i = wa(t[1]),
            s = (i ? 2 : 1) + (e < 2 ? 0 : 1),
            o = t[s],
            a, l;
        if (i && (o.duration = t[1]), o.parent = n, e) {
            for (a = o, l = n; l && !("immediateRender" in a);) a = l.vars.defaults || {}, l = Xr(l.vars.inherit) && l.parent;
            o.immediateRender = Xr(a.immediateRender), e < 2 ? o.runBackwards = 1 : o.startAt = t[s - 1]
        }
        return new Ci(t[0], o, t[s + 1])
    },
    Il = function(e, t) {
        return e || e === 0 ? t(e) : t
    },
    kp = function(e, t, n) {
        return n < e ? e : n > t ? t : n
    },
    hr = function(e, t) {
        return !Xi(e) || !(t = tU.exec(e)) ? "" : t[1]
    },
    dU = function(e, t, n) {
        return Il(n, function(i) {
            return kp(e, t, i)
        })
    },
    z1 = [].slice,
    oP = function(e, t) {
        return e && No(e) && "length" in e && (!t && !e.length || e.length - 1 in e && No(e[0])) && !e.nodeType && e !== bo
    },
    pU = function(e, t, n) {
        return n === void 0 && (n = []), e.forEach(function(i) {
            var s;
            return Xi(i) && !t || oP(i, 1) ? (s = n).push.apply(s, Xs(i)) : n.push(i)
        }) || n
    },
    Xs = function(e, t, n) {
        return Kn && !t && Kn.selector ? Kn.selector(e) : Xi(e) && !n && (U1 || !jf()) ? z1.call((t || fS).querySelectorAll(e), 0) : mr(e) ? pU(e, n) : oP(e) ? z1.call(e, 0) : e ? [e] : []
    },
    G1 = function(e) {
        return e = Xs(e)[0] || rp("Invalid scope") || {},
            function(t) {
                var n = e.current || e.nativeElement || e;
                return Xs(t, n.querySelectorAll ? n : n === e ? rp("Invalid scope") || fS.createElement("div") : e)
            }
    },
    aP = function(e) {
        return e.sort(function() {
            return .5 - Math.random()
        })
    },
    lP = function(e) {
        if (hi(e)) return e;
        var t = No(e) ? e : {
                each: e
            },
            n = Gc(t.ease),
            i = t.from || 0,
            s = parseFloat(t.base) || 0,
            o = {},
            a = i > 0 && i < 1,
            l = isNaN(i) || a,
            c = t.axis,
            u = i,
            f = i;
        return Xi(i) ? u = f = {
                center: .5,
                edges: .5,
                end: 1
            }[i] || 0 : !a && l && (u = i[0], f = i[1]),
            function(d, m, g) {
                var y = (g || t).length,
                    v = o[y],
                    _, A, S, M, C, E, R, P, b;
                if (!v) {
                    if (b = t.grid === "auto" ? 0 : (t.grid || [1, js])[1], !b) {
                        for (R = -js; R < (R = g[b++].getBoundingClientRect().left) && b < y;);
                        b < y && b--
                    }
                    for (v = o[y] = [], _ = l ? Math.min(b, y) * u - .5 : i % b, A = b === js ? 0 : l ? y * f / b - .5 : i / b | 0, R = 0, P = js, E = 0; E < y; E++) S = E % b - _, M = A - (E / b | 0), v[E] = C = c ? Math.abs(c === "y" ? M : S) : V2(S * S + M * M), C > R && (R = C), C < P && (P = C);
                    i === "random" && aP(v), v.max = R - P, v.min = P, v.v = y = (parseFloat(t.amount) || parseFloat(t.each) * (b > y ? y - 1 : c ? c === "y" ? y / b : b : Math.max(b, y / b)) || 0) * (i === "edges" ? -1 : 1), v.b = y < 0 ? s - y : s, v.u = hr(t.amount || t.each) || 0, n = n && y < 0 ? yP(n) : n
                }
                return y = (v[d] - v.min) / v.max || 0, Vi(v.b + (n ? n(y) : y) * v.v) + v.u
            }
    },
    H1 = function(e) {
        var t = Math.pow(10, ((e + "").split(".")[1] || "").length);
        return function(n) {
            var i = Vi(Math.round(parseFloat(n) / e) * e * t);
            return (i - i % 1) / t + (wa(n) ? 0 : hr(n))
        }
    },
    cP = function(e, t) {
        var n = mr(e),
            i, s;
        return !n && No(e) && (i = n = e.radius || js, e.values ? (e = Xs(e.values), (s = !wa(e[0])) && (i *= i)) : e = H1(e.increment)), Il(t, n ? hi(e) ? function(o) {
            return s = e(o), Math.abs(s - o) <= i ? s : o
        } : function(o) {
            for (var a = parseFloat(s ? o.x : o), l = parseFloat(s ? o.y : 0), c = js, u = 0, f = e.length, d, m; f--;) s ? (d = e[f].x - a, m = e[f].y - l, d = d * d + m * m) : d = Math.abs(e[f] - a), d < c && (c = d, u = f);
            return u = !i || c <= i ? e[u] : o, s || u === o || wa(o) ? u : u + hr(o)
        } : H1(e))
    },
    uP = function(e, t, n, i) {
        return Il(mr(e) ? !t : n === !0 ? !!(n = 0) : !i, function() {
            return mr(e) ? e[~~(Math.random() * e.length)] : (n = n || 1e-5) && (i = n < 1 ? Math.pow(10, (n + "").length - 2) : 1) && Math.floor(Math.round((e - n / 2 + Math.random() * (t - e + n * .99)) / n) * n * i) / i
        })
    },
    mU = function() {
        for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
        return function(i) {
            return t.reduce(function(s, o) {
                return o(s)
            }, i)
        }
    },
    gU = function(e, t) {
        return function(n) {
            return e(parseFloat(n)) + (t || hr(n))
        }
    },
    vU = function(e, t, n) {
        return hP(e, t, 0, 1, n)
    },
    fP = function(e, t, n) {
        return Il(n, function(i) {
            return e[~~t(i)]
        })
    },
    yU = function r(e, t, n) {
        var i = t - e;
        return mr(e) ? fP(e, r(0, e.length), t) : Il(n, function(s) {
            return (i + (s - e) % i) % i + e
        })
    },
    _U = function r(e, t, n) {
        var i = t - e,
            s = i * 2;
        return mr(e) ? fP(e, r(0, e.length - 1), t) : Il(n, function(o) {
            return o = (s + (o - e) % s) % s || 0, e + (o > i ? s - o : o)
        })
    },
    op = function(e) {
        for (var t = 0, n = "", i, s, o, a; ~(i = e.indexOf("random(", t));) o = e.indexOf(")", i), a = e.charAt(i + 7) === "[", s = e.substr(i + 7, o - i - 7).match(a ? Y2 : F1), n += e.substr(t, i - t) + uP(a ? s : +s[0], a ? 0 : +s[1], +s[2] || 1e-5), t = o + 1;
        return n + e.substr(t, e.length - t)
    },
    hP = function(e, t, n, i, s) {
        var o = t - e,
            a = i - n;
        return Il(s, function(l) {
            return n + ((l - e) / o * a || 0)
        })
    },
    xU = function r(e, t, n, i) {
        var s = isNaN(e + t) ? 0 : function(m) {
            return (1 - m) * e + m * t
        };
        if (!s) {
            var o = Xi(e),
                a = {},
                l, c, u, f, d;
            if (n === !0 && (i = 1) && (n = null), o) e = {
                p: e
            }, t = {
                p: t
            };
            else if (mr(e) && !mr(t)) {
                for (u = [], f = e.length, d = f - 2, c = 1; c < f; c++) u.push(r(e[c - 1], e[c]));
                f--, s = function(g) {
                    g *= f;
                    var y = Math.min(d, ~~g);
                    return u[y](g - y)
                }, n = t
            } else i || (e = eu(mr(e) ? [] : {}, e));
            if (!u) {
                for (l in t) gS.call(a, e, l, "get", t[l]);
                s = function(g) {
                    return xS(g, a) || (o ? e.p : e)
                }
            }
        }
        return Il(n, s)
    },
    oT = function(e, t, n) {
        var i = e.labels,
            s = js,
            o, a, l;
        for (o in i) a = i[o] - t, a < 0 == !!n && a && s > (a = Math.abs(a)) && (l = o, s = a);
        return l
    },
    ms = function(e, t, n) {
        var i = e.vars,
            s = i[t],
            o = Kn,
            a = e._ctx,
            l, c, u;
        if (s) return l = i[t + "Params"], c = i.callbackScope || e, n && ul.length && k0(), a && (Kn = a), u = l ? s.apply(c, l) : s.call(c), Kn = o, u
    },
    pd = function(e) {
        return vl(e), e.scrollTrigger && e.scrollTrigger.kill(!!pr), e.progress() < 1 && ms(e, "onInterrupt"), e
    },
    df, dP = [],
    pP = function(e) {
        if (e)
            if (e = !e.name && e.default || e, uS() || e.headless) {
                var t = e.name,
                    n = hi(e),
                    i = t && !n && e.init ? function() {
                        this._props = []
                    } : e,
                    s = {
                        init: sp,
                        render: xS,
                        add: gS,
                        kill: UU,
                        modifier: FU,
                        rawVars: 0
                    },
                    o = {
                        targetTest: 0,
                        get: 0,
                        getSetter: _S,
                        aliases: {},
                        register: 0
                    };
                if (jf(), e !== i) {
                    if (fs[t]) return;
                    qs(i, qs(z0(e, s), o)), eu(i.prototype, eu(s, z0(e, o))), fs[i.prop = t] = i, e.targetTest && (S0.push(i), dS[t] = 1), t = (t === "css" ? "CSS" : t.charAt(0).toUpperCase() + t.substr(1)) + "Plugin"
                }
                q2(t, i), e.register && e.register(Zr, i, Jr)
            } else dP.push(e)
    },
    On = 255,
    md = {
        aqua: [0, On, On],
        lime: [0, On, 0],
        silver: [192, 192, 192],
        black: [0, 0, 0],
        maroon: [128, 0, 0],
        teal: [0, 128, 128],
        blue: [0, 0, On],
        navy: [0, 0, 128],
        white: [On, On, On],
        olive: [128, 128, 0],
        yellow: [On, On, 0],
        orange: [On, 165, 0],
        gray: [128, 128, 128],
        purple: [128, 0, 128],
        green: [0, 128, 0],
        red: [On, 0, 0],
        pink: [On, 192, 203],
        cyan: [0, On, On],
        transparent: [On, On, On, 0]
    },
    W_ = function(e, t, n) {
        return e += e < 0 ? 1 : e > 1 ? -1 : 0, (e * 6 < 1 ? t + (n - t) * e * 6 : e < .5 ? n : e * 3 < 2 ? t + (n - t) * (2 / 3 - e) * 6 : t) * On + .5 | 0
    },
    mP = function(e, t, n) {
        var i = e ? wa(e) ? [e >> 16, e >> 8 & On, e & On] : 0 : md.black,
            s, o, a, l, c, u, f, d, m, g;
        if (!i) {
            if (e.substr(-1) === "," && (e = e.substr(0, e.length - 1)), md[e]) i = md[e];
            else if (e.charAt(0) === "#") {
                if (e.length < 6 && (s = e.charAt(1), o = e.charAt(2), a = e.charAt(3), e = "#" + s + s + o + o + a + a + (e.length === 5 ? e.charAt(4) + e.charAt(4) : "")), e.length === 9) return i = parseInt(e.substr(1, 6), 16), [i >> 16, i >> 8 & On, i & On, parseInt(e.substr(7), 16) / 255];
                e = parseInt(e.substr(1), 16), i = [e >> 16, e >> 8 & On, e & On]
            } else if (e.substr(0, 3) === "hsl") {
                if (i = g = e.match(F1), !t) l = +i[0] % 360 / 360, c = +i[1] / 100, u = +i[2] / 100, o = u <= .5 ? u * (c + 1) : u + c - u * c, s = u * 2 - o, i.length > 3 && (i[3] *= 1), i[0] = W_(l + 1 / 3, s, o), i[1] = W_(l, s, o), i[2] = W_(l - 1 / 3, s, o);
                else if (~e.indexOf("=")) return i = e.match(j2), n && i.length < 4 && (i[3] = 1), i
            } else i = e.match(F1) || md.transparent;
            i = i.map(Number)
        }
        return t && !g && (s = i[0] / On, o = i[1] / On, a = i[2] / On, f = Math.max(s, o, a), d = Math.min(s, o, a), u = (f + d) / 2, f === d ? l = c = 0 : (m = f - d, c = u > .5 ? m / (2 - f - d) : m / (f + d), l = f === s ? (o - a) / m + (o < a ? 6 : 0) : f === o ? (a - s) / m + 2 : (s - o) / m + 4, l *= 60), i[0] = ~~(l + .5), i[1] = ~~(c * 100 + .5), i[2] = ~~(u * 100 + .5)), n && i.length < 4 && (i[3] = 1), i
    },
    gP = function(e) {
        var t = [],
            n = [],
            i = -1;
        return e.split(fl).forEach(function(s) {
            var o = s.match(hf) || [];
            t.push.apply(t, o), n.push(i += o.length + 1)
        }), t.c = n, t
    },
    aT = function(e, t, n) {
        var i = "",
            s = (e + i).match(fl),
            o = t ? "hsla(" : "rgba(",
            a = 0,
            l, c, u, f;
        if (!s) return e;
        if (s = s.map(function(d) {
                return (d = mP(d, t, 1)) && o + (t ? d[0] + "," + d[1] + "%," + d[2] + "%," + d[3] : d.join(",")) + ")"
            }), n && (u = gP(e), l = n.c, l.join(i) !== u.c.join(i)))
            for (c = e.replace(fl, "1").split(hf), f = c.length - 1; a < f; a++) i += c[a] + (~l.indexOf(a) ? s.shift() || o + "0,0,0,0)" : (u.length ? u : s.length ? s : n).shift());
        if (!c)
            for (c = e.split(fl), f = c.length - 1; a < f; a++) i += c[a] + s[a];
        return i + c[f]
    },
    fl = function() {
        var r = "(?:\\b(?:(?:rgb|rgba|hsl|hsla)\\(.+?\\))|\\B#(?:[0-9a-f]{3,4}){1,2}\\b",
            e;
        for (e in md) r += "|" + e + "\\b";
        return new RegExp(r + ")", "gi")
    }(),
    AU = /hsl[a]?\(/,
    vP = function(e) {
        var t = e.join(" "),
            n;
        if (fl.lastIndex = 0, fl.test(t)) return n = AU.test(t), e[1] = aT(e[1], n), e[0] = aT(e[0], n, gP(e[1])), !0
    },
    ap, ds = function() {
        var r = Date.now,
            e = 500,
            t = 33,
            n = r(),
            i = n,
            s = 1e3 / 240,
            o = s,
            a = [],
            l, c, u, f, d, m, g = function y(v) {
                var _ = r() - i,
                    A = v === !0,
                    S, M, C, E;
                if ((_ > e || _ < 0) && (n += _ - t), i += _, C = i - n, S = C - o, (S > 0 || A) && (E = ++f.frame, d = C - f.time * 1e3, f.time = C = C / 1e3, o += S + (S >= s ? 4 : s - S), M = 1), A || (l = c(y)), M)
                    for (m = 0; m < a.length; m++) a[m](C, d, E, v)
            };
        return f = {
            time: 0,
            frame: 0,
            tick: function() {
                g(!0)
            },
            deltaRatio: function(v) {
                return d / (1e3 / (v || 60))
            },
            wake: function() {
                J2 && (!U1 && uS() && (bo = U1 = window, fS = bo.document || {}, xs.gsap = Zr, (bo.gsapVersions || (bo.gsapVersions = [])).push(Zr.version), K2(N0 || bo.GreenSockGlobals || !bo.gsap && bo || {}), dP.forEach(pP)), u = typeof requestAnimationFrame < "u" && requestAnimationFrame, l && f.sleep(), c = u || function(v) {
                    return setTimeout(v, o - f.time * 1e3 + 1 | 0)
                }, ap = 1, g(2))
            },
            sleep: function() {
                (u ? cancelAnimationFrame : clearTimeout)(l), ap = 0, c = sp
            },
            lagSmoothing: function(v, _) {
                e = v || 1 / 0, t = Math.min(_ || 33, e)
            },
            fps: function(v) {
                s = 1e3 / (v || 240), o = f.time * 1e3 + s
            },
            add: function(v, _, A) {
                var S = _ ? function(M, C, E, R) {
                    v(M, C, E, R), f.remove(S)
                } : v;
                return f.remove(v), a[A ? "unshift" : "push"](S), jf(), S
            },
            remove: function(v, _) {
                ~(_ = a.indexOf(v)) && a.splice(_, 1) && m >= _ && m--
            },
            _listeners: a
        }, f
    }(),
    jf = function() {
        return !ap && ds.wake()
    },
    Sn = {},
    SU = /^[\d.\-M][\d.\-,\s]/,
    MU = /["']/g,
    wU = function(e) {
        for (var t = {}, n = e.substr(1, e.length - 3).split(":"), i = n[0], s = 1, o = n.length, a, l, c; s < o; s++) l = n[s], a = s !== o - 1 ? l.lastIndexOf(",") : l.length, c = l.substr(0, a), t[i] = isNaN(c) ? c.replace(MU, "").trim() : +c, i = l.substr(a + 1).trim();
        return t
    },
    bU = function(e) {
        var t = e.indexOf("(") + 1,
            n = e.indexOf(")"),
            i = e.indexOf("(", t);
        return e.substring(t, ~i && i < n ? e.indexOf(")", n + 1) : n)
    },
    TU = function(e) {
        var t = (e + "").split("("),
            n = Sn[t[0]];
        return n && t.length > 1 && n.config ? n.config.apply(null, ~e.indexOf("{") ? [wU(t[1])] : bU(e).split(",").map(eP)) : Sn._CE && SU.test(e) ? Sn._CE("", e) : n
    },
    yP = function(e) {
        return function(t) {
            return 1 - e(1 - t)
        }
    },
    _P = function r(e, t) {
        for (var n = e._first, i; n;) n instanceof Dr ? r(n, t) : n.vars.yoyoEase && (!n._yoyo || !n._repeat) && n._yoyo !== t && (n.timeline ? r(n.timeline, t) : (i = n._ease, n._ease = n._yEase, n._yEase = i, n._yoyo = t)), n = n._next
    },
    Gc = function(e, t) {
        return e && (hi(e) ? e : Sn[e] || TU(e)) || t
    },
    hu = function(e, t, n, i) {
        n === void 0 && (n = function(l) {
            return 1 - t(1 - l)
        }), i === void 0 && (i = function(l) {
            return l < .5 ? t(l * 2) / 2 : 1 - t((1 - l) * 2) / 2
        });
        var s = {
                easeIn: t,
                easeOut: n,
                easeInOut: i
            },
            o;
        return Yr(e, function(a) {
            Sn[a] = xs[a] = s, Sn[o = a.toLowerCase()] = n;
            for (var l in s) Sn[o + (l === "easeIn" ? ".in" : l === "easeOut" ? ".out" : ".inOut")] = Sn[a + "." + l] = s[l]
        }), s
    },
    xP = function(e) {
        return function(t) {
            return t < .5 ? (1 - e(1 - t * 2)) / 2 : .5 + e((t - .5) * 2) / 2
        }
    },
    j_ = function r(e, t, n) {
        var i = t >= 1 ? t : 1,
            s = (n || (e ? .3 : .45)) / (t < 1 ? t : 1),
            o = s / L1 * (Math.asin(1 / i) || 0),
            a = function(u) {
                return u === 1 ? 1 : i * Math.pow(2, -10 * u) * eU((u - o) * s) + 1
            },
            l = e === "out" ? a : e === "in" ? function(c) {
                return 1 - a(1 - c)
            } : xP(a);
        return s = L1 / s, l.config = function(c, u) {
            return r(e, c, u)
        }, l
    },
    X_ = function r(e, t) {
        t === void 0 && (t = 1.70158);
        var n = function(o) {
                return o ? --o * o * ((t + 1) * o + t) + 1 : 0
            },
            i = e === "out" ? n : e === "in" ? function(s) {
                return 1 - n(1 - s)
            } : xP(n);
        return i.config = function(s) {
            return r(e, s)
        }, i
    };
Yr("Linear,Quad,Cubic,Quart,Quint,Strong", function(r, e) {
    var t = e < 5 ? e + 1 : e;
    hu(r + ",Power" + (t - 1), e ? function(n) {
        return Math.pow(n, t)
    } : function(n) {
        return n
    }, function(n) {
        return 1 - Math.pow(1 - n, t)
    }, function(n) {
        return n < .5 ? Math.pow(n * 2, t) / 2 : 1 - Math.pow((1 - n) * 2, t) / 2
    })
});
Sn.Linear.easeNone = Sn.none = Sn.Linear.easeIn;
hu("Elastic", j_("in"), j_("out"), j_());
(function(r, e) {
    var t = 1 / e,
        n = 2 * t,
        i = 2.5 * t,
        s = function(a) {
            return a < t ? r * a * a : a < n ? r * Math.pow(a - 1.5 / e, 2) + .75 : a < i ? r * (a -= 2.25 / e) * a + .9375 : r * Math.pow(a - 2.625 / e, 2) + .984375
        };
    hu("Bounce", function(o) {
        return 1 - s(1 - o)
    }, s)
})(7.5625, 2.75);
hu("Expo", function(r) {
    return r ? Math.pow(2, 10 * (r - 1)) : 0
});
hu("Circ", function(r) {
    return -(V2(1 - r * r) - 1)
});
hu("Sine", function(r) {
    return r === 1 ? 1 : -$F(r * ZF) + 1
});
hu("Back", X_("in"), X_("out"), X_());
Sn.SteppedEase = Sn.steps = xs.SteppedEase = {
    config: function(e, t) {
        e === void 0 && (e = 1);
        var n = 1 / e,
            i = e + (t ? 0 : 1),
            s = t ? 1 : 0,
            o = 1 - Gn;
        return function(a) {
            return ((i * kp(0, o, a) | 0) + s) * n
        }
    }
};
Hf.ease = Sn["quad.out"];
Yr("onComplete,onUpdate,onStart,onRepeat,onReverseComplete,onInterrupt", function(r) {
    return pS += r + "," + r + "Params,"
});
var AP = function(e, t) {
        this.id = QF++, e._gsap = this, this.target = e, this.harness = t, this.get = t ? t.get : Q2, this.set = t ? t.getSetter : _S
    },
    lp = function() {
        function r(t) {
            this.vars = t, this._delay = +t.delay || 0, (this._repeat = t.repeat === 1 / 0 ? -2 : t.repeat || 0) && (this._rDelay = t.repeatDelay || 0, this._yoyo = !!t.yoyo || !!t.yoyoEase), this._ts = 1, Wf(this, +t.duration, 1, 1), this.data = t.data, Kn && (this._ctx = Kn, Kn.data.push(this)), ap || ds.wake()
        }
        var e = r.prototype;
        return e.delay = function(n) {
            return n || n === 0 ? (this.parent && this.parent.smoothChildTiming && this.startTime(this._start + n - this._delay), this._delay = n, this) : this._delay
        }, e.duration = function(n) {
            return arguments.length ? this.totalDuration(this._repeat > 0 ? n + (n + this._rDelay) * this._repeat : n) : this.totalDuration() && this._dur
        }, e.totalDuration = function(n) {
            return arguments.length ? (this._dirty = 0, Wf(this, this._repeat < 0 ? n : (n - this._repeat * this._rDelay) / (this._repeat + 1))) : this._tDur
        }, e.totalTime = function(n, i) {
            if (jf(), !arguments.length) return this._tTime;
            var s = this._dp;
            if (s && s.smoothChildTiming && this._ts) {
                for (ey(this, n), !s._dp || s.parent || iP(s, this); s && s.parent;) s.parent._time !== s._start + (s._ts >= 0 ? s._tTime / s._ts : (s.totalDuration() - s._tTime) / -s._ts) && s.totalTime(s._tTime, !0), s = s.parent;
                !this.parent && this._dp.autoRemoveChildren && (this._ts > 0 && n < this._tDur || this._ts < 0 && n > 0 || !this._tDur && !n) && Eo(this._dp, this, this._start - this._delay)
            }
            return (this._tTime !== n || !this._dur && !i || this._initted && Math.abs(this._zTime) === Gn || !n && !this._initted && (this.add || this._ptLookup)) && (this._ts || (this._pTime = n), $2(this, n, i)), this
        }, e.time = function(n, i) {
            return arguments.length ? this.totalTime(Math.min(this.totalDuration(), n + rT(this)) % (this._dur + this._rDelay) || (n ? this._dur : 0), i) : this._time
        }, e.totalProgress = function(n, i) {
            return arguments.length ? this.totalTime(this.totalDuration() * n, i) : this.totalDuration() ? Math.min(1, this._tTime / this._tDur) : this.rawTime() > 0 ? 1 : 0
        }, e.progress = function(n, i) {
            return arguments.length ? this.totalTime(this.duration() * (this._yoyo && !(this.iteration() & 1) ? 1 - n : n) + rT(this), i) : this.duration() ? Math.min(1, this._time / this._dur) : this.rawTime() > 0 ? 1 : 0
        }, e.iteration = function(n, i) {
            var s = this.duration() + this._rDelay;
            return arguments.length ? this.totalTime(this._time + (n - 1) * s, i) : this._repeat ? Vf(this._tTime, s) + 1 : 1
        }, e.timeScale = function(n, i) {
            if (!arguments.length) return this._rts === -Gn ? 0 : this._rts;
            if (this._rts === n) return this;
            var s = this.parent && this._ts ? G0(this.parent._time, this) : this._tTime;
            return this._rts = +n || 0, this._ts = this._ps || n === -Gn ? 0 : this._rts, this.totalTime(kp(-Math.abs(this._delay), this._tDur, s), i !== !1), $v(this), aU(this)
        }, e.paused = function(n) {
            return arguments.length ? (this._ps !== n && (this._ps = n, n ? (this._pTime = this._tTime || Math.max(-this._delay, this.rawTime()), this._ts = this._act = 0) : (jf(), this._ts = this._rts, this.totalTime(this.parent && !this.parent.smoothChildTiming ? this.rawTime() : this._tTime || this._pTime, this.progress() === 1 && Math.abs(this._zTime) !== Gn && (this._tTime -= Gn)))), this) : this._ps
        }, e.startTime = function(n) {
            if (arguments.length) {
                this._start = n;
                var i = this.parent || this._dp;
                return i && (i._sort || !this.parent) && Eo(i, this, n - this._delay), this
            }
            return this._start
        }, e.endTime = function(n) {
            return this._start + (Xr(n) ? this.totalDuration() : this.duration()) / Math.abs(this._ts || 1)
        }, e.rawTime = function(n) {
            var i = this.parent || this._dp;
            return i ? n && (!this._ts || this._repeat && this._time && this.totalProgress() < 1) ? this._tTime % (this._dur + this._rDelay) : this._ts ? G0(i.rawTime(n), this) : this._tTime : this._tTime
        }, e.revert = function(n) {
            n === void 0 && (n = iU);
            var i = pr;
            return pr = n, (this._initted || this._startAt) && (this.timeline && this.timeline.revert(n), this.totalTime(-.01, n.suppressEvents)), this.data !== "nested" && n.kill !== !1 && this.kill(), pr = i, this
        }, e.globalTime = function(n) {
            for (var i = this, s = arguments.length ? n : i.rawTime(); i;) s = i._start + s / (Math.abs(i._ts) || 1), i = i._dp;
            return !this.parent && this._sat ? this._sat.globalTime(n) : s
        }, e.repeat = function(n) {
            return arguments.length ? (this._repeat = n === 1 / 0 ? -2 : n, sT(this)) : this._repeat === -2 ? 1 / 0 : this._repeat
        }, e.repeatDelay = function(n) {
            if (arguments.length) {
                var i = this._time;
                return this._rDelay = n, sT(this), i ? this.time(i) : this
            }
            return this._rDelay
        }, e.yoyo = function(n) {
            return arguments.length ? (this._yoyo = n, this) : this._yoyo
        }, e.seek = function(n, i) {
            return this.totalTime(Ns(this, n), Xr(i))
        }, e.restart = function(n, i) {
            return this.play().totalTime(n ? -this._delay : 0, Xr(i))
        }, e.play = function(n, i) {
            return n != null && this.seek(n, i), this.reversed(!1).paused(!1)
        }, e.reverse = function(n, i) {
            return n != null && this.seek(n || this.totalDuration(), i), this.reversed(!0).paused(!1)
        }, e.pause = function(n, i) {
            return n != null && this.seek(n, i), this.paused(!0)
        }, e.resume = function() {
            return this.paused(!1)
        }, e.reversed = function(n) {
            return arguments.length ? (!!n !== this.reversed() && this.timeScale(-this._rts || (n ? -Gn : 0)), this) : this._rts < 0
        }, e.invalidate = function() {
            return this._initted = this._act = 0, this._zTime = -Gn, this
        }, e.isActive = function() {
            var n = this.parent || this._dp,
                i = this._start,
                s;
            return !!(!n || this._ts && this._initted && n.isActive() && (s = n.rawTime(!0)) >= i && s < this.endTime(!0) - Gn)
        }, e.eventCallback = function(n, i, s) {
            var o = this.vars;
            return arguments.length > 1 ? (i ? (o[n] = i, s && (o[n + "Params"] = s), n === "onUpdate" && (this._onUpdate = i)) : delete o[n], this) : o[n]
        }, e.then = function(n) {
            var i = this;
            return new Promise(function(s) {
                var o = hi(n) ? n : tP,
                    a = function() {
                        var c = i.then;
                        i.then = null, hi(o) && (o = o(i)) && (o.then || o === i) && (i.then = c), s(o), i.then = c
                    };
                i._initted && i.totalProgress() === 1 && i._ts >= 0 || !i._tTime && i._ts < 0 ? a() : i._prom = a
            })
        }, e.kill = function() {
            pd(this)
        }, r
    }();
qs(lp.prototype, {
    _time: 0,
    _start: 0,
    _end: 0,
    _tTime: 0,
    _tDur: 0,
    _dirty: 0,
    _repeat: 0,
    _yoyo: !1,
    parent: null,
    _initted: !1,
    _rDelay: 0,
    _ts: 1,
    _dp: 0,
    ratio: 0,
    _zTime: -Gn,
    _prom: 0,
    _ps: !1,
    _rts: 1
});
var Dr = function(r) {
    H2(e, r);

    function e(n, i) {
        var s;
        return n === void 0 && (n = {}), s = r.call(this, n) || this, s.labels = {}, s.smoothChildTiming = !!n.smoothChildTiming, s.autoRemoveChildren = !!n.autoRemoveChildren, s._sort = Xr(n.sortChildren), ii && Eo(n.parent || ii, ra(s), i), n.reversed && s.reverse(), n.paused && s.paused(!0), n.scrollTrigger && rP(ra(s), n.scrollTrigger), s
    }
    var t = e.prototype;
    return t.to = function(i, s, o) {
        return Rd(0, arguments, this), this
    }, t.from = function(i, s, o) {
        return Rd(1, arguments, this), this
    }, t.fromTo = function(i, s, o, a) {
        return Rd(2, arguments, this), this
    }, t.set = function(i, s, o) {
        return s.duration = 0, s.parent = this, Cd(s).repeatDelay || (s.repeat = 0), s.immediateRender = !!s.immediateRender, new Ci(i, s, Ns(this, o), 1), this
    }, t.call = function(i, s, o) {
        return Eo(this, Ci.delayedCall(0, i, s), o)
    }, t.staggerTo = function(i, s, o, a, l, c, u) {
        return o.duration = s, o.stagger = o.stagger || a, o.onComplete = c, o.onCompleteParams = u, o.parent = this, new Ci(i, o, Ns(this, l)), this
    }, t.staggerFrom = function(i, s, o, a, l, c, u) {
        return o.runBackwards = 1, Cd(o).immediateRender = Xr(o.immediateRender), this.staggerTo(i, s, o, a, l, c, u)
    }, t.staggerFromTo = function(i, s, o, a, l, c, u, f) {
        return a.startAt = o, Cd(a).immediateRender = Xr(a.immediateRender), this.staggerTo(i, s, a, l, c, u, f)
    }, t.render = function(i, s, o) {
        var a = this._time,
            l = this._dirty ? this.totalDuration() : this._tDur,
            c = this._dur,
            u = i <= 0 ? 0 : Vi(i),
            f = this._zTime < 0 != i < 0 && (this._initted || !c),
            d, m, g, y, v, _, A, S, M, C, E, R;
        if (this !== ii && u > l && i >= 0 && (u = l), u !== this._tTime || o || f) {
            if (a !== this._time && c && (u += this._time - a, i += this._time - a), d = u, M = this._start, S = this._ts, _ = !S, f && (c || (a = this._zTime), (i || !s) && (this._zTime = i)), this._repeat) {
                if (E = this._yoyo, v = c + this._rDelay, this._repeat < -1 && i < 0) return this.totalTime(v * 100 + i, s, o);
                if (d = Vi(u % v), u === l ? (y = this._repeat, d = c) : (y = ~~(u / v), y && y === u / v && (d = c, y--), d > c && (d = c)), C = Vf(this._tTime, v), !a && this._tTime && C !== y && this._tTime - C * v - this._dur <= 0 && (C = y), E && y & 1 && (d = c - d, R = 1), y !== C && !this._lock) {
                    var P = E && C & 1,
                        b = P === (E && y & 1);
                    if (y < C && (P = !P), a = P ? 0 : u % c ? c : u, this._lock = 1, this.render(a || (R ? 0 : Vi(y * v)), s, !c)._lock = 0, this._tTime = u, !s && this.parent && ms(this, "onRepeat"), this.vars.repeatRefresh && !R && (this.invalidate()._lock = 1), a && a !== this._time || _ !== !this._ts || this.vars.onRepeat && !this.parent && !this._act) return this;
                    if (c = this._dur, l = this._tDur, b && (this._lock = 2, a = P ? c : -1e-4, this.render(a, !0), this.vars.repeatRefresh && !R && this.invalidate()), this._lock = 0, !this._ts && !_) return this;
                    _P(this, R)
                }
            }
            if (this._hasPause && !this._forcing && this._lock < 2 && (A = fU(this, Vi(a), Vi(d)), A && (u -= d - (d = A._start))), this._tTime = u, this._time = d, this._act = !S, this._initted || (this._onUpdate = this.vars.onUpdate, this._initted = 1, this._zTime = i, a = 0), !a && d && !s && !y && (ms(this, "onStart"), this._tTime !== u)) return this;
            if (d >= a && i >= 0)
                for (m = this._first; m;) {
                    if (g = m._next, (m._act || d >= m._start) && m._ts && A !== m) {
                        if (m.parent !== this) return this.render(i, s, o);
                        if (m.render(m._ts > 0 ? (d - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (d - m._start) * m._ts, s, o), d !== this._time || !this._ts && !_) {
                            A = 0, g && (u += this._zTime = -Gn);
                            break
                        }
                    }
                    m = g
                } else {
                    m = this._last;
                    for (var T = i < 0 ? i : d; m;) {
                        if (g = m._prev, (m._act || T <= m._end) && m._ts && A !== m) {
                            if (m.parent !== this) return this.render(i, s, o);
                            if (m.render(m._ts > 0 ? (T - m._start) * m._ts : (m._dirty ? m.totalDuration() : m._tDur) + (T - m._start) * m._ts, s, o || pr && (m._initted || m._startAt)), d !== this._time || !this._ts && !_) {
                                A = 0, g && (u += this._zTime = T ? -Gn : Gn);
                                break
                            }
                        }
                        m = g
                    }
                }
            if (A && !s && (this.pause(), A.render(d >= a ? 0 : -Gn)._zTime = d >= a ? 1 : -1, this._ts)) return this._start = M, $v(this), this.render(i, s, o);
            this._onUpdate && !s && ms(this, "onUpdate", !0), (u === l && this._tTime >= this.totalDuration() || !u && a) && (M === this._start || Math.abs(S) !== Math.abs(this._ts)) && (this._lock || ((i || !c) && (u === l && this._ts > 0 || !u && this._ts < 0) && vl(this, 1), !s && !(i < 0 && !a) && (u || a || !l) && (ms(this, u === l && i >= 0 ? "onComplete" : "onReverseComplete", !0), this._prom && !(u < l && this.timeScale() > 0) && this._prom())))
        }
        return this
    }, t.add = function(i, s) {
        var o = this;
        if (wa(s) || (s = Ns(this, s, i)), !(i instanceof lp)) {
            if (mr(i)) return i.forEach(function(a) {
                return o.add(a, s)
            }), this;
            if (Xi(i)) return this.addLabel(i, s);
            if (hi(i)) i = Ci.delayedCall(0, i);
            else return this
        }
        return this !== i ? Eo(this, i, s) : this
    }, t.getChildren = function(i, s, o, a) {
        i === void 0 && (i = !0), s === void 0 && (s = !0), o === void 0 && (o = !0), a === void 0 && (a = -js);
        for (var l = [], c = this._first; c;) c._start >= a && (c instanceof Ci ? s && l.push(c) : (o && l.push(c), i && l.push.apply(l, c.getChildren(!0, s, o)))), c = c._next;
        return l
    }, t.getById = function(i) {
        for (var s = this.getChildren(1, 1, 1), o = s.length; o--;)
            if (s[o].vars.id === i) return s[o]
    }, t.remove = function(i) {
        return Xi(i) ? this.removeLabel(i) : hi(i) ? this.killTweensOf(i) : (Qv(this, i), i === this._recent && (this._recent = this._last), zc(this))
    }, t.totalTime = function(i, s) {
        return arguments.length ? (this._forcing = 1, !this._dp && this._ts && (this._start = Vi(ds.time - (this._ts > 0 ? i / this._ts : (this.totalDuration() - i) / -this._ts))), r.prototype.totalTime.call(this, i, s), this._forcing = 0, this) : this._tTime
    }, t.addLabel = function(i, s) {
        return this.labels[i] = Ns(this, s), this
    }, t.removeLabel = function(i) {
        return delete this.labels[i], this
    }, t.addPause = function(i, s, o) {
        var a = Ci.delayedCall(0, s || sp, o);
        return a.data = "isPause", this._hasPause = 1, Eo(this, a, Ns(this, i))
    }, t.removePause = function(i) {
        var s = this._first;
        for (i = Ns(this, i); s;) s._start === i && s.data === "isPause" && vl(s), s = s._next
    }, t.killTweensOf = function(i, s, o) {
        for (var a = this.getTweensOf(i, o), l = a.length; l--;) nl !== a[l] && a[l].kill(i, s);
        return this
    }, t.getTweensOf = function(i, s) {
        for (var o = [], a = Xs(i), l = this._first, c = wa(s), u; l;) l instanceof Ci ? rU(l._targets, a) && (c ? (!nl || l._initted && l._ts) && l.globalTime(0) <= s && l.globalTime(l.totalDuration()) > s : !s || l.isActive()) && o.push(l) : (u = l.getTweensOf(a, s)).length && o.push.apply(o, u), l = l._next;
        return o
    }, t.tweenTo = function(i, s) {
        s = s || {};
        var o = this,
            a = Ns(o, i),
            l = s,
            c = l.startAt,
            u = l.onStart,
            f = l.onStartParams,
            d = l.immediateRender,
            m, g = Ci.to(o, qs({
                ease: s.ease || "none",
                lazy: !1,
                immediateRender: !1,
                time: a,
                overwrite: "auto",
                duration: s.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale()) || Gn,
                onStart: function() {
                    if (o.pause(), !m) {
                        var v = s.duration || Math.abs((a - (c && "time" in c ? c.time : o._time)) / o.timeScale());
                        g._dur !== v && Wf(g, v, 0, 1).render(g._time, !0, !0), m = 1
                    }
                    u && u.apply(g, f || [])
                }
            }, s));
        return d ? g.render(0) : g
    }, t.tweenFromTo = function(i, s, o) {
        return this.tweenTo(s, qs({
            startAt: {
                time: Ns(this, i)
            }
        }, o))
    }, t.recent = function() {
        return this._recent
    }, t.nextLabel = function(i) {
        return i === void 0 && (i = this._time), oT(this, Ns(this, i))
    }, t.previousLabel = function(i) {
        return i === void 0 && (i = this._time), oT(this, Ns(this, i), 1)
    }, t.currentLabel = function(i) {
        return arguments.length ? this.seek(i, !0) : this.previousLabel(this._time + Gn)
    }, t.shiftChildren = function(i, s, o) {
        o === void 0 && (o = 0);
        for (var a = this._first, l = this.labels, c; a;) a._start >= o && (a._start += i, a._end += i), a = a._next;
        if (s)
            for (c in l) l[c] >= o && (l[c] += i);
        return zc(this)
    }, t.invalidate = function(i) {
        var s = this._first;
        for (this._lock = 0; s;) s.invalidate(i), s = s._next;
        return r.prototype.invalidate.call(this, i)
    }, t.clear = function(i) {
        i === void 0 && (i = !0);
        for (var s = this._first, o; s;) o = s._next, this.remove(s), s = o;
        return this._dp && (this._time = this._tTime = this._pTime = 0), i && (this.labels = {}), zc(this)
    }, t.totalDuration = function(i) {
        var s = 0,
            o = this,
            a = o._last,
            l = js,
            c, u, f;
        if (arguments.length) return o.timeScale((o._repeat < 0 ? o.duration() : o.totalDuration()) / (o.reversed() ? -i : i));
        if (o._dirty) {
            for (f = o.parent; a;) c = a._prev, a._dirty && a.totalDuration(), u = a._start, u > l && o._sort && a._ts && !o._lock ? (o._lock = 1, Eo(o, a, u - a._delay, 1)._lock = 0) : l = u, u < 0 && a._ts && (s -= u, (!f && !o._dp || f && f.smoothChildTiming) && (o._start += u / o._ts, o._time -= u, o._tTime -= u), o.shiftChildren(-u, !1, -1 / 0), l = 0), a._end > s && a._ts && (s = a._end), a = c;
            Wf(o, o === ii && o._time > s ? o._time : s, 1, 1), o._dirty = 0
        }
        return o._tDur
    }, e.updateRoot = function(i) {
        if (ii._ts && ($2(ii, G0(i, ii)), Z2 = ds.frame), ds.frame >= nT) {
            nT += vs.autoSleep || 120;
            var s = ii._first;
            if ((!s || !s._ts) && vs.autoSleep && ds._listeners.length < 2) {
                for (; s && !s._ts;) s = s._next;
                s || ds.sleep()
            }
        }
    }, e
}(lp);
qs(Dr.prototype, {
    _lock: 0,
    _hasPause: 0,
    _forcing: 0
});
var EU = function(e, t, n, i, s, o, a) {
        var l = new Jr(this._pt, e, t, 0, 1, EP, null, s),
            c = 0,
            u = 0,
            f, d, m, g, y, v, _, A;
        for (l.b = n, l.e = i, n += "", i += "", (_ = ~i.indexOf("random(")) && (i = op(i)), o && (A = [n, i], o(A, e, t), n = A[0], i = A[1]), d = n.match(H_) || []; f = H_.exec(i);) g = f[0], y = i.substring(c, f.index), m ? m = (m + 1) % 5 : y.substr(-5) === "rgba(" && (m = 1), g !== d[u++] && (v = parseFloat(d[u - 1]) || 0, l._pt = {
            _next: l._pt,
            p: y || u === 1 ? y : ",",
            s: v,
            c: g.charAt(1) === "=" ? bf(v, g) - v : parseFloat(g) - v,
            m: m && m < 4 ? Math.round : 0
        }, c = H_.lastIndex);
        return l.c = c < i.length ? i.substring(c, i.length) : "", l.fp = a, (X2.test(i) || _) && (l.e = 0), this._pt = l, l
    },
    gS = function(e, t, n, i, s, o, a, l, c, u) {
        hi(i) && (i = i(s || 0, e, o));
        var f = e[t],
            d = n !== "get" ? n : hi(f) ? c ? e[t.indexOf("set") || !hi(e["get" + t.substr(3)]) ? t : "get" + t.substr(3)](c) : e[t]() : f,
            m = hi(f) ? c ? BU : bP : yS,
            g;
        if (Xi(i) && (~i.indexOf("random(") && (i = op(i)), i.charAt(1) === "=" && (g = bf(d, i) + (hr(d) || 0), (g || g === 0) && (i = g))), !u || d !== i || V1) return !isNaN(d * i) && i !== "" ? (g = new Jr(this._pt, e, t, +d || 0, i - (d || 0), typeof f == "boolean" ? LU : TP, 0, m), c && (g.fp = c), a && g.modifier(a, this, e), this._pt = g) : (!f && !(t in e) && hS(t, i), EU.call(this, e, t, d, i, m, l || vs.stringFilter, c))
    },
    CU = function(e, t, n, i, s) {
        if (hi(e) && (e = Pd(e, s, t, n, i)), !No(e) || e.style && e.nodeType || mr(e) || W2(e)) return Xi(e) ? Pd(e, s, t, n, i) : e;
        var o = {},
            a;
        for (a in e) o[a] = Pd(e[a], s, t, n, i);
        return o
    },
    SP = function(e, t, n, i, s, o) {
        var a, l, c, u;
        if (fs[e] && (a = new fs[e]).init(s, a.rawVars ? t[e] : CU(t[e], i, s, o, n), n, i, o) !== !1 && (n._pt = l = new Jr(n._pt, s, e, 0, 1, a.render, a, 0, a.priority), n !== df))
            for (c = n._ptLookup[n._targets.indexOf(s)], u = a._props.length; u--;) c[a._props[u]] = l;
        return a
    },
    nl, V1, vS = function r(e, t, n) {
        var i = e.vars,
            s = i.ease,
            o = i.startAt,
            a = i.immediateRender,
            l = i.lazy,
            c = i.onUpdate,
            u = i.runBackwards,
            f = i.yoyoEase,
            d = i.keyframes,
            m = i.autoRevert,
            g = e._dur,
            y = e._startAt,
            v = e._targets,
            _ = e.parent,
            A = _ && _.data === "nested" ? _.vars.targets : v,
            S = e._overwrite === "auto" && !lS,
            M = e.timeline,
            C, E, R, P, b, T, L, D, V, H, q, X, oe;
        if (M && (!d || !s) && (s = "none"), e._ease = Gc(s, Hf.ease), e._yEase = f ? yP(Gc(f === !0 ? s : f, Hf.ease)) : 0, f && e._yoyo && !e._repeat && (f = e._yEase, e._yEase = e._ease, e._ease = f), e._from = !M && !!i.runBackwards, !M || d && !i.stagger) {
            if (D = v[0] ? kc(v[0]).harness : 0, X = D && i[D.prop], C = z0(i, dS), y && (y._zTime < 0 && y.progress(1), t < 0 && u && a && !m ? y.render(-1, !0) : y.revert(u && g ? A0 : nU), y._lazy = 0), o) {
                if (vl(e._startAt = Ci.set(v, qs({
                        data: "isStart",
                        overwrite: !1,
                        parent: _,
                        immediateRender: !0,
                        lazy: !y && Xr(l),
                        startAt: null,
                        delay: 0,
                        onUpdate: c && function() {
                            return ms(e, "onUpdate")
                        },
                        stagger: 0
                    }, o))), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (pr || !a && !m) && e._startAt.revert(A0), a && g && t <= 0 && n <= 0) {
                    t && (e._zTime = t);
                    return
                }
            } else if (u && g && !y) {
                if (t && (a = !1), R = qs({
                        overwrite: !1,
                        data: "isFromStart",
                        lazy: a && !y && Xr(l),
                        immediateRender: a,
                        stagger: 0,
                        parent: _
                    }, C), X && (R[D.prop] = X), vl(e._startAt = Ci.set(v, R)), e._startAt._dp = 0, e._startAt._sat = e, t < 0 && (pr ? e._startAt.revert(A0) : e._startAt.render(-1, !0)), e._zTime = t, !a) r(e._startAt, Gn, Gn);
                else if (!t) return
            }
            for (e._pt = e._ptCache = 0, l = g && Xr(l) || l && !g, E = 0; E < v.length; E++) {
                if (b = v[E], L = b._gsap || mS(v)[E]._gsap, e._ptLookup[E] = H = {}, O1[L.id] && ul.length && k0(), q = A === v ? E : A.indexOf(b), D && (V = new D).init(b, X || C, e, q, A) !== !1 && (e._pt = P = new Jr(e._pt, b, V.name, 0, 1, V.render, V, 0, V.priority), V._props.forEach(function(Y) {
                        H[Y] = P
                    }), V.priority && (T = 1)), !D || X)
                    for (R in C) fs[R] && (V = SP(R, C, e, q, b, A)) ? V.priority && (T = 1) : H[R] = P = gS.call(e, b, R, "get", C[R], q, A, 0, i.stringFilter);
                e._op && e._op[E] && e.kill(b, e._op[E]), S && e._pt && (nl = e, ii.killTweensOf(b, H, e.globalTime(t)), oe = !e.parent, nl = 0), e._pt && l && (O1[L.id] = 1)
            }
            T && CP(e), e._onInit && e._onInit(e)
        }
        e._onUpdate = c, e._initted = (!e._op || e._pt) && !oe, d && t <= 0 && M.render(js, !0, !0)
    },
    RU = function(e, t, n, i, s, o, a, l) {
        var c = (e._pt && e._ptCache || (e._ptCache = {}))[t],
            u, f, d, m;
        if (!c)
            for (c = e._ptCache[t] = [], d = e._ptLookup, m = e._targets.length; m--;) {
                if (u = d[m][t], u && u.d && u.d._pt)
                    for (u = u.d._pt; u && u.p !== t && u.fp !== t;) u = u._next;
                if (!u) return V1 = 1, e.vars[t] = "+=0", vS(e, a), V1 = 0, l ? rp(t + " not eligible for reset") : 1;
                c.push(u)
            }
        for (m = c.length; m--;) f = c[m], u = f._pt || f, u.s = (i || i === 0) && !s ? i : u.s + (i || 0) + o * u.c, u.c = n - u.s, f.e && (f.e = Ai(n) + hr(f.e)), f.b && (f.b = u.s + hr(f.b))
    },
    PU = function(e, t) {
        var n = e[0] ? kc(e[0]).harness : 0,
            i = n && n.aliases,
            s, o, a, l;
        if (!i) return t;
        s = eu({}, t);
        for (o in i)
            if (o in s)
                for (l = i[o].split(","), a = l.length; a--;) s[l[a]] = s[o];
        return s
    },
    IU = function(e, t, n, i) {
        var s = t.ease || i || "power1.inOut",
            o, a;
        if (mr(t)) a = n[e] || (n[e] = []), t.forEach(function(l, c) {
            return a.push({
                t: c / (t.length - 1) * 100,
                v: l,
                e: s
            })
        });
        else
            for (o in t) a = n[o] || (n[o] = []), o === "ease" || a.push({
                t: parseFloat(e),
                v: t[o],
                e: s
            })
    },
    Pd = function(e, t, n, i, s) {
        return hi(e) ? e.call(t, n, i, s) : Xi(e) && ~e.indexOf("random(") ? op(e) : e
    },
    MP = pS + "repeat,repeatDelay,yoyo,repeatRefresh,yoyoEase,autoRevert",
    wP = {};
Yr(MP + ",id,stagger,delay,duration,paused,scrollTrigger", function(r) {
    return wP[r] = 1
});
var Ci = function(r) {
    H2(e, r);

    function e(n, i, s, o) {
        var a;
        typeof i == "number" && (s.duration = i, i = s, s = null), a = r.call(this, o ? i : Cd(i)) || this;
        var l = a.vars,
            c = l.duration,
            u = l.delay,
            f = l.immediateRender,
            d = l.stagger,
            m = l.overwrite,
            g = l.keyframes,
            y = l.defaults,
            v = l.scrollTrigger,
            _ = l.yoyoEase,
            A = i.parent || ii,
            S = (mr(n) || W2(n) ? wa(n[0]) : "length" in i) ? [n] : Xs(n),
            M, C, E, R, P, b, T, L;
        if (a._targets = S.length ? mS(S) : rp("GSAP target " + n + " not found. https://gsap.com", !vs.nullTargetWarn) || [], a._ptLookup = [], a._overwrite = m, g || d || ng(c) || ng(u)) {
            if (i = a.vars, M = a.timeline = new Dr({
                    data: "nested",
                    defaults: y || {},
                    targets: A && A.data === "nested" ? A.vars.targets : S
                }), M.kill(), M.parent = M._dp = ra(a), M._start = 0, d || ng(c) || ng(u)) {
                if (R = S.length, T = d && lP(d), No(d))
                    for (P in d) ~MP.indexOf(P) && (L || (L = {}), L[P] = d[P]);
                for (C = 0; C < R; C++) E = z0(i, wP), E.stagger = 0, _ && (E.yoyoEase = _), L && eu(E, L), b = S[C], E.duration = +Pd(c, ra(a), C, b, S), E.delay = (+Pd(u, ra(a), C, b, S) || 0) - a._delay, !d && R === 1 && E.delay && (a._delay = u = E.delay, a._start += u, E.delay = 0), M.to(b, E, T ? T(C, b, S) : 0), M._ease = Sn.none;
                M.duration() ? c = u = 0 : a.timeline = 0
            } else if (g) {
                Cd(qs(M.vars.defaults, {
                    ease: "none"
                })), M._ease = Gc(g.ease || i.ease || "none");
                var D = 0,
                    V, H, q;
                if (mr(g)) g.forEach(function(X) {
                    return M.to(S, X, ">")
                }), M.duration();
                else {
                    E = {};
                    for (P in g) P === "ease" || P === "easeEach" || IU(P, g[P], E, g.easeEach);
                    for (P in E)
                        for (V = E[P].sort(function(X, oe) {
                                return X.t - oe.t
                            }), D = 0, C = 0; C < V.length; C++) H = V[C], q = {
                            ease: H.e,
                            duration: (H.t - (C ? V[C - 1].t : 0)) / 100 * c
                        }, q[P] = H.v, M.to(S, q, D), D += q.duration;
                    M.duration() < c && M.to({}, {
                        duration: c - M.duration()
                    })
                }
            }
            c || a.duration(c = M.duration())
        } else a.timeline = 0;
        return m === !0 && !lS && (nl = ra(a), ii.killTweensOf(S), nl = 0), Eo(A, ra(a), s), i.reversed && a.reverse(), i.paused && a.paused(!0), (f || !c && !g && a._start === Vi(A._time) && Xr(f) && lU(ra(a)) && A.data !== "nested") && (a._tTime = -Gn, a.render(Math.max(0, -u) || 0)), v && rP(ra(a), v), a
    }
    var t = e.prototype;
    return t.render = function(i, s, o) {
        var a = this._time,
            l = this._tDur,
            c = this._dur,
            u = i < 0,
            f = i > l - Gn && !u ? l : i < Gn ? 0 : i,
            d, m, g, y, v, _, A, S, M;
        if (!c) uU(this, i, s, o);
        else if (f !== this._tTime || !i || o || !this._initted && this._tTime || this._startAt && this._zTime < 0 !== u) {
            if (d = f, S = this.timeline, this._repeat) {
                if (y = c + this._rDelay, this._repeat < -1 && u) return this.totalTime(y * 100 + i, s, o);
                if (d = Vi(f % y), f === l ? (g = this._repeat, d = c) : (g = ~~(f / y), g && g === Vi(f / y) && (d = c, g--), d > c && (d = c)), _ = this._yoyo && g & 1, _ && (M = this._yEase, d = c - d), v = Vf(this._tTime, y), d === a && !o && this._initted && g === v) return this._tTime = f, this;
                g !== v && (S && this._yEase && _P(S, _), this.vars.repeatRefresh && !_ && !this._lock && this._time !== y && this._initted && (this._lock = o = 1, this.render(Vi(y * g), !0).invalidate()._lock = 0))
            }
            if (!this._initted) {
                if (sP(this, u ? i : d, o, s, f)) return this._tTime = 0, this;
                if (a !== this._time && !(o && this.vars.repeatRefresh && g !== v)) return this;
                if (c !== this._dur) return this.render(i, s, o)
            }
            if (this._tTime = f, this._time = d, !this._act && this._ts && (this._act = 1, this._lazy = 0), this.ratio = A = (M || this._ease)(d / c), this._from && (this.ratio = A = 1 - A), d && !a && !s && !g && (ms(this, "onStart"), this._tTime !== f)) return this;
            for (m = this._pt; m;) m.r(A, m.d), m = m._next;
            S && S.render(i < 0 ? i : S._dur * S._ease(d / this._dur), s, o) || this._startAt && (this._zTime = i), this._onUpdate && !s && (u && N1(this, i, s, o), ms(this, "onUpdate")), this._repeat && g !== v && this.vars.onRepeat && !s && this.parent && ms(this, "onRepeat"), (f === this._tDur || !f) && this._tTime === f && (u && !this._onUpdate && N1(this, i, !0, !0), (i || !c) && (f === this._tDur && this._ts > 0 || !f && this._ts < 0) && vl(this, 1), !s && !(u && !a) && (f || a || _) && (ms(this, f === l ? "onComplete" : "onReverseComplete", !0), this._prom && !(f < l && this.timeScale() > 0) && this._prom()))
        }
        return this
    }, t.targets = function() {
        return this._targets
    }, t.invalidate = function(i) {
        return (!i || !this.vars.runBackwards) && (this._startAt = 0), this._pt = this._op = this._onUpdate = this._lazy = this.ratio = 0, this._ptLookup = [], this.timeline && this.timeline.invalidate(i), r.prototype.invalidate.call(this, i)
    }, t.resetTo = function(i, s, o, a, l) {
        ap || ds.wake(), this._ts || this.play();
        var c = Math.min(this._dur, (this._dp._time - this._start) * this._ts),
            u;
        return this._initted || vS(this, c), u = this._ease(c / this._dur), RU(this, i, s, o, a, u, c, l) ? this.resetTo(i, s, o, a, 1) : (ey(this, 0), this.parent || nP(this._dp, this, "_first", "_last", this._dp._sort ? "_start" : 0), this.render(0))
    }, t.kill = function(i, s) {
        if (s === void 0 && (s = "all"), !i && (!s || s === "all")) return this._lazy = this._pt = 0, this.parent ? pd(this) : this;
        if (this.timeline) {
            var o = this.timeline.totalDuration();
            return this.timeline.killTweensOf(i, s, nl && nl.vars.overwrite !== !0)._first || pd(this), this.parent && o !== this.timeline.totalDuration() && Wf(this, this._dur * this.timeline._tDur / o, 0, 1), this
        }
        var a = this._targets,
            l = i ? Xs(i) : a,
            c = this._ptLookup,
            u = this._pt,
            f, d, m, g, y, v, _;
        if ((!s || s === "all") && oU(a, l)) return s === "all" && (this._pt = 0), pd(this);
        for (f = this._op = this._op || [], s !== "all" && (Xi(s) && (y = {}, Yr(s, function(A) {
                return y[A] = 1
            }), s = y), s = PU(a, s)), _ = a.length; _--;)
            if (~l.indexOf(a[_])) {
                d = c[_], s === "all" ? (f[_] = s, g = d, m = {}) : (m = f[_] = f[_] || {}, g = s);
                for (y in g) v = d && d[y], v && ((!("kill" in v.d) || v.d.kill(y) === !0) && Qv(this, v, "_pt"), delete d[y]), m !== "all" && (m[y] = 1)
            }
        return this._initted && !this._pt && u && pd(this), this
    }, e.to = function(i, s) {
        return new e(i, s, arguments[2])
    }, e.from = function(i, s) {
        return Rd(1, arguments)
    }, e.delayedCall = function(i, s, o, a) {
        return new e(s, 0, {
            immediateRender: !1,
            lazy: !1,
            overwrite: !1,
            delay: i,
            onComplete: s,
            onReverseComplete: s,
            onCompleteParams: o,
            onReverseCompleteParams: o,
            callbackScope: a
        })
    }, e.fromTo = function(i, s, o) {
        return Rd(2, arguments)
    }, e.set = function(i, s) {
        return s.duration = 0, s.repeatDelay || (s.repeat = 0), new e(i, s)
    }, e.killTweensOf = function(i, s, o) {
        return ii.killTweensOf(i, s, o)
    }, e
}(lp);
qs(Ci.prototype, {
    _targets: [],
    _lazy: 0,
    _startAt: 0,
    _op: 0,
    _onInit: 0
});
Yr("staggerTo,staggerFrom,staggerFromTo", function(r) {
    Ci[r] = function() {
        var e = new Dr,
            t = z1.call(arguments, 0);
        return t.splice(r === "staggerFromTo" ? 5 : 4, 0, 0), e[r].apply(e, t)
    }
});
var yS = function(e, t, n) {
        return e[t] = n
    },
    bP = function(e, t, n) {
        return e[t](n)
    },
    BU = function(e, t, n, i) {
        return e[t](i.fp, n)
    },
    DU = function(e, t, n) {
        return e.setAttribute(t, n)
    },
    _S = function(e, t) {
        return hi(e[t]) ? bP : cS(e[t]) && e.setAttribute ? DU : yS
    },
    TP = function(e, t) {
        return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e6) / 1e6, t)
    },
    LU = function(e, t) {
        return t.set(t.t, t.p, !!(t.s + t.c * e), t)
    },
    EP = function(e, t) {
        var n = t._pt,
            i = "";
        if (!e && t.b) i = t.b;
        else if (e === 1 && t.e) i = t.e;
        else {
            for (; n;) i = n.p + (n.m ? n.m(n.s + n.c * e) : Math.round((n.s + n.c * e) * 1e4) / 1e4) + i, n = n._next;
            i += t.c
        }
        t.set(t.t, t.p, i, t)
    },
    xS = function(e, t) {
        for (var n = t._pt; n;) n.r(e, n.d), n = n._next
    },
    FU = function(e, t, n, i) {
        for (var s = this._pt, o; s;) o = s._next, s.p === i && s.modifier(e, t, n), s = o
    },
    UU = function(e) {
        for (var t = this._pt, n, i; t;) i = t._next, t.p === e && !t.op || t.op === e ? Qv(this, t, "_pt") : t.dep || (n = 1), t = i;
        return !n
    },
    OU = function(e, t, n, i) {
        i.mSet(e, t, i.m.call(i.tween, n, i.mt), i)
    },
    CP = function(e) {
        for (var t = e._pt, n, i, s, o; t;) {
            for (n = t._next, i = s; i && i.pr > t.pr;) i = i._next;
            (t._prev = i ? i._prev : o) ? t._prev._next = t: s = t, (t._next = i) ? i._prev = t : o = t, t = n
        }
        e._pt = s
    },
    Jr = function() {
        function r(t, n, i, s, o, a, l, c, u) {
            this.t = n, this.s = s, this.c = o, this.p = i, this.r = a || TP, this.d = l || this, this.set = c || yS, this.pr = u || 0, this._next = t, t && (t._prev = this)
        }
        var e = r.prototype;
        return e.modifier = function(n, i, s) {
            this.mSet = this.mSet || this.set, this.set = OU, this.m = n, this.mt = s, this.tween = i
        }, r
    }();
Yr(pS + "parent,duration,ease,delay,overwrite,runBackwards,startAt,yoyo,immediateRender,repeat,repeatDelay,data,paused,reversed,lazy,callbackScope,stringFilter,id,yoyoEase,stagger,inherit,repeatRefresh,keyframes,autoRevert,scrollTrigger", function(r) {
    return dS[r] = 1
});
xs.TweenMax = xs.TweenLite = Ci;
xs.TimelineLite = xs.TimelineMax = Dr;
ii = new Dr({
    sortChildren: !1,
    defaults: Hf,
    autoRemoveChildren: !0,
    id: "root",
    smoothChildTiming: !0
});
vs.stringFilter = vP;
var Hc = [],
    M0 = {},
    NU = [],
    lT = 0,
    kU = 0,
    Y_ = function(e) {
        return (M0[e] || NU).map(function(t) {
            return t()
        })
    },
    W1 = function() {
        var e = Date.now(),
            t = [];
        e - lT > 2 && (Y_("matchMediaInit"), Hc.forEach(function(n) {
            var i = n.queries,
                s = n.conditions,
                o, a, l, c;
            for (a in i) o = bo.matchMedia(i[a]).matches, o && (l = 1), o !== s[a] && (s[a] = o, c = 1);
            c && (n.revert(), l && t.push(n))
        }), Y_("matchMediaRevert"), t.forEach(function(n) {
            return n.onMatch(n, function(i) {
                return n.add(null, i)
            })
        }), lT = e, Y_("matchMedia"))
    },
    RP = function() {
        function r(t, n) {
            this.selector = n && G1(n), this.data = [], this._r = [], this.isReverted = !1, this.id = kU++, t && this.add(t)
        }
        var e = r.prototype;
        return e.add = function(n, i, s) {
            hi(n) && (s = i, i = n, n = hi);
            var o = this,
                a = function() {
                    var c = Kn,
                        u = o.selector,
                        f;
                    return c && c !== o && c.data.push(o), s && (o.selector = G1(s)), Kn = o, f = i.apply(o, arguments), hi(f) && o._r.push(f), Kn = c, o.selector = u, o.isReverted = !1, f
                };
            return o.last = a, n === hi ? a(o, function(l) {
                return o.add(null, l)
            }) : n ? o[n] = a : a
        }, e.ignore = function(n) {
            var i = Kn;
            Kn = null, n(this), Kn = i
        }, e.getTweens = function() {
            var n = [];
            return this.data.forEach(function(i) {
                return i instanceof r ? n.push.apply(n, i.getTweens()) : i instanceof Ci && !(i.parent && i.parent.data === "nested") && n.push(i)
            }), n
        }, e.clear = function() {
            this._r.length = this.data.length = 0
        }, e.kill = function(n, i) {
            var s = this;
            if (n ? function() {
                    for (var a = s.getTweens(), l = s.data.length, c; l--;) c = s.data[l], c.data === "isFlip" && (c.revert(), c.getChildren(!0, !0, !1).forEach(function(u) {
                        return a.splice(a.indexOf(u), 1)
                    }));
                    for (a.map(function(u) {
                            return {
                                g: u._dur || u._delay || u._sat && !u._sat.vars.immediateRender ? u.globalTime(0) : -1 / 0,
                                t: u
                            }
                        }).sort(function(u, f) {
                            return f.g - u.g || -1 / 0
                        }).forEach(function(u) {
                            return u.t.revert(n)
                        }), l = s.data.length; l--;) c = s.data[l], c instanceof Dr ? c.data !== "nested" && (c.scrollTrigger && c.scrollTrigger.revert(), c.kill()) : !(c instanceof Ci) && c.revert && c.revert(n);
                    s._r.forEach(function(u) {
                        return u(n, s)
                    }), s.isReverted = !0
                }() : this.data.forEach(function(a) {
                    return a.kill && a.kill()
                }), this.clear(), i)
                for (var o = Hc.length; o--;) Hc[o].id === this.id && Hc.splice(o, 1)
        }, e.revert = function(n) {
            this.kill(n || {})
        }, r
    }(),
    zU = function() {
        function r(t) {
            this.contexts = [], this.scope = t, Kn && Kn.data.push(this)
        }
        var e = r.prototype;
        return e.add = function(n, i, s) {
            No(n) || (n = {
                matches: n
            });
            var o = new RP(0, s || this.scope),
                a = o.conditions = {},
                l, c, u;
            Kn && !o.selector && (o.selector = Kn.selector), this.contexts.push(o), i = o.add("onMatch", i), o.queries = n;
            for (c in n) c === "all" ? u = 1 : (l = bo.matchMedia(n[c]), l && (Hc.indexOf(o) < 0 && Hc.push(o), (a[c] = l.matches) && (u = 1), l.addListener ? l.addListener(W1) : l.addEventListener("change", W1)));
            return u && i(o, function(f) {
                return o.add(null, f)
            }), this
        }, e.revert = function(n) {
            this.kill(n || {})
        }, e.kill = function(n) {
            this.contexts.forEach(function(i) {
                return i.kill(n, !0)
            })
        }, r
    }(),
    H0 = {
        registerPlugin: function() {
            for (var e = arguments.length, t = new Array(e), n = 0; n < e; n++) t[n] = arguments[n];
            t.forEach(function(i) {
                return pP(i)
            })
        },
        timeline: function(e) {
            return new Dr(e)
        },
        getTweensOf: function(e, t) {
            return ii.getTweensOf(e, t)
        },
        getProperty: function(e, t, n, i) {
            Xi(e) && (e = Xs(e)[0]);
            var s = kc(e || {}).get,
                o = n ? tP : eP;
            return n === "native" && (n = ""), e && (t ? o((fs[t] && fs[t].get || s)(e, t, n, i)) : function(a, l, c) {
                return o((fs[a] && fs[a].get || s)(e, a, l, c))
            })
        },
        quickSetter: function(e, t, n) {
            if (e = Xs(e), e.length > 1) {
                var i = e.map(function(u) {
                        return Zr.quickSetter(u, t, n)
                    }),
                    s = i.length;
                return function(u) {
                    for (var f = s; f--;) i[f](u)
                }
            }
            e = e[0] || {};
            var o = fs[t],
                a = kc(e),
                l = a.harness && (a.harness.aliases || {})[t] || t,
                c = o ? function(u) {
                    var f = new o;
                    df._pt = 0, f.init(e, n ? u + n : u, df, 0, [e]), f.render(1, f), df._pt && xS(1, df)
                } : a.set(e, l);
            return o ? c : function(u) {
                return c(e, l, n ? u + n : u, a, 1)
            }
        },
        quickTo: function(e, t, n) {
            var i, s = Zr.to(e, eu((i = {}, i[t] = "+=0.1", i.paused = !0, i), n || {})),
                o = function(l, c, u) {
                    return s.resetTo(t, l, c, u)
                };
            return o.tween = s, o
        },
        isTweening: function(e) {
            return ii.getTweensOf(e, !0).length > 0
        },
        defaults: function(e) {
            return e && e.ease && (e.ease = Gc(e.ease, Hf.ease)), iT(Hf, e || {})
        },
        config: function(e) {
            return iT(vs, e || {})
        },
        registerEffect: function(e) {
            var t = e.name,
                n = e.effect,
                i = e.plugins,
                s = e.defaults,
                o = e.extendTimeline;
            (i || "").split(",").forEach(function(a) {
                return a && !fs[a] && !xs[a] && rp(t + " effect requires " + a + " plugin.")
            }), V_[t] = function(a, l, c) {
                return n(Xs(a), qs(l || {}, s), c)
            }, o && (Dr.prototype[t] = function(a, l, c) {
                return this.add(V_[t](a, No(l) ? l : (c = l) && {}, this), c)
            })
        },
        registerEase: function(e, t) {
            Sn[e] = Gc(t)
        },
        parseEase: function(e, t) {
            return arguments.length ? Gc(e, t) : Sn
        },
        getById: function(e) {
            return ii.getById(e)
        },
        exportRoot: function(e, t) {
            e === void 0 && (e = {});
            var n = new Dr(e),
                i, s;
            for (n.smoothChildTiming = Xr(e.smoothChildTiming), ii.remove(n), n._dp = 0, n._time = n._tTime = ii._time, i = ii._first; i;) s = i._next, (t || !(!i._dur && i instanceof Ci && i.vars.onComplete === i._targets[0])) && Eo(n, i, i._start - i._delay), i = s;
            return Eo(ii, n, 0), n
        },
        context: function(e, t) {
            return e ? new RP(e, t) : Kn
        },
        matchMedia: function(e) {
            return new zU(e)
        },
        matchMediaRefresh: function() {
            return Hc.forEach(function(e) {
                var t = e.conditions,
                    n, i;
                for (i in t) t[i] && (t[i] = !1, n = 1);
                n && e.revert()
            }) || W1()
        },
        addEventListener: function(e, t) {
            var n = M0[e] || (M0[e] = []);
            ~n.indexOf(t) || n.push(t)
        },
        removeEventListener: function(e, t) {
            var n = M0[e],
                i = n && n.indexOf(t);
            i >= 0 && n.splice(i, 1)
        },
        utils: {
            wrap: yU,
            wrapYoyo: _U,
            distribute: lP,
            random: uP,
            snap: cP,
            normalize: vU,
            getUnit: hr,
            clamp: dU,
            splitColor: mP,
            toArray: Xs,
            selector: G1,
            mapRange: hP,
            pipe: mU,
            unitize: gU,
            interpolate: xU,
            shuffle: aP
        },
        install: K2,
        effects: V_,
        ticker: ds,
        updateRoot: Dr.updateRoot,
        plugins: fs,
        globalTimeline: ii,
        core: {
            PropTween: Jr,
            globals: q2,
            Tween: Ci,
            Timeline: Dr,
            Animation: lp,
            getCache: kc,
            _removeLinkedListItem: Qv,
            reverting: function() {
                return pr
            },
            context: function(e) {
                return e && Kn && (Kn.data.push(e), e._ctx = Kn), Kn
            },
            suppressOverwrites: function(e) {
                return lS = e
            }
        }
    };
Yr("to,from,fromTo,delayedCall,set,killTweensOf", function(r) {
    return H0[r] = Ci[r]
});
ds.add(Dr.updateRoot);
df = H0.to({}, {
    duration: 0
});
var GU = function(e, t) {
        for (var n = e._pt; n && n.p !== t && n.op !== t && n.fp !== t;) n = n._next;
        return n
    },
    HU = function(e, t) {
        var n = e._targets,
            i, s, o;
        for (i in t)
            for (s = n.length; s--;) o = e._ptLookup[s][i], o && (o = o.d) && (o._pt && (o = GU(o, i)), o && o.modifier && o.modifier(t[i], e, n[s], i))
    },
    J_ = function(e, t) {
        return {
            name: e,
            rawVars: 1,
            init: function(i, s, o) {
                o._onInit = function(a) {
                    var l, c;
                    if (Xi(s) && (l = {}, Yr(s, function(u) {
                            return l[u] = 1
                        }), s = l), t) {
                        l = {};
                        for (c in s) l[c] = t(s[c]);
                        s = l
                    }
                    HU(a, s)
                }
            }
        }
    },
    Zr = H0.registerPlugin({
        name: "attr",
        init: function(e, t, n, i, s) {
            var o, a, l;
            this.tween = n;
            for (o in t) l = e.getAttribute(o) || "", a = this.add(e, "setAttribute", (l || 0) + "", t[o], i, s, 0, 0, o), a.op = o, a.b = l, this._props.push(o)
        },
        render: function(e, t) {
            for (var n = t._pt; n;) pr ? n.set(n.t, n.p, n.b, n) : n.r(e, n.d), n = n._next
        }
    }, {
        name: "endArray",
        init: function(e, t) {
            for (var n = t.length; n--;) this.add(e, n, e[n] || 0, t[n], 0, 0, 0, 0, 0, 1)
        }
    }, J_("roundProps", H1), J_("modifiers"), J_("snap", cP)) || H0;
Ci.version = Dr.version = Zr.version = "3.12.5";
J2 = 1;
uS() && jf();
Sn.Power0;
Sn.Power1;
Sn.Power2;
Sn.Power3;
Sn.Power4;
Sn.Linear;
Sn.Quad;
Sn.Cubic;
Sn.Quart;
Sn.Quint;
Sn.Strong;
Sn.Elastic;
Sn.Back;
Sn.SteppedEase;
Sn.Bounce;
Sn.Sine;
Sn.Expo;
Sn.Circ;
/*!
 * CSSPlugin 3.12.5
 * https://gsap.com
 *
 * Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var cT, il, Tf, AS, Cc, uT, SS, VU = function() {
        return typeof window < "u"
    },
    ba = {},
    xc = 180 / Math.PI,
    Ef = Math.PI / 180,
    Fu = Math.atan2,
    fT = 1e8,
    MS = /([A-Z])/g,
    WU = /(left|right|width|margin|padding|x)/i,
    jU = /[\s,\(]\S/,
    Ro = {
        autoAlpha: "opacity,visibility",
        scale: "scaleX,scaleY",
        alpha: "opacity"
    },
    j1 = function(e, t) {
        return t.set(t.t, t.p, Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
    },
    XU = function(e, t) {
        return t.set(t.t, t.p, e === 1 ? t.e : Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u, t)
    },
    YU = function(e, t) {
        return t.set(t.t, t.p, e ? Math.round((t.s + t.c * e) * 1e4) / 1e4 + t.u : t.b, t)
    },
    JU = function(e, t) {
        var n = t.s + t.c * e;
        t.set(t.t, t.p, ~~(n + (n < 0 ? -.5 : .5)) + t.u, t)
    },
    PP = function(e, t) {
        return t.set(t.t, t.p, e ? t.e : t.b, t)
    },
    IP = function(e, t) {
        return t.set(t.t, t.p, e !== 1 ? t.b : t.e, t)
    },
    KU = function(e, t, n) {
        return e.style[t] = n
    },
    qU = function(e, t, n) {
        return e.style.setProperty(t, n)
    },
    ZU = function(e, t, n) {
        return e._gsap[t] = n
    },
    QU = function(e, t, n) {
        return e._gsap.scaleX = e._gsap.scaleY = n
    },
    $U = function(e, t, n, i, s) {
        var o = e._gsap;
        o.scaleX = o.scaleY = n, o.renderTransform(s, o)
    },
    eO = function(e, t, n, i, s) {
        var o = e._gsap;
        o[t] = n, o.renderTransform(s, o)
    },
    si = "transform",
    Kr = si + "Origin",
    tO = function r(e, t) {
        var n = this,
            i = this.target,
            s = i.style,
            o = i._gsap;
        if (e in ba && s) {
            if (this.tfm = this.tfm || {}, e !== "transform") e = Ro[e] || e, ~e.indexOf(",") ? e.split(",").forEach(function(a) {
                return n.tfm[a] = oa(i, a)
            }) : this.tfm[e] = o.x ? o[e] : oa(i, e), e === Kr && (this.tfm.zOrigin = o.zOrigin);
            else return Ro.transform.split(",").forEach(function(a) {
                return r.call(n, a, t)
            });
            if (this.props.indexOf(si) >= 0) return;
            o.svg && (this.svgo = i.getAttribute("data-svg-origin"), this.props.push(Kr, t, "")), e = si
        }(s || t) && this.props.push(e, t, s[e])
    },
    BP = function(e) {
        e.translate && (e.removeProperty("translate"), e.removeProperty("scale"), e.removeProperty("rotate"))
    },
    nO = function() {
        var e = this.props,
            t = this.target,
            n = t.style,
            i = t._gsap,
            s, o;
        for (s = 0; s < e.length; s += 3) e[s + 1] ? t[e[s]] = e[s + 2] : e[s + 2] ? n[e[s]] = e[s + 2] : n.removeProperty(e[s].substr(0, 2) === "--" ? e[s] : e[s].replace(MS, "-$1").toLowerCase());
        if (this.tfm) {
            for (o in this.tfm) i[o] = this.tfm[o];
            i.svg && (i.renderTransform(), t.setAttribute("data-svg-origin", this.svgo || "")), s = SS(), (!s || !s.isStart) && !n[si] && (BP(n), i.zOrigin && n[Kr] && (n[Kr] += " " + i.zOrigin + "px", i.zOrigin = 0, i.renderTransform()), i.uncache = 1)
        }
    },
    DP = function(e, t) {
        var n = {
            target: e,
            props: [],
            revert: nO,
            save: tO
        };
        return e._gsap || Zr.core.getCache(e), t && t.split(",").forEach(function(i) {
            return n.save(i)
        }), n
    },
    LP, X1 = function(e, t) {
        var n = il.createElementNS ? il.createElementNS((t || "http://www.w3.org/1999/xhtml").replace(/^https/, "http"), e) : il.createElement(e);
        return n && n.style ? n : il.createElement(e)
    },
    Do = function r(e, t, n) {
        var i = getComputedStyle(e);
        return i[t] || i.getPropertyValue(t.replace(MS, "-$1").toLowerCase()) || i.getPropertyValue(t) || !n && r(e, Xf(t) || t, 1) || ""
    },
    hT = "O,Moz,ms,Ms,Webkit".split(","),
    Xf = function(e, t, n) {
        var i = t || Cc,
            s = i.style,
            o = 5;
        if (e in s && !n) return e;
        for (e = e.charAt(0).toUpperCase() + e.substr(1); o-- && !(hT[o] + e in s););
        return o < 0 ? null : (o === 3 ? "ms" : o >= 0 ? hT[o] : "") + e
    },
    Y1 = function() {
        VU() && window.document && (cT = window, il = cT.document, Tf = il.documentElement, Cc = X1("div") || {
            style: {}
        }, X1("div"), si = Xf(si), Kr = si + "Origin", Cc.style.cssText = "border-width:0;line-height:0;position:absolute;padding:0", LP = !!Xf("perspective"), SS = Zr.core.reverting, AS = 1)
    },
    K_ = function r(e) {
        var t = X1("svg", this.ownerSVGElement && this.ownerSVGElement.getAttribute("xmlns") || "http://www.w3.org/2000/svg"),
            n = this.parentNode,
            i = this.nextSibling,
            s = this.style.cssText,
            o;
        if (Tf.appendChild(t), t.appendChild(this), this.style.display = "block", e) try {
            o = this.getBBox(), this._gsapBBox = this.getBBox, this.getBBox = r
        } catch {} else this._gsapBBox && (o = this._gsapBBox());
        return n && (i ? n.insertBefore(this, i) : n.appendChild(this)), Tf.removeChild(t), this.style.cssText = s, o
    },
    dT = function(e, t) {
        for (var n = t.length; n--;)
            if (e.hasAttribute(t[n])) return e.getAttribute(t[n])
    },
    FP = function(e) {
        var t;
        try {
            t = e.getBBox()
        } catch {
            t = K_.call(e, !0)
        }
        return t && (t.width || t.height) || e.getBBox === K_ || (t = K_.call(e, !0)), t && !t.width && !t.x && !t.y ? {
            x: +dT(e, ["x", "cx", "x1"]) || 0,
            y: +dT(e, ["y", "cy", "y1"]) || 0,
            width: 0,
            height: 0
        } : t
    },
    UP = function(e) {
        return !!(e.getCTM && (!e.parentNode || e.ownerSVGElement) && FP(e))
    },
    tu = function(e, t) {
        if (t) {
            var n = e.style,
                i;
            t in ba && t !== Kr && (t = si), n.removeProperty ? (i = t.substr(0, 2), (i === "ms" || t.substr(0, 6) === "webkit") && (t = "-" + t), n.removeProperty(i === "--" ? t : t.replace(MS, "-$1").toLowerCase())) : n.removeAttribute(t)
        }
    },
    rl = function(e, t, n, i, s, o) {
        var a = new Jr(e._pt, t, n, 0, 1, o ? IP : PP);
        return e._pt = a, a.b = i, a.e = s, e._props.push(n), a
    },
    pT = {
        deg: 1,
        rad: 1,
        turn: 1
    },
    iO = {
        grid: 1,
        flex: 1
    },
    yl = function r(e, t, n, i) {
        var s = parseFloat(n) || 0,
            o = (n + "").trim().substr((s + "").length) || "px",
            a = Cc.style,
            l = WU.test(t),
            c = e.tagName.toLowerCase() === "svg",
            u = (c ? "client" : "offset") + (l ? "Width" : "Height"),
            f = 100,
            d = i === "px",
            m = i === "%",
            g, y, v, _;
        if (i === o || !s || pT[i] || pT[o]) return s;
        if (o !== "px" && !d && (s = r(e, t, n, "px")), _ = e.getCTM && UP(e), (m || o === "%") && (ba[t] || ~t.indexOf("adius"))) return g = _ ? e.getBBox()[l ? "width" : "height"] : e[u], Ai(m ? s / g * f : s / 100 * g);
        if (a[l ? "width" : "height"] = f + (d ? o : i), y = ~t.indexOf("adius") || i === "em" && e.appendChild && !c ? e : e.parentNode, _ && (y = (e.ownerSVGElement || {}).parentNode), (!y || y === il || !y.appendChild) && (y = il.body), v = y._gsap, v && m && v.width && l && v.time === ds.time && !v.uncache) return Ai(s / v.width * f);
        if (m && (t === "height" || t === "width")) {
            var A = e.style[t];
            e.style[t] = f + i, g = e[u], A ? e.style[t] = A : tu(e, t)
        } else(m || o === "%") && !iO[Do(y, "display")] && (a.position = Do(e, "position")), y === e && (a.position = "static"), y.appendChild(Cc), g = Cc[u], y.removeChild(Cc), a.position = "absolute";
        return l && m && (v = kc(y), v.time = ds.time, v.width = y[u]), Ai(d ? g * s / f : g && s ? f / g * s : 0)
    },
    oa = function(e, t, n, i) {
        var s;
        return AS || Y1(), t in Ro && t !== "transform" && (t = Ro[t], ~t.indexOf(",") && (t = t.split(",")[0])), ba[t] && t !== "transform" ? (s = up(e, i), s = t !== "transformOrigin" ? s[t] : s.svg ? s.origin : W0(Do(e, Kr)) + " " + s.zOrigin + "px") : (s = e.style[t], (!s || s === "auto" || i || ~(s + "").indexOf("calc(")) && (s = V0[t] && V0[t](e, t, n) || Do(e, t) || Q2(e, t) || (t === "opacity" ? 1 : 0))), n && !~(s + "").trim().indexOf(" ") ? yl(e, t, s, n) + n : s
    },
    rO = function(e, t, n, i) {
        if (!n || n === "none") {
            var s = Xf(t, e, 1),
                o = s && Do(e, s, 1);
            o && o !== n ? (t = s, n = o) : t === "borderColor" && (n = Do(e, "borderTopColor"))
        }
        var a = new Jr(this._pt, e.style, t, 0, 1, EP),
            l = 0,
            c = 0,
            u, f, d, m, g, y, v, _, A, S, M, C;
        if (a.b = n, a.e = i, n += "", i += "", i === "auto" && (y = e.style[t], e.style[t] = i, i = Do(e, t) || i, y ? e.style[t] = y : tu(e, t)), u = [n, i], vP(u), n = u[0], i = u[1], d = n.match(hf) || [], C = i.match(hf) || [], C.length) {
            for (; f = hf.exec(i);) v = f[0], A = i.substring(l, f.index), g ? g = (g + 1) % 5 : (A.substr(-5) === "rgba(" || A.substr(-5) === "hsla(") && (g = 1), v !== (y = d[c++] || "") && (m = parseFloat(y) || 0, M = y.substr((m + "").length), v.charAt(1) === "=" && (v = bf(m, v) + M), _ = parseFloat(v), S = v.substr((_ + "").length), l = hf.lastIndex - S.length, S || (S = S || vs.units[t] || M, l === i.length && (i += S, a.e += S)), M !== S && (m = yl(e, t, y, S) || 0), a._pt = {
                _next: a._pt,
                p: A || c === 1 ? A : ",",
                s: m,
                c: _ - m,
                m: g && g < 4 || t === "zIndex" ? Math.round : 0
            });
            a.c = l < i.length ? i.substring(l, i.length) : ""
        } else a.r = t === "display" && i === "none" ? IP : PP;
        return X2.test(i) && (a.e = 0), this._pt = a, a
    },
    mT = {
        top: "0%",
        bottom: "100%",
        left: "0%",
        right: "100%",
        center: "50%"
    },
    sO = function(e) {
        var t = e.split(" "),
            n = t[0],
            i = t[1] || "50%";
        return (n === "top" || n === "bottom" || i === "left" || i === "right") && (e = n, n = i, i = e), t[0] = mT[n] || n, t[1] = mT[i] || i, t.join(" ")
    },
    oO = function(e, t) {
        if (t.tween && t.tween._time === t.tween._dur) {
            var n = t.t,
                i = n.style,
                s = t.u,
                o = n._gsap,
                a, l, c;
            if (s === "all" || s === !0) i.cssText = "", l = 1;
            else
                for (s = s.split(","), c = s.length; --c > -1;) a = s[c], ba[a] && (l = 1, a = a === "transformOrigin" ? Kr : si), tu(n, a);
            l && (tu(n, si), o && (o.svg && n.removeAttribute("transform"), up(n, 1), o.uncache = 1, BP(i)))
        }
    },
    V0 = {
        clearProps: function(e, t, n, i, s) {
            if (s.data !== "isFromStart") {
                var o = e._pt = new Jr(e._pt, t, n, 0, 0, oO);
                return o.u = i, o.pr = -10, o.tween = s, e._props.push(n), 1
            }
        }
    },
    cp = [1, 0, 0, 1, 0, 0],
    OP = {},
    NP = function(e) {
        return e === "matrix(1, 0, 0, 1, 0, 0)" || e === "none" || !e
    },
    gT = function(e) {
        var t = Do(e, si);
        return NP(t) ? cp : t.substr(7).match(j2).map(Ai)
    },
    wS = function(e, t) {
        var n = e._gsap || kc(e),
            i = e.style,
            s = gT(e),
            o, a, l, c;
        return n.svg && e.getAttribute("transform") ? (l = e.transform.baseVal.consolidate().matrix, s = [l.a, l.b, l.c, l.d, l.e, l.f], s.join(",") === "1,0,0,1,0,0" ? cp : s) : (s === cp && !e.offsetParent && e !== Tf && !n.svg && (l = i.display, i.display = "block", o = e.parentNode, (!o || !e.offsetParent) && (c = 1, a = e.nextElementSibling, Tf.appendChild(e)), s = gT(e), l ? i.display = l : tu(e, "display"), c && (a ? o.insertBefore(e, a) : o ? o.appendChild(e) : Tf.removeChild(e))), t && s.length > 6 ? [s[0], s[1], s[4], s[5], s[12], s[13]] : s)
    },
    J1 = function(e, t, n, i, s, o) {
        var a = e._gsap,
            l = s || wS(e, !0),
            c = a.xOrigin || 0,
            u = a.yOrigin || 0,
            f = a.xOffset || 0,
            d = a.yOffset || 0,
            m = l[0],
            g = l[1],
            y = l[2],
            v = l[3],
            _ = l[4],
            A = l[5],
            S = t.split(" "),
            M = parseFloat(S[0]) || 0,
            C = parseFloat(S[1]) || 0,
            E, R, P, b;
        n ? l !== cp && (R = m * v - g * y) && (P = M * (v / R) + C * (-y / R) + (y * A - v * _) / R, b = M * (-g / R) + C * (m / R) - (m * A - g * _) / R, M = P, C = b) : (E = FP(e), M = E.x + (~S[0].indexOf("%") ? M / 100 * E.width : M), C = E.y + (~(S[1] || S[0]).indexOf("%") ? C / 100 * E.height : C)), i || i !== !1 && a.smooth ? (_ = M - c, A = C - u, a.xOffset = f + (_ * m + A * y) - _, a.yOffset = d + (_ * g + A * v) - A) : a.xOffset = a.yOffset = 0, a.xOrigin = M, a.yOrigin = C, a.smooth = !!i, a.origin = t, a.originIsAbsolute = !!n, e.style[Kr] = "0px 0px", o && (rl(o, a, "xOrigin", c, M), rl(o, a, "yOrigin", u, C), rl(o, a, "xOffset", f, a.xOffset), rl(o, a, "yOffset", d, a.yOffset)), e.setAttribute("data-svg-origin", M + " " + C)
    },
    up = function(e, t) {
        var n = e._gsap || new AP(e);
        if ("x" in n && !t && !n.uncache) return n;
        var i = e.style,
            s = n.scaleX < 0,
            o = "px",
            a = "deg",
            l = getComputedStyle(e),
            c = Do(e, Kr) || "0",
            u, f, d, m, g, y, v, _, A, S, M, C, E, R, P, b, T, L, D, V, H, q, X, oe, Y, Z, U, j, te, he, $, ne;
        return u = f = d = y = v = _ = A = S = M = 0, m = g = 1, n.svg = !!(e.getCTM && UP(e)), l.translate && ((l.translate !== "none" || l.scale !== "none" || l.rotate !== "none") && (i[si] = (l.translate !== "none" ? "translate3d(" + (l.translate + " 0 0").split(" ").slice(0, 3).join(", ") + ") " : "") + (l.rotate !== "none" ? "rotate(" + l.rotate + ") " : "") + (l.scale !== "none" ? "scale(" + l.scale.split(" ").join(",") + ") " : "") + (l[si] !== "none" ? l[si] : "")), i.scale = i.rotate = i.translate = "none"), R = wS(e, n.svg), n.svg && (n.uncache ? (Y = e.getBBox(), c = n.xOrigin - Y.x + "px " + (n.yOrigin - Y.y) + "px", oe = "") : oe = !t && e.getAttribute("data-svg-origin"), J1(e, oe || c, !!oe || n.originIsAbsolute, n.smooth !== !1, R)), C = n.xOrigin || 0, E = n.yOrigin || 0, R !== cp && (L = R[0], D = R[1], V = R[2], H = R[3], u = q = R[4], f = X = R[5], R.length === 6 ? (m = Math.sqrt(L * L + D * D), g = Math.sqrt(H * H + V * V), y = L || D ? Fu(D, L) * xc : 0, A = V || H ? Fu(V, H) * xc + y : 0, A && (g *= Math.abs(Math.cos(A * Ef))), n.svg && (u -= C - (C * L + E * V), f -= E - (C * D + E * H))) : (ne = R[6], he = R[7], U = R[8], j = R[9], te = R[10], $ = R[11], u = R[12], f = R[13], d = R[14], P = Fu(ne, te), v = P * xc, P && (b = Math.cos(-P), T = Math.sin(-P), oe = q * b + U * T, Y = X * b + j * T, Z = ne * b + te * T, U = q * -T + U * b, j = X * -T + j * b, te = ne * -T + te * b, $ = he * -T + $ * b, q = oe, X = Y, ne = Z), P = Fu(-V, te), _ = P * xc, P && (b = Math.cos(-P), T = Math.sin(-P), oe = L * b - U * T, Y = D * b - j * T, Z = V * b - te * T, $ = H * T + $ * b, L = oe, D = Y, V = Z), P = Fu(D, L), y = P * xc, P && (b = Math.cos(P), T = Math.sin(P), oe = L * b + D * T, Y = q * b + X * T, D = D * b - L * T, X = X * b - q * T, L = oe, q = Y), v && Math.abs(v) + Math.abs(y) > 359.9 && (v = y = 0, _ = 180 - _), m = Ai(Math.sqrt(L * L + D * D + V * V)), g = Ai(Math.sqrt(X * X + ne * ne)), P = Fu(q, X), A = Math.abs(P) > 2e-4 ? P * xc : 0, M = $ ? 1 / ($ < 0 ? -$ : $) : 0), n.svg && (oe = e.getAttribute("transform"), n.forceCSS = e.setAttribute("transform", "") || !NP(Do(e, si)), oe && e.setAttribute("transform", oe))), Math.abs(A) > 90 && Math.abs(A) < 270 && (s ? (m *= -1, A += y <= 0 ? 180 : -180, y += y <= 0 ? 180 : -180) : (g *= -1, A += A <= 0 ? 180 : -180)), t = t || n.uncache, n.x = u - ((n.xPercent = u && (!t && n.xPercent || (Math.round(e.offsetWidth / 2) === Math.round(-u) ? -50 : 0))) ? e.offsetWidth * n.xPercent / 100 : 0) + o, n.y = f - ((n.yPercent = f && (!t && n.yPercent || (Math.round(e.offsetHeight / 2) === Math.round(-f) ? -50 : 0))) ? e.offsetHeight * n.yPercent / 100 : 0) + o, n.z = d + o, n.scaleX = Ai(m), n.scaleY = Ai(g), n.rotation = Ai(y) + a, n.rotationX = Ai(v) + a, n.rotationY = Ai(_) + a, n.skewX = A + a, n.skewY = S + a, n.transformPerspective = M + o, (n.zOrigin = parseFloat(c.split(" ")[2]) || !t && n.zOrigin || 0) && (i[Kr] = W0(c)), n.xOffset = n.yOffset = 0, n.force3D = vs.force3D, n.renderTransform = n.svg ? lO : LP ? kP : aO, n.uncache = 0, n
    },
    W0 = function(e) {
        return (e = e.split(" "))[0] + " " + e[1]
    },
    q_ = function(e, t, n) {
        var i = hr(t);
        return Ai(parseFloat(t) + parseFloat(yl(e, "x", n + "px", i))) + i
    },
    aO = function(e, t) {
        t.z = "0px", t.rotationY = t.rotationX = "0deg", t.force3D = 0, kP(e, t)
    },
    tc = "0deg",
    Hh = "0px",
    nc = ") ",
    kP = function(e, t) {
        var n = t || this,
            i = n.xPercent,
            s = n.yPercent,
            o = n.x,
            a = n.y,
            l = n.z,
            c = n.rotation,
            u = n.rotationY,
            f = n.rotationX,
            d = n.skewX,
            m = n.skewY,
            g = n.scaleX,
            y = n.scaleY,
            v = n.transformPerspective,
            _ = n.force3D,
            A = n.target,
            S = n.zOrigin,
            M = "",
            C = _ === "auto" && e && e !== 1 || _ === !0;
        if (S && (f !== tc || u !== tc)) {
            var E = parseFloat(u) * Ef,
                R = Math.sin(E),
                P = Math.cos(E),
                b;
            E = parseFloat(f) * Ef, b = Math.cos(E), o = q_(A, o, R * b * -S), a = q_(A, a, -Math.sin(E) * -S), l = q_(A, l, P * b * -S + S)
        }
        v !== Hh && (M += "perspective(" + v + nc), (i || s) && (M += "translate(" + i + "%, " + s + "%) "), (C || o !== Hh || a !== Hh || l !== Hh) && (M += l !== Hh || C ? "translate3d(" + o + ", " + a + ", " + l + ") " : "translate(" + o + ", " + a + nc), c !== tc && (M += "rotate(" + c + nc), u !== tc && (M += "rotateY(" + u + nc), f !== tc && (M += "rotateX(" + f + nc), (d !== tc || m !== tc) && (M += "skew(" + d + ", " + m + nc), (g !== 1 || y !== 1) && (M += "scale(" + g + ", " + y + nc), A.style[si] = M || "translate(0, 0)"
    },
    lO = function(e, t) {
        var n = t || this,
            i = n.xPercent,
            s = n.yPercent,
            o = n.x,
            a = n.y,
            l = n.rotation,
            c = n.skewX,
            u = n.skewY,
            f = n.scaleX,
            d = n.scaleY,
            m = n.target,
            g = n.xOrigin,
            y = n.yOrigin,
            v = n.xOffset,
            _ = n.yOffset,
            A = n.forceCSS,
            S = parseFloat(o),
            M = parseFloat(a),
            C, E, R, P, b;
        l = parseFloat(l), c = parseFloat(c), u = parseFloat(u), u && (u = parseFloat(u), c += u, l += u), l || c ? (l *= Ef, c *= Ef, C = Math.cos(l) * f, E = Math.sin(l) * f, R = Math.sin(l - c) * -d, P = Math.cos(l - c) * d, c && (u *= Ef, b = Math.tan(c - u), b = Math.sqrt(1 + b * b), R *= b, P *= b, u && (b = Math.tan(u), b = Math.sqrt(1 + b * b), C *= b, E *= b)), C = Ai(C), E = Ai(E), R = Ai(R), P = Ai(P)) : (C = f, P = d, E = R = 0), (S && !~(o + "").indexOf("px") || M && !~(a + "").indexOf("px")) && (S = yl(m, "x", o, "px"), M = yl(m, "y", a, "px")), (g || y || v || _) && (S = Ai(S + g - (g * C + y * R) + v), M = Ai(M + y - (g * E + y * P) + _)), (i || s) && (b = m.getBBox(), S = Ai(S + i / 100 * b.width), M = Ai(M + s / 100 * b.height)), b = "matrix(" + C + "," + E + "," + R + "," + P + "," + S + "," + M + ")", m.setAttribute("transform", b), A && (m.style[si] = b)
    },
    cO = function(e, t, n, i, s) {
        var o = 360,
            a = Xi(s),
            l = parseFloat(s) * (a && ~s.indexOf("rad") ? xc : 1),
            c = l - i,
            u = i + c + "deg",
            f, d;
        return a && (f = s.split("_")[1], f === "short" && (c %= o, c !== c % (o / 2) && (c += c < 0 ? o : -o)), f === "cw" && c < 0 ? c = (c + o * fT) % o - ~~(c / o) * o : f === "ccw" && c > 0 && (c = (c - o * fT) % o - ~~(c / o) * o)), e._pt = d = new Jr(e._pt, t, n, i, c, XU), d.e = u, d.u = "deg", e._props.push(n), d
    },
    vT = function(e, t) {
        for (var n in t) e[n] = t[n];
        return e
    },
    uO = function(e, t, n) {
        var i = vT({}, n._gsap),
            s = "perspective,force3D,transformOrigin,svgOrigin",
            o = n.style,
            a, l, c, u, f, d, m, g;
        i.svg ? (c = n.getAttribute("transform"), n.setAttribute("transform", ""), o[si] = t, a = up(n, 1), tu(n, si), n.setAttribute("transform", c)) : (c = getComputedStyle(n)[si], o[si] = t, a = up(n, 1), o[si] = c);
        for (l in ba) c = i[l], u = a[l], c !== u && s.indexOf(l) < 0 && (m = hr(c), g = hr(u), f = m !== g ? yl(n, l, c, g) : parseFloat(c), d = parseFloat(u), e._pt = new Jr(e._pt, a, l, f, d - f, j1), e._pt.u = g || 0, e._props.push(l));
        vT(a, i)
    };
Yr("padding,margin,Width,Radius", function(r, e) {
    var t = "Top",
        n = "Right",
        i = "Bottom",
        s = "Left",
        o = (e < 3 ? [t, n, i, s] : [t + s, t + n, i + n, i + s]).map(function(a) {
            return e < 2 ? r + a : "border" + a + r
        });
    V0[e > 1 ? "border" + r : r] = function(a, l, c, u, f) {
        var d, m;
        if (arguments.length < 4) return d = o.map(function(g) {
            return oa(a, g, c)
        }), m = d.join(" "), m.split(d[0]).length === 5 ? d[0] : m;
        d = (u + "").split(" "), m = {}, o.forEach(function(g, y) {
            return m[g] = d[y] = d[y] || d[(y - 1) / 2 | 0]
        }), a.init(l, m, f)
    }
});
var zP = {
    name: "css",
    register: Y1,
    targetTest: function(e) {
        return e.style && e.nodeType
    },
    init: function(e, t, n, i, s) {
        var o = this._props,
            a = e.style,
            l = n.vars.startAt,
            c, u, f, d, m, g, y, v, _, A, S, M, C, E, R, P;
        AS || Y1(), this.styles = this.styles || DP(e), P = this.styles.props, this.tween = n;
        for (y in t)
            if (y !== "autoRound" && (u = t[y], !(fs[y] && SP(y, t, n, i, e, s)))) {
                if (m = typeof u, g = V0[y], m === "function" && (u = u.call(n, i, e, s), m = typeof u), m === "string" && ~u.indexOf("random(") && (u = op(u)), g) g(this, e, y, u, n) && (R = 1);
                else if (y.substr(0, 2) === "--") c = (getComputedStyle(e).getPropertyValue(y) + "").trim(), u += "", fl.lastIndex = 0, fl.test(c) || (v = hr(c), _ = hr(u)), _ ? v !== _ && (c = yl(e, y, c, _) + _) : v && (u += v), this.add(a, "setProperty", c, u, i, s, 0, 0, y), o.push(y), P.push(y, 0, a[y]);
                else if (m !== "undefined") {
                    if (l && y in l ? (c = typeof l[y] == "function" ? l[y].call(n, i, e, s) : l[y], Xi(c) && ~c.indexOf("random(") && (c = op(c)), hr(c + "") || c === "auto" || (c += vs.units[y] || hr(oa(e, y)) || ""), (c + "").charAt(1) === "=" && (c = oa(e, y))) : c = oa(e, y), d = parseFloat(c), A = m === "string" && u.charAt(1) === "=" && u.substr(0, 2), A && (u = u.substr(2)), f = parseFloat(u), y in Ro && (y === "autoAlpha" && (d === 1 && oa(e, "visibility") === "hidden" && f && (d = 0), P.push("visibility", 0, a.visibility), rl(this, a, "visibility", d ? "inherit" : "hidden", f ? "inherit" : "hidden", !f)), y !== "scale" && y !== "transform" && (y = Ro[y], ~y.indexOf(",") && (y = y.split(",")[0]))), S = y in ba, S) {
                        if (this.styles.save(y), M || (C = e._gsap, C.renderTransform && !t.parseTransform || up(e, t.parseTransform), E = t.smoothOrigin !== !1 && C.smooth, M = this._pt = new Jr(this._pt, a, si, 0, 1, C.renderTransform, C, 0, -1), M.dep = 1), y === "scale") this._pt = new Jr(this._pt, C, "scaleY", C.scaleY, (A ? bf(C.scaleY, A + f) : f) - C.scaleY || 0, j1), this._pt.u = 0, o.push("scaleY", y), y += "X";
                        else if (y === "transformOrigin") {
                            P.push(Kr, 0, a[Kr]), u = sO(u), C.svg ? J1(e, u, 0, E, 0, this) : (_ = parseFloat(u.split(" ")[2]) || 0, _ !== C.zOrigin && rl(this, C, "zOrigin", C.zOrigin, _), rl(this, a, y, W0(c), W0(u)));
                            continue
                        } else if (y === "svgOrigin") {
                            J1(e, u, 1, E, 0, this);
                            continue
                        } else if (y in OP) {
                            cO(this, C, y, d, A ? bf(d, A + u) : u);
                            continue
                        } else if (y === "smoothOrigin") {
                            rl(this, C, "smooth", C.smooth, u);
                            continue
                        } else if (y === "force3D") {
                            C[y] = u;
                            continue
                        } else if (y === "transform") {
                            uO(this, u, e);
                            continue
                        }
                    } else y in a || (y = Xf(y) || y);
                    if (S || (f || f === 0) && (d || d === 0) && !jU.test(u) && y in a) v = (c + "").substr((d + "").length), f || (f = 0), _ = hr(u) || (y in vs.units ? vs.units[y] : v), v !== _ && (d = yl(e, y, c, _)), this._pt = new Jr(this._pt, S ? C : a, y, d, (A ? bf(d, A + f) : f) - d, !S && (_ === "px" || y === "zIndex") && t.autoRound !== !1 ? JU : j1), this._pt.u = _ || 0, v !== _ && _ !== "%" && (this._pt.b = c, this._pt.r = YU);
                    else if (y in a) rO.call(this, e, y, c, A ? A + u : u);
                    else if (y in e) this.add(e, y, c || e[y], A ? A + u : u, i, s);
                    else if (y !== "parseTransform") {
                        hS(y, u);
                        continue
                    }
                    S || (y in a ? P.push(y, 0, a[y]) : P.push(y, 1, c || e[y])), o.push(y)
                }
            }
        R && CP(this)
    },
    render: function(e, t) {
        if (t.tween._time || !SS())
            for (var n = t._pt; n;) n.r(e, n.d), n = n._next;
        else t.styles.revert()
    },
    get: oa,
    aliases: Ro,
    getSetter: function(e, t, n) {
        var i = Ro[t];
        return i && i.indexOf(",") < 0 && (t = i), t in ba && t !== Kr && (e._gsap.x || oa(e, "x")) ? n && uT === n ? t === "scale" ? QU : ZU : (uT = n || {}) && (t === "scale" ? $U : eO) : e.style && !cS(e.style[t]) ? KU : ~t.indexOf("-") ? qU : _S(e, t)
    },
    core: {
        _removeProperty: tu,
        _getMatrix: wS
    }
};
Zr.utils.checkPrefix = Xf;
Zr.core.getStyleSaver = DP;
(function(r, e, t, n) {
    var i = Yr(r + "," + e + "," + t, function(s) {
        ba[s] = 1
    });
    Yr(e, function(s) {
        vs.units[s] = "deg", OP[s] = 1
    }), Ro[i[13]] = r + "," + e, Yr(n, function(s) {
        var o = s.split(":");
        Ro[o[1]] = i[o[0]]
    })
})("x,y,z,scale,scaleX,scaleY,xPercent,yPercent", "rotation,rotationX,rotationY,skewX,skewY", "transform,transformOrigin,svgOrigin,force3D,smoothOrigin,transformPerspective", "0:translateX,1:translateY,2:translateZ,8:rotate,8:rotationZ,8:rotateZ,9:rotateX,10:rotateY");
Yr("x,y,z,top,right,bottom,left,width,height,fontSize,padding,margin,perspective", function(r) {
    vs.units[r] = "px"
});
Zr.registerPlugin(zP);
var et = Zr.registerPlugin(zP) || Zr;
et.core.Tween;

function fO(r, e) {
    for (var t = 0; t < e.length; t++) {
        var n = e[t];
        n.enumerable = n.enumerable || !1, n.configurable = !0, "value" in n && (n.writable = !0), Object.defineProperty(r, n.key, n)
    }
}

function hO(r, e, t) {
    return e && fO(r.prototype, e), r
}
/*!
 * Observer 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var Qi, w0, ps, sl, ol, Cf, GP, Ac, Id, HP, fa, oo, VP, WP = function() {
        return Qi || typeof window < "u" && (Qi = window.gsap) && Qi.registerPlugin && Qi
    },
    jP = 1,
    pf = [],
    pn = [],
    Lo = [],
    Bd = Date.now,
    K1 = function(e, t) {
        return t
    },
    dO = function() {
        var e = Id.core,
            t = e.bridge || {},
            n = e._scrollers,
            i = e._proxies;
        n.push.apply(n, pn), i.push.apply(i, Lo), pn = n, Lo = i, K1 = function(o, a) {
            return t[o](a)
        }
    },
    hl = function(e, t) {
        return ~Lo.indexOf(e) && Lo[Lo.indexOf(e) + 1][t]
    },
    Dd = function(e) {
        return !!~HP.indexOf(e)
    },
    Er = function(e, t, n, i, s) {
        return e.addEventListener(t, n, {
            passive: i !== !1,
            capture: !!s
        })
    },
    br = function(e, t, n, i) {
        return e.removeEventListener(t, n, !!i)
    },
    ig = "scrollLeft",
    rg = "scrollTop",
    q1 = function() {
        return fa && fa.isPressed || pn.cache++
    },
    j0 = function(e, t) {
        var n = function i(s) {
            if (s || s === 0) {
                jP && (ps.history.scrollRestoration = "manual");
                var o = fa && fa.isPressed;
                s = i.v = Math.round(s) || (fa && fa.iOS ? 1 : 0), e(s), i.cacheID = pn.cache, o && K1("ss", s)
            } else(t || pn.cache !== i.cacheID || K1("ref")) && (i.cacheID = pn.cache, i.v = e());
            return i.v + i.offset
        };
        return n.offset = 0, e && n
    },
    Lr = {
        s: ig,
        p: "left",
        p2: "Left",
        os: "right",
        os2: "Right",
        d: "width",
        d2: "Width",
        a: "x",
        sc: j0(function(r) {
            return arguments.length ? ps.scrollTo(r, Bi.sc()) : ps.pageXOffset || sl[ig] || ol[ig] || Cf[ig] || 0
        })
    },
    Bi = {
        s: rg,
        p: "top",
        p2: "Top",
        os: "bottom",
        os2: "Bottom",
        d: "height",
        d2: "Height",
        a: "y",
        op: Lr,
        sc: j0(function(r) {
            return arguments.length ? ps.scrollTo(Lr.sc(), r) : ps.pageYOffset || sl[rg] || ol[rg] || Cf[rg] || 0
        })
    },
    jr = function(e, t) {
        return (t && t._ctx && t._ctx.selector || Qi.utils.toArray)(e)[0] || (typeof e == "string" && Qi.config().nullTargetWarn !== !1 ? console.warn("Element not found:", e) : null)
    },
    _l = function(e, t) {
        var n = t.s,
            i = t.sc;
        Dd(e) && (e = sl.scrollingElement || ol);
        var s = pn.indexOf(e),
            o = i === Bi.sc ? 1 : 2;
        !~s && (s = pn.push(e) - 1), pn[s + o] || Er(e, "scroll", q1);
        var a = pn[s + o],
            l = a || (pn[s + o] = j0(hl(e, n), !0) || (Dd(e) ? i : j0(function(c) {
                return arguments.length ? e[n] = c : e[n]
            })));
        return l.target = e, a || (l.smooth = Qi.getProperty(e, "scrollBehavior") === "smooth"), l
    },
    Z1 = function(e, t, n) {
        var i = e,
            s = e,
            o = Bd(),
            a = o,
            l = t || 50,
            c = Math.max(500, l * 3),
            u = function(g, y) {
                var v = Bd();
                y || v - o > l ? (s = i, i = g, a = o, o = v) : n ? i += g : i = s + (g - s) / (v - a) * (o - a)
            },
            f = function() {
                s = i = n ? 0 : i, a = o = 0
            },
            d = function(g) {
                var y = a,
                    v = s,
                    _ = Bd();
                return (g || g === 0) && g !== i && u(g), o === a || _ - a > c ? 0 : (i + (n ? v : -v)) / ((n ? _ : o) - y) * 1e3
            };
        return {
            update: u,
            reset: f,
            getVelocity: d
        }
    },
    Vh = function(e, t) {
        return t && !e._gsapAllow && e.preventDefault(), e.changedTouches ? e.changedTouches[0] : e
    },
    yT = function(e) {
        var t = Math.max.apply(Math, e),
            n = Math.min.apply(Math, e);
        return Math.abs(t) >= Math.abs(n) ? t : n
    },
    XP = function() {
        Id = Qi.core.globals().ScrollTrigger, Id && Id.core && dO()
    },
    YP = function(e) {
        return Qi = e || WP(), !w0 && Qi && typeof document < "u" && document.body && (ps = window, sl = document, ol = sl.documentElement, Cf = sl.body, HP = [ps, sl, ol, Cf], Qi.utils.clamp, VP = Qi.core.context || function() {}, Ac = "onpointerenter" in Cf ? "pointer" : "mouse", GP = Si.isTouch = ps.matchMedia && ps.matchMedia("(hover: none), (pointer: coarse)").matches ? 1 : "ontouchstart" in ps || navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0 ? 2 : 0, oo = Si.eventTypes = ("ontouchstart" in ol ? "touchstart,touchmove,touchcancel,touchend" : "onpointerdown" in ol ? "pointerdown,pointermove,pointercancel,pointerup" : "mousedown,mousemove,mouseup,mouseup").split(","), setTimeout(function() {
            return jP = 0
        }, 500), XP(), w0 = 1), w0
    };
Lr.op = Bi;
pn.cache = 0;
var Si = function() {
    function r(t) {
        this.init(t)
    }
    var e = r.prototype;
    return e.init = function(n) {
        w0 || YP(Qi) || console.warn("Please gsap.registerPlugin(Observer)"), Id || XP();
        var i = n.tolerance,
            s = n.dragMinimum,
            o = n.type,
            a = n.target,
            l = n.lineHeight,
            c = n.debounce,
            u = n.preventDefault,
            f = n.onStop,
            d = n.onStopDelay,
            m = n.ignore,
            g = n.wheelSpeed,
            y = n.event,
            v = n.onDragStart,
            _ = n.onDragEnd,
            A = n.onDrag,
            S = n.onPress,
            M = n.onRelease,
            C = n.onRight,
            E = n.onLeft,
            R = n.onUp,
            P = n.onDown,
            b = n.onChangeX,
            T = n.onChangeY,
            L = n.onChange,
            D = n.onToggleX,
            V = n.onToggleY,
            H = n.onHover,
            q = n.onHoverEnd,
            X = n.onMove,
            oe = n.ignoreCheck,
            Y = n.isNormalizer,
            Z = n.onGestureStart,
            U = n.onGestureEnd,
            j = n.onWheel,
            te = n.onEnable,
            he = n.onDisable,
            $ = n.onClick,
            ne = n.scrollSpeed,
            me = n.capture,
            ce = n.allowClicks,
            _e = n.lockAxis,
            Oe = n.onLockAxis;
        this.target = a = jr(a) || ol, this.vars = n, m && (m = Qi.utils.toArray(m)), i = i || 1e-9, s = s || 0, g = g || 1, ne = ne || 1, o = o || "wheel,touch,pointer", c = c !== !1, l || (l = parseFloat(ps.getComputedStyle(Cf).lineHeight) || 22);
        var ke, Ee, pe, xe, J, De, Ce, se = this,
            Se = 0,
            Xe = 0,
            Le = n.passive || !u,
            k = _l(a, Lr),
            z = _l(a, Bi),
            ue = k(),
            ye = z(),
            ge = ~o.indexOf("touch") && !~o.indexOf("pointer") && oo[0] === "pointerdown",
            Re = Dd(a),
            Be = a.ownerDocument || sl,
            Fe = [0, 0, 0],
            Ne = [0, 0, 0],
            ot = 0,
            je = function() {
                return ot = Bd()
            },
            Ze = function(ut, Rt) {
                return (se.event = ut) && m && ~m.indexOf(ut.target) || Rt && ge && ut.pointerType !== "touch" || oe && oe(ut, Rt)
            },
            it = function() {
                se._vx.reset(), se._vy.reset(), Ee.pause(), f && f(se)
            },
            $e = function() {
                var ut = se.deltaX = yT(Fe),
                    Rt = se.deltaY = yT(Ne),
                    nt = Math.abs(ut) >= i,
                    It = Math.abs(Rt) >= i;
                L && (nt || It) && L(se, ut, Rt, Fe, Ne), nt && (C && se.deltaX > 0 && C(se), E && se.deltaX < 0 && E(se), b && b(se), D && se.deltaX < 0 != Se < 0 && D(se), Se = se.deltaX, Fe[0] = Fe[1] = Fe[2] = 0), It && (P && se.deltaY > 0 && P(se), R && se.deltaY < 0 && R(se), T && T(se), V && se.deltaY < 0 != Xe < 0 && V(se), Xe = se.deltaY, Ne[0] = Ne[1] = Ne[2] = 0), (xe || pe) && (X && X(se), pe && (A(se), pe = !1), xe = !1), De && !(De = !1) && Oe && Oe(se), J && (j(se), J = !1), ke = 0
            },
            We = function(ut, Rt, nt) {
                Fe[nt] += ut, Ne[nt] += Rt, se._vx.update(ut), se._vy.update(Rt), c ? ke || (ke = requestAnimationFrame($e)) : $e()
            },
            yt = function(ut, Rt) {
                _e && !Ce && (se.axis = Ce = Math.abs(ut) > Math.abs(Rt) ? "x" : "y", De = !0), Ce !== "y" && (Fe[2] += ut, se._vx.update(ut, !0)), Ce !== "x" && (Ne[2] += Rt, se._vy.update(Rt, !0)), c ? ke || (ke = requestAnimationFrame($e)) : $e()
            },
            at = function(ut) {
                if (!Ze(ut, 1)) {
                    ut = Vh(ut, u);
                    var Rt = ut.clientX,
                        nt = ut.clientY,
                        It = Rt - se.x,
                        pt = nt - se.y,
                        Ct = se.isDragging;
                    se.x = Rt, se.y = nt, (Ct || Math.abs(se.startX - Rt) >= s || Math.abs(se.startY - nt) >= s) && (A && (pe = !0), Ct || (se.isDragging = !0), yt(It, pt), Ct || v && v(se))
                }
            },
            Mt = se.onPress = function(tt) {
                Ze(tt, 1) || tt && tt.button || (se.axis = Ce = null, Ee.pause(), se.isPressed = !0, tt = Vh(tt), Se = Xe = 0, se.startX = se.x = tt.clientX, se.startY = se.y = tt.clientY, se._vx.reset(), se._vy.reset(), Er(Y ? a : Be, oo[1], at, Le, !0), se.deltaX = se.deltaY = 0, S && S(se))
            },
            ae = se.onRelease = function(tt) {
                if (!Ze(tt, 1)) {
                    br(Y ? a : Be, oo[1], at, !0);
                    var ut = !isNaN(se.y - se.startY),
                        Rt = se.isDragging,
                        nt = Rt && (Math.abs(se.x - se.startX) > 3 || Math.abs(se.y - se.startY) > 3),
                        It = Vh(tt);
                    !nt && ut && (se._vx.reset(), se._vy.reset(), u && ce && Qi.delayedCall(.08, function() {
                        if (Bd() - ot > 300 && !tt.defaultPrevented) {
                            if (tt.target.click) tt.target.click();
                            else if (Be.createEvent) {
                                var pt = Be.createEvent("MouseEvents");
                                pt.initMouseEvent("click", !0, !0, ps, 1, It.screenX, It.screenY, It.clientX, It.clientY, !1, !1, !1, !1, 0, null), tt.target.dispatchEvent(pt)
                            }
                        }
                    })), se.isDragging = se.isGesturing = se.isPressed = !1, f && Rt && !Y && Ee.restart(!0), _ && Rt && _(se), M && M(se, nt)
                }
            },
            ve = function(ut) {
                return ut.touches && ut.touches.length > 1 && (se.isGesturing = !0) && Z(ut, se.isDragging)
            },
            we = function() {
                return (se.isGesturing = !1) || U(se)
            },
            He = function(ut) {
                if (!Ze(ut)) {
                    var Rt = k(),
                        nt = z();
                    We((Rt - ue) * ne, (nt - ye) * ne, 1), ue = Rt, ye = nt, f && Ee.restart(!0)
                }
            },
            Je = function(ut) {
                if (!Ze(ut)) {
                    ut = Vh(ut, u), j && (J = !0);
                    var Rt = (ut.deltaMode === 1 ? l : ut.deltaMode === 2 ? ps.innerHeight : 1) * g;
                    We(ut.deltaX * Rt, ut.deltaY * Rt, 0), f && !Y && Ee.restart(!0)
                }
            },
            Ye = function(ut) {
                if (!Ze(ut)) {
                    var Rt = ut.clientX,
                        nt = ut.clientY,
                        It = Rt - se.x,
                        pt = nt - se.y;
                    se.x = Rt, se.y = nt, xe = !0, f && Ee.restart(!0), (It || pt) && yt(It, pt)
                }
            },
            mt = function(ut) {
                se.event = ut, H(se)
            },
            Pt = function(ut) {
                se.event = ut, q(se)
            },
            St = function(ut) {
                return Ze(ut) || Vh(ut, u) && $(se)
            };
        Ee = se._dc = Qi.delayedCall(d || .25, it).pause(), se.deltaX = se.deltaY = 0, se._vx = Z1(0, 50, !0), se._vy = Z1(0, 50, !0), se.scrollX = k, se.scrollY = z, se.isDragging = se.isGesturing = se.isPressed = !1, VP(this), se.enable = function(tt) {
            return se.isEnabled || (Er(Re ? Be : a, "scroll", q1), o.indexOf("scroll") >= 0 && Er(Re ? Be : a, "scroll", He, Le, me), o.indexOf("wheel") >= 0 && Er(a, "wheel", Je, Le, me), (o.indexOf("touch") >= 0 && GP || o.indexOf("pointer") >= 0) && (Er(a, oo[0], Mt, Le, me), Er(Be, oo[2], ae), Er(Be, oo[3], ae), ce && Er(a, "click", je, !0, !0), $ && Er(a, "click", St), Z && Er(Be, "gesturestart", ve), U && Er(Be, "gestureend", we), H && Er(a, Ac + "enter", mt), q && Er(a, Ac + "leave", Pt), X && Er(a, Ac + "move", Ye)), se.isEnabled = !0, tt && tt.type && Mt(tt), te && te(se)), se
        }, se.disable = function() {
            se.isEnabled && (pf.filter(function(tt) {
                return tt !== se && Dd(tt.target)
            }).length || br(Re ? Be : a, "scroll", q1), se.isPressed && (se._vx.reset(), se._vy.reset(), br(Y ? a : Be, oo[1], at, !0)), br(Re ? Be : a, "scroll", He, me), br(a, "wheel", Je, me), br(a, oo[0], Mt, me), br(Be, oo[2], ae), br(Be, oo[3], ae), br(a, "click", je, !0), br(a, "click", St), br(Be, "gesturestart", ve), br(Be, "gestureend", we), br(a, Ac + "enter", mt), br(a, Ac + "leave", Pt), br(a, Ac + "move", Ye), se.isEnabled = se.isPressed = se.isDragging = !1, he && he(se))
        }, se.kill = se.revert = function() {
            se.disable();
            var tt = pf.indexOf(se);
            tt >= 0 && pf.splice(tt, 1), fa === se && (fa = 0)
        }, pf.push(se), Y && Dd(a) && (fa = se), se.enable(y)
    }, hO(r, [{
        key: "velocityX",
        get: function() {
            return this._vx.getVelocity()
        }
    }, {
        key: "velocityY",
        get: function() {
            return this._vy.getVelocity()
        }
    }]), r
}();
Si.version = "3.12.5";
Si.create = function(r) {
    return new Si(r)
};
Si.register = YP;
Si.getAll = function() {
    return pf.slice()
};
Si.getById = function(r) {
    return pf.filter(function(e) {
        return e.vars.id === r
    })[0]
};
WP() && Qi.registerPlugin(Si);
/*!
 * ScrollTrigger 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var Tt, of , _n, ni, co, Vn, JP, X0, fp, Ld, gd, sg, cr, ty, Q1, Pr, _T, xT, af, KP, Z_, qP, Rr, $1, ZP, QP, Za, eA, bS, Rf, TS, Y0, tA, Q_, og = 1,
    fr = Date.now,
    $_ = fr(),
    Ys = 0,
    vd = 0,
    AT = function(e, t, n) {
        var i = cs(e) && (e.substr(0, 6) === "clamp(" || e.indexOf("max") > -1);
        return n["_" + t + "Clamp"] = i, i ? e.substr(6, e.length - 7) : e
    },
    ST = function(e, t) {
        return t && (!cs(e) || e.substr(0, 6) !== "clamp(") ? "clamp(" + e + ")" : e
    },
    pO = function r() {
        return vd && requestAnimationFrame(r)
    },
    MT = function() {
        return ty = 1
    },
    wT = function() {
        return ty = 0
    },
    To = function(e) {
        return e
    },
    yd = function(e) {
        return Math.round(e * 1e5) / 1e5 || 0
    },
    $P = function() {
        return typeof window < "u"
    },
    eI = function() {
        return Tt || $P() && (Tt = window.gsap) && Tt.registerPlugin && Tt
    },
    nu = function(e) {
        return !!~JP.indexOf(e)
    },
    tI = function(e) {
        return (e === "Height" ? TS : _n["inner" + e]) || co["client" + e] || Vn["client" + e]
    },
    nI = function(e) {
        return hl(e, "getBoundingClientRect") || (nu(e) ? function() {
            return R0.width = _n.innerWidth, R0.height = TS, R0
        } : function() {
            return aa(e)
        })
    },
    mO = function(e, t, n) {
        var i = n.d,
            s = n.d2,
            o = n.a;
        return (o = hl(e, "getBoundingClientRect")) ? function() {
            return o()[i]
        } : function() {
            return (t ? tI(s) : e["client" + s]) || 0
        }
    },
    gO = function(e, t) {
        return !t || ~Lo.indexOf(e) ? nI(e) : function() {
            return R0
        }
    },
    Po = function(e, t) {
        var n = t.s,
            i = t.d2,
            s = t.d,
            o = t.a;
        return Math.max(0, (n = "scroll" + i) && (o = hl(e, n)) ? o() - nI(e)()[s] : nu(e) ? (co[n] || Vn[n]) - tI(i) : e[n] - e["offset" + i])
    },
    ag = function(e, t) {
        for (var n = 0; n < af.length; n += 3)(!t || ~t.indexOf(af[n + 1])) && e(af[n], af[n + 1], af[n + 2])
    },
    cs = function(e) {
        return typeof e == "string"
    },
    Fr = function(e) {
        return typeof e == "function"
    },
    _d = function(e) {
        return typeof e == "number"
    },
    Sc = function(e) {
        return typeof e == "object"
    },
    Wh = function(e, t, n) {
        return e && e.progress(t ? 0 : 1) && n && e.pause()
    },
    ex = function(e, t) {
        if (e.enabled) {
            var n = e._ctx ? e._ctx.add(function() {
                return t(e)
            }) : t(e);
            n && n.totalTime && (e.callbackAnimation = n)
        }
    },
    Uu = Math.abs,
    iI = "left",
    rI = "top",
    ES = "right",
    CS = "bottom",
    Vc = "width",
    Wc = "height",
    Fd = "Right",
    Ud = "Left",
    Od = "Top",
    Nd = "Bottom",
    Ei = "padding",
    Gs = "margin",
    Yf = "Width",
    RS = "Height",
    Ii = "px",
    Hs = function(e) {
        return _n.getComputedStyle(e)
    },
    vO = function(e) {
        var t = Hs(e).position;
        e.style.position = t === "absolute" || t === "fixed" ? t : "relative"
    },
    bT = function(e, t) {
        for (var n in t) n in e || (e[n] = t[n]);
        return e
    },
    aa = function(e, t) {
        var n = t && Hs(e)[Q1] !== "matrix(1, 0, 0, 1, 0, 0)" && Tt.to(e, {
                x: 0,
                y: 0,
                xPercent: 0,
                yPercent: 0,
                rotation: 0,
                rotationX: 0,
                rotationY: 0,
                scale: 1,
                skewX: 0,
                skewY: 0
            }).progress(1),
            i = e.getBoundingClientRect();
        return n && n.progress(0).kill(), i
    },
    J0 = function(e, t) {
        var n = t.d2;
        return e["offset" + n] || e["client" + n] || 0
    },
    sI = function(e) {
        var t = [],
            n = e.labels,
            i = e.duration(),
            s;
        for (s in n) t.push(n[s] / i);
        return t
    },
    yO = function(e) {
        return function(t) {
            return Tt.utils.snap(sI(e), t)
        }
    },
    PS = function(e) {
        var t = Tt.utils.snap(e),
            n = Array.isArray(e) && e.slice(0).sort(function(i, s) {
                return i - s
            });
        return n ? function(i, s, o) {
            o === void 0 && (o = .001);
            var a;
            if (!s) return t(i);
            if (s > 0) {
                for (i -= o, a = 0; a < n.length; a++)
                    if (n[a] >= i) return n[a];
                return n[a - 1]
            } else
                for (a = n.length, i += o; a--;)
                    if (n[a] <= i) return n[a];
            return n[0]
        } : function(i, s, o) {
            o === void 0 && (o = .001);
            var a = t(i);
            return !s || Math.abs(a - i) < o || a - i < 0 == s < 0 ? a : t(s < 0 ? i - e : i + e)
        }
    },
    _O = function(e) {
        return function(t, n) {
            return PS(sI(e))(t, n.direction)
        }
    },
    lg = function(e, t, n, i) {
        return n.split(",").forEach(function(s) {
            return e(t, s, i)
        })
    },
    Hi = function(e, t, n, i, s) {
        return e.addEventListener(t, n, {
            passive: !i,
            capture: !!s
        })
    },
    Gi = function(e, t, n, i) {
        return e.removeEventListener(t, n, !!i)
    },
    cg = function(e, t, n) {
        n = n && n.wheelHandler, n && (e(t, "wheel", n), e(t, "touchmove", n))
    },
    TT = {
        startColor: "green",
        endColor: "red",
        indent: 0,
        fontSize: "16px",
        fontWeight: "normal"
    },
    ug = {
        toggleActions: "play",
        anticipatePin: 0
    },
    K0 = {
        top: 0,
        left: 0,
        center: .5,
        bottom: 1,
        right: 1
    },
    b0 = function(e, t) {
        if (cs(e)) {
            var n = e.indexOf("="),
                i = ~n ? +(e.charAt(n - 1) + 1) * parseFloat(e.substr(n + 1)) : 0;
            ~n && (e.indexOf("%") > n && (i *= t / 100), e = e.substr(0, n - 1)), e = i + (e in K0 ? K0[e] * t : ~e.indexOf("%") ? parseFloat(e) * t / 100 : parseFloat(e) || 0)
        }
        return e
    },
    fg = function(e, t, n, i, s, o, a, l) {
        var c = s.startColor,
            u = s.endColor,
            f = s.fontSize,
            d = s.indent,
            m = s.fontWeight,
            g = ni.createElement("div"),
            y = nu(n) || hl(n, "pinType") === "fixed",
            v = e.indexOf("scroller") !== -1,
            _ = y ? Vn : n,
            A = e.indexOf("start") !== -1,
            S = A ? c : u,
            M = "border-color:" + S + ";font-size:" + f + ";color:" + S + ";font-weight:" + m + ";pointer-events:none;white-space:nowrap;font-family:sans-serif,Arial;z-index:1000;padding:4px 8px;border-width:0;border-style:solid;";
        return M += "position:" + ((v || l) && y ? "fixed;" : "absolute;"), (v || l || !y) && (M += (i === Bi ? ES : CS) + ":" + (o + parseFloat(d)) + "px;"), a && (M += "box-sizing:border-box;text-align:left;width:" + a.offsetWidth + "px;"), g._isStart = A, g.setAttribute("class", "gsap-marker-" + e + (t ? " marker-" + t : "")), g.style.cssText = M, g.innerText = t || t === 0 ? e + "-" + t : e, _.children[0] ? _.insertBefore(g, _.children[0]) : _.appendChild(g), g._offset = g["offset" + i.op.d2], T0(g, 0, i, A), g
    },
    T0 = function(e, t, n, i) {
        var s = {
                display: "block"
            },
            o = n[i ? "os2" : "p2"],
            a = n[i ? "p2" : "os2"];
        e._isFlipped = i, s[n.a + "Percent"] = i ? -100 : 0, s[n.a] = i ? "1px" : 0, s["border" + o + Yf] = 1, s["border" + a + Yf] = 0, s[n.p] = t + "px", Tt.set(e, s)
    },
    fn = [],
    nA = {},
    hp, ET = function() {
        return fr() - Ys > 34 && (hp || (hp = requestAnimationFrame(va)))
    },
    Ou = function() {
        (!Rr || !Rr.isPressed || Rr.startX > Vn.clientWidth) && (pn.cache++, Rr ? hp || (hp = requestAnimationFrame(va)) : va(), Ys || ru("scrollStart"), Ys = fr())
    },
    tx = function() {
        QP = _n.innerWidth, ZP = _n.innerHeight
    },
    xd = function() {
        pn.cache++, !cr && !qP && !ni.fullscreenElement && !ni.webkitFullscreenElement && (!$1 || QP !== _n.innerWidth || Math.abs(_n.innerHeight - ZP) > _n.innerHeight * .25) && X0.restart(!0)
    },
    iu = {},
    xO = [],
    oI = function r() {
        return Gi(Zt, "scrollEnd", r) || Rc(!0)
    },
    ru = function(e) {
        return iu[e] && iu[e].map(function(t) {
            return t()
        }) || xO
    },
    ls = [],
    aI = function(e) {
        for (var t = 0; t < ls.length; t += 5)(!e || ls[t + 4] && ls[t + 4].query === e) && (ls[t].style.cssText = ls[t + 1], ls[t].getBBox && ls[t].setAttribute("transform", ls[t + 2] || ""), ls[t + 3].uncache = 1)
    },
    IS = function(e, t) {
        var n;
        for (Pr = 0; Pr < fn.length; Pr++) n = fn[Pr], n && (!t || n._ctx === t) && (e ? n.kill(1) : n.revert(!0, !0));
        Y0 = !0, t && aI(t), t || ru("revert")
    },
    lI = function(e, t) {
        pn.cache++, (t || !Ir) && pn.forEach(function(n) {
            return Fr(n) && n.cacheID++ && (n.rec = 0)
        }), cs(e) && (_n.history.scrollRestoration = bS = e)
    },
    Ir, jc = 0,
    CT, AO = function() {
        if (CT !== jc) {
            var e = CT = jc;
            requestAnimationFrame(function() {
                return e === jc && Rc(!0)
            })
        }
    },
    cI = function() {
        Vn.appendChild(Rf), TS = !Rr && Rf.offsetHeight || _n.innerHeight, Vn.removeChild(Rf)
    },
    RT = function(e) {
        return fp(".gsap-marker-start, .gsap-marker-end, .gsap-marker-scroller-start, .gsap-marker-scroller-end").forEach(function(t) {
            return t.style.display = e ? "none" : "block"
        })
    },
    Rc = function(e, t) {
        if (Ys && !e && !Y0) {
            Hi(Zt, "scrollEnd", oI);
            return
        }
        cI(), Ir = Zt.isRefreshing = !0, pn.forEach(function(i) {
            return Fr(i) && ++i.cacheID && (i.rec = i())
        });
        var n = ru("refreshInit");
        KP && Zt.sort(), t || IS(), pn.forEach(function(i) {
            Fr(i) && (i.smooth && (i.target.style.scrollBehavior = "auto"), i(0))
        }), fn.slice(0).forEach(function(i) {
            return i.refresh()
        }), Y0 = !1, fn.forEach(function(i) {
            if (i._subPinOffset && i.pin) {
                var s = i.vars.horizontal ? "offsetWidth" : "offsetHeight",
                    o = i.pin[s];
                i.revert(!0, 1), i.adjustPinSpacing(i.pin[s] - o), i.refresh()
            }
        }), tA = 1, RT(!0), fn.forEach(function(i) {
            var s = Po(i.scroller, i._dir),
                o = i.vars.end === "max" || i._endClamp && i.end > s,
                a = i._startClamp && i.start >= s;
            (o || a) && i.setPositions(a ? s - 1 : i.start, o ? Math.max(a ? s : i.start + 1, s) : i.end, !0)
        }), RT(!1), tA = 0, n.forEach(function(i) {
            return i && i.render && i.render(-1)
        }), pn.forEach(function(i) {
            Fr(i) && (i.smooth && requestAnimationFrame(function() {
                return i.target.style.scrollBehavior = "smooth"
            }), i.rec && i(i.rec))
        }), lI(bS, 1), X0.pause(), jc++, Ir = 2, va(2), fn.forEach(function(i) {
            return Fr(i.vars.onRefresh) && i.vars.onRefresh(i)
        }), Ir = Zt.isRefreshing = !1, ru("refresh")
    },
    iA = 0,
    E0 = 1,
    kd, va = function(e) {
        if (e === 2 || !Ir && !Y0) {
            Zt.isUpdating = !0, kd && kd.update(0);
            var t = fn.length,
                n = fr(),
                i = n - $_ >= 50,
                s = t && fn[0].scroll();
            if (E0 = iA > s ? -1 : 1, Ir || (iA = s), i && (Ys && !ty && n - Ys > 200 && (Ys = 0, ru("scrollEnd")), gd = $_, $_ = n), E0 < 0) {
                for (Pr = t; Pr-- > 0;) fn[Pr] && fn[Pr].update(0, i);
                E0 = 1
            } else
                for (Pr = 0; Pr < t; Pr++) fn[Pr] && fn[Pr].update(0, i);
            Zt.isUpdating = !1
        }
        hp = 0
    },
    rA = [iI, rI, CS, ES, Gs + Nd, Gs + Fd, Gs + Od, Gs + Ud, "display", "flexShrink", "float", "zIndex", "gridColumnStart", "gridColumnEnd", "gridRowStart", "gridRowEnd", "gridArea", "justifySelf", "alignSelf", "placeSelf", "order"],
    C0 = rA.concat([Vc, Wc, "boxSizing", "max" + Yf, "max" + RS, "position", Gs, Ei, Ei + Od, Ei + Fd, Ei + Nd, Ei + Ud]),
    SO = function(e, t, n) {
        Pf(n);
        var i = e._gsap;
        if (i.spacerIsNative) Pf(i.spacerState);
        else if (e._gsap.swappedIn) {
            var s = t.parentNode;
            s && (s.insertBefore(e, t), s.removeChild(t))
        }
        e._gsap.swappedIn = !1
    },
    nx = function(e, t, n, i) {
        if (!e._gsap.swappedIn) {
            for (var s = rA.length, o = t.style, a = e.style, l; s--;) l = rA[s], o[l] = n[l];
            o.position = n.position === "absolute" ? "absolute" : "relative", n.display === "inline" && (o.display = "inline-block"), a[CS] = a[ES] = "auto", o.flexBasis = n.flexBasis || "auto", o.overflow = "visible", o.boxSizing = "border-box", o[Vc] = J0(e, Lr) + Ii, o[Wc] = J0(e, Bi) + Ii, o[Ei] = a[Gs] = a[rI] = a[iI] = "0", Pf(i), a[Vc] = a["max" + Yf] = n[Vc], a[Wc] = a["max" + RS] = n[Wc], a[Ei] = n[Ei], e.parentNode !== t && (e.parentNode.insertBefore(t, e), t.appendChild(e)), e._gsap.swappedIn = !0
        }
    },
    MO = /([A-Z])/g,
    Pf = function(e) {
        if (e) {
            var t = e.t.style,
                n = e.length,
                i = 0,
                s, o;
            for ((e.t._gsap || Tt.core.getCache(e.t)).uncache = 1; i < n; i += 2) o = e[i + 1], s = e[i], o ? t[s] = o : t[s] && t.removeProperty(s.replace(MO, "-$1").toLowerCase())
        }
    },
    hg = function(e) {
        for (var t = C0.length, n = e.style, i = [], s = 0; s < t; s++) i.push(C0[s], n[C0[s]]);
        return i.t = e, i
    },
    wO = function(e, t, n) {
        for (var i = [], s = e.length, o = n ? 8 : 0, a; o < s; o += 2) a = e[o], i.push(a, a in t ? t[a] : e[o + 1]);
        return i.t = e.t, i
    },
    R0 = {
        left: 0,
        top: 0
    },
    PT = function(e, t, n, i, s, o, a, l, c, u, f, d, m, g) {
        Fr(e) && (e = e(l)), cs(e) && e.substr(0, 3) === "max" && (e = d + (e.charAt(4) === "=" ? b0("0" + e.substr(3), n) : 0));
        var y = m ? m.time() : 0,
            v, _, A;
        if (m && m.seek(0), isNaN(e) || (e = +e), _d(e)) m && (e = Tt.utils.mapRange(m.scrollTrigger.start, m.scrollTrigger.end, 0, d, e)), a && T0(a, n, i, !0);
        else {
            Fr(t) && (t = t(l));
            var S = (e || "0").split(" "),
                M, C, E, R;
            A = jr(t, l) || Vn, M = aa(A) || {}, (!M || !M.left && !M.top) && Hs(A).display === "none" && (R = A.style.display, A.style.display = "block", M = aa(A), R ? A.style.display = R : A.style.removeProperty("display")), C = b0(S[0], M[i.d]), E = b0(S[1] || "0", n), e = M[i.p] - c[i.p] - u + C + s - E, a && T0(a, E, i, n - E < 20 || a._isStart && E > 20), n -= n - E
        }
        if (g && (l[g] = e || -.001, e < 0 && (e = 0)), o) {
            var P = e + n,
                b = o._isStart;
            v = "scroll" + i.d2, T0(o, P, i, b && P > 20 || !b && (f ? Math.max(Vn[v], co[v]) : o.parentNode[v]) <= P + 1), f && (c = aa(a), f && (o.style[i.op.p] = c[i.op.p] - i.op.m - o._offset + Ii))
        }
        return m && A && (v = aa(A), m.seek(d), _ = aa(A), m._caScrollDist = v[i.p] - _[i.p], e = e / m._caScrollDist * d), m && m.seek(y), m ? e : Math.round(e)
    },
    bO = /(webkit|moz|length|cssText|inset)/i,
    IT = function(e, t, n, i) {
        if (e.parentNode !== t) {
            var s = e.style,
                o, a;
            if (t === Vn) {
                e._stOrig = s.cssText, a = Hs(e);
                for (o in a) !+o && !bO.test(o) && a[o] && typeof s[o] == "string" && o !== "0" && (s[o] = a[o]);
                s.top = n, s.left = i
            } else s.cssText = e._stOrig;
            Tt.core.getCache(e).uncache = 1, t.appendChild(e)
        }
    },
    uI = function(e, t, n) {
        var i = t,
            s = i;
        return function(o) {
            var a = Math.round(e());
            return a !== i && a !== s && Math.abs(a - i) > 3 && Math.abs(a - s) > 3 && (o = a, n && n()), s = i, i = o, o
        }
    },
    dg = function(e, t, n) {
        var i = {};
        i[t.p] = "+=" + n, Tt.set(e, i)
    },
    BT = function(e, t) {
        var n = _l(e, t),
            i = "_scroll" + t.p2,
            s = function o(a, l, c, u, f) {
                var d = o.tween,
                    m = l.onComplete,
                    g = {};
                c = c || n();
                var y = uI(n, c, function() {
                    d.kill(), o.tween = 0
                });
                return f = u && f || 0, u = u || a - c, d && d.kill(), l[i] = a, l.inherit = !1, l.modifiers = g, g[i] = function() {
                    return y(c + u * d.ratio + f * d.ratio * d.ratio)
                }, l.onUpdate = function() {
                    pn.cache++, o.tween && va()
                }, l.onComplete = function() {
                    o.tween = 0, m && m.call(d)
                }, d = o.tween = Tt.to(e, l), d
            };
        return e[i] = n, n.wheelHandler = function() {
            return s.tween && s.tween.kill() && (s.tween = 0)
        }, Hi(e, "wheel", n.wheelHandler), Zt.isTouch && Hi(e, "touchmove", n.wheelHandler), s
    },
    Zt = function() {
        function r(t, n) { of || r.register(Tt) || console.warn("Please gsap.registerPlugin(ScrollTrigger)"), eA(this), this.init(t, n)
        }
        var e = r.prototype;
        return e.init = function(n, i) {
            if (this.progress = this.start = 0, this.vars && this.kill(!0, !0), !vd) {
                this.update = this.refresh = this.kill = To;
                return
            }
            n = bT(cs(n) || _d(n) || n.nodeType ? {
                trigger: n
            } : n, ug);
            var s = n,
                o = s.onUpdate,
                a = s.toggleClass,
                l = s.id,
                c = s.onToggle,
                u = s.onRefresh,
                f = s.scrub,
                d = s.trigger,
                m = s.pin,
                g = s.pinSpacing,
                y = s.invalidateOnRefresh,
                v = s.anticipatePin,
                _ = s.onScrubComplete,
                A = s.onSnapComplete,
                S = s.once,
                M = s.snap,
                C = s.pinReparent,
                E = s.pinSpacer,
                R = s.containerAnimation,
                P = s.fastScrollEnd,
                b = s.preventOverlaps,
                T = n.horizontal || n.containerAnimation && n.horizontal !== !1 ? Lr : Bi,
                L = !f && f !== 0,
                D = jr(n.scroller || _n),
                V = Tt.core.getCache(D),
                H = nu(D),
                q = ("pinType" in n ? n.pinType : hl(D, "pinType") || H && "fixed") === "fixed",
                X = [n.onEnter, n.onLeave, n.onEnterBack, n.onLeaveBack],
                oe = L && n.toggleActions.split(" "),
                Y = "markers" in n ? n.markers : ug.markers,
                Z = H ? 0 : parseFloat(Hs(D)["border" + T.p2 + Yf]) || 0,
                U = this,
                j = n.onRefreshInit && function() {
                    return n.onRefreshInit(U)
                },
                te = mO(D, H, T),
                he = gO(D, H),
                $ = 0,
                ne = 0,
                me = 0,
                ce = _l(D, T),
                _e, Oe, ke, Ee, pe, xe, J, De, Ce, se, Se, Xe, Le, k, z, ue, ye, ge, Re, Be, Fe, Ne, ot, je, Ze, it, $e, We, yt, at, Mt, ae, ve, we, He, Je, Ye, mt, Pt;
            if (U._startClamp = U._endClamp = !1, U._dir = T, v *= 45, U.scroller = D, U.scroll = R ? R.time.bind(R) : ce, Ee = ce(), U.vars = n, i = i || n.animation, "refreshPriority" in n && (KP = 1, n.refreshPriority === -9999 && (kd = U)), V.tweenScroll = V.tweenScroll || {
                    top: BT(D, Bi),
                    left: BT(D, Lr)
                }, U.tweenTo = _e = V.tweenScroll[T.p], U.scrubDuration = function(nt) {
                    ve = _d(nt) && nt, ve ? ae ? ae.duration(nt) : ae = Tt.to(i, {
                        ease: "expo",
                        totalProgress: "+=0",
                        inherit: !1,
                        duration: ve,
                        paused: !0,
                        onComplete: function() {
                            return _ && _(U)
                        }
                    }) : (ae && ae.progress(1).kill(), ae = 0)
                }, i && (i.vars.lazy = !1, i._initted && !U.isReverted || i.vars.immediateRender !== !1 && n.immediateRender !== !1 && i.duration() && i.render(0, !0, !0), U.animation = i.pause(), i.scrollTrigger = U, U.scrubDuration(f), at = 0, l || (l = i.vars.id)), M && ((!Sc(M) || M.push) && (M = {
                    snapTo: M
                }), "scrollBehavior" in Vn.style && Tt.set(H ? [Vn, co] : D, {
                    scrollBehavior: "auto"
                }), pn.forEach(function(nt) {
                    return Fr(nt) && nt.target === (H ? ni.scrollingElement || co : D) && (nt.smooth = !1)
                }), ke = Fr(M.snapTo) ? M.snapTo : M.snapTo === "labels" ? yO(i) : M.snapTo === "labelsDirectional" ? _O(i) : M.directional !== !1 ? function(nt, It) {
                    return PS(M.snapTo)(nt, fr() - ne < 500 ? 0 : It.direction)
                } : Tt.utils.snap(M.snapTo), we = M.duration || {
                    min: .1,
                    max: 2
                }, we = Sc(we) ? Ld(we.min, we.max) : Ld(we, we), He = Tt.delayedCall(M.delay || ve / 2 || .1, function() {
                    var nt = ce(),
                        It = fr() - ne < 500,
                        pt = _e.tween;
                    if ((It || Math.abs(U.getVelocity()) < 10) && !pt && !ty && $ !== nt) {
                        var Ct = (nt - xe) / k,
                            ln = i && !L ? i.totalProgress() : Ct,
                            Dt = It ? 0 : (ln - Mt) / (fr() - gd) * 1e3 || 0,
                            gt = Tt.utils.clamp(-Ct, 1 - Ct, Uu(Dt / 2) * Dt / .185),
                            $t = Ct + (M.inertia === !1 ? 0 : gt),
                            rn, O, W = M,
                            de = W.onStart,
                            be = W.onInterrupt,
                            Pe = W.onComplete;
                        if (rn = ke($t, U), _d(rn) || (rn = $t), O = Math.round(xe + rn * k), nt <= J && nt >= xe && O !== nt) {
                            if (pt && !pt._initted && pt.data <= Uu(O - nt)) return;
                            M.inertia === !1 && (gt = rn - Ct), _e(O, {
                                duration: we(Uu(Math.max(Uu($t - ln), Uu(rn - ln)) * .185 / Dt / .05 || 0)),
                                ease: M.ease || "power3",
                                data: Uu(O - nt),
                                onInterrupt: function() {
                                    return He.restart(!0) && be && be(U)
                                },
                                onComplete: function() {
                                    U.update(), $ = ce(), i && (ae ? ae.resetTo("totalProgress", rn, i._tTime / i._tDur) : i.progress(rn)), at = Mt = i && !L ? i.totalProgress() : U.progress, A && A(U), Pe && Pe(U)
                                }
                            }, nt, gt * k, O - nt - gt * k), de && de(U, _e.tween)
                        }
                    } else U.isActive && $ !== nt && He.restart(!0)
                }).pause()), l && (nA[l] = U), d = U.trigger = jr(d || m !== !0 && m), Pt = d && d._gsap && d._gsap.stRevert, Pt && (Pt = Pt(U)), m = m === !0 ? d : jr(m), cs(a) && (a = {
                    targets: d,
                    className: a
                }), m && (g === !1 || g === Gs || (g = !g && m.parentNode && m.parentNode.style && Hs(m.parentNode).display === "flex" ? !1 : Ei), U.pin = m, Oe = Tt.core.getCache(m), Oe.spacer ? z = Oe.pinState : (E && (E = jr(E), E && !E.nodeType && (E = E.current || E.nativeElement), Oe.spacerIsNative = !!E, E && (Oe.spacerState = hg(E))), Oe.spacer = ge = E || ni.createElement("div"), ge.classList.add("pin-spacer"), l && ge.classList.add("pin-spacer-" + l), Oe.pinState = z = hg(m)), n.force3D !== !1 && Tt.set(m, {
                    force3D: !0
                }), U.spacer = ge = Oe.spacer, yt = Hs(m), je = yt[g + T.os2], Be = Tt.getProperty(m), Fe = Tt.quickSetter(m, T.a, Ii), nx(m, ge, yt), ye = hg(m)), Y) {
                Xe = Sc(Y) ? bT(Y, TT) : TT, se = fg("scroller-start", l, D, T, Xe, 0), Se = fg("scroller-end", l, D, T, Xe, 0, se), Re = se["offset" + T.op.d2];
                var St = jr(hl(D, "content") || D);
                De = this.markerStart = fg("start", l, St, T, Xe, Re, 0, R), Ce = this.markerEnd = fg("end", l, St, T, Xe, Re, 0, R), R && (mt = Tt.quickSetter([De, Ce], T.a, Ii)), !q && !(Lo.length && hl(D, "fixedMarkers") === !0) && (vO(H ? Vn : D), Tt.set([se, Se], {
                    force3D: !0
                }), it = Tt.quickSetter(se, T.a, Ii), We = Tt.quickSetter(Se, T.a, Ii))
            }
            if (R) {
                var tt = R.vars.onUpdate,
                    ut = R.vars.onUpdateParams;
                R.eventCallback("onUpdate", function() {
                    U.update(0, 0, 1), tt && tt.apply(R, ut || [])
                })
            }
            if (U.previous = function() {
                    return fn[fn.indexOf(U) - 1]
                }, U.next = function() {
                    return fn[fn.indexOf(U) + 1]
                }, U.revert = function(nt, It) {
                    if (!It) return U.kill(!0);
                    var pt = nt !== !1 || !U.enabled,
                        Ct = cr;
                    pt !== U.isReverted && (pt && (Je = Math.max(ce(), U.scroll.rec || 0), me = U.progress, Ye = i && i.progress()), De && [De, Ce, se, Se].forEach(function(ln) {
                        return ln.style.display = pt ? "none" : "block"
                    }), pt && (cr = U, U.update(pt)), m && (!C || !U.isActive) && (pt ? SO(m, ge, z) : nx(m, ge, Hs(m), Ze)), pt || U.update(pt), cr = Ct, U.isReverted = pt)
                }, U.refresh = function(nt, It, pt, Ct) {
                    if (!((cr || !U.enabled) && !It)) {
                        if (m && nt && Ys) {
                            Hi(r, "scrollEnd", oI);
                            return
                        }!Ir && j && j(U), cr = U, _e.tween && !pt && (_e.tween.kill(), _e.tween = 0), ae && ae.pause(), y && i && i.revert({
                            kill: !1
                        }).invalidate(), U.isReverted || U.revert(!0, !0), U._subPinOffset = !1;
                        var ln = te(),
                            Dt = he(),
                            gt = R ? R.duration() : Po(D, T),
                            $t = k <= .01,
                            rn = 0,
                            O = Ct || 0,
                            W = Sc(pt) ? pt.end : n.end,
                            de = n.endTrigger || d,
                            be = Sc(pt) ? pt.start : n.start || (n.start === 0 || !d ? 0 : m ? "0 0" : "0 100%"),
                            Pe = U.pinnedContainer = n.pinnedContainer && jr(n.pinnedContainer, U),
                            F = d && Math.max(0, fn.indexOf(U)) || 0,
                            Q = F,
                            re, le, ee, Te, fe, Ke, Ge, qe, st, Qe, ft, _t, ht;
                        for (Y && Sc(pt) && (_t = Tt.getProperty(se, T.p), ht = Tt.getProperty(Se, T.p)); Q--;) Ke = fn[Q], Ke.end || Ke.refresh(0, 1) || (cr = U), Ge = Ke.pin, Ge && (Ge === d || Ge === m || Ge === Pe) && !Ke.isReverted && (Qe || (Qe = []), Qe.unshift(Ke), Ke.revert(!0, !0)), Ke !== fn[Q] && (F--, Q--);
                        for (Fr(be) && (be = be(U)), be = AT(be, "start", U), xe = PT(be, d, ln, T, ce(), De, se, U, Dt, Z, q, gt, R, U._startClamp && "_startClamp") || (m ? -.001 : 0), Fr(W) && (W = W(U)), cs(W) && !W.indexOf("+=") && (~W.indexOf(" ") ? W = (cs(be) ? be.split(" ")[0] : "") + W : (rn = b0(W.substr(2), ln), W = cs(be) ? be : (R ? Tt.utils.mapRange(0, R.duration(), R.scrollTrigger.start, R.scrollTrigger.end, xe) : xe) + rn, de = d)), W = AT(W, "end", U), J = Math.max(xe, PT(W || (de ? "100% 0" : gt), de, ln, T, ce() + rn, Ce, Se, U, Dt, Z, q, gt, R, U._endClamp && "_endClamp")) || -.001, rn = 0, Q = F; Q--;) Ke = fn[Q], Ge = Ke.pin, Ge && Ke.start - Ke._pinPush <= xe && !R && Ke.end > 0 && (re = Ke.end - (U._startClamp ? Math.max(0, Ke.start) : Ke.start), (Ge === d && Ke.start - Ke._pinPush < xe || Ge === Pe) && isNaN(be) && (rn += re * (1 - Ke.progress)), Ge === m && (O += re));
                        if (xe += rn, J += rn, U._startClamp && (U._startClamp += rn), U._endClamp && !Ir && (U._endClamp = J || -.001, J = Math.min(J, Po(D, T))), k = J - xe || (xe -= .01) && .001, $t && (me = Tt.utils.clamp(0, 1, Tt.utils.normalize(xe, J, Je))), U._pinPush = O, De && rn && (re = {}, re[T.a] = "+=" + rn, Pe && (re[T.p] = "-=" + ce()), Tt.set([De, Ce], re)), m && !(tA && U.end >= Po(D, T))) re = Hs(m), Te = T === Bi, ee = ce(), Ne = parseFloat(Be(T.a)) + O, !gt && J > 1 && (ft = (H ? ni.scrollingElement || co : D).style, ft = {
                            style: ft,
                            value: ft["overflow" + T.a.toUpperCase()]
                        }, H && Hs(Vn)["overflow" + T.a.toUpperCase()] !== "scroll" && (ft.style["overflow" + T.a.toUpperCase()] = "scroll")), nx(m, ge, re), ye = hg(m), le = aa(m, !0), qe = q && _l(D, Te ? Lr : Bi)(), g ? (Ze = [g + T.os2, k + O + Ii], Ze.t = ge, Q = g === Ei ? J0(m, T) + k + O : 0, Q && (Ze.push(T.d, Q + Ii), ge.style.flexBasis !== "auto" && (ge.style.flexBasis = Q + Ii)), Pf(Ze), Pe && fn.forEach(function(wt) {
                            wt.pin === Pe && wt.vars.pinSpacing !== !1 && (wt._subPinOffset = !0)
                        }), q && ce(Je)) : (Q = J0(m, T), Q && ge.style.flexBasis !== "auto" && (ge.style.flexBasis = Q + Ii)), q && (fe = {
                            top: le.top + (Te ? ee - xe : qe) + Ii,
                            left: le.left + (Te ? qe : ee - xe) + Ii,
                            boxSizing: "border-box",
                            position: "fixed"
                        }, fe[Vc] = fe["max" + Yf] = Math.ceil(le.width) + Ii, fe[Wc] = fe["max" + RS] = Math.ceil(le.height) + Ii, fe[Gs] = fe[Gs + Od] = fe[Gs + Fd] = fe[Gs + Nd] = fe[Gs + Ud] = "0", fe[Ei] = re[Ei], fe[Ei + Od] = re[Ei + Od], fe[Ei + Fd] = re[Ei + Fd], fe[Ei + Nd] = re[Ei + Nd], fe[Ei + Ud] = re[Ei + Ud], ue = wO(z, fe, C), Ir && ce(0)), i ? (st = i._initted, Z_(1), i.render(i.duration(), !0, !0), ot = Be(T.a) - Ne + k + O, $e = Math.abs(k - ot) > 1, q && $e && ue.splice(ue.length - 2, 2), i.render(0, !0, !0), st || i.invalidate(!0), i.parent || i.totalTime(i.totalTime()), Z_(0)) : ot = k, ft && (ft.value ? ft.style["overflow" + T.a.toUpperCase()] = ft.value : ft.style.removeProperty("overflow-" + T.a));
                        else if (d && ce() && !R)
                            for (le = d.parentNode; le && le !== Vn;) le._pinOffset && (xe -= le._pinOffset, J -= le._pinOffset), le = le.parentNode;
                        Qe && Qe.forEach(function(wt) {
                            return wt.revert(!1, !0)
                        }), U.start = xe, U.end = J, Ee = pe = Ir ? Je : ce(), !R && !Ir && (Ee < Je && ce(Je), U.scroll.rec = 0), U.revert(!1, !0), ne = fr(), He && ($ = -1, He.restart(!0)), cr = 0, i && L && (i._initted || Ye) && i.progress() !== Ye && i.progress(Ye || 0, !0).render(i.time(), !0, !0), ($t || me !== U.progress || R || y) && (i && !L && i.totalProgress(R && xe < -.001 && !me ? Tt.utils.normalize(xe, J, 0) : me, !0), U.progress = $t || (Ee - xe) / k === me ? 0 : me), m && g && (ge._pinOffset = Math.round(U.progress * ot)), ae && ae.invalidate(), isNaN(_t) || (_t -= Tt.getProperty(se, T.p), ht -= Tt.getProperty(Se, T.p), dg(se, T, _t), dg(De, T, _t - (Ct || 0)), dg(Se, T, ht), dg(Ce, T, ht - (Ct || 0))), $t && !Ir && U.update(), u && !Ir && !Le && (Le = !0, u(U), Le = !1)
                    }
                }, U.getVelocity = function() {
                    return (ce() - pe) / (fr() - gd) * 1e3 || 0
                }, U.endAnimation = function() {
                    Wh(U.callbackAnimation), i && (ae ? ae.progress(1) : i.paused() ? L || Wh(i, U.direction < 0, 1) : Wh(i, i.reversed()))
                }, U.labelToScroll = function(nt) {
                    return i && i.labels && (xe || U.refresh() || xe) + i.labels[nt] / i.duration() * k || 0
                }, U.getTrailing = function(nt) {
                    var It = fn.indexOf(U),
                        pt = U.direction > 0 ? fn.slice(0, It).reverse() : fn.slice(It + 1);
                    return (cs(nt) ? pt.filter(function(Ct) {
                        return Ct.vars.preventOverlaps === nt
                    }) : pt).filter(function(Ct) {
                        return U.direction > 0 ? Ct.end <= xe : Ct.start >= J
                    })
                }, U.update = function(nt, It, pt) {
                    if (!(R && !pt && !nt)) {
                        var Ct = Ir === !0 ? Je : U.scroll(),
                            ln = nt ? 0 : (Ct - xe) / k,
                            Dt = ln < 0 ? 0 : ln > 1 ? 1 : ln || 0,
                            gt = U.progress,
                            $t, rn, O, W, de, be, Pe, F;
                        if (It && (pe = Ee, Ee = R ? ce() : Ct, M && (Mt = at, at = i && !L ? i.totalProgress() : Dt)), v && m && !cr && !og && Ys && (!Dt && xe < Ct + (Ct - pe) / (fr() - gd) * v ? Dt = 1e-4 : Dt === 1 && J > Ct + (Ct - pe) / (fr() - gd) * v && (Dt = .9999)), Dt !== gt && U.enabled) {
                            if ($t = U.isActive = !!Dt && Dt < 1, rn = !!gt && gt < 1, be = $t !== rn, de = be || !!Dt != !!gt, U.direction = Dt > gt ? 1 : -1, U.progress = Dt, de && !cr && (O = Dt && !gt ? 0 : Dt === 1 ? 1 : gt === 1 ? 2 : 3, L && (W = !be && oe[O + 1] !== "none" && oe[O + 1] || oe[O], F = i && (W === "complete" || W === "reset" || W in i))), b && (be || F) && (F || f || !i) && (Fr(b) ? b(U) : U.getTrailing(b).forEach(function(ee) {
                                    return ee.endAnimation()
                                })), L || (ae && !cr && !og ? (ae._dp._time - ae._start !== ae._time && ae.render(ae._dp._time - ae._start), ae.resetTo ? ae.resetTo("totalProgress", Dt, i._tTime / i._tDur) : (ae.vars.totalProgress = Dt, ae.invalidate().restart())) : i && i.totalProgress(Dt, !!(cr && (ne || nt)))), m) {
                                if (nt && g && (ge.style[g + T.os2] = je), !q) Fe(yd(Ne + ot * Dt));
                                else if (de) {
                                    if (Pe = !nt && Dt > gt && J + 1 > Ct && Ct + 1 >= Po(D, T), C)
                                        if (!nt && ($t || Pe)) {
                                            var Q = aa(m, !0),
                                                re = Ct - xe;
                                            IT(m, Vn, Q.top + (T === Bi ? re : 0) + Ii, Q.left + (T === Bi ? 0 : re) + Ii)
                                        } else IT(m, ge);
                                    Pf($t || Pe ? ue : ye), $e && Dt < 1 && $t || Fe(Ne + (Dt === 1 && !Pe ? ot : 0))
                                }
                            }
                            M && !_e.tween && !cr && !og && He.restart(!0), a && (be || S && Dt && (Dt < 1 || !Q_)) && fp(a.targets).forEach(function(ee) {
                                return ee.classList[$t || S ? "add" : "remove"](a.className)
                            }), o && !L && !nt && o(U), de && !cr ? (L && (F && (W === "complete" ? i.pause().totalProgress(1) : W === "reset" ? i.restart(!0).pause() : W === "restart" ? i.restart(!0) : i[W]()), o && o(U)), (be || !Q_) && (c && be && ex(U, c), X[O] && ex(U, X[O]), S && (Dt === 1 ? U.kill(!1, 1) : X[O] = 0), be || (O = Dt === 1 ? 1 : 3, X[O] && ex(U, X[O]))), P && !$t && Math.abs(U.getVelocity()) > (_d(P) ? P : 2500) && (Wh(U.callbackAnimation), ae ? ae.progress(1) : Wh(i, W === "reverse" ? 1 : !Dt, 1))) : L && o && !cr && o(U)
                        }
                        if (We) {
                            var le = R ? Ct / R.duration() * (R._caScrollDist || 0) : Ct;
                            it(le + (se._isFlipped ? 1 : 0)), We(le)
                        }
                        mt && mt(-Ct / R.duration() * (R._caScrollDist || 0))
                    }
                }, U.enable = function(nt, It) {
                    U.enabled || (U.enabled = !0, Hi(D, "resize", xd), H || Hi(D, "scroll", Ou), j && Hi(r, "refreshInit", j), nt !== !1 && (U.progress = me = 0, Ee = pe = $ = ce()), It !== !1 && U.refresh())
                }, U.getTween = function(nt) {
                    return nt && _e ? _e.tween : ae
                }, U.setPositions = function(nt, It, pt, Ct) {
                    if (R) {
                        var ln = R.scrollTrigger,
                            Dt = R.duration(),
                            gt = ln.end - ln.start;
                        nt = ln.start + gt * nt / Dt, It = ln.start + gt * It / Dt
                    }
                    U.refresh(!1, !1, {
                        start: ST(nt, pt && !!U._startClamp),
                        end: ST(It, pt && !!U._endClamp)
                    }, Ct), U.update()
                }, U.adjustPinSpacing = function(nt) {
                    if (Ze && nt) {
                        var It = Ze.indexOf(T.d) + 1;
                        Ze[It] = parseFloat(Ze[It]) + nt + Ii, Ze[1] = parseFloat(Ze[1]) + nt + Ii, Pf(Ze)
                    }
                }, U.disable = function(nt, It) {
                    if (U.enabled && (nt !== !1 && U.revert(!0, !0), U.enabled = U.isActive = !1, It || ae && ae.pause(), Je = 0, Oe && (Oe.uncache = 1), j && Gi(r, "refreshInit", j), He && (He.pause(), _e.tween && _e.tween.kill() && (_e.tween = 0)), !H)) {
                        for (var pt = fn.length; pt--;)
                            if (fn[pt].scroller === D && fn[pt] !== U) return;
                        Gi(D, "resize", xd), H || Gi(D, "scroll", Ou)
                    }
                }, U.kill = function(nt, It) {
                    U.disable(nt, It), ae && !It && ae.kill(), l && delete nA[l];
                    var pt = fn.indexOf(U);
                    pt >= 0 && fn.splice(pt, 1), pt === Pr && E0 > 0 && Pr--, pt = 0, fn.forEach(function(Ct) {
                        return Ct.scroller === U.scroller && (pt = 1)
                    }), pt || Ir || (U.scroll.rec = 0), i && (i.scrollTrigger = null, nt && i.revert({
                        kill: !1
                    }), It || i.kill()), De && [De, Ce, se, Se].forEach(function(Ct) {
                        return Ct.parentNode && Ct.parentNode.removeChild(Ct)
                    }), kd === U && (kd = 0), m && (Oe && (Oe.uncache = 1), pt = 0, fn.forEach(function(Ct) {
                        return Ct.pin === m && pt++
                    }), pt || (Oe.spacer = 0)), n.onKill && n.onKill(U)
                }, fn.push(U), U.enable(!1, !1), Pt && Pt(U), i && i.add && !k) {
                var Rt = U.update;
                U.update = function() {
                    U.update = Rt, xe || J || U.refresh()
                }, Tt.delayedCall(.01, U.update), k = .01, xe = J = 0
            } else U.refresh();
            m && AO()
        }, r.register = function(n) {
            return of || (Tt = n || eI(), $P() && window.document && r.enable(), of = vd), of
        }, r.defaults = function(n) {
            if (n)
                for (var i in n) ug[i] = n[i];
            return ug
        }, r.disable = function(n, i) {
            vd = 0, fn.forEach(function(o) {
                return o[i ? "kill" : "disable"](n)
            }), Gi(_n, "wheel", Ou), Gi(ni, "scroll", Ou), clearInterval(sg), Gi(ni, "touchcancel", To), Gi(Vn, "touchstart", To), lg(Gi, ni, "pointerdown,touchstart,mousedown", MT), lg(Gi, ni, "pointerup,touchend,mouseup", wT), X0.kill(), ag(Gi);
            for (var s = 0; s < pn.length; s += 3) cg(Gi, pn[s], pn[s + 1]), cg(Gi, pn[s], pn[s + 2])
        }, r.enable = function() {
            if (_n = window, ni = document, co = ni.documentElement, Vn = ni.body, Tt && (fp = Tt.utils.toArray, Ld = Tt.utils.clamp, eA = Tt.core.context || To, Z_ = Tt.core.suppressOverwrites || To, bS = _n.history.scrollRestoration || "auto", iA = _n.pageYOffset, Tt.core.globals("ScrollTrigger", r), Vn)) {
                vd = 1, Rf = document.createElement("div"), Rf.style.height = "100vh", Rf.style.position = "absolute", cI(), pO(), Si.register(Tt), r.isTouch = Si.isTouch, Za = Si.isTouch && /(iPad|iPhone|iPod|Mac)/g.test(navigator.userAgent), $1 = Si.isTouch === 1, Hi(_n, "wheel", Ou), JP = [_n, ni, co, Vn], Tt.matchMedia ? (r.matchMedia = function(l) {
                    var c = Tt.matchMedia(),
                        u;
                    for (u in l) c.add(u, l[u]);
                    return c
                }, Tt.addEventListener("matchMediaInit", function() {
                    return IS()
                }), Tt.addEventListener("matchMediaRevert", function() {
                    return aI()
                }), Tt.addEventListener("matchMedia", function() {
                    Rc(0, 1), ru("matchMedia")
                }), Tt.matchMedia("(orientation: portrait)", function() {
                    return tx(), tx
                })) : console.warn("Requires GSAP 3.11.0 or later"), tx(), Hi(ni, "scroll", Ou);
                var n = Vn.style,
                    i = n.borderTopStyle,
                    s = Tt.core.Animation.prototype,
                    o, a;
                for (s.revert || Object.defineProperty(s, "revert", {
                        value: function() {
                            return this.time(-.01, !0)
                        }
                    }), n.borderTopStyle = "solid", o = aa(Vn), Bi.m = Math.round(o.top + Bi.sc()) || 0, Lr.m = Math.round(o.left + Lr.sc()) || 0, i ? n.borderTopStyle = i : n.removeProperty("border-top-style"), sg = setInterval(ET, 250), Tt.delayedCall(.5, function() {
                        return og = 0
                    }), Hi(ni, "touchcancel", To), Hi(Vn, "touchstart", To), lg(Hi, ni, "pointerdown,touchstart,mousedown", MT), lg(Hi, ni, "pointerup,touchend,mouseup", wT), Q1 = Tt.utils.checkPrefix("transform"), C0.push(Q1), of = fr(), X0 = Tt.delayedCall(.2, Rc).pause(), af = [ni, "visibilitychange", function() {
                        var l = _n.innerWidth,
                            c = _n.innerHeight;
                        ni.hidden ? (_T = l, xT = c) : (_T !== l || xT !== c) && xd()
                    }, ni, "DOMContentLoaded", Rc, _n, "load", Rc, _n, "resize", xd], ag(Hi), fn.forEach(function(l) {
                        return l.enable(0, 1)
                    }), a = 0; a < pn.length; a += 3) cg(Gi, pn[a], pn[a + 1]), cg(Gi, pn[a], pn[a + 2])
            }
        }, r.config = function(n) {
            "limitCallbacks" in n && (Q_ = !!n.limitCallbacks);
            var i = n.syncInterval;
            i && clearInterval(sg) || (sg = i) && setInterval(ET, i), "ignoreMobileResize" in n && ($1 = r.isTouch === 1 && n.ignoreMobileResize), "autoRefreshEvents" in n && (ag(Gi) || ag(Hi, n.autoRefreshEvents || "none"), qP = (n.autoRefreshEvents + "").indexOf("resize") === -1)
        }, r.scrollerProxy = function(n, i) {
            var s = jr(n),
                o = pn.indexOf(s),
                a = nu(s);
            ~o && pn.splice(o, a ? 6 : 2), i && (a ? Lo.unshift(_n, i, Vn, i, co, i) : Lo.unshift(s, i))
        }, r.clearMatchMedia = function(n) {
            fn.forEach(function(i) {
                return i._ctx && i._ctx.query === n && i._ctx.kill(!0, !0)
            })
        }, r.isInViewport = function(n, i, s) {
            var o = (cs(n) ? jr(n) : n).getBoundingClientRect(),
                a = o[s ? Vc : Wc] * i || 0;
            return s ? o.right - a > 0 && o.left + a < _n.innerWidth : o.bottom - a > 0 && o.top + a < _n.innerHeight
        }, r.positionInViewport = function(n, i, s) {
            cs(n) && (n = jr(n));
            var o = n.getBoundingClientRect(),
                a = o[s ? Vc : Wc],
                l = i == null ? a / 2 : i in K0 ? K0[i] * a : ~i.indexOf("%") ? parseFloat(i) * a / 100 : parseFloat(i) || 0;
            return s ? (o.left + l) / _n.innerWidth : (o.top + l) / _n.innerHeight
        }, r.killAll = function(n) {
            if (fn.slice(0).forEach(function(s) {
                    return s.vars.id !== "ScrollSmoother" && s.kill()
                }), n !== !0) {
                var i = iu.killAll || [];
                iu = {}, i.forEach(function(s) {
                    return s()
                })
            }
        }, r
    }();
Zt.version = "3.12.5";
Zt.saveStyles = function(r) {
    return r ? fp(r).forEach(function(e) {
        if (e && e.style) {
            var t = ls.indexOf(e);
            t >= 0 && ls.splice(t, 5), ls.push(e, e.style.cssText, e.getBBox && e.getAttribute("transform"), Tt.core.getCache(e), eA())
        }
    }) : ls
};
Zt.revert = function(r, e) {
    return IS(!r, e)
};
Zt.create = function(r, e) {
    return new Zt(r, e)
};
Zt.refresh = function(r) {
    return r ? xd() : ( of || Zt.register()) && Rc(!0)
};
Zt.update = function(r) {
    return ++pn.cache && va(r === !0 ? 2 : 0)
};
Zt.clearScrollMemory = lI;
Zt.maxScroll = function(r, e) {
    return Po(r, e ? Lr : Bi)
};
Zt.getScrollFunc = function(r, e) {
    return _l(jr(r), e ? Lr : Bi)
};
Zt.getById = function(r) {
    return nA[r]
};
Zt.getAll = function() {
    return fn.filter(function(r) {
        return r.vars.id !== "ScrollSmoother"
    })
};
Zt.isScrolling = function() {
    return !!Ys
};
Zt.snapDirectional = PS;
Zt.addEventListener = function(r, e) {
    var t = iu[r] || (iu[r] = []);
    ~t.indexOf(e) || t.push(e)
};
Zt.removeEventListener = function(r, e) {
    var t = iu[r],
        n = t && t.indexOf(e);
    n >= 0 && t.splice(n, 1)
};
Zt.batch = function(r, e) {
    var t = [],
        n = {},
        i = e.interval || .016,
        s = e.batchMax || 1e9,
        o = function(c, u) {
            var f = [],
                d = [],
                m = Tt.delayedCall(i, function() {
                    u(f, d), f = [], d = []
                }).pause();
            return function(g) {
                f.length || m.restart(!0), f.push(g.trigger), d.push(g), s <= f.length && m.progress(1)
            }
        },
        a;
    for (a in e) n[a] = a.substr(0, 2) === "on" && Fr(e[a]) && a !== "onRefreshInit" ? o(a, e[a]) : e[a];
    return Fr(s) && (s = s(), Hi(Zt, "refresh", function() {
        return s = e.batchMax()
    })), fp(r).forEach(function(l) {
        var c = {};
        for (a in n) c[a] = n[a];
        c.trigger = l, t.push(Zt.create(c))
    }), t
};
var DT = function(e, t, n, i) {
        return t > i ? e(i) : t < 0 && e(0), n > i ? (i - t) / (n - t) : n < 0 ? t / (t - n) : 1
    },
    ix = function r(e, t) {
        t === !0 ? e.style.removeProperty("touch-action") : e.style.touchAction = t === !0 ? "auto" : t ? "pan-" + t + (Si.isTouch ? " pinch-zoom" : "") : "none", e === co && r(Vn, t)
    },
    pg = {
        auto: 1,
        scroll: 1
    },
    TO = function(e) {
        var t = e.event,
            n = e.target,
            i = e.axis,
            s = (t.changedTouches ? t.changedTouches[0] : t).target,
            o = s._gsap || Tt.core.getCache(s),
            a = fr(),
            l;
        if (!o._isScrollT || a - o._isScrollT > 2e3) {
            for (; s && s !== Vn && (s.scrollHeight <= s.clientHeight && s.scrollWidth <= s.clientWidth || !(pg[(l = Hs(s)).overflowY] || pg[l.overflowX]));) s = s.parentNode;
            o._isScroll = s && s !== n && !nu(s) && (pg[(l = Hs(s)).overflowY] || pg[l.overflowX]), o._isScrollT = a
        }(o._isScroll || i === "x") && (t.stopPropagation(), t._gsapAllow = !0)
    },
    fI = function(e, t, n, i) {
        return Si.create({
            target: e,
            capture: !0,
            debounce: !1,
            lockAxis: !0,
            type: t,
            onWheel: i = i && TO,
            onPress: i,
            onDrag: i,
            onScroll: i,
            onEnable: function() {
                return n && Hi(ni, Si.eventTypes[0], FT, !1, !0)
            },
            onDisable: function() {
                return Gi(ni, Si.eventTypes[0], FT, !0)
            }
        })
    },
    EO = /(input|label|select|textarea)/i,
    LT, FT = function(e) {
        var t = EO.test(e.target.tagName);
        (t || LT) && (e._gsapAllow = !0, LT = t)
    },
    CO = function(e) {
        Sc(e) || (e = {}), e.preventDefault = e.isNormalizer = e.allowClicks = !0, e.type || (e.type = "wheel,touch"), e.debounce = !!e.debounce, e.id = e.id || "normalizer";
        var t = e,
            n = t.normalizeScrollX,
            i = t.momentum,
            s = t.allowNestedScroll,
            o = t.onRelease,
            a, l, c = jr(e.target) || co,
            u = Tt.core.globals().ScrollSmoother,
            f = u && u.get(),
            d = Za && (e.content && jr(e.content) || f && e.content !== !1 && !f.smooth() && f.content()),
            m = _l(c, Bi),
            g = _l(c, Lr),
            y = 1,
            v = (Si.isTouch && _n.visualViewport ? _n.visualViewport.scale * _n.visualViewport.width : _n.outerWidth) / _n.innerWidth,
            _ = 0,
            A = Fr(i) ? function() {
                return i(a)
            } : function() {
                return i || 2.8
            },
            S, M, C = fI(c, e.type, !0, s),
            E = function() {
                return M = !1
            },
            R = To,
            P = To,
            b = function() {
                l = Po(c, Bi), P = Ld(Za ? 1 : 0, l), n && (R = Ld(0, Po(c, Lr))), S = jc
            },
            T = function() {
                d._gsap.y = yd(parseFloat(d._gsap.y) + m.offset) + "px", d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + parseFloat(d._gsap.y) + ", 0, 1)", m.offset = m.cacheID = 0
            },
            L = function() {
                if (M) {
                    requestAnimationFrame(E);
                    var Y = yd(a.deltaY / 2),
                        Z = P(m.v - Y);
                    if (d && Z !== m.v + m.offset) {
                        m.offset = Z - m.v;
                        var U = yd((parseFloat(d && d._gsap.y) || 0) - m.offset);
                        d.style.transform = "matrix3d(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, " + U + ", 0, 1)", d._gsap.y = U + "px", m.cacheID = pn.cache, va()
                    }
                    return !0
                }
                m.offset && T(), M = !0
            },
            D, V, H, q, X = function() {
                b(), D.isActive() && D.vars.scrollY > l && (m() > l ? D.progress(1) && m(l) : D.resetTo("scrollY", l))
            };
        return d && Tt.set(d, {
            y: "+=0"
        }), e.ignoreCheck = function(oe) {
            return Za && oe.type === "touchmove" && L() || y > 1.05 && oe.type !== "touchstart" || a.isGesturing || oe.touches && oe.touches.length > 1
        }, e.onPress = function() {
            M = !1;
            var oe = y;
            y = yd((_n.visualViewport && _n.visualViewport.scale || 1) / v), D.pause(), oe !== y && ix(c, y > 1.01 ? !0 : n ? !1 : "x"), V = g(), H = m(), b(), S = jc
        }, e.onRelease = e.onGestureStart = function(oe, Y) {
            if (m.offset && T(), !Y) q.restart(!0);
            else {
                pn.cache++;
                var Z = A(),
                    U, j;
                n && (U = g(), j = U + Z * .05 * -oe.velocityX / .227, Z *= DT(g, U, j, Po(c, Lr)), D.vars.scrollX = R(j)), U = m(), j = U + Z * .05 * -oe.velocityY / .227, Z *= DT(m, U, j, Po(c, Bi)), D.vars.scrollY = P(j), D.invalidate().duration(Z).play(.01), (Za && D.vars.scrollY >= l || U >= l - 1) && Tt.to({}, {
                    onUpdate: X,
                    duration: Z
                })
            }
            o && o(oe)
        }, e.onWheel = function() {
            D._ts && D.pause(), fr() - _ > 1e3 && (S = 0, _ = fr())
        }, e.onChange = function(oe, Y, Z, U, j) {
            if (jc !== S && b(), Y && n && g(R(U[2] === Y ? V + (oe.startX - oe.x) : g() + Y - U[1])), Z) {
                m.offset && T();
                var te = j[2] === Z,
                    he = te ? H + oe.startY - oe.y : m() + Z - j[1],
                    $ = P(he);
                te && he !== $ && (H += $ - he), m($)
            }(Z || Y) && va()
        }, e.onEnable = function() {
            ix(c, n ? !1 : "x"), Zt.addEventListener("refresh", X), Hi(_n, "resize", X), m.smooth && (m.target.style.scrollBehavior = "auto", m.smooth = g.smooth = !1), C.enable()
        }, e.onDisable = function() {
            ix(c, !0), Gi(_n, "resize", X), Zt.removeEventListener("refresh", X), C.kill()
        }, e.lockAxis = e.lockAxis !== !1, a = new Si(e), a.iOS = Za, Za && !m() && m(1), Za && Tt.ticker.add(To), q = a._dc, D = Tt.to(a, {
            ease: "power4",
            paused: !0,
            inherit: !1,
            scrollX: n ? "+=0.1" : "+=0",
            scrollY: "+=0.1",
            modifiers: {
                scrollY: uI(m, m(), function() {
                    return D.pause()
                })
            },
            onUpdate: va,
            onComplete: q.vars.onComplete
        }), a
    };
Zt.sort = function(r) {
    return fn.sort(r || function(e, t) {
        return (e.vars.refreshPriority || 0) * -1e6 + e.start - (t.start + (t.vars.refreshPriority || 0) * -1e6)
    })
};
Zt.observe = function(r) {
    return new Si(r)
};
Zt.normalizeScroll = function(r) {
    if (typeof r > "u") return Rr;
    if (r === !0 && Rr) return Rr.enable();
    if (r === !1) {
        Rr && Rr.kill(), Rr = r;
        return
    }
    var e = r instanceof Si ? r : CO(r);
    return Rr && Rr.target === e.target && Rr.kill(), nu(e.target) && (Rr = e), e
};
Zt.core = {
    _getVelocityProp: Z1,
    _inputObserver: fI,
    _scrollers: pn,
    _proxies: Lo,
    bridge: {
        ss: function() {
            Ys || ru("scrollStart"), Ys = fr()
        },
        ref: function() {
            return cr
        }
    }
};
eI() && Tt.registerPlugin(Zt);
var UT = typeof window < "u" && new class {
    constructor() {
        this.raf = r => {
            requestAnimationFrame(this.raf);
            const e = r - this.now;
            this.now = r;
            for (let t = 0; t < this.callbacks.length; t++) this.callbacks[t].callback(r, e)
        }, this.callbacks = [], this.now = performance.now(), requestAnimationFrame(this.raf)
    }
    add(r, e = 0) {
        return this.callbacks.push({
            callback: r,
            priority: e
        }), this.callbacks.sort((t, n) => t.priority - n.priority), () => this.remove(r)
    }
    remove(r) {
        this.callbacks = this.callbacks.filter(({
            callback: e
        }) => r !== e)
    }
};

function RO(r, e = 0) {
    N.useEffect(() => {
        if (r) return UT.add(r, e), () => UT.remove(r)
    }, [r, e])
}

function hI(r, e, t) {
    return Math.max(r, Math.min(e, t))
}
class PO {
    advance(e) {
        var a;
        if (!this.isRunning) return;
        let t = !1;
        if (this.lerp) this.value = (n = this.value, i = this.to, s = 60 * this.lerp, o = e, function(l, c, u) {
            return (1 - u) * l + u * c
        }(n, i, 1 - Math.exp(-s * o))), Math.round(this.value) === this.to && (this.value = this.to, t = !0);
        else {
            this.currentTime += e;
            const l = hI(0, this.currentTime / this.duration, 1);
            t = l >= 1;
            const c = t ? 1 : this.easing(l);
            this.value = this.from + (this.to - this.from) * c
        }
        var n, i, s, o;
        (a = this.onUpdate) == null || a.call(this, this.value, t), t && this.stop()
    }
    stop() {
        this.isRunning = !1
    }
    fromTo(e, t, {
        lerp: n = .1,
        duration: i = 1,
        easing: s = l => l,
        onStart: o,
        onUpdate: a
    }) {
        this.from = this.value = e, this.to = t, this.lerp = n, this.duration = i, this.easing = s, this.currentTime = 0, this.isRunning = !0, o == null || o(), this.onUpdate = a
    }
}
class IO {
    constructor({
        wrapper: e,
        content: t,
        autoResize: n = !0,
        debounce: i = 250
    } = {}) {
        ss(this, "resize", () => {
            this.onWrapperResize(), this.onContentResize()
        });
        ss(this, "onWrapperResize", () => {
            this.wrapper === window ? (this.width = window.innerWidth, this.height = window.innerHeight) : (this.width = this.wrapper.clientWidth, this.height = this.wrapper.clientHeight)
        });
        ss(this, "onContentResize", () => {
            this.wrapper === window ? (this.scrollHeight = this.content.scrollHeight, this.scrollWidth = this.content.scrollWidth) : (this.scrollHeight = this.wrapper.scrollHeight, this.scrollWidth = this.wrapper.scrollWidth)
        });
        this.wrapper = e, this.content = t, n && (this.debouncedResize = function(s, o) {
            let a;
            return function() {
                let l = arguments,
                    c = this;
                clearTimeout(a), a = setTimeout(function() {
                    s.apply(c, l)
                }, o)
            }
        }(this.resize, i), this.wrapper === window ? window.addEventListener("resize", this.debouncedResize, !1) : (this.wrapperResizeObserver = new ResizeObserver(this.debouncedResize), this.wrapperResizeObserver.observe(this.wrapper)), this.contentResizeObserver = new ResizeObserver(this.debouncedResize), this.contentResizeObserver.observe(this.content)), this.resize()
    }
    destroy() {
        var e, t;
        (e = this.wrapperResizeObserver) == null || e.disconnect(), (t = this.contentResizeObserver) == null || t.disconnect(), window.removeEventListener("resize", this.debouncedResize, !1)
    }
    get limit() {
        return {
            x: this.scrollWidth - this.width,
            y: this.scrollHeight - this.height
        }
    }
}
class dI {
    constructor() {
        this.events = {}
    }
    emit(e, ...t) {
        let n = this.events[e] || [];
        for (let i = 0, s = n.length; i < s; i++) n[i](...t)
    }
    on(e, t) {
        var n;
        return (n = this.events[e]) != null && n.push(t) || (this.events[e] = [t]), () => {
            var i;
            this.events[e] = (i = this.events[e]) == null ? void 0 : i.filter(s => t !== s)
        }
    }
    off(e, t) {
        var n;
        this.events[e] = (n = this.events[e]) == null ? void 0 : n.filter(i => t !== i)
    }
    destroy() {
        this.events = {}
    }
}
const OT = 100 / 6;
class BO {
    constructor(e, {
        wheelMultiplier: t = 1,
        touchMultiplier: n = 1
    }) {
        ss(this, "onTouchStart", e => {
            const {
                clientX: t,
                clientY: n
            } = e.targetTouches ? e.targetTouches[0] : e;
            this.touchStart.x = t, this.touchStart.y = n, this.lastDelta = {
                x: 0,
                y: 0
            }, this.emitter.emit("scroll", {
                deltaX: 0,
                deltaY: 0,
                event: e
            })
        });
        ss(this, "onTouchMove", e => {
            const {
                clientX: t,
                clientY: n
            } = e.targetTouches ? e.targetTouches[0] : e, i = -(t - this.touchStart.x) * this.touchMultiplier, s = -(n - this.touchStart.y) * this.touchMultiplier;
            this.touchStart.x = t, this.touchStart.y = n, this.lastDelta = {
                x: i,
                y: s
            }, this.emitter.emit("scroll", {
                deltaX: i,
                deltaY: s,
                event: e
            })
        });
        ss(this, "onTouchEnd", e => {
            this.emitter.emit("scroll", {
                deltaX: this.lastDelta.x,
                deltaY: this.lastDelta.y,
                event: e
            })
        });
        ss(this, "onWheel", e => {
            let {
                deltaX: t,
                deltaY: n,
                deltaMode: i
            } = e;
            t *= i === 1 ? OT : i === 2 ? this.windowWidth : 1, n *= i === 1 ? OT : i === 2 ? this.windowHeight : 1, t *= this.wheelMultiplier, n *= this.wheelMultiplier, this.emitter.emit("scroll", {
                deltaX: t,
                deltaY: n,
                event: e
            })
        });
        ss(this, "onWindowResize", () => {
            this.windowWidth = window.innerWidth, this.windowHeight = window.innerHeight
        });
        this.element = e, this.wheelMultiplier = t, this.touchMultiplier = n, this.touchStart = {
            x: null,
            y: null
        }, this.emitter = new dI, window.addEventListener("resize", this.onWindowResize, !1), this.onWindowResize(), this.element.addEventListener("wheel", this.onWheel, {
            passive: !1
        }), this.element.addEventListener("touchstart", this.onTouchStart, {
            passive: !1
        }), this.element.addEventListener("touchmove", this.onTouchMove, {
            passive: !1
        }), this.element.addEventListener("touchend", this.onTouchEnd, {
            passive: !1
        })
    }
    on(e, t) {
        return this.emitter.on(e, t)
    }
    destroy() {
        this.emitter.destroy(), window.removeEventListener("resize", this.onWindowResize, !1), this.element.removeEventListener("wheel", this.onWheel, {
            passive: !1
        }), this.element.removeEventListener("touchstart", this.onTouchStart, {
            passive: !1
        }), this.element.removeEventListener("touchmove", this.onTouchMove, {
            passive: !1
        }), this.element.removeEventListener("touchend", this.onTouchEnd, {
            passive: !1
        })
    }
}
class pI {
    constructor({
        wrapper: e = window,
        content: t = document.documentElement,
        wheelEventsTarget: n = e,
        eventsTarget: i = n,
        smoothWheel: s = !0,
        syncTouch: o = !1,
        syncTouchLerp: a = .075,
        touchInertiaMultiplier: l = 35,
        duration: c,
        easing: u = S => Math.min(1, 1.001 - Math.pow(2, -10 * S)),
        lerp: f = !c && .1,
        infinite: d = !1,
        orientation: m = "vertical",
        gestureOrientation: g = "vertical",
        touchMultiplier: y = 1,
        wheelMultiplier: v = 1,
        autoResize: _ = !0,
        __experimental__naiveDimensions: A = !1
    } = {}) {
        this.__isSmooth = !1, this.__isScrolling = !1, this.__isStopped = !1, this.__isLocked = !1, this.onVirtualScroll = ({
            deltaX: S,
            deltaY: M,
            event: C
        }) => {
            if (C.ctrlKey) return;
            const E = C.type.includes("touch"),
                R = C.type.includes("wheel");
            if (this.options.syncTouch && E && C.type === "touchstart" && !this.isStopped && !this.isLocked) return void this.reset();
            const P = S === 0 && M === 0,
                b = this.options.gestureOrientation === "vertical" && M === 0 || this.options.gestureOrientation === "horizontal" && S === 0;
            if (P || b) return;
            let T = C.composedPath();
            if (T = T.slice(0, T.indexOf(this.rootElement)), T.find(H => {
                    var q, X, oe, Y, Z;
                    return ((q = H.hasAttribute) === null || q === void 0 ? void 0 : q.call(H, "data-lenis-prevent")) || E && ((X = H.hasAttribute) === null || X === void 0 ? void 0 : X.call(H, "data-lenis-prevent-touch")) || R && ((oe = H.hasAttribute) === null || oe === void 0 ? void 0 : oe.call(H, "data-lenis-prevent-wheel")) || ((Y = H.classList) === null || Y === void 0 ? void 0 : Y.contains("lenis")) && !(!((Z = H.classList) === null || Z === void 0) && Z.contains("lenis-stopped"))
                })) return;
            if (this.isStopped || this.isLocked) return void C.preventDefault();
            if (this.isSmooth = this.options.syncTouch && E || this.options.smoothWheel && R, !this.isSmooth) return this.isScrolling = !1, void this.animate.stop();
            C.preventDefault();
            let L = M;
            this.options.gestureOrientation === "both" ? L = Math.abs(M) > Math.abs(S) ? M : S : this.options.gestureOrientation === "horizontal" && (L = S);
            const D = E && this.options.syncTouch,
                V = E && C.type === "touchend" && Math.abs(L) > 5;
            V && (L = this.velocity * this.options.touchInertiaMultiplier), this.scrollTo(this.targetScroll + L, Object.assign({
                programmatic: !1
            }, D ? {
                lerp: V ? this.options.syncTouchLerp : 1
            } : {
                lerp: this.options.lerp,
                duration: this.options.duration,
                easing: this.options.easing
            }))
        }, this.onNativeScroll = () => {
            if (!this.__preventNextScrollEvent && !this.isScrolling) {
                const S = this.animatedScroll;
                this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.direction = Math.sign(this.animatedScroll - S), this.emit()
            }
        }, window.lenisVersion = "1.0.42", e !== document.documentElement && e !== document.body || (e = window), this.options = {
            wrapper: e,
            content: t,
            wheelEventsTarget: n,
            eventsTarget: i,
            smoothWheel: s,
            syncTouch: o,
            syncTouchLerp: a,
            touchInertiaMultiplier: l,
            duration: c,
            easing: u,
            lerp: f,
            infinite: d,
            gestureOrientation: g,
            orientation: m,
            touchMultiplier: y,
            wheelMultiplier: v,
            autoResize: _,
            __experimental__naiveDimensions: A
        }, this.animate = new PO, this.emitter = new dI, this.dimensions = new IO({
            wrapper: e,
            content: t,
            autoResize: _
        }), this.toggleClassName("lenis", !0), this.velocity = 0, this.isLocked = !1, this.isStopped = !1, this.isSmooth = o || s, this.isScrolling = !1, this.targetScroll = this.animatedScroll = this.actualScroll, this.options.wrapper.addEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll = new BO(i, {
            touchMultiplier: y,
            wheelMultiplier: v
        }), this.virtualScroll.on("scroll", this.onVirtualScroll)
    }
    destroy() {
        this.emitter.destroy(), this.options.wrapper.removeEventListener("scroll", this.onNativeScroll, !1), this.virtualScroll.destroy(), this.dimensions.destroy(), this.toggleClassName("lenis", !1), this.toggleClassName("lenis-smooth", !1), this.toggleClassName("lenis-scrolling", !1), this.toggleClassName("lenis-stopped", !1), this.toggleClassName("lenis-locked", !1)
    }
    on(e, t) {
        return this.emitter.on(e, t)
    }
    off(e, t) {
        return this.emitter.off(e, t)
    }
    setScroll(e) {
        this.isHorizontal ? this.rootElement.scrollLeft = e : this.rootElement.scrollTop = e
    }
    resize() {
        this.dimensions.resize()
    }
    emit() {
        this.emitter.emit("scroll", this)
    }
    reset() {
        this.isLocked = !1, this.isScrolling = !1, this.animatedScroll = this.targetScroll = this.actualScroll, this.velocity = 0, this.animate.stop()
    }
    start() {
        this.isStopped && (this.isStopped = !1, this.reset())
    }
    stop() {
        this.isStopped || (this.isStopped = !0, this.animate.stop(), this.reset())
    }
    raf(e) {
        const t = e - (this.time || e);
        this.time = e, this.animate.advance(.001 * t)
    }
    scrollTo(e, {
        offset: t = 0,
        immediate: n = !1,
        lock: i = !1,
        duration: s = this.options.duration,
        easing: o = this.options.easing,
        lerp: a = !s && this.options.lerp,
        onComplete: l,
        force: c = !1,
        programmatic: u = !0
    } = {}) {
        if (!this.isStopped && !this.isLocked || c) {
            if (["top", "left", "start"].includes(e)) e = 0;
            else if (["bottom", "right", "end"].includes(e)) e = this.limit;
            else {
                let f;
                if (typeof e == "string" ? f = document.querySelector(e) : e != null && e.nodeType && (f = e), f) {
                    if (this.options.wrapper !== window) {
                        const m = this.options.wrapper.getBoundingClientRect();
                        t -= this.isHorizontal ? m.left : m.top
                    }
                    const d = f.getBoundingClientRect();
                    e = (this.isHorizontal ? d.left : d.top) + this.animatedScroll
                }
            }
            if (typeof e == "number") {
                if (e += t, e = Math.round(e), this.options.infinite ? u && (this.targetScroll = this.animatedScroll = this.scroll) : e = hI(0, e, this.limit), n) return this.animatedScroll = this.targetScroll = e, this.setScroll(this.scroll), this.reset(), void(l == null || l(this));
                if (!u) {
                    if (e === this.targetScroll) return;
                    this.targetScroll = e
                }
                this.animate.fromTo(this.animatedScroll, e, {
                    duration: s,
                    easing: o,
                    lerp: a,
                    onStart: () => {
                        i && (this.isLocked = !0), this.isScrolling = !0
                    },
                    onUpdate: (f, d) => {
                        this.isScrolling = !0, this.velocity = f - this.animatedScroll, this.direction = Math.sign(this.velocity), this.animatedScroll = f, this.setScroll(this.scroll), u && (this.targetScroll = f), d || this.emit(), d && (this.reset(), this.emit(), l == null || l(this), this.__preventNextScrollEvent = !0, requestAnimationFrame(() => {
                            delete this.__preventNextScrollEvent
                        }))
                    }
                })
            }
        }
    }
    get rootElement() {
        return this.options.wrapper === window ? document.documentElement : this.options.wrapper
    }
    get limit() {
        return this.options.__experimental__naiveDimensions ? this.isHorizontal ? this.rootElement.scrollWidth - this.rootElement.clientWidth : this.rootElement.scrollHeight - this.rootElement.clientHeight : this.dimensions.limit[this.isHorizontal ? "x" : "y"]
    }
    get isHorizontal() {
        return this.options.orientation === "horizontal"
    }
    get actualScroll() {
        return this.isHorizontal ? this.rootElement.scrollLeft : this.rootElement.scrollTop
    }
    get scroll() {
        return this.options.infinite ? (e = this.animatedScroll, t = this.limit, (e % t + t) % t) : this.animatedScroll;
        var e, t
    }
    get progress() {
        return this.limit === 0 ? 1 : this.scroll / this.limit
    }
    get isSmooth() {
        return this.__isSmooth
    }
    set isSmooth(e) {
        this.__isSmooth !== e && (this.__isSmooth = e, this.toggleClassName("lenis-smooth", e))
    }
    get isScrolling() {
        return this.__isScrolling
    }
    set isScrolling(e) {
        this.__isScrolling !== e && (this.__isScrolling = e, this.toggleClassName("lenis-scrolling", e))
    }
    get isStopped() {
        return this.__isStopped
    }
    set isStopped(e) {
        this.__isStopped !== e && (this.__isStopped = e, this.toggleClassName("lenis-stopped", e))
    }
    get isLocked() {
        return this.__isLocked
    }
    set isLocked(e) {
        this.__isLocked !== e && (this.__isLocked = e, this.toggleClassName("lenis-locked", e))
    }
    get className() {
        let e = "lenis";
        return this.isStopped && (e += " lenis-stopped"), this.isLocked && (e += " lenis-locked"), this.isScrolling && (e += " lenis-scrolling"), this.isSmooth && (e += " lenis-smooth"), e
    }
    toggleClassName(e, t) {
        this.rootElement.classList.toggle(e, t), this.emitter.emit("className change", this)
    }
}

function mI(r) {
    var e, t, n = "";
    if (typeof r == "string" || typeof r == "number") n += r;
    else if (typeof r == "object")
        if (Array.isArray(r)) {
            var i = r.length;
            for (e = 0; e < i; e++) r[e] && (t = mI(r[e])) && (n && (n += " "), n += t)
        } else
            for (t in r) r[t] && (n && (n += " "), n += t);
    return n
}

function sA() {
    for (var r, e, t = 0, n = "", i = arguments.length; t < i; t++)(r = arguments[t]) && (e = mI(r)) && (n && (n += " "), n += e);
    return n
}
const DO = {
        BASE_URL: "./",
        DEV: !1,
        MODE: "production",
        PROD: !0,
        SSR: !1,
        VITE_VERCEL_BRANCH_URL: "sage-git-main-gits-projects-10732a9b.vercel.app",
        VITE_VERCEL_DEPLOYMENT_ID: "dpl_8Q1r1zQL9VeUt5Zab5JjtceMVgSa",
        VITE_VERCEL_ENV: "production",
        VITE_VERCEL_GIT_COMMIT_AUTHOR_LOGIN: "admin-fantik",
        VITE_VERCEL_GIT_COMMIT_AUTHOR_NAME: "admin-fantik",
        VITE_VERCEL_GIT_COMMIT_MESSAGE: `Merge pull request #81 from admin-fantik/dev-dmytro

Dev dmytro`,
        VITE_VERCEL_GIT_COMMIT_REF: "main",
        VITE_VERCEL_GIT_COMMIT_SHA: "8e476b1a62d340589157c71fb9d26e5e4752d6a1",
        VITE_VERCEL_GIT_PREVIOUS_SHA: "",
        VITE_VERCEL_GIT_PROVIDER: "github",
        VITE_VERCEL_GIT_PULL_REQUEST_ID: "",
        VITE_VERCEL_GIT_REPO_ID: "855724001",
        VITE_VERCEL_GIT_REPO_OWNER: "admin-fantik",
        VITE_VERCEL_GIT_REPO_SLUG: "sage",
        VITE_VERCEL_PROJECT_ID: "prj_fHiuUvP3DLJx8pOWu5bmkFCqqGS5",
        VITE_VERCEL_PROJECT_PRODUCTION_URL: "sage.fantik.studio",
        VITE_VERCEL_TARGET_ENV: "production",
        VITE_VERCEL_URL: "sage-686ces92e-gits-projects-10732a9b.vercel.app"
    },
    NT = r => {
        let e;
        const t = new Set,
            n = (u, f) => {
                const d = typeof u == "function" ? u(e) : u;
                if (!Object.is(d, e)) {
                    const m = e;
                    e = f ? ? (typeof d != "object" || d === null) ? d : Object.assign({}, e, d), t.forEach(g => g(e, m))
                }
            },
            i = () => e,
            l = {
                setState: n,
                getState: i,
                getInitialState: () => c,
                subscribe: u => (t.add(u), () => t.delete(u)),
                destroy: () => {
                    (DO ? "production" : void 0) !== "production" && console.warn("[DEPRECATED] The `destroy` method will be unsupported in a future version. Instead use unsubscribe function returned by subscribe. Everything will be garbage-collected if store is garbage-collected."), t.clear()
                }
            },
            c = e = r(n, i, l);
        return l
    },
    LO = r => r ? NT(r) : NT;
var gI = {
        exports: {}
    },
    vI = {},
    yI = {
        exports: {}
    },
    _I = {};
/**
 * @license React
 * use-sync-external-store-shim.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var Jf = N;

function FO(r, e) {
    return r === e && (r !== 0 || 1 / r === 1 / e) || r !== r && e !== e
}
var UO = typeof Object.is == "function" ? Object.is : FO,
    OO = Jf.useState,
    NO = Jf.useEffect,
    kO = Jf.useLayoutEffect,
    zO = Jf.useDebugValue;

function GO(r, e) {
    var t = e(),
        n = OO({
            inst: {
                value: t,
                getSnapshot: e
            }
        }),
        i = n[0].inst,
        s = n[1];
    return kO(function() {
        i.value = t, i.getSnapshot = e, rx(i) && s({
            inst: i
        })
    }, [r, t, e]), NO(function() {
        return rx(i) && s({
            inst: i
        }), r(function() {
            rx(i) && s({
                inst: i
            })
        })
    }, [r]), zO(t), t
}

function rx(r) {
    var e = r.getSnapshot;
    r = r.value;
    try {
        var t = e();
        return !UO(r, t)
    } catch {
        return !0
    }
}

function HO(r, e) {
    return e()
}
var VO = typeof window > "u" || typeof window.document > "u" || typeof window.document.createElement > "u" ? HO : GO;
_I.useSyncExternalStore = Jf.useSyncExternalStore !== void 0 ? Jf.useSyncExternalStore : VO;
yI.exports = _I;
var WO = yI.exports;
/**
 * @license React
 * use-sync-external-store-shim/with-selector.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var ny = N,
    jO = WO;

function XO(r, e) {
    return r === e && (r !== 0 || 1 / r === 1 / e) || r !== r && e !== e
}
var YO = typeof Object.is == "function" ? Object.is : XO,
    JO = jO.useSyncExternalStore,
    KO = ny.useRef,
    qO = ny.useEffect,
    ZO = ny.useMemo,
    QO = ny.useDebugValue;
vI.useSyncExternalStoreWithSelector = function(r, e, t, n, i) {
    var s = KO(null);
    if (s.current === null) {
        var o = {
            hasValue: !1,
            value: null
        };
        s.current = o
    } else o = s.current;
    s = ZO(function() {
        function l(m) {
            if (!c) {
                if (c = !0, u = m, m = n(m), i !== void 0 && o.hasValue) {
                    var g = o.value;
                    if (i(g, m)) return f = g
                }
                return f = m
            }
            if (g = f, YO(u, m)) return g;
            var y = n(m);
            return i !== void 0 && i(g, y) ? g : (u = m, f = y)
        }
        var c = !1,
            u, f, d = t === void 0 ? null : t;
        return [function() {
            return l(e())
        }, d === null ? void 0 : function() {
            return l(d())
        }]
    }, [e, t, n, i]);
    var a = JO(r, s[0], s[1]);
    return qO(function() {
        o.hasValue = !0, o.value = a
    }, [a]), QO(a), a
};
gI.exports = vI;
var $O = gI.exports;
const eN = aS($O),
    xI = {
        BASE_URL: "./",
        DEV: !1,
        MODE: "production",
        PROD: !0,
        SSR: !1,
        VITE_VERCEL_BRANCH_URL: "sage-git-main-gits-projects-10732a9b.vercel.app",
        VITE_VERCEL_DEPLOYMENT_ID: "dpl_8Q1r1zQL9VeUt5Zab5JjtceMVgSa",
        VITE_VERCEL_ENV: "production",
        VITE_VERCEL_GIT_COMMIT_AUTHOR_LOGIN: "admin-fantik",
        VITE_VERCEL_GIT_COMMIT_AUTHOR_NAME: "admin-fantik",
        VITE_VERCEL_GIT_COMMIT_MESSAGE: `Merge pull request #81 from admin-fantik/dev-dmytro

Dev dmytro`,
        VITE_VERCEL_GIT_COMMIT_REF: "main",
        VITE_VERCEL_GIT_COMMIT_SHA: "8e476b1a62d340589157c71fb9d26e5e4752d6a1",
        VITE_VERCEL_GIT_PREVIOUS_SHA: "",
        VITE_VERCEL_GIT_PROVIDER: "github",
        VITE_VERCEL_GIT_PULL_REQUEST_ID: "",
        VITE_VERCEL_GIT_REPO_ID: "855724001",
        VITE_VERCEL_GIT_REPO_OWNER: "admin-fantik",
        VITE_VERCEL_GIT_REPO_SLUG: "sage",
        VITE_VERCEL_PROJECT_ID: "prj_fHiuUvP3DLJx8pOWu5bmkFCqqGS5",
        VITE_VERCEL_PROJECT_PRODUCTION_URL: "sage.fantik.studio",
        VITE_VERCEL_TARGET_ENV: "production",
        VITE_VERCEL_URL: "sage-686ces92e-gits-projects-10732a9b.vercel.app"
    },
    {
        useDebugValue: tN
    } = ga,
    {
        useSyncExternalStoreWithSelector: nN
    } = eN;
let kT = !1;
const iN = r => r;

function rN(r, e = iN, t) {
    (xI ? "production" : void 0) !== "production" && t && !kT && (console.warn("[DEPRECATED] Use `createWithEqualityFn` instead of `create` or use `useStoreWithEqualityFn` instead of `useStore`. They can be imported from 'zustand/traditional'. https://github.com/pmndrs/zustand/discussions/1937"), kT = !0);
    const n = nN(r.subscribe, r.getState, r.getServerState || r.getInitialState, e, t);
    return tN(n), n
}
const zT = r => {
        (xI ? "production" : void 0) !== "production" && typeof r != "function" && console.warn("[DEPRECATED] Passing a vanilla store will be unsupported in a future version. Instead use `import { useStore } from 'zustand'`.");
        const e = typeof r == "function" ? LO(r) : r,
            t = (n, i) => rN(e, n, i);
        return Object.assign(t, e), t
    },
    sN = r => r ? zT(r) : zT;
typeof window < "u" && (window.reactLenisVersion = "0.0.47");
const oN = N.createContext(null),
    aN = sN(() => ({})),
    lN = N.forwardRef((r, e) => {
        var {
            children: t,
            root: n = !1,
            options: i = {},
            autoRaf: s = !0,
            rafPriority: o = 0,
            className: a
        } = r, l = function(A, S) {
            var M = {};
            for (var C in A) Object.prototype.hasOwnProperty.call(A, C) && S.indexOf(C) < 0 && (M[C] = A[C]);
            if (A != null && typeof Object.getOwnPropertySymbols == "function") {
                var E = 0;
                for (C = Object.getOwnPropertySymbols(A); E < C.length; E++) S.indexOf(C[E]) < 0 && Object.prototype.propertyIsEnumerable.call(A, C[E]) && (M[C[E]] = A[C[E]])
            }
            return M
        }(r, ["children", "root", "options", "autoRaf", "rafPriority", "className"]);
        const c = N.useRef(null),
            u = N.useRef(null),
            [f, d] = N.useState(void 0),
            m = N.useRef([]),
            g = N.useCallback((A, S) => {
                m.current.push({
                    callback: A,
                    priority: S
                }), m.current.sort((M, C) => M.priority - C.priority)
            }, []),
            y = N.useCallback(A => {
                m.current = m.current.filter(S => S.callback !== A)
            }, []);
        N.useImperativeHandle(e, () => ({
            wrapper: c.current,
            content: u.current,
            lenis: f
        }), [f]), N.useEffect(() => {
            const A = new pI(Object.assign(Object.assign({}, i), !n && {
                wrapper: c.current,
                content: u.current
            }));
            return d(A), () => {
                A.destroy(), d(void 0)
            }
        }, [n, JSON.stringify(i)]), RO(A => {
            s && (f == null || f.raf(A))
        }, o), N.useEffect(() => {
            n && f && aN.setState({
                lenis: f,
                addCallback: g,
                removeCallback: y
            })
        }, [n, f, g, y]);
        const v = N.useCallback(A => {
            for (let S = 0; S < m.current.length; S++) m.current[S].callback(A)
        }, []);
        N.useEffect(() => (f == null || f.on("scroll", v), () => {
            f == null || f.off("scroll", v)
        }), [f, v]);
        const _ = N.useCallback(() => {
            c.current && (c.current.className = sA(f == null ? void 0 : f.className, a))
        }, [f, a]);
        return N.useEffect(() => (_(), f == null || f.on("className change", _), () => {
            f == null || f.off("className change", _)
        }), [f, _]), ga.createElement(oN.Provider, {
            value: {
                lenis: f,
                addCallback: g,
                removeCallback: y
            }
        }, n ? t : ga.createElement("div", Object.assign({
            ref: c,
            className: sA(f == null ? void 0 : f.className, a)
        }, l), ga.createElement("div", {
            ref: u
        }, t)))
    });
/**
 * @license
 * Copyright 2010-2024 Three.js Authors
 * SPDX-License-Identifier: MIT
 */
const du = "170",
    cN = {
        LEFT: 0,
        MIDDLE: 1,
        RIGHT: 2,
        ROTATE: 0,
        DOLLY: 1,
        PAN: 2
    },
    uN = {
        ROTATE: 0,
        PAN: 1,
        DOLLY_PAN: 2,
        DOLLY_ROTATE: 3
    },
    AI = 0,
    oA = 1,
    SI = 2,
    fN = 3,
    MI = 0,
    iy = 1,
    zd = 2,
    lo = 3,
    Zs = 0,
    di = 1,
    hn = 2,
    pi = 0,
    Xc = 1,
    aA = 2,
    lA = 3,
    cA = 4,
    wI = 5,
    tl = 100,
    bI = 101,
    TI = 102,
    EI = 103,
    CI = 104,
    RI = 200,
    PI = 201,
    II = 202,
    BI = 203,
    q0 = 204,
    Z0 = 205,
    DI = 206,
    LI = 207,
    FI = 208,
    UI = 209,
    OI = 210,
    NI = 211,
    kI = 212,
    zI = 213,
    GI = 214,
    Q0 = 0,
    $0 = 1,
    ev = 2,
    su = 3,
    tv = 4,
    nv = 5,
    iv = 6,
    rv = 7,
    zp = 0,
    HI = 1,
    VI = 2,
    Js = 0,
    WI = 1,
    jI = 2,
    XI = 3,
    ry = 4,
    YI = 5,
    JI = 6,
    KI = 7,
    uA = "attached",
    qI = "detached",
    xl = 300,
    ko = 301,
    Al = 302,
    ou = 303,
    dp = 304,
    ah = 306,
    Sl = 1e3,
    Nn = 1001,
    au = 1002,
    bn = 1003,
    sy = 1004,
    hN = 1004,
    Pc = 1005,
    dN = 1005,
    nn = 1006,
    If = 1007,
    pN = 1007,
    gs = 1008,
    fA = 1008,
    Yi = 1009,
    oy = 1010,
    ay = 1011,
    Kf = 1012,
    Gp = 1013,
    fo = 1014,
    Bn = 1015,
    Ri = 1016,
    ly = 1017,
    cy = 1018,
    Ml = 1020,
    BS = 35902,
    DS = 1021,
    LS = 1022,
    kn = 1023,
    FS = 1024,
    US = 1025,
    Yc = 1026,
    wl = 1027,
    Hp = 1028,
    Vp = 1029,
    OS = 1030,
    uy = 1031,
    mN = 1032,
    fy = 1033,
    Gd = 33776,
    Hd = 33777,
    Vd = 33778,
    Wd = 33779,
    sv = 35840,
    ov = 35841,
    av = 35842,
    lv = 35843,
    cv = 36196,
    uv = 37492,
    fv = 37496,
    hv = 37808,
    dv = 37809,
    pv = 37810,
    mv = 37811,
    gv = 37812,
    vv = 37813,
    yv = 37814,
    _v = 37815,
    xv = 37816,
    Av = 37817,
    Sv = 37818,
    Mv = 37819,
    wv = 37820,
    bv = 37821,
    jd = 36492,
    Tv = 36494,
    Ev = 36495,
    NS = 36283,
    Cv = 36284,
    Rv = 36285,
    Pv = 36286,
    ZI = 2200,
    QI = 2201,
    $I = 2202,
    qf = 2300,
    Zf = 2301,
    P0 = 2302,
    Ic = 2400,
    Bc = 2401,
    pp = 2402,
    hy = 2500,
    kS = 2501,
    eB = 0,
    zS = 1,
    Iv = 2,
    Bl = 3200,
    GS = 3201,
    gN = 3202,
    vN = 3203,
    Dl = 0,
    tB = 1,
    uo = "",
    Jn = "srgb",
    Qs = "srgb-linear",
    Wp = "linear",
    Ln = "srgb",
    yN = 0,
    Mc = 7680,
    _N = 7681,
    xN = 7682,
    AN = 7683,
    SN = 34055,
    MN = 34056,
    wN = 5386,
    bN = 512,
    TN = 513,
    EN = 514,
    CN = 515,
    RN = 516,
    PN = 517,
    IN = 518,
    hA = 519,
    nB = 512,
    iB = 513,
    rB = 514,
    HS = 515,
    sB = 516,
    oB = 517,
    aB = 518,
    lB = 519,
    mp = 35044,
    BN = 35048,
    DN = 35040,
    LN = 35045,
    FN = 35049,
    UN = 35041,
    ON = 35046,
    NN = 35050,
    kN = 35042,
    zN = "100",
    dA = "300 es",
    Io = 2e3,
    gp = 2001;
class ws {
    addEventListener(e, t) {
        this._listeners === void 0 && (this._listeners = {});
        const n = this._listeners;
        n[e] === void 0 && (n[e] = []), n[e].indexOf(t) === -1 && n[e].push(t)
    }
    hasEventListener(e, t) {
        if (this._listeners === void 0) return !1;
        const n = this._listeners;
        return n[e] !== void 0 && n[e].indexOf(t) !== -1
    }
    removeEventListener(e, t) {
        if (this._listeners === void 0) return;
        const i = this._listeners[e];
        if (i !== void 0) {
            const s = i.indexOf(t);
            s !== -1 && i.splice(s, 1)
        }
    }
    dispatchEvent(e) {
        if (this._listeners === void 0) return;
        const n = this._listeners[e.type];
        if (n !== void 0) {
            e.target = this;
            const i = n.slice(0);
            for (let s = 0, o = i.length; s < o; s++) i[s].call(this, e);
            e.target = null
        }
    }
}
const or = ["00", "01", "02", "03", "04", "05", "06", "07", "08", "09", "0a", "0b", "0c", "0d", "0e", "0f", "10", "11", "12", "13", "14", "15", "16", "17", "18", "19", "1a", "1b", "1c", "1d", "1e", "1f", "20", "21", "22", "23", "24", "25", "26", "27", "28", "29", "2a", "2b", "2c", "2d", "2e", "2f", "30", "31", "32", "33", "34", "35", "36", "37", "38", "39", "3a", "3b", "3c", "3d", "3e", "3f", "40", "41", "42", "43", "44", "45", "46", "47", "48", "49", "4a", "4b", "4c", "4d", "4e", "4f", "50", "51", "52", "53", "54", "55", "56", "57", "58", "59", "5a", "5b", "5c", "5d", "5e", "5f", "60", "61", "62", "63", "64", "65", "66", "67", "68", "69", "6a", "6b", "6c", "6d", "6e", "6f", "70", "71", "72", "73", "74", "75", "76", "77", "78", "79", "7a", "7b", "7c", "7d", "7e", "7f", "80", "81", "82", "83", "84", "85", "86", "87", "88", "89", "8a", "8b", "8c", "8d", "8e", "8f", "90", "91", "92", "93", "94", "95", "96", "97", "98", "99", "9a", "9b", "9c", "9d", "9e", "9f", "a0", "a1", "a2", "a3", "a4", "a5", "a6", "a7", "a8", "a9", "aa", "ab", "ac", "ad", "ae", "af", "b0", "b1", "b2", "b3", "b4", "b5", "b6", "b7", "b8", "b9", "ba", "bb", "bc", "bd", "be", "bf", "c0", "c1", "c2", "c3", "c4", "c5", "c6", "c7", "c8", "c9", "ca", "cb", "cc", "cd", "ce", "cf", "d0", "d1", "d2", "d3", "d4", "d5", "d6", "d7", "d8", "d9", "da", "db", "dc", "dd", "de", "df", "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9", "ea", "eb", "ec", "ed", "ee", "ef", "f0", "f1", "f2", "f3", "f4", "f5", "f6", "f7", "f8", "f9", "fa", "fb", "fc", "fd", "fe", "ff"];
let GT = 1234567;
const Jc = Math.PI / 180,
    Qf = 180 / Math.PI;

function ys() {
    const r = Math.random() * 4294967295 | 0,
        e = Math.random() * 4294967295 | 0,
        t = Math.random() * 4294967295 | 0,
        n = Math.random() * 4294967295 | 0;
    return (or[r & 255] + or[r >> 8 & 255] + or[r >> 16 & 255] + or[r >> 24 & 255] + "-" + or[e & 255] + or[e >> 8 & 255] + "-" + or[e >> 16 & 15 | 64] + or[e >> 24 & 255] + "-" + or[t & 63 | 128] + or[t >> 8 & 255] + "-" + or[t >> 16 & 255] + or[t >> 24 & 255] + or[n & 255] + or[n >> 8 & 255] + or[n >> 16 & 255] + or[n >> 24 & 255]).toLowerCase()
}

function fi(r, e, t) {
    return Math.max(e, Math.min(t, r))
}

function VS(r, e) {
    return (r % e + e) % e
}

function GN(r, e, t, n, i) {
    return n + (r - e) * (i - n) / (t - e)
}

function HN(r, e, t) {
    return r !== e ? (t - r) / (e - r) : 0
}

function Xd(r, e, t) {
    return (1 - t) * r + t * e
}

function VN(r, e, t, n) {
    return Xd(r, e, 1 - Math.exp(-t * n))
}

function WN(r, e = 1) {
    return e - Math.abs(VS(r, e * 2) - e)
}

function jN(r, e, t) {
    return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * (3 - 2 * r))
}

function XN(r, e, t) {
    return r <= e ? 0 : r >= t ? 1 : (r = (r - e) / (t - e), r * r * r * (r * (r * 6 - 15) + 10))
}

function YN(r, e) {
    return r + Math.floor(Math.random() * (e - r + 1))
}

function JN(r, e) {
    return r + Math.random() * (e - r)
}

function KN(r) {
    return r * (.5 - Math.random())
}

function qN(r) {
    r !== void 0 && (GT = r);
    let e = GT += 1831565813;
    return e = Math.imul(e ^ e >>> 15, e | 1), e ^= e + Math.imul(e ^ e >>> 7, e | 61), ((e ^ e >>> 14) >>> 0) / 4294967296
}

function ZN(r) {
    return r * Jc
}

function QN(r) {
    return r * Qf
}

function $N(r) {
    return (r & r - 1) === 0 && r !== 0
}

function ek(r) {
    return Math.pow(2, Math.ceil(Math.log(r) / Math.LN2))
}

function tk(r) {
    return Math.pow(2, Math.floor(Math.log(r) / Math.LN2))
}

function nk(r, e, t, n, i) {
    const s = Math.cos,
        o = Math.sin,
        a = s(t / 2),
        l = o(t / 2),
        c = s((e + n) / 2),
        u = o((e + n) / 2),
        f = s((e - n) / 2),
        d = o((e - n) / 2),
        m = s((n - e) / 2),
        g = o((n - e) / 2);
    switch (i) {
        case "XYX":
            r.set(a * u, l * f, l * d, a * c);
            break;
        case "YZY":
            r.set(l * d, a * u, l * f, a * c);
            break;
        case "ZXZ":
            r.set(l * f, l * d, a * u, a * c);
            break;
        case "XZX":
            r.set(a * u, l * g, l * m, a * c);
            break;
        case "YXY":
            r.set(l * m, a * u, l * g, a * c);
            break;
        case "ZYZ":
            r.set(l * g, l * m, a * u, a * c);
            break;
        default:
            console.warn("THREE.MathUtils: .setQuaternionFromProperEuler() encountered an unknown order: " + i)
    }
}

function Ur(r, e) {
    switch (e.constructor) {
        case Float32Array:
            return r;
        case Uint32Array:
            return r / 4294967295;
        case Uint16Array:
            return r / 65535;
        case Uint8Array:
            return r / 255;
        case Int32Array:
            return Math.max(r / 2147483647, -1);
        case Int16Array:
            return Math.max(r / 32767, -1);
        case Int8Array:
            return Math.max(r / 127, -1);
        default:
            throw new Error("Invalid component type.")
    }
}

function Kt(r, e) {
    switch (e.constructor) {
        case Float32Array:
            return r;
        case Uint32Array:
            return Math.round(r * 4294967295);
        case Uint16Array:
            return Math.round(r * 65535);
        case Uint8Array:
            return Math.round(r * 255);
        case Int32Array:
            return Math.round(r * 2147483647);
        case Int16Array:
            return Math.round(r * 32767);
        case Int8Array:
            return Math.round(r * 127);
        default:
            throw new Error("Invalid component type.")
    }
}
const ha = {
    DEG2RAD: Jc,
    RAD2DEG: Qf,
    generateUUID: ys,
    clamp: fi,
    euclideanModulo: VS,
    mapLinear: GN,
    inverseLerp: HN,
    lerp: Xd,
    damp: VN,
    pingpong: WN,
    smoothstep: jN,
    smootherstep: XN,
    randInt: YN,
    randFloat: JN,
    randFloatSpread: KN,
    seededRandom: qN,
    degToRad: ZN,
    radToDeg: QN,
    isPowerOfTwo: $N,
    ceilPowerOfTwo: ek,
    floorPowerOfTwo: tk,
    setQuaternionFromProperEuler: nk,
    normalize: Kt,
    denormalize: Ur
};
class Ue {
    constructor(e = 0, t = 0) {
        Ue.prototype.isVector2 = !0, this.x = e, this.y = t
    }
    get width() {
        return this.x
    }
    set width(e) {
        this.x = e
    }
    get height() {
        return this.y
    }
    set height(e) {
        this.y = e
    }
    set(e, t) {
        return this.x = e, this.y = t, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            default:
                throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    applyMatrix3(e) {
        const t = this.x,
            n = this.y,
            i = e.elements;
        return this.x = i[0] * t + i[3] * n + i[6], this.y = i[1] * t + i[4] * n + i[7], this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y
    }
    cross(e) {
        return this.x * e.y - this.y * e.x
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    angle() {
        return Math.atan2(-this.y, -this.x) + Math.PI
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(fi(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x,
            n = this.y - e.y;
        return t * t + n * n
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this
    }
    rotateAround(e, t) {
        const n = Math.cos(t),
            i = Math.sin(t),
            s = this.x - e.x,
            o = this.y - e.y;
        return this.x = s * n - o * i + e.x, this.y = s * i + o * n + e.y, this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y
    }
}
class jt {
    constructor(e, t, n, i, s, o, a, l, c) {
        jt.prototype.isMatrix3 = !0, this.elements = [1, 0, 0, 0, 1, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, i, s, o, a, l, c)
    }
    set(e, t, n, i, s, o, a, l, c) {
        const u = this.elements;
        return u[0] = e, u[1] = i, u[2] = a, u[3] = t, u[4] = s, u[5] = l, u[6] = n, u[7] = o, u[8] = c, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 1, 0, 0, 0, 1), this
    }
    copy(e) {
        const t = this.elements,
            n = e.elements;
        return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrix3Column(this, 0), t.setFromMatrix3Column(this, 1), n.setFromMatrix3Column(this, 2), this
    }
    setFromMatrix4(e) {
        const t = e.elements;
        return this.set(t[0], t[4], t[8], t[1], t[5], t[9], t[2], t[6], t[10]), this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements,
            i = t.elements,
            s = this.elements,
            o = n[0],
            a = n[3],
            l = n[6],
            c = n[1],
            u = n[4],
            f = n[7],
            d = n[2],
            m = n[5],
            g = n[8],
            y = i[0],
            v = i[3],
            _ = i[6],
            A = i[1],
            S = i[4],
            M = i[7],
            C = i[2],
            E = i[5],
            R = i[8];
        return s[0] = o * y + a * A + l * C, s[3] = o * v + a * S + l * E, s[6] = o * _ + a * M + l * R, s[1] = c * y + u * A + f * C, s[4] = c * v + u * S + f * E, s[7] = c * _ + u * M + f * R, s[2] = d * y + m * A + g * C, s[5] = d * v + m * S + g * E, s[8] = d * _ + m * M + g * R, this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e, t[3] *= e, t[6] *= e, t[1] *= e, t[4] *= e, t[7] *= e, t[2] *= e, t[5] *= e, t[8] *= e, this
    }
    determinant() {
        const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8];
        return t * o * u - t * a * c - n * s * u + n * a * l + i * s * c - i * o * l
    }
    invert() {
        const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            f = u * o - a * c,
            d = a * l - u * s,
            m = c * s - o * l,
            g = t * f + n * d + i * m;
        if (g === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0);
        const y = 1 / g;
        return e[0] = f * y, e[1] = (i * c - u * n) * y, e[2] = (a * n - i * o) * y, e[3] = d * y, e[4] = (u * t - i * l) * y, e[5] = (i * s - a * t) * y, e[6] = m * y, e[7] = (n * l - c * t) * y, e[8] = (o * t - n * s) * y, this
    }
    transpose() {
        let e;
        const t = this.elements;
        return e = t[1], t[1] = t[3], t[3] = e, e = t[2], t[2] = t[6], t[6] = e, e = t[5], t[5] = t[7], t[7] = e, this
    }
    getNormalMatrix(e) {
        return this.setFromMatrix4(e).invert().transpose()
    }
    transposeIntoArray(e) {
        const t = this.elements;
        return e[0] = t[0], e[1] = t[3], e[2] = t[6], e[3] = t[1], e[4] = t[4], e[5] = t[7], e[6] = t[2], e[7] = t[5], e[8] = t[8], this
    }
    setUvTransform(e, t, n, i, s, o, a) {
        const l = Math.cos(s),
            c = Math.sin(s);
        return this.set(n * l, n * c, -n * (l * o + c * a) + o + e, -i * c, i * l, -i * (-c * o + l * a) + a + t, 0, 0, 1), this
    }
    scale(e, t) {
        return this.premultiply(sx.makeScale(e, t)), this
    }
    rotate(e) {
        return this.premultiply(sx.makeRotation(-e)), this
    }
    translate(e, t) {
        return this.premultiply(sx.makeTranslation(e, t)), this
    }
    makeTranslation(e, t) {
        return e.isVector2 ? this.set(1, 0, e.x, 0, 1, e.y, 0, 0, 1) : this.set(1, 0, e, 0, 1, t, 0, 0, 1), this
    }
    makeRotation(e) {
        const t = Math.cos(e),
            n = Math.sin(e);
        return this.set(t, -n, 0, n, t, 0, 0, 0, 1), this
    }
    makeScale(e, t) {
        return this.set(e, 0, 0, 0, t, 0, 0, 0, 1), this
    }
    equals(e) {
        const t = this.elements,
            n = e.elements;
        for (let i = 0; i < 9; i++)
            if (t[i] !== n[i]) return !1;
        return !0
    }
    fromArray(e, t = 0) {
        for (let n = 0; n < 9; n++) this.elements[n] = e[n + t];
        return this
    }
    toArray(e = [], t = 0) {
        const n = this.elements;
        return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e
    }
    clone() {
        return new this.constructor().fromArray(this.elements)
    }
}
const sx = new jt;

function cB(r) {
    for (let e = r.length - 1; e >= 0; --e)
        if (r[e] >= 65535) return !0;
    return !1
}
const ik = {
    Int8Array,
    Uint8Array,
    Uint8ClampedArray,
    Int16Array,
    Uint16Array,
    Int32Array,
    Uint32Array,
    Float32Array,
    Float64Array
};

function mf(r, e) {
    return new ik[r](e)
}

function vp(r) {
    return document.createElementNS("http://www.w3.org/1999/xhtml", r)
}

function uB() {
    const r = vp("canvas");
    return r.style.display = "block", r
}
const HT = {};

function Ad(r) {
    r in HT || (HT[r] = !0, console.warn(r))
}

function rk(r, e, t) {
    return new Promise(function(n, i) {
        function s() {
            switch (r.clientWaitSync(e, r.SYNC_FLUSH_COMMANDS_BIT, 0)) {
                case r.WAIT_FAILED:
                    i();
                    break;
                case r.TIMEOUT_EXPIRED:
                    setTimeout(s, t);
                    break;
                default:
                    n()
            }
        }
        setTimeout(s, t)
    })
}

function sk(r) {
    const e = r.elements;
    e[2] = .5 * e[2] + .5 * e[3], e[6] = .5 * e[6] + .5 * e[7], e[10] = .5 * e[10] + .5 * e[11], e[14] = .5 * e[14] + .5 * e[15]
}

function ok(r) {
    const e = r.elements;
    e[11] === -1 ? (e[10] = -e[10] - 1, e[14] = -e[14]) : (e[10] = -e[10], e[14] = -e[14] + 1)
}
const xn = {
    enabled: !0,
    workingColorSpace: Qs,
    spaces: {},
    convert: function(r, e, t) {
        return this.enabled === !1 || e === t || !e || !t || (this.spaces[e].transfer === Ln && (r.r = ya(r.r), r.g = ya(r.g), r.b = ya(r.b)), this.spaces[e].primaries !== this.spaces[t].primaries && (r.applyMatrix3(this.spaces[e].toXYZ), r.applyMatrix3(this.spaces[t].fromXYZ)), this.spaces[t].transfer === Ln && (r.r = Bf(r.r), r.g = Bf(r.g), r.b = Bf(r.b))), r
    },
    fromWorkingColorSpace: function(r, e) {
        return this.convert(r, this.workingColorSpace, e)
    },
    toWorkingColorSpace: function(r, e) {
        return this.convert(r, e, this.workingColorSpace)
    },
    getPrimaries: function(r) {
        return this.spaces[r].primaries
    },
    getTransfer: function(r) {
        return r === uo ? Wp : this.spaces[r].transfer
    },
    getLuminanceCoefficients: function(r, e = this.workingColorSpace) {
        return r.fromArray(this.spaces[e].luminanceCoefficients)
    },
    define: function(r) {
        Object.assign(this.spaces, r)
    },
    _getMatrix: function(r, e, t) {
        return r.copy(this.spaces[e].toXYZ).multiply(this.spaces[t].fromXYZ)
    },
    _getDrawingBufferColorSpace: function(r) {
        return this.spaces[r].outputColorSpaceConfig.drawingBufferColorSpace
    },
    _getUnpackColorSpace: function(r = this.workingColorSpace) {
        return this.spaces[r].workingColorSpaceConfig.unpackColorSpace
    }
};

function ya(r) {
    return r < .04045 ? r * .0773993808 : Math.pow(r * .9478672986 + .0521327014, 2.4)
}

function Bf(r) {
    return r < .0031308 ? r * 12.92 : 1.055 * Math.pow(r, .41666) - .055
}
const VT = [.64, .33, .3, .6, .15, .06],
    WT = [.2126, .7152, .0722],
    jT = [.3127, .329],
    XT = new jt().set(.4123908, .3575843, .1804808, .212639, .7151687, .0721923, .0193308, .1191948, .9505322),
    YT = new jt().set(3.2409699, -1.5373832, -.4986108, -.9692436, 1.8759675, .0415551, .0556301, -.203977, 1.0569715);
xn.define({
    [Qs]: {
        primaries: VT,
        whitePoint: jT,
        transfer: Wp,
        toXYZ: XT,
        fromXYZ: YT,
        luminanceCoefficients: WT,
        workingColorSpaceConfig: {
            unpackColorSpace: Jn
        },
        outputColorSpaceConfig: {
            drawingBufferColorSpace: Jn
        }
    },
    [Jn]: {
        primaries: VT,
        whitePoint: jT,
        transfer: Ln,
        toXYZ: XT,
        fromXYZ: YT,
        luminanceCoefficients: WT,
        outputColorSpaceConfig: {
            drawingBufferColorSpace: Jn
        }
    }
});
let Nu;
class fB {
    static getDataURL(e) {
        if (/^data:/i.test(e.src) || typeof HTMLCanvasElement > "u") return e.src;
        let t;
        if (e instanceof HTMLCanvasElement) t = e;
        else {
            Nu === void 0 && (Nu = vp("canvas")), Nu.width = e.width, Nu.height = e.height;
            const n = Nu.getContext("2d");
            e instanceof ImageData ? n.putImageData(e, 0, 0) : n.drawImage(e, 0, 0, e.width, e.height), t = Nu
        }
        return t.width > 2048 || t.height > 2048 ? (console.warn("THREE.ImageUtils.getDataURL: Image converted to jpg for performance reasons", e), t.toDataURL("image/jpeg", .6)) : t.toDataURL("image/png")
    }
    static sRGBToLinear(e) {
        if (typeof HTMLImageElement < "u" && e instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && e instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && e instanceof ImageBitmap) {
            const t = vp("canvas");
            t.width = e.width, t.height = e.height;
            const n = t.getContext("2d");
            n.drawImage(e, 0, 0, e.width, e.height);
            const i = n.getImageData(0, 0, e.width, e.height),
                s = i.data;
            for (let o = 0; o < s.length; o++) s[o] = ya(s[o] / 255) * 255;
            return n.putImageData(i, 0, 0), t
        } else if (e.data) {
            const t = e.data.slice(0);
            for (let n = 0; n < t.length; n++) t instanceof Uint8Array || t instanceof Uint8ClampedArray ? t[n] = Math.floor(ya(t[n] / 255) * 255) : t[n] = ya(t[n]);
            return {
                data: t,
                width: e.width,
                height: e.height
            }
        } else return console.warn("THREE.ImageUtils.sRGBToLinear(): Unsupported image type. No color space conversion applied."), e
    }
}
let ak = 0;
class Dc {
    constructor(e = null) {
        this.isSource = !0, Object.defineProperty(this, "id", {
            value: ak++
        }), this.uuid = ys(), this.data = e, this.dataReady = !0, this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.images[this.uuid] !== void 0) return e.images[this.uuid];
        const n = {
                uuid: this.uuid,
                url: ""
            },
            i = this.data;
        if (i !== null) {
            let s;
            if (Array.isArray(i)) {
                s = [];
                for (let o = 0, a = i.length; o < a; o++) i[o].isDataTexture ? s.push(ox(i[o].image)) : s.push(ox(i[o]))
            } else s = ox(i);
            n.url = s
        }
        return t || (e.images[this.uuid] = n), n
    }
}

function ox(r) {
    return typeof HTMLImageElement < "u" && r instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && r instanceof ImageBitmap ? fB.getDataURL(r) : r.data ? {
        data: Array.from(r.data),
        width: r.width,
        height: r.height,
        type: r.data.constructor.name
    } : (console.warn("THREE.Texture: Unable to serialize Texture."), {})
}
let lk = 0;
class gn extends ws {
    constructor(e = gn.DEFAULT_IMAGE, t = gn.DEFAULT_MAPPING, n = Nn, i = Nn, s = nn, o = gs, a = kn, l = Yi, c = gn.DEFAULT_ANISOTROPY, u = uo) {
        super(), this.isTexture = !0, Object.defineProperty(this, "id", {
            value: lk++
        }), this.uuid = ys(), this.name = "", this.source = new Dc(e), this.mipmaps = [], this.mapping = t, this.channel = 0, this.wrapS = n, this.wrapT = i, this.magFilter = s, this.minFilter = o, this.anisotropy = c, this.format = a, this.internalFormat = null, this.type = l, this.offset = new Ue(0, 0), this.repeat = new Ue(1, 1), this.center = new Ue(0, 0), this.rotation = 0, this.matrixAutoUpdate = !0, this.matrix = new jt, this.generateMipmaps = !0, this.premultiplyAlpha = !1, this.flipY = !0, this.unpackAlignment = 4, this.colorSpace = u, this.userData = {}, this.version = 0, this.onUpdate = null, this.isRenderTargetTexture = !1, this.pmremVersion = 0
    }
    get image() {
        return this.source.data
    }
    set image(e = null) {
        this.source.data = e
    }
    updateMatrix() {
        this.matrix.setUvTransform(this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.name = e.name, this.source = e.source, this.mipmaps = e.mipmaps.slice(0), this.mapping = e.mapping, this.channel = e.channel, this.wrapS = e.wrapS, this.wrapT = e.wrapT, this.magFilter = e.magFilter, this.minFilter = e.minFilter, this.anisotropy = e.anisotropy, this.format = e.format, this.internalFormat = e.internalFormat, this.type = e.type, this.offset.copy(e.offset), this.repeat.copy(e.repeat), this.center.copy(e.center), this.rotation = e.rotation, this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrix.copy(e.matrix), this.generateMipmaps = e.generateMipmaps, this.premultiplyAlpha = e.premultiplyAlpha, this.flipY = e.flipY, this.unpackAlignment = e.unpackAlignment, this.colorSpace = e.colorSpace, this.userData = JSON.parse(JSON.stringify(e.userData)), this.needsUpdate = !0, this
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        if (!t && e.textures[this.uuid] !== void 0) return e.textures[this.uuid];
        const n = {
            metadata: {
                version: 4.6,
                type: "Texture",
                generator: "Texture.toJSON"
            },
            uuid: this.uuid,
            name: this.name,
            image: this.source.toJSON(e).uuid,
            mapping: this.mapping,
            channel: this.channel,
            repeat: [this.repeat.x, this.repeat.y],
            offset: [this.offset.x, this.offset.y],
            center: [this.center.x, this.center.y],
            rotation: this.rotation,
            wrap: [this.wrapS, this.wrapT],
            format: this.format,
            internalFormat: this.internalFormat,
            type: this.type,
            colorSpace: this.colorSpace,
            minFilter: this.minFilter,
            magFilter: this.magFilter,
            anisotropy: this.anisotropy,
            flipY: this.flipY,
            generateMipmaps: this.generateMipmaps,
            premultiplyAlpha: this.premultiplyAlpha,
            unpackAlignment: this.unpackAlignment
        };
        return Object.keys(this.userData).length > 0 && (n.userData = this.userData), t || (e.textures[this.uuid] = n), n
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    transformUv(e) {
        if (this.mapping !== xl) return e;
        if (e.applyMatrix3(this.matrix), e.x < 0 || e.x > 1) switch (this.wrapS) {
            case Sl:
                e.x = e.x - Math.floor(e.x);
                break;
            case Nn:
                e.x = e.x < 0 ? 0 : 1;
                break;
            case au:
                Math.abs(Math.floor(e.x) % 2) === 1 ? e.x = Math.ceil(e.x) - e.x : e.x = e.x - Math.floor(e.x);
                break
        }
        if (e.y < 0 || e.y > 1) switch (this.wrapT) {
            case Sl:
                e.y = e.y - Math.floor(e.y);
                break;
            case Nn:
                e.y = e.y < 0 ? 0 : 1;
                break;
            case au:
                Math.abs(Math.floor(e.y) % 2) === 1 ? e.y = Math.ceil(e.y) - e.y : e.y = e.y - Math.floor(e.y);
                break
        }
        return this.flipY && (e.y = 1 - e.y), e
    }
    set needsUpdate(e) {
        e === !0 && (this.version++, this.source.needsUpdate = !0)
    }
    set needsPMREMUpdate(e) {
        e === !0 && this.pmremVersion++
    }
}
gn.DEFAULT_IMAGE = null;
gn.DEFAULT_MAPPING = xl;
gn.DEFAULT_ANISOTROPY = 1;
class An {
    constructor(e = 0, t = 0, n = 0, i = 1) {
        An.prototype.isVector4 = !0, this.x = e, this.y = t, this.z = n, this.w = i
    }
    get width() {
        return this.z
    }
    set width(e) {
        this.z = e
    }
    get height() {
        return this.w
    }
    set height(e) {
        this.w = e
    }
    set(e, t, n, i) {
        return this.x = e, this.y = t, this.z = n, this.w = i, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this.w = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setZ(e) {
        return this.z = e, this
    }
    setW(e) {
        return this.w = e, this
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            case 3:
                this.w = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            case 3:
                return this.w;
            default:
                throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z, this.w)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this.w = e.w !== void 0 ? e.w : 1, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this.w += e.w, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this.w += e, this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this.w = e.w + t.w, this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this.w += e.w * t, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this.w -= e.w, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this.w -= e, this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this.w = e.w - t.w, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this.w *= e.w, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this.w *= e, this
    }
    applyMatrix4(e) {
        const t = this.x,
            n = this.y,
            i = this.z,
            s = this.w,
            o = e.elements;
        return this.x = o[0] * t + o[4] * n + o[8] * i + o[12] * s, this.y = o[1] * t + o[5] * n + o[9] * i + o[13] * s, this.z = o[2] * t + o[6] * n + o[10] * i + o[14] * s, this.w = o[3] * t + o[7] * n + o[11] * i + o[15] * s, this
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this.w /= e.w, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    setAxisAngleFromQuaternion(e) {
        this.w = 2 * Math.acos(e.w);
        const t = Math.sqrt(1 - e.w * e.w);
        return t < 1e-4 ? (this.x = 1, this.y = 0, this.z = 0) : (this.x = e.x / t, this.y = e.y / t, this.z = e.z / t), this
    }
    setAxisAngleFromRotationMatrix(e) {
        let t, n, i, s;
        const l = e.elements,
            c = l[0],
            u = l[4],
            f = l[8],
            d = l[1],
            m = l[5],
            g = l[9],
            y = l[2],
            v = l[6],
            _ = l[10];
        if (Math.abs(u - d) < .01 && Math.abs(f - y) < .01 && Math.abs(g - v) < .01) {
            if (Math.abs(u + d) < .1 && Math.abs(f + y) < .1 && Math.abs(g + v) < .1 && Math.abs(c + m + _ - 3) < .1) return this.set(1, 0, 0, 0), this;
            t = Math.PI;
            const S = (c + 1) / 2,
                M = (m + 1) / 2,
                C = (_ + 1) / 2,
                E = (u + d) / 4,
                R = (f + y) / 4,
                P = (g + v) / 4;
            return S > M && S > C ? S < .01 ? (n = 0, i = .707106781, s = .707106781) : (n = Math.sqrt(S), i = E / n, s = R / n) : M > C ? M < .01 ? (n = .707106781, i = 0, s = .707106781) : (i = Math.sqrt(M), n = E / i, s = P / i) : C < .01 ? (n = .707106781, i = .707106781, s = 0) : (s = Math.sqrt(C), n = R / s, i = P / s), this.set(n, i, s, t), this
        }
        let A = Math.sqrt((v - g) * (v - g) + (f - y) * (f - y) + (d - u) * (d - u));
        return Math.abs(A) < .001 && (A = 1), this.x = (v - g) / A, this.y = (f - y) / A, this.z = (d - u) / A, this.w = Math.acos((c + m + _ - 1) / 2), this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12], this.y = t[13], this.z = t[14], this.w = t[15], this
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this.w = Math.min(this.w, e.w), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this.w = Math.max(this.w, e.w), this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this.w = Math.max(e.w, Math.min(t.w, this.w)), this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this.w = Math.max(e, Math.min(t, this.w)), this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this.w = Math.floor(this.w), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this.w = Math.ceil(this.w), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this.w = Math.round(this.w), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this.w = Math.trunc(this.w), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this.w = -this.w, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z + this.w * e.w
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z) + Math.abs(this.w)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this.w += (e.w - this.w) * t, this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this.w = e.w + (t.w - e.w) * n, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z && e.w === this.w
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this.w = e[t + 3], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e[t + 3] = this.w, e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this.w = e.getW(t), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this.w = Math.random(), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z, yield this.w
    }
}
class hB extends ws {
    constructor(e = 1, t = 1, n = {}) {
        super(), this.isRenderTarget = !0, this.width = e, this.height = t, this.depth = 1, this.scissor = new An(0, 0, e, t), this.scissorTest = !1, this.viewport = new An(0, 0, e, t);
        const i = {
            width: e,
            height: t,
            depth: 1
        };
        n = Object.assign({
            generateMipmaps: !1,
            internalFormat: null,
            minFilter: nn,
            depthBuffer: !0,
            stencilBuffer: !1,
            resolveDepthBuffer: !0,
            resolveStencilBuffer: !0,
            depthTexture: null,
            samples: 0,
            count: 1
        }, n);
        const s = new gn(i, n.mapping, n.wrapS, n.wrapT, n.magFilter, n.minFilter, n.format, n.type, n.anisotropy, n.colorSpace);
        s.flipY = !1, s.generateMipmaps = n.generateMipmaps, s.internalFormat = n.internalFormat, this.textures = [];
        const o = n.count;
        for (let a = 0; a < o; a++) this.textures[a] = s.clone(), this.textures[a].isRenderTargetTexture = !0;
        this.depthBuffer = n.depthBuffer, this.stencilBuffer = n.stencilBuffer, this.resolveDepthBuffer = n.resolveDepthBuffer, this.resolveStencilBuffer = n.resolveStencilBuffer, this.depthTexture = n.depthTexture, this.samples = n.samples
    }
    get texture() {
        return this.textures[0]
    }
    set texture(e) {
        this.textures[0] = e
    }
    setSize(e, t, n = 1) {
        if (this.width !== e || this.height !== t || this.depth !== n) {
            this.width = e, this.height = t, this.depth = n;
            for (let i = 0, s = this.textures.length; i < s; i++) this.textures[i].image.width = e, this.textures[i].image.height = t, this.textures[i].image.depth = n;
            this.dispose()
        }
        this.viewport.set(0, 0, e, t), this.scissor.set(0, 0, e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.width = e.width, this.height = e.height, this.depth = e.depth, this.scissor.copy(e.scissor), this.scissorTest = e.scissorTest, this.viewport.copy(e.viewport), this.textures.length = 0;
        for (let n = 0, i = e.textures.length; n < i; n++) this.textures[n] = e.textures[n].clone(), this.textures[n].isRenderTargetTexture = !0;
        const t = Object.assign({}, e.texture.image);
        return this.texture.source = new Dc(t), this.depthBuffer = e.depthBuffer, this.stencilBuffer = e.stencilBuffer, this.resolveDepthBuffer = e.resolveDepthBuffer, this.resolveStencilBuffer = e.resolveStencilBuffer, e.depthTexture !== null && (this.depthTexture = e.depthTexture.clone()), this.samples = e.samples, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
class Zn extends hB {
    constructor(e = 1, t = 1, n = {}) {
        super(e, t, n), this.isWebGLRenderTarget = !0
    }
}
class dy extends gn {
    constructor(e = null, t = 1, n = 1, i = 1) {
        super(null), this.isDataArrayTexture = !0, this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        }, this.magFilter = bn, this.minFilter = bn, this.wrapR = Nn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1, this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class ck extends Zn {
    constructor(e = 1, t = 1, n = 1, i = {}) {
        super(e, t, i), this.isWebGLArrayRenderTarget = !0, this.depth = n, this.texture = new dy(null, e, t, n), this.texture.isRenderTargetTexture = !0
    }
}
class WS extends gn {
    constructor(e = null, t = 1, n = 1, i = 1) {
        super(null), this.isData3DTexture = !0, this.image = {
            data: e,
            width: t,
            height: n,
            depth: i
        }, this.magFilter = bn, this.minFilter = bn, this.wrapR = Nn, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
class uk extends Zn {
    constructor(e = 1, t = 1, n = 1, i = {}) {
        super(e, t, i), this.isWebGL3DRenderTarget = !0, this.depth = n, this.texture = new WS(null, e, t, n), this.texture.isRenderTargetTexture = !0
    }
}
class gr {
    constructor(e = 0, t = 0, n = 0, i = 1) {
        this.isQuaternion = !0, this._x = e, this._y = t, this._z = n, this._w = i
    }
    static slerpFlat(e, t, n, i, s, o, a) {
        let l = n[i + 0],
            c = n[i + 1],
            u = n[i + 2],
            f = n[i + 3];
        const d = s[o + 0],
            m = s[o + 1],
            g = s[o + 2],
            y = s[o + 3];
        if (a === 0) {
            e[t + 0] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = f;
            return
        }
        if (a === 1) {
            e[t + 0] = d, e[t + 1] = m, e[t + 2] = g, e[t + 3] = y;
            return
        }
        if (f !== y || l !== d || c !== m || u !== g) {
            let v = 1 - a;
            const _ = l * d + c * m + u * g + f * y,
                A = _ >= 0 ? 1 : -1,
                S = 1 - _ * _;
            if (S > Number.EPSILON) {
                const C = Math.sqrt(S),
                    E = Math.atan2(C, _ * A);
                v = Math.sin(v * E) / C, a = Math.sin(a * E) / C
            }
            const M = a * A;
            if (l = l * v + d * M, c = c * v + m * M, u = u * v + g * M, f = f * v + y * M, v === 1 - a) {
                const C = 1 / Math.sqrt(l * l + c * c + u * u + f * f);
                l *= C, c *= C, u *= C, f *= C
            }
        }
        e[t] = l, e[t + 1] = c, e[t + 2] = u, e[t + 3] = f
    }
    static multiplyQuaternionsFlat(e, t, n, i, s, o) {
        const a = n[i],
            l = n[i + 1],
            c = n[i + 2],
            u = n[i + 3],
            f = s[o],
            d = s[o + 1],
            m = s[o + 2],
            g = s[o + 3];
        return e[t] = a * g + u * f + l * m - c * d, e[t + 1] = l * g + u * d + c * f - a * m, e[t + 2] = c * g + u * m + a * d - l * f, e[t + 3] = u * g - a * f - l * d - c * m, e
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e, this._onChangeCallback()
    }
    get w() {
        return this._w
    }
    set w(e) {
        this._w = e, this._onChangeCallback()
    }
    set(e, t, n, i) {
        return this._x = e, this._y = t, this._z = n, this._w = i, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._w)
    }
    copy(e) {
        return this._x = e.x, this._y = e.y, this._z = e.z, this._w = e.w, this._onChangeCallback(), this
    }
    setFromEuler(e, t = !0) {
        const n = e._x,
            i = e._y,
            s = e._z,
            o = e._order,
            a = Math.cos,
            l = Math.sin,
            c = a(n / 2),
            u = a(i / 2),
            f = a(s / 2),
            d = l(n / 2),
            m = l(i / 2),
            g = l(s / 2);
        switch (o) {
            case "XYZ":
                this._x = d * u * f + c * m * g, this._y = c * m * f - d * u * g, this._z = c * u * g + d * m * f, this._w = c * u * f - d * m * g;
                break;
            case "YXZ":
                this._x = d * u * f + c * m * g, this._y = c * m * f - d * u * g, this._z = c * u * g - d * m * f, this._w = c * u * f + d * m * g;
                break;
            case "ZXY":
                this._x = d * u * f - c * m * g, this._y = c * m * f + d * u * g, this._z = c * u * g + d * m * f, this._w = c * u * f - d * m * g;
                break;
            case "ZYX":
                this._x = d * u * f - c * m * g, this._y = c * m * f + d * u * g, this._z = c * u * g - d * m * f, this._w = c * u * f + d * m * g;
                break;
            case "YZX":
                this._x = d * u * f + c * m * g, this._y = c * m * f + d * u * g, this._z = c * u * g - d * m * f, this._w = c * u * f - d * m * g;
                break;
            case "XZY":
                this._x = d * u * f - c * m * g, this._y = c * m * f - d * u * g, this._z = c * u * g + d * m * f, this._w = c * u * f + d * m * g;
                break;
            default:
                console.warn("THREE.Quaternion: .setFromEuler() encountered an unknown order: " + o)
        }
        return t === !0 && this._onChangeCallback(), this
    }
    setFromAxisAngle(e, t) {
        const n = t / 2,
            i = Math.sin(n);
        return this._x = e.x * i, this._y = e.y * i, this._z = e.z * i, this._w = Math.cos(n), this._onChangeCallback(), this
    }
    setFromRotationMatrix(e) {
        const t = e.elements,
            n = t[0],
            i = t[4],
            s = t[8],
            o = t[1],
            a = t[5],
            l = t[9],
            c = t[2],
            u = t[6],
            f = t[10],
            d = n + a + f;
        if (d > 0) {
            const m = .5 / Math.sqrt(d + 1);
            this._w = .25 / m, this._x = (u - l) * m, this._y = (s - c) * m, this._z = (o - i) * m
        } else if (n > a && n > f) {
            const m = 2 * Math.sqrt(1 + n - a - f);
            this._w = (u - l) / m, this._x = .25 * m, this._y = (i + o) / m, this._z = (s + c) / m
        } else if (a > f) {
            const m = 2 * Math.sqrt(1 + a - n - f);
            this._w = (s - c) / m, this._x = (i + o) / m, this._y = .25 * m, this._z = (l + u) / m
        } else {
            const m = 2 * Math.sqrt(1 + f - n - a);
            this._w = (o - i) / m, this._x = (s + c) / m, this._y = (l + u) / m, this._z = .25 * m
        }
        return this._onChangeCallback(), this
    }
    setFromUnitVectors(e, t) {
        let n = e.dot(t) + 1;
        return n < Number.EPSILON ? (n = 0, Math.abs(e.x) > Math.abs(e.z) ? (this._x = -e.y, this._y = e.x, this._z = 0, this._w = n) : (this._x = 0, this._y = -e.z, this._z = e.y, this._w = n)) : (this._x = e.y * t.z - e.z * t.y, this._y = e.z * t.x - e.x * t.z, this._z = e.x * t.y - e.y * t.x, this._w = n), this.normalize()
    }
    angleTo(e) {
        return 2 * Math.acos(Math.abs(fi(this.dot(e), -1, 1)))
    }
    rotateTowards(e, t) {
        const n = this.angleTo(e);
        if (n === 0) return this;
        const i = Math.min(1, t / n);
        return this.slerp(e, i), this
    }
    identity() {
        return this.set(0, 0, 0, 1)
    }
    invert() {
        return this.conjugate()
    }
    conjugate() {
        return this._x *= -1, this._y *= -1, this._z *= -1, this._onChangeCallback(), this
    }
    dot(e) {
        return this._x * e._x + this._y * e._y + this._z * e._z + this._w * e._w
    }
    lengthSq() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w
    }
    length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w)
    }
    normalize() {
        let e = this.length();
        return e === 0 ? (this._x = 0, this._y = 0, this._z = 0, this._w = 1) : (e = 1 / e, this._x = this._x * e, this._y = this._y * e, this._z = this._z * e, this._w = this._w * e), this._onChangeCallback(), this
    }
    multiply(e) {
        return this.multiplyQuaternions(this, e)
    }
    premultiply(e) {
        return this.multiplyQuaternions(e, this)
    }
    multiplyQuaternions(e, t) {
        const n = e._x,
            i = e._y,
            s = e._z,
            o = e._w,
            a = t._x,
            l = t._y,
            c = t._z,
            u = t._w;
        return this._x = n * u + o * a + i * c - s * l, this._y = i * u + o * l + s * a - n * c, this._z = s * u + o * c + n * l - i * a, this._w = o * u - n * a - i * l - s * c, this._onChangeCallback(), this
    }
    slerp(e, t) {
        if (t === 0) return this;
        if (t === 1) return this.copy(e);
        const n = this._x,
            i = this._y,
            s = this._z,
            o = this._w;
        let a = o * e._w + n * e._x + i * e._y + s * e._z;
        if (a < 0 ? (this._w = -e._w, this._x = -e._x, this._y = -e._y, this._z = -e._z, a = -a) : this.copy(e), a >= 1) return this._w = o, this._x = n, this._y = i, this._z = s, this;
        const l = 1 - a * a;
        if (l <= Number.EPSILON) {
            const m = 1 - t;
            return this._w = m * o + t * this._w, this._x = m * n + t * this._x, this._y = m * i + t * this._y, this._z = m * s + t * this._z, this.normalize(), this
        }
        const c = Math.sqrt(l),
            u = Math.atan2(c, a),
            f = Math.sin((1 - t) * u) / c,
            d = Math.sin(t * u) / c;
        return this._w = o * f + this._w * d, this._x = n * f + this._x * d, this._y = i * f + this._y * d, this._z = s * f + this._z * d, this._onChangeCallback(), this
    }
    slerpQuaternions(e, t, n) {
        return this.copy(e).slerp(t, n)
    }
    random() {
        const e = 2 * Math.PI * Math.random(),
            t = 2 * Math.PI * Math.random(),
            n = Math.random(),
            i = Math.sqrt(1 - n),
            s = Math.sqrt(n);
        return this.set(i * Math.sin(e), i * Math.cos(e), s * Math.sin(t), s * Math.cos(t))
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._w === this._w
    }
    fromArray(e, t = 0) {
        return this._x = e[t], this._y = e[t + 1], this._z = e[t + 2], this._w = e[t + 3], this._onChangeCallback(), this
    }
    toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._w, e
    }
    fromBufferAttribute(e, t) {
        return this._x = e.getX(t), this._y = e.getY(t), this._z = e.getZ(t), this._w = e.getW(t), this._onChangeCallback(), this
    }
    toJSON() {
        return this.toArray()
    }
    _onChange(e) {
        return this._onChangeCallback = e, this
    }
    _onChangeCallback() {}*[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._w
    }
}
class K {
    constructor(e = 0, t = 0, n = 0) {
        K.prototype.isVector3 = !0, this.x = e, this.y = t, this.z = n
    }
    set(e, t, n) {
        return n === void 0 && (n = this.z), this.x = e, this.y = t, this.z = n, this
    }
    setScalar(e) {
        return this.x = e, this.y = e, this.z = e, this
    }
    setX(e) {
        return this.x = e, this
    }
    setY(e) {
        return this.y = e, this
    }
    setZ(e) {
        return this.z = e, this
    }
    setComponent(e, t) {
        switch (e) {
            case 0:
                this.x = t;
                break;
            case 1:
                this.y = t;
                break;
            case 2:
                this.z = t;
                break;
            default:
                throw new Error("index is out of range: " + e)
        }
        return this
    }
    getComponent(e) {
        switch (e) {
            case 0:
                return this.x;
            case 1:
                return this.y;
            case 2:
                return this.z;
            default:
                throw new Error("index is out of range: " + e)
        }
    }
    clone() {
        return new this.constructor(this.x, this.y, this.z)
    }
    copy(e) {
        return this.x = e.x, this.y = e.y, this.z = e.z, this
    }
    add(e) {
        return this.x += e.x, this.y += e.y, this.z += e.z, this
    }
    addScalar(e) {
        return this.x += e, this.y += e, this.z += e, this
    }
    addVectors(e, t) {
        return this.x = e.x + t.x, this.y = e.y + t.y, this.z = e.z + t.z, this
    }
    addScaledVector(e, t) {
        return this.x += e.x * t, this.y += e.y * t, this.z += e.z * t, this
    }
    sub(e) {
        return this.x -= e.x, this.y -= e.y, this.z -= e.z, this
    }
    subScalar(e) {
        return this.x -= e, this.y -= e, this.z -= e, this
    }
    subVectors(e, t) {
        return this.x = e.x - t.x, this.y = e.y - t.y, this.z = e.z - t.z, this
    }
    multiply(e) {
        return this.x *= e.x, this.y *= e.y, this.z *= e.z, this
    }
    multiplyScalar(e) {
        return this.x *= e, this.y *= e, this.z *= e, this
    }
    multiplyVectors(e, t) {
        return this.x = e.x * t.x, this.y = e.y * t.y, this.z = e.z * t.z, this
    }
    applyEuler(e) {
        return this.applyQuaternion(JT.setFromEuler(e))
    }
    applyAxisAngle(e, t) {
        return this.applyQuaternion(JT.setFromAxisAngle(e, t))
    }
    applyMatrix3(e) {
        const t = this.x,
            n = this.y,
            i = this.z,
            s = e.elements;
        return this.x = s[0] * t + s[3] * n + s[6] * i, this.y = s[1] * t + s[4] * n + s[7] * i, this.z = s[2] * t + s[5] * n + s[8] * i, this
    }
    applyNormalMatrix(e) {
        return this.applyMatrix3(e).normalize()
    }
    applyMatrix4(e) {
        const t = this.x,
            n = this.y,
            i = this.z,
            s = e.elements,
            o = 1 / (s[3] * t + s[7] * n + s[11] * i + s[15]);
        return this.x = (s[0] * t + s[4] * n + s[8] * i + s[12]) * o, this.y = (s[1] * t + s[5] * n + s[9] * i + s[13]) * o, this.z = (s[2] * t + s[6] * n + s[10] * i + s[14]) * o, this
    }
    applyQuaternion(e) {
        const t = this.x,
            n = this.y,
            i = this.z,
            s = e.x,
            o = e.y,
            a = e.z,
            l = e.w,
            c = 2 * (o * i - a * n),
            u = 2 * (a * t - s * i),
            f = 2 * (s * n - o * t);
        return this.x = t + l * c + o * f - a * u, this.y = n + l * u + a * c - s * f, this.z = i + l * f + s * u - o * c, this
    }
    project(e) {
        return this.applyMatrix4(e.matrixWorldInverse).applyMatrix4(e.projectionMatrix)
    }
    unproject(e) {
        return this.applyMatrix4(e.projectionMatrixInverse).applyMatrix4(e.matrixWorld)
    }
    transformDirection(e) {
        const t = this.x,
            n = this.y,
            i = this.z,
            s = e.elements;
        return this.x = s[0] * t + s[4] * n + s[8] * i, this.y = s[1] * t + s[5] * n + s[9] * i, this.z = s[2] * t + s[6] * n + s[10] * i, this.normalize()
    }
    divide(e) {
        return this.x /= e.x, this.y /= e.y, this.z /= e.z, this
    }
    divideScalar(e) {
        return this.multiplyScalar(1 / e)
    }
    min(e) {
        return this.x = Math.min(this.x, e.x), this.y = Math.min(this.y, e.y), this.z = Math.min(this.z, e.z), this
    }
    max(e) {
        return this.x = Math.max(this.x, e.x), this.y = Math.max(this.y, e.y), this.z = Math.max(this.z, e.z), this
    }
    clamp(e, t) {
        return this.x = Math.max(e.x, Math.min(t.x, this.x)), this.y = Math.max(e.y, Math.min(t.y, this.y)), this.z = Math.max(e.z, Math.min(t.z, this.z)), this
    }
    clampScalar(e, t) {
        return this.x = Math.max(e, Math.min(t, this.x)), this.y = Math.max(e, Math.min(t, this.y)), this.z = Math.max(e, Math.min(t, this.z)), this
    }
    clampLength(e, t) {
        const n = this.length();
        return this.divideScalar(n || 1).multiplyScalar(Math.max(e, Math.min(t, n)))
    }
    floor() {
        return this.x = Math.floor(this.x), this.y = Math.floor(this.y), this.z = Math.floor(this.z), this
    }
    ceil() {
        return this.x = Math.ceil(this.x), this.y = Math.ceil(this.y), this.z = Math.ceil(this.z), this
    }
    round() {
        return this.x = Math.round(this.x), this.y = Math.round(this.y), this.z = Math.round(this.z), this
    }
    roundToZero() {
        return this.x = Math.trunc(this.x), this.y = Math.trunc(this.y), this.z = Math.trunc(this.z), this
    }
    negate() {
        return this.x = -this.x, this.y = -this.y, this.z = -this.z, this
    }
    dot(e) {
        return this.x * e.x + this.y * e.y + this.z * e.z
    }
    lengthSq() {
        return this.x * this.x + this.y * this.y + this.z * this.z
    }
    length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z)
    }
    manhattanLength() {
        return Math.abs(this.x) + Math.abs(this.y) + Math.abs(this.z)
    }
    normalize() {
        return this.divideScalar(this.length() || 1)
    }
    setLength(e) {
        return this.normalize().multiplyScalar(e)
    }
    lerp(e, t) {
        return this.x += (e.x - this.x) * t, this.y += (e.y - this.y) * t, this.z += (e.z - this.z) * t, this
    }
    lerpVectors(e, t, n) {
        return this.x = e.x + (t.x - e.x) * n, this.y = e.y + (t.y - e.y) * n, this.z = e.z + (t.z - e.z) * n, this
    }
    cross(e) {
        return this.crossVectors(this, e)
    }
    crossVectors(e, t) {
        const n = e.x,
            i = e.y,
            s = e.z,
            o = t.x,
            a = t.y,
            l = t.z;
        return this.x = i * l - s * a, this.y = s * o - n * l, this.z = n * a - i * o, this
    }
    projectOnVector(e) {
        const t = e.lengthSq();
        if (t === 0) return this.set(0, 0, 0);
        const n = e.dot(this) / t;
        return this.copy(e).multiplyScalar(n)
    }
    projectOnPlane(e) {
        return ax.copy(this).projectOnVector(e), this.sub(ax)
    }
    reflect(e) {
        return this.sub(ax.copy(e).multiplyScalar(2 * this.dot(e)))
    }
    angleTo(e) {
        const t = Math.sqrt(this.lengthSq() * e.lengthSq());
        if (t === 0) return Math.PI / 2;
        const n = this.dot(e) / t;
        return Math.acos(fi(n, -1, 1))
    }
    distanceTo(e) {
        return Math.sqrt(this.distanceToSquared(e))
    }
    distanceToSquared(e) {
        const t = this.x - e.x,
            n = this.y - e.y,
            i = this.z - e.z;
        return t * t + n * n + i * i
    }
    manhattanDistanceTo(e) {
        return Math.abs(this.x - e.x) + Math.abs(this.y - e.y) + Math.abs(this.z - e.z)
    }
    setFromSpherical(e) {
        return this.setFromSphericalCoords(e.radius, e.phi, e.theta)
    }
    setFromSphericalCoords(e, t, n) {
        const i = Math.sin(t) * e;
        return this.x = i * Math.sin(n), this.y = Math.cos(t) * e, this.z = i * Math.cos(n), this
    }
    setFromCylindrical(e) {
        return this.setFromCylindricalCoords(e.radius, e.theta, e.y)
    }
    setFromCylindricalCoords(e, t, n) {
        return this.x = e * Math.sin(t), this.y = n, this.z = e * Math.cos(t), this
    }
    setFromMatrixPosition(e) {
        const t = e.elements;
        return this.x = t[12], this.y = t[13], this.z = t[14], this
    }
    setFromMatrixScale(e) {
        const t = this.setFromMatrixColumn(e, 0).length(),
            n = this.setFromMatrixColumn(e, 1).length(),
            i = this.setFromMatrixColumn(e, 2).length();
        return this.x = t, this.y = n, this.z = i, this
    }
    setFromMatrixColumn(e, t) {
        return this.fromArray(e.elements, t * 4)
    }
    setFromMatrix3Column(e, t) {
        return this.fromArray(e.elements, t * 3)
    }
    setFromEuler(e) {
        return this.x = e._x, this.y = e._y, this.z = e._z, this
    }
    setFromColor(e) {
        return this.x = e.r, this.y = e.g, this.z = e.b, this
    }
    equals(e) {
        return e.x === this.x && e.y === this.y && e.z === this.z
    }
    fromArray(e, t = 0) {
        return this.x = e[t], this.y = e[t + 1], this.z = e[t + 2], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.x, e[t + 1] = this.y, e[t + 2] = this.z, e
    }
    fromBufferAttribute(e, t) {
        return this.x = e.getX(t), this.y = e.getY(t), this.z = e.getZ(t), this
    }
    random() {
        return this.x = Math.random(), this.y = Math.random(), this.z = Math.random(), this
    }
    randomDirection() {
        const e = Math.random() * Math.PI * 2,
            t = Math.random() * 2 - 1,
            n = Math.sqrt(1 - t * t);
        return this.x = n * Math.cos(e), this.y = t, this.z = n * Math.sin(e), this
    }*[Symbol.iterator]() {
        yield this.x, yield this.y, yield this.z
    }
}
const ax = new K,
    JT = new gr;
class Wi {
    constructor(e = new K(1 / 0, 1 / 0, 1 / 0), t = new K(-1 / 0, -1 / 0, -1 / 0)) {
        this.isBox3 = !0, this.min = e, this.max = t
    }
    set(e, t) {
        return this.min.copy(e), this.max.copy(t), this
    }
    setFromArray(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t += 3) this.expandByPoint(no.fromArray(e, t));
        return this
    }
    setFromBufferAttribute(e) {
        this.makeEmpty();
        for (let t = 0, n = e.count; t < n; t++) this.expandByPoint(no.fromBufferAttribute(e, t));
        return this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const n = no.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
    }
    setFromObject(e, t = !1) {
        return this.makeEmpty(), this.expandByObject(e, t)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this
    }
    makeEmpty() {
        return this.min.x = this.min.y = this.min.z = 1 / 0, this.max.x = this.max.y = this.max.z = -1 / 0, this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y || this.max.z < this.min.z
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this
    }
    expandByObject(e, t = !1) {
        e.updateWorldMatrix(!1, !1);
        const n = e.geometry;
        if (n !== void 0) {
            const s = n.getAttribute("position");
            if (t === !0 && s !== void 0 && e.isInstancedMesh !== !0)
                for (let o = 0, a = s.count; o < a; o++) e.isMesh === !0 ? e.getVertexPosition(o, no) : no.fromBufferAttribute(s, o), no.applyMatrix4(e.matrixWorld), this.expandByPoint(no);
            else e.boundingBox !== void 0 ? (e.boundingBox === null && e.computeBoundingBox(), mg.copy(e.boundingBox)) : (n.boundingBox === null && n.computeBoundingBox(), mg.copy(n.boundingBox)), mg.applyMatrix4(e.matrixWorld), this.union(mg)
        }
        const i = e.children;
        for (let s = 0, o = i.length; s < o; s++) this.expandByObject(i[s], t);
        return this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y && e.z >= this.min.z && e.z <= this.max.z
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y && this.min.z <= e.min.z && e.max.z <= this.max.z
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y), (e.z - this.min.z) / (this.max.z - this.min.z))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y && e.max.z >= this.min.z && e.min.z <= this.max.z
    }
    intersectsSphere(e) {
        return this.clampPoint(e.center, no), no.distanceToSquared(e.center) <= e.radius * e.radius
    }
    intersectsPlane(e) {
        let t, n;
        return e.normal.x > 0 ? (t = e.normal.x * this.min.x, n = e.normal.x * this.max.x) : (t = e.normal.x * this.max.x, n = e.normal.x * this.min.x), e.normal.y > 0 ? (t += e.normal.y * this.min.y, n += e.normal.y * this.max.y) : (t += e.normal.y * this.max.y, n += e.normal.y * this.min.y), e.normal.z > 0 ? (t += e.normal.z * this.min.z, n += e.normal.z * this.max.z) : (t += e.normal.z * this.max.z, n += e.normal.z * this.min.z), t <= -e.constant && n >= -e.constant
    }
    intersectsTriangle(e) {
        if (this.isEmpty()) return !1;
        this.getCenter(jh), gg.subVectors(this.max, jh), ku.subVectors(e.a, jh), zu.subVectors(e.b, jh), Gu.subVectors(e.c, jh), ka.subVectors(zu, ku), za.subVectors(Gu, zu), ic.subVectors(ku, Gu);
        let t = [0, -ka.z, ka.y, 0, -za.z, za.y, 0, -ic.z, ic.y, ka.z, 0, -ka.x, za.z, 0, -za.x, ic.z, 0, -ic.x, -ka.y, ka.x, 0, -za.y, za.x, 0, -ic.y, ic.x, 0];
        return !lx(t, ku, zu, Gu, gg) || (t = [1, 0, 0, 0, 1, 0, 0, 0, 1], !lx(t, ku, zu, Gu, gg)) ? !1 : (vg.crossVectors(ka, za), t = [vg.x, vg.y, vg.z], lx(t, ku, zu, Gu, gg))
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, no).distanceTo(e)
    }
    getBoundingSphere(e) {
        return this.isEmpty() ? e.makeEmpty() : (this.getCenter(e.center), e.radius = this.getSize(no).length() * .5), e
    }
    intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this
    }
    applyMatrix4(e) {
        return this.isEmpty() ? this : (Zo[0].set(this.min.x, this.min.y, this.min.z).applyMatrix4(e), Zo[1].set(this.min.x, this.min.y, this.max.z).applyMatrix4(e), Zo[2].set(this.min.x, this.max.y, this.min.z).applyMatrix4(e), Zo[3].set(this.min.x, this.max.y, this.max.z).applyMatrix4(e), Zo[4].set(this.max.x, this.min.y, this.min.z).applyMatrix4(e), Zo[5].set(this.max.x, this.min.y, this.max.z).applyMatrix4(e), Zo[6].set(this.max.x, this.max.y, this.min.z).applyMatrix4(e), Zo[7].set(this.max.x, this.max.y, this.max.z).applyMatrix4(e), this.setFromPoints(Zo), this)
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const Zo = [new K, new K, new K, new K, new K, new K, new K, new K],
    no = new K,
    mg = new Wi,
    ku = new K,
    zu = new K,
    Gu = new K,
    ka = new K,
    za = new K,
    ic = new K,
    jh = new K,
    gg = new K,
    vg = new K,
    rc = new K;

function lx(r, e, t, n, i) {
    for (let s = 0, o = r.length - 3; s <= o; s += 3) {
        rc.fromArray(r, s);
        const a = i.x * Math.abs(rc.x) + i.y * Math.abs(rc.y) + i.z * Math.abs(rc.z),
            l = e.dot(rc),
            c = t.dot(rc),
            u = n.dot(rc);
        if (Math.max(-Math.max(l, c, u), Math.min(l, c, u)) > a) return !1
    }
    return !0
}
const fk = new Wi,
    Xh = new K,
    cx = new K;
class ji {
    constructor(e = new K, t = -1) {
        this.isSphere = !0, this.center = e, this.radius = t
    }
    set(e, t) {
        return this.center.copy(e), this.radius = t, this
    }
    setFromPoints(e, t) {
        const n = this.center;
        t !== void 0 ? n.copy(t) : fk.setFromPoints(e).getCenter(n);
        let i = 0;
        for (let s = 0, o = e.length; s < o; s++) i = Math.max(i, n.distanceToSquared(e[s]));
        return this.radius = Math.sqrt(i), this
    }
    copy(e) {
        return this.center.copy(e.center), this.radius = e.radius, this
    }
    isEmpty() {
        return this.radius < 0
    }
    makeEmpty() {
        return this.center.set(0, 0, 0), this.radius = -1, this
    }
    containsPoint(e) {
        return e.distanceToSquared(this.center) <= this.radius * this.radius
    }
    distanceToPoint(e) {
        return e.distanceTo(this.center) - this.radius
    }
    intersectsSphere(e) {
        const t = this.radius + e.radius;
        return e.center.distanceToSquared(this.center) <= t * t
    }
    intersectsBox(e) {
        return e.intersectsSphere(this)
    }
    intersectsPlane(e) {
        return Math.abs(e.distanceToPoint(this.center)) <= this.radius
    }
    clampPoint(e, t) {
        const n = this.center.distanceToSquared(e);
        return t.copy(e), n > this.radius * this.radius && (t.sub(this.center).normalize(), t.multiplyScalar(this.radius).add(this.center)), t
    }
    getBoundingBox(e) {
        return this.isEmpty() ? (e.makeEmpty(), e) : (e.set(this.center, this.center), e.expandByScalar(this.radius), e)
    }
    applyMatrix4(e) {
        return this.center.applyMatrix4(e), this.radius = this.radius * e.getMaxScaleOnAxis(), this
    }
    translate(e) {
        return this.center.add(e), this
    }
    expandByPoint(e) {
        if (this.isEmpty()) return this.center.copy(e), this.radius = 0, this;
        Xh.subVectors(e, this.center);
        const t = Xh.lengthSq();
        if (t > this.radius * this.radius) {
            const n = Math.sqrt(t),
                i = (n - this.radius) * .5;
            this.center.addScaledVector(Xh, i / n), this.radius += i
        }
        return this
    }
    union(e) {
        return e.isEmpty() ? this : this.isEmpty() ? (this.copy(e), this) : (this.center.equals(e.center) === !0 ? this.radius = Math.max(this.radius, e.radius) : (cx.subVectors(e.center, this.center).setLength(e.radius), this.expandByPoint(Xh.copy(e.center).add(cx)), this.expandByPoint(Xh.copy(e.center).sub(cx))), this)
    }
    equals(e) {
        return e.center.equals(this.center) && e.radius === this.radius
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Qo = new K,
    ux = new K,
    yg = new K,
    Ga = new K,
    fx = new K,
    _g = new K,
    hx = new K;
class Ll {
    constructor(e = new K, t = new K(0, 0, -1)) {
        this.origin = e, this.direction = t
    }
    set(e, t) {
        return this.origin.copy(e), this.direction.copy(t), this
    }
    copy(e) {
        return this.origin.copy(e.origin), this.direction.copy(e.direction), this
    }
    at(e, t) {
        return t.copy(this.origin).addScaledVector(this.direction, e)
    }
    lookAt(e) {
        return this.direction.copy(e).sub(this.origin).normalize(), this
    }
    recast(e) {
        return this.origin.copy(this.at(e, Qo)), this
    }
    closestPointToPoint(e, t) {
        t.subVectors(e, this.origin);
        const n = t.dot(this.direction);
        return n < 0 ? t.copy(this.origin) : t.copy(this.origin).addScaledVector(this.direction, n)
    }
    distanceToPoint(e) {
        return Math.sqrt(this.distanceSqToPoint(e))
    }
    distanceSqToPoint(e) {
        const t = Qo.subVectors(e, this.origin).dot(this.direction);
        return t < 0 ? this.origin.distanceToSquared(e) : (Qo.copy(this.origin).addScaledVector(this.direction, t), Qo.distanceToSquared(e))
    }
    distanceSqToSegment(e, t, n, i) {
        ux.copy(e).add(t).multiplyScalar(.5), yg.copy(t).sub(e).normalize(), Ga.copy(this.origin).sub(ux);
        const s = e.distanceTo(t) * .5,
            o = -this.direction.dot(yg),
            a = Ga.dot(this.direction),
            l = -Ga.dot(yg),
            c = Ga.lengthSq(),
            u = Math.abs(1 - o * o);
        let f, d, m, g;
        if (u > 0)
            if (f = o * l - a, d = o * a - l, g = s * u, f >= 0)
                if (d >= -g)
                    if (d <= g) {
                        const y = 1 / u;
                        f *= y, d *= y, m = f * (f + o * d + 2 * a) + d * (o * f + d + 2 * l) + c
                    } else d = s, f = Math.max(0, -(o * d + a)), m = -f * f + d * (d + 2 * l) + c;
        else d = -s, f = Math.max(0, -(o * d + a)), m = -f * f + d * (d + 2 * l) + c;
        else d <= -g ? (f = Math.max(0, -(-o * s + a)), d = f > 0 ? -s : Math.min(Math.max(-s, -l), s), m = -f * f + d * (d + 2 * l) + c) : d <= g ? (f = 0, d = Math.min(Math.max(-s, -l), s), m = d * (d + 2 * l) + c) : (f = Math.max(0, -(o * s + a)), d = f > 0 ? s : Math.min(Math.max(-s, -l), s), m = -f * f + d * (d + 2 * l) + c);
        else d = o > 0 ? -s : s, f = Math.max(0, -(o * d + a)), m = -f * f + d * (d + 2 * l) + c;
        return n && n.copy(this.origin).addScaledVector(this.direction, f), i && i.copy(ux).addScaledVector(yg, d), m
    }
    intersectSphere(e, t) {
        Qo.subVectors(e.center, this.origin);
        const n = Qo.dot(this.direction),
            i = Qo.dot(Qo) - n * n,
            s = e.radius * e.radius;
        if (i > s) return null;
        const o = Math.sqrt(s - i),
            a = n - o,
            l = n + o;
        return l < 0 ? null : a < 0 ? this.at(l, t) : this.at(a, t)
    }
    intersectsSphere(e) {
        return this.distanceSqToPoint(e.center) <= e.radius * e.radius
    }
    distanceToPlane(e) {
        const t = e.normal.dot(this.direction);
        if (t === 0) return e.distanceToPoint(this.origin) === 0 ? 0 : null;
        const n = -(this.origin.dot(e.normal) + e.constant) / t;
        return n >= 0 ? n : null
    }
    intersectPlane(e, t) {
        const n = this.distanceToPlane(e);
        return n === null ? null : this.at(n, t)
    }
    intersectsPlane(e) {
        const t = e.distanceToPoint(this.origin);
        return t === 0 || e.normal.dot(this.direction) * t < 0
    }
    intersectBox(e, t) {
        let n, i, s, o, a, l;
        const c = 1 / this.direction.x,
            u = 1 / this.direction.y,
            f = 1 / this.direction.z,
            d = this.origin;
        return c >= 0 ? (n = (e.min.x - d.x) * c, i = (e.max.x - d.x) * c) : (n = (e.max.x - d.x) * c, i = (e.min.x - d.x) * c), u >= 0 ? (s = (e.min.y - d.y) * u, o = (e.max.y - d.y) * u) : (s = (e.max.y - d.y) * u, o = (e.min.y - d.y) * u), n > o || s > i || ((s > n || isNaN(n)) && (n = s), (o < i || isNaN(i)) && (i = o), f >= 0 ? (a = (e.min.z - d.z) * f, l = (e.max.z - d.z) * f) : (a = (e.max.z - d.z) * f, l = (e.min.z - d.z) * f), n > l || a > i) || ((a > n || n !== n) && (n = a), (l < i || i !== i) && (i = l), i < 0) ? null : this.at(n >= 0 ? n : i, t)
    }
    intersectsBox(e) {
        return this.intersectBox(e, Qo) !== null
    }
    intersectTriangle(e, t, n, i, s) {
        fx.subVectors(t, e), _g.subVectors(n, e), hx.crossVectors(fx, _g);
        let o = this.direction.dot(hx),
            a;
        if (o > 0) {
            if (i) return null;
            a = 1
        } else if (o < 0) a = -1, o = -o;
        else return null;
        Ga.subVectors(this.origin, e);
        const l = a * this.direction.dot(_g.crossVectors(Ga, _g));
        if (l < 0) return null;
        const c = a * this.direction.dot(fx.cross(Ga));
        if (c < 0 || l + c > o) return null;
        const u = -a * Ga.dot(hx);
        return u < 0 ? null : this.at(u / o, s)
    }
    applyMatrix4(e) {
        return this.origin.applyMatrix4(e), this.direction.transformDirection(e), this
    }
    equals(e) {
        return e.origin.equals(this.origin) && e.direction.equals(this.direction)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class Ot {
    constructor(e, t, n, i, s, o, a, l, c, u, f, d, m, g, y, v) {
        Ot.prototype.isMatrix4 = !0, this.elements = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1], e !== void 0 && this.set(e, t, n, i, s, o, a, l, c, u, f, d, m, g, y, v)
    }
    set(e, t, n, i, s, o, a, l, c, u, f, d, m, g, y, v) {
        const _ = this.elements;
        return _[0] = e, _[4] = t, _[8] = n, _[12] = i, _[1] = s, _[5] = o, _[9] = a, _[13] = l, _[2] = c, _[6] = u, _[10] = f, _[14] = d, _[3] = m, _[7] = g, _[11] = y, _[15] = v, this
    }
    identity() {
        return this.set(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    clone() {
        return new Ot().fromArray(this.elements)
    }
    copy(e) {
        const t = this.elements,
            n = e.elements;
        return t[0] = n[0], t[1] = n[1], t[2] = n[2], t[3] = n[3], t[4] = n[4], t[5] = n[5], t[6] = n[6], t[7] = n[7], t[8] = n[8], t[9] = n[9], t[10] = n[10], t[11] = n[11], t[12] = n[12], t[13] = n[13], t[14] = n[14], t[15] = n[15], this
    }
    copyPosition(e) {
        const t = this.elements,
            n = e.elements;
        return t[12] = n[12], t[13] = n[13], t[14] = n[14], this
    }
    setFromMatrix3(e) {
        const t = e.elements;
        return this.set(t[0], t[3], t[6], 0, t[1], t[4], t[7], 0, t[2], t[5], t[8], 0, 0, 0, 0, 1), this
    }
    extractBasis(e, t, n) {
        return e.setFromMatrixColumn(this, 0), t.setFromMatrixColumn(this, 1), n.setFromMatrixColumn(this, 2), this
    }
    makeBasis(e, t, n) {
        return this.set(e.x, t.x, n.x, 0, e.y, t.y, n.y, 0, e.z, t.z, n.z, 0, 0, 0, 0, 1), this
    }
    extractRotation(e) {
        const t = this.elements,
            n = e.elements,
            i = 1 / Hu.setFromMatrixColumn(e, 0).length(),
            s = 1 / Hu.setFromMatrixColumn(e, 1).length(),
            o = 1 / Hu.setFromMatrixColumn(e, 2).length();
        return t[0] = n[0] * i, t[1] = n[1] * i, t[2] = n[2] * i, t[3] = 0, t[4] = n[4] * s, t[5] = n[5] * s, t[6] = n[6] * s, t[7] = 0, t[8] = n[8] * o, t[9] = n[9] * o, t[10] = n[10] * o, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
    }
    makeRotationFromEuler(e) {
        const t = this.elements,
            n = e.x,
            i = e.y,
            s = e.z,
            o = Math.cos(n),
            a = Math.sin(n),
            l = Math.cos(i),
            c = Math.sin(i),
            u = Math.cos(s),
            f = Math.sin(s);
        if (e.order === "XYZ") {
            const d = o * u,
                m = o * f,
                g = a * u,
                y = a * f;
            t[0] = l * u, t[4] = -l * f, t[8] = c, t[1] = m + g * c, t[5] = d - y * c, t[9] = -a * l, t[2] = y - d * c, t[6] = g + m * c, t[10] = o * l
        } else if (e.order === "YXZ") {
            const d = l * u,
                m = l * f,
                g = c * u,
                y = c * f;
            t[0] = d + y * a, t[4] = g * a - m, t[8] = o * c, t[1] = o * f, t[5] = o * u, t[9] = -a, t[2] = m * a - g, t[6] = y + d * a, t[10] = o * l
        } else if (e.order === "ZXY") {
            const d = l * u,
                m = l * f,
                g = c * u,
                y = c * f;
            t[0] = d - y * a, t[4] = -o * f, t[8] = g + m * a, t[1] = m + g * a, t[5] = o * u, t[9] = y - d * a, t[2] = -o * c, t[6] = a, t[10] = o * l
        } else if (e.order === "ZYX") {
            const d = o * u,
                m = o * f,
                g = a * u,
                y = a * f;
            t[0] = l * u, t[4] = g * c - m, t[8] = d * c + y, t[1] = l * f, t[5] = y * c + d, t[9] = m * c - g, t[2] = -c, t[6] = a * l, t[10] = o * l
        } else if (e.order === "YZX") {
            const d = o * l,
                m = o * c,
                g = a * l,
                y = a * c;
            t[0] = l * u, t[4] = y - d * f, t[8] = g * f + m, t[1] = f, t[5] = o * u, t[9] = -a * u, t[2] = -c * u, t[6] = m * f + g, t[10] = d - y * f
        } else if (e.order === "XZY") {
            const d = o * l,
                m = o * c,
                g = a * l,
                y = a * c;
            t[0] = l * u, t[4] = -f, t[8] = c * u, t[1] = d * f + y, t[5] = o * u, t[9] = m * f - g, t[2] = g * f - m, t[6] = a * u, t[10] = y * f + d
        }
        return t[3] = 0, t[7] = 0, t[11] = 0, t[12] = 0, t[13] = 0, t[14] = 0, t[15] = 1, this
    }
    makeRotationFromQuaternion(e) {
        return this.compose(hk, e, dk)
    }
    lookAt(e, t, n) {
        const i = this.elements;
        return os.subVectors(e, t), os.lengthSq() === 0 && (os.z = 1), os.normalize(), Ha.crossVectors(n, os), Ha.lengthSq() === 0 && (Math.abs(n.z) === 1 ? os.x += 1e-4 : os.z += 1e-4, os.normalize(), Ha.crossVectors(n, os)), Ha.normalize(), xg.crossVectors(os, Ha), i[0] = Ha.x, i[4] = xg.x, i[8] = os.x, i[1] = Ha.y, i[5] = xg.y, i[9] = os.y, i[2] = Ha.z, i[6] = xg.z, i[10] = os.z, this
    }
    multiply(e) {
        return this.multiplyMatrices(this, e)
    }
    premultiply(e) {
        return this.multiplyMatrices(e, this)
    }
    multiplyMatrices(e, t) {
        const n = e.elements,
            i = t.elements,
            s = this.elements,
            o = n[0],
            a = n[4],
            l = n[8],
            c = n[12],
            u = n[1],
            f = n[5],
            d = n[9],
            m = n[13],
            g = n[2],
            y = n[6],
            v = n[10],
            _ = n[14],
            A = n[3],
            S = n[7],
            M = n[11],
            C = n[15],
            E = i[0],
            R = i[4],
            P = i[8],
            b = i[12],
            T = i[1],
            L = i[5],
            D = i[9],
            V = i[13],
            H = i[2],
            q = i[6],
            X = i[10],
            oe = i[14],
            Y = i[3],
            Z = i[7],
            U = i[11],
            j = i[15];
        return s[0] = o * E + a * T + l * H + c * Y, s[4] = o * R + a * L + l * q + c * Z, s[8] = o * P + a * D + l * X + c * U, s[12] = o * b + a * V + l * oe + c * j, s[1] = u * E + f * T + d * H + m * Y, s[5] = u * R + f * L + d * q + m * Z, s[9] = u * P + f * D + d * X + m * U, s[13] = u * b + f * V + d * oe + m * j, s[2] = g * E + y * T + v * H + _ * Y, s[6] = g * R + y * L + v * q + _ * Z, s[10] = g * P + y * D + v * X + _ * U, s[14] = g * b + y * V + v * oe + _ * j, s[3] = A * E + S * T + M * H + C * Y, s[7] = A * R + S * L + M * q + C * Z, s[11] = A * P + S * D + M * X + C * U, s[15] = A * b + S * V + M * oe + C * j, this
    }
    multiplyScalar(e) {
        const t = this.elements;
        return t[0] *= e, t[4] *= e, t[8] *= e, t[12] *= e, t[1] *= e, t[5] *= e, t[9] *= e, t[13] *= e, t[2] *= e, t[6] *= e, t[10] *= e, t[14] *= e, t[3] *= e, t[7] *= e, t[11] *= e, t[15] *= e, this
    }
    determinant() {
        const e = this.elements,
            t = e[0],
            n = e[4],
            i = e[8],
            s = e[12],
            o = e[1],
            a = e[5],
            l = e[9],
            c = e[13],
            u = e[2],
            f = e[6],
            d = e[10],
            m = e[14],
            g = e[3],
            y = e[7],
            v = e[11],
            _ = e[15];
        return g * (+s * l * f - i * c * f - s * a * d + n * c * d + i * a * m - n * l * m) + y * (+t * l * m - t * c * d + s * o * d - i * o * m + i * c * u - s * l * u) + v * (+t * c * f - t * a * m - s * o * f + n * o * m + s * a * u - n * c * u) + _ * (-i * a * u - t * l * f + t * a * d + i * o * f - n * o * d + n * l * u)
    }
    transpose() {
        const e = this.elements;
        let t;
        return t = e[1], e[1] = e[4], e[4] = t, t = e[2], e[2] = e[8], e[8] = t, t = e[6], e[6] = e[9], e[9] = t, t = e[3], e[3] = e[12], e[12] = t, t = e[7], e[7] = e[13], e[13] = t, t = e[11], e[11] = e[14], e[14] = t, this
    }
    setPosition(e, t, n) {
        const i = this.elements;
        return e.isVector3 ? (i[12] = e.x, i[13] = e.y, i[14] = e.z) : (i[12] = e, i[13] = t, i[14] = n), this
    }
    invert() {
        const e = this.elements,
            t = e[0],
            n = e[1],
            i = e[2],
            s = e[3],
            o = e[4],
            a = e[5],
            l = e[6],
            c = e[7],
            u = e[8],
            f = e[9],
            d = e[10],
            m = e[11],
            g = e[12],
            y = e[13],
            v = e[14],
            _ = e[15],
            A = f * v * c - y * d * c + y * l * m - a * v * m - f * l * _ + a * d * _,
            S = g * d * c - u * v * c - g * l * m + o * v * m + u * l * _ - o * d * _,
            M = u * y * c - g * f * c + g * a * m - o * y * m - u * a * _ + o * f * _,
            C = g * f * l - u * y * l - g * a * d + o * y * d + u * a * v - o * f * v,
            E = t * A + n * S + i * M + s * C;
        if (E === 0) return this.set(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        const R = 1 / E;
        return e[0] = A * R, e[1] = (y * d * s - f * v * s - y * i * m + n * v * m + f * i * _ - n * d * _) * R, e[2] = (a * v * s - y * l * s + y * i * c - n * v * c - a * i * _ + n * l * _) * R, e[3] = (f * l * s - a * d * s - f * i * c + n * d * c + a * i * m - n * l * m) * R, e[4] = S * R, e[5] = (u * v * s - g * d * s + g * i * m - t * v * m - u * i * _ + t * d * _) * R, e[6] = (g * l * s - o * v * s - g * i * c + t * v * c + o * i * _ - t * l * _) * R, e[7] = (o * d * s - u * l * s + u * i * c - t * d * c - o * i * m + t * l * m) * R, e[8] = M * R, e[9] = (g * f * s - u * y * s - g * n * m + t * y * m + u * n * _ - t * f * _) * R, e[10] = (o * y * s - g * a * s + g * n * c - t * y * c - o * n * _ + t * a * _) * R, e[11] = (u * a * s - o * f * s - u * n * c + t * f * c + o * n * m - t * a * m) * R, e[12] = C * R, e[13] = (u * y * i - g * f * i + g * n * d - t * y * d - u * n * v + t * f * v) * R, e[14] = (g * a * i - o * y * i - g * n * l + t * y * l + o * n * v - t * a * v) * R, e[15] = (o * f * i - u * a * i + u * n * l - t * f * l - o * n * d + t * a * d) * R, this
    }
    scale(e) {
        const t = this.elements,
            n = e.x,
            i = e.y,
            s = e.z;
        return t[0] *= n, t[4] *= i, t[8] *= s, t[1] *= n, t[5] *= i, t[9] *= s, t[2] *= n, t[6] *= i, t[10] *= s, t[3] *= n, t[7] *= i, t[11] *= s, this
    }
    getMaxScaleOnAxis() {
        const e = this.elements,
            t = e[0] * e[0] + e[1] * e[1] + e[2] * e[2],
            n = e[4] * e[4] + e[5] * e[5] + e[6] * e[6],
            i = e[8] * e[8] + e[9] * e[9] + e[10] * e[10];
        return Math.sqrt(Math.max(t, n, i))
    }
    makeTranslation(e, t, n) {
        return e.isVector3 ? this.set(1, 0, 0, e.x, 0, 1, 0, e.y, 0, 0, 1, e.z, 0, 0, 0, 1) : this.set(1, 0, 0, e, 0, 1, 0, t, 0, 0, 1, n, 0, 0, 0, 1), this
    }
    makeRotationX(e) {
        const t = Math.cos(e),
            n = Math.sin(e);
        return this.set(1, 0, 0, 0, 0, t, -n, 0, 0, n, t, 0, 0, 0, 0, 1), this
    }
    makeRotationY(e) {
        const t = Math.cos(e),
            n = Math.sin(e);
        return this.set(t, 0, n, 0, 0, 1, 0, 0, -n, 0, t, 0, 0, 0, 0, 1), this
    }
    makeRotationZ(e) {
        const t = Math.cos(e),
            n = Math.sin(e);
        return this.set(t, -n, 0, 0, n, t, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1), this
    }
    makeRotationAxis(e, t) {
        const n = Math.cos(t),
            i = Math.sin(t),
            s = 1 - n,
            o = e.x,
            a = e.y,
            l = e.z,
            c = s * o,
            u = s * a;
        return this.set(c * o + n, c * a - i * l, c * l + i * a, 0, c * a + i * l, u * a + n, u * l - i * o, 0, c * l - i * a, u * l + i * o, s * l * l + n, 0, 0, 0, 0, 1), this
    }
    makeScale(e, t, n) {
        return this.set(e, 0, 0, 0, 0, t, 0, 0, 0, 0, n, 0, 0, 0, 0, 1), this
    }
    makeShear(e, t, n, i, s, o) {
        return this.set(1, n, s, 0, e, 1, o, 0, t, i, 1, 0, 0, 0, 0, 1), this
    }
    compose(e, t, n) {
        const i = this.elements,
            s = t._x,
            o = t._y,
            a = t._z,
            l = t._w,
            c = s + s,
            u = o + o,
            f = a + a,
            d = s * c,
            m = s * u,
            g = s * f,
            y = o * u,
            v = o * f,
            _ = a * f,
            A = l * c,
            S = l * u,
            M = l * f,
            C = n.x,
            E = n.y,
            R = n.z;
        return i[0] = (1 - (y + _)) * C, i[1] = (m + M) * C, i[2] = (g - S) * C, i[3] = 0, i[4] = (m - M) * E, i[5] = (1 - (d + _)) * E, i[6] = (v + A) * E, i[7] = 0, i[8] = (g + S) * R, i[9] = (v - A) * R, i[10] = (1 - (d + y)) * R, i[11] = 0, i[12] = e.x, i[13] = e.y, i[14] = e.z, i[15] = 1, this
    }
    decompose(e, t, n) {
        const i = this.elements;
        let s = Hu.set(i[0], i[1], i[2]).length();
        const o = Hu.set(i[4], i[5], i[6]).length(),
            a = Hu.set(i[8], i[9], i[10]).length();
        this.determinant() < 0 && (s = -s), e.x = i[12], e.y = i[13], e.z = i[14], io.copy(this);
        const c = 1 / s,
            u = 1 / o,
            f = 1 / a;
        return io.elements[0] *= c, io.elements[1] *= c, io.elements[2] *= c, io.elements[4] *= u, io.elements[5] *= u, io.elements[6] *= u, io.elements[8] *= f, io.elements[9] *= f, io.elements[10] *= f, t.setFromRotationMatrix(io), n.x = s, n.y = o, n.z = a, this
    }
    makePerspective(e, t, n, i, s, o, a = Io) {
        const l = this.elements,
            c = 2 * s / (t - e),
            u = 2 * s / (n - i),
            f = (t + e) / (t - e),
            d = (n + i) / (n - i);
        let m, g;
        if (a === Io) m = -(o + s) / (o - s), g = -2 * o * s / (o - s);
        else if (a === gp) m = -o / (o - s), g = -o * s / (o - s);
        else throw new Error("THREE.Matrix4.makePerspective(): Invalid coordinate system: " + a);
        return l[0] = c, l[4] = 0, l[8] = f, l[12] = 0, l[1] = 0, l[5] = u, l[9] = d, l[13] = 0, l[2] = 0, l[6] = 0, l[10] = m, l[14] = g, l[3] = 0, l[7] = 0, l[11] = -1, l[15] = 0, this
    }
    makeOrthographic(e, t, n, i, s, o, a = Io) {
        const l = this.elements,
            c = 1 / (t - e),
            u = 1 / (n - i),
            f = 1 / (o - s),
            d = (t + e) * c,
            m = (n + i) * u;
        let g, y;
        if (a === Io) g = (o + s) * f, y = -2 * f;
        else if (a === gp) g = s * f, y = -1 * f;
        else throw new Error("THREE.Matrix4.makeOrthographic(): Invalid coordinate system: " + a);
        return l[0] = 2 * c, l[4] = 0, l[8] = 0, l[12] = -d, l[1] = 0, l[5] = 2 * u, l[9] = 0, l[13] = -m, l[2] = 0, l[6] = 0, l[10] = y, l[14] = -g, l[3] = 0, l[7] = 0, l[11] = 0, l[15] = 1, this
    }
    equals(e) {
        const t = this.elements,
            n = e.elements;
        for (let i = 0; i < 16; i++)
            if (t[i] !== n[i]) return !1;
        return !0
    }
    fromArray(e, t = 0) {
        for (let n = 0; n < 16; n++) this.elements[n] = e[n + t];
        return this
    }
    toArray(e = [], t = 0) {
        const n = this.elements;
        return e[t] = n[0], e[t + 1] = n[1], e[t + 2] = n[2], e[t + 3] = n[3], e[t + 4] = n[4], e[t + 5] = n[5], e[t + 6] = n[6], e[t + 7] = n[7], e[t + 8] = n[8], e[t + 9] = n[9], e[t + 10] = n[10], e[t + 11] = n[11], e[t + 12] = n[12], e[t + 13] = n[13], e[t + 14] = n[14], e[t + 15] = n[15], e
    }
}
const Hu = new K,
    io = new Ot,
    hk = new K(0, 0, 0),
    dk = new K(1, 1, 1),
    Ha = new K,
    xg = new K,
    os = new K,
    KT = new Ot,
    qT = new gr;
class As {
    constructor(e = 0, t = 0, n = 0, i = As.DEFAULT_ORDER) {
        this.isEuler = !0, this._x = e, this._y = t, this._z = n, this._order = i
    }
    get x() {
        return this._x
    }
    set x(e) {
        this._x = e, this._onChangeCallback()
    }
    get y() {
        return this._y
    }
    set y(e) {
        this._y = e, this._onChangeCallback()
    }
    get z() {
        return this._z
    }
    set z(e) {
        this._z = e, this._onChangeCallback()
    }
    get order() {
        return this._order
    }
    set order(e) {
        this._order = e, this._onChangeCallback()
    }
    set(e, t, n, i = this._order) {
        return this._x = e, this._y = t, this._z = n, this._order = i, this._onChangeCallback(), this
    }
    clone() {
        return new this.constructor(this._x, this._y, this._z, this._order)
    }
    copy(e) {
        return this._x = e._x, this._y = e._y, this._z = e._z, this._order = e._order, this._onChangeCallback(), this
    }
    setFromRotationMatrix(e, t = this._order, n = !0) {
        const i = e.elements,
            s = i[0],
            o = i[4],
            a = i[8],
            l = i[1],
            c = i[5],
            u = i[9],
            f = i[2],
            d = i[6],
            m = i[10];
        switch (t) {
            case "XYZ":
                this._y = Math.asin(fi(a, -1, 1)), Math.abs(a) < .9999999 ? (this._x = Math.atan2(-u, m), this._z = Math.atan2(-o, s)) : (this._x = Math.atan2(d, c), this._z = 0);
                break;
            case "YXZ":
                this._x = Math.asin(-fi(u, -1, 1)), Math.abs(u) < .9999999 ? (this._y = Math.atan2(a, m), this._z = Math.atan2(l, c)) : (this._y = Math.atan2(-f, s), this._z = 0);
                break;
            case "ZXY":
                this._x = Math.asin(fi(d, -1, 1)), Math.abs(d) < .9999999 ? (this._y = Math.atan2(-f, m), this._z = Math.atan2(-o, c)) : (this._y = 0, this._z = Math.atan2(l, s));
                break;
            case "ZYX":
                this._y = Math.asin(-fi(f, -1, 1)), Math.abs(f) < .9999999 ? (this._x = Math.atan2(d, m), this._z = Math.atan2(l, s)) : (this._x = 0, this._z = Math.atan2(-o, c));
                break;
            case "YZX":
                this._z = Math.asin(fi(l, -1, 1)), Math.abs(l) < .9999999 ? (this._x = Math.atan2(-u, c), this._y = Math.atan2(-f, s)) : (this._x = 0, this._y = Math.atan2(a, m));
                break;
            case "XZY":
                this._z = Math.asin(-fi(o, -1, 1)), Math.abs(o) < .9999999 ? (this._x = Math.atan2(d, c), this._y = Math.atan2(a, s)) : (this._x = Math.atan2(-u, m), this._y = 0);
                break;
            default:
                console.warn("THREE.Euler: .setFromRotationMatrix() encountered an unknown order: " + t)
        }
        return this._order = t, n === !0 && this._onChangeCallback(), this
    }
    setFromQuaternion(e, t, n) {
        return KT.makeRotationFromQuaternion(e), this.setFromRotationMatrix(KT, t, n)
    }
    setFromVector3(e, t = this._order) {
        return this.set(e.x, e.y, e.z, t)
    }
    reorder(e) {
        return qT.setFromEuler(this), this.setFromQuaternion(qT, e)
    }
    equals(e) {
        return e._x === this._x && e._y === this._y && e._z === this._z && e._order === this._order
    }
    fromArray(e) {
        return this._x = e[0], this._y = e[1], this._z = e[2], e[3] !== void 0 && (this._order = e[3]), this._onChangeCallback(), this
    }
    toArray(e = [], t = 0) {
        return e[t] = this._x, e[t + 1] = this._y, e[t + 2] = this._z, e[t + 3] = this._order, e
    }
    _onChange(e) {
        return this._onChangeCallback = e, this
    }
    _onChangeCallback() {}*[Symbol.iterator]() {
        yield this._x, yield this._y, yield this._z, yield this._order
    }
}
As.DEFAULT_ORDER = "XYZ";
class Kc {
    constructor() {
        this.mask = 1
    }
    set(e) {
        this.mask = (1 << e | 0) >>> 0
    }
    enable(e) {
        this.mask |= 1 << e | 0
    }
    enableAll() {
        this.mask = -1
    }
    toggle(e) {
        this.mask ^= 1 << e | 0
    }
    disable(e) {
        this.mask &= ~(1 << e | 0)
    }
    disableAll() {
        this.mask = 0
    }
    test(e) {
        return (this.mask & e.mask) !== 0
    }
    isEnabled(e) {
        return (this.mask & (1 << e | 0)) !== 0
    }
}
let pk = 0;
const ZT = new K,
    Vu = new gr,
    $o = new Ot,
    Ag = new K,
    Yh = new K,
    mk = new K,
    gk = new gr,
    QT = new K(1, 0, 0),
    $T = new K(0, 1, 0),
    eE = new K(0, 0, 1),
    tE = {
        type: "added"
    },
    vk = {
        type: "removed"
    },
    Wu = {
        type: "childadded",
        child: null
    },
    dx = {
        type: "childremoved",
        child: null
    };
class vn extends ws {
    constructor() {
        super(), this.isObject3D = !0, Object.defineProperty(this, "id", {
            value: pk++
        }), this.uuid = ys(), this.name = "", this.type = "Object3D", this.parent = null, this.children = [], this.up = vn.DEFAULT_UP.clone();
        const e = new K,
            t = new As,
            n = new gr,
            i = new K(1, 1, 1);

        function s() {
            n.setFromEuler(t, !1)
        }

        function o() {
            t.setFromQuaternion(n, void 0, !1)
        }
        t._onChange(s), n._onChange(o), Object.defineProperties(this, {
            position: {
                configurable: !0,
                enumerable: !0,
                value: e
            },
            rotation: {
                configurable: !0,
                enumerable: !0,
                value: t
            },
            quaternion: {
                configurable: !0,
                enumerable: !0,
                value: n
            },
            scale: {
                configurable: !0,
                enumerable: !0,
                value: i
            },
            modelViewMatrix: {
                value: new Ot
            },
            normalMatrix: {
                value: new jt
            }
        }), this.matrix = new Ot, this.matrixWorld = new Ot, this.matrixAutoUpdate = vn.DEFAULT_MATRIX_AUTO_UPDATE, this.matrixWorldAutoUpdate = vn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE, this.matrixWorldNeedsUpdate = !1, this.layers = new Kc, this.visible = !0, this.castShadow = !1, this.receiveShadow = !1, this.frustumCulled = !0, this.renderOrder = 0, this.animations = [], this.userData = {}
    }
    onBeforeShadow() {}
    onAfterShadow() {}
    onBeforeRender() {}
    onAfterRender() {}
    applyMatrix4(e) {
        this.matrixAutoUpdate && this.updateMatrix(), this.matrix.premultiply(e), this.matrix.decompose(this.position, this.quaternion, this.scale)
    }
    applyQuaternion(e) {
        return this.quaternion.premultiply(e), this
    }
    setRotationFromAxisAngle(e, t) {
        this.quaternion.setFromAxisAngle(e, t)
    }
    setRotationFromEuler(e) {
        this.quaternion.setFromEuler(e, !0)
    }
    setRotationFromMatrix(e) {
        this.quaternion.setFromRotationMatrix(e)
    }
    setRotationFromQuaternion(e) {
        this.quaternion.copy(e)
    }
    rotateOnAxis(e, t) {
        return Vu.setFromAxisAngle(e, t), this.quaternion.multiply(Vu), this
    }
    rotateOnWorldAxis(e, t) {
        return Vu.setFromAxisAngle(e, t), this.quaternion.premultiply(Vu), this
    }
    rotateX(e) {
        return this.rotateOnAxis(QT, e)
    }
    rotateY(e) {
        return this.rotateOnAxis($T, e)
    }
    rotateZ(e) {
        return this.rotateOnAxis(eE, e)
    }
    translateOnAxis(e, t) {
        return ZT.copy(e).applyQuaternion(this.quaternion), this.position.add(ZT.multiplyScalar(t)), this
    }
    translateX(e) {
        return this.translateOnAxis(QT, e)
    }
    translateY(e) {
        return this.translateOnAxis($T, e)
    }
    translateZ(e) {
        return this.translateOnAxis(eE, e)
    }
    localToWorld(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4(this.matrixWorld)
    }
    worldToLocal(e) {
        return this.updateWorldMatrix(!0, !1), e.applyMatrix4($o.copy(this.matrixWorld).invert())
    }
    lookAt(e, t, n) {
        e.isVector3 ? Ag.copy(e) : Ag.set(e, t, n);
        const i = this.parent;
        this.updateWorldMatrix(!0, !1), Yh.setFromMatrixPosition(this.matrixWorld), this.isCamera || this.isLight ? $o.lookAt(Yh, Ag, this.up) : $o.lookAt(Ag, Yh, this.up), this.quaternion.setFromRotationMatrix($o), i && ($o.extractRotation(i.matrixWorld), Vu.setFromRotationMatrix($o), this.quaternion.premultiply(Vu.invert()))
    }
    add(e) {
        if (arguments.length > 1) {
            for (let t = 0; t < arguments.length; t++) this.add(arguments[t]);
            return this
        }
        return e === this ? (console.error("THREE.Object3D.add: object can't be added as a child of itself.", e), this) : (e && e.isObject3D ? (e.removeFromParent(), e.parent = this, this.children.push(e), e.dispatchEvent(tE), Wu.child = e, this.dispatchEvent(Wu), Wu.child = null) : console.error("THREE.Object3D.add: object not an instance of THREE.Object3D.", e), this)
    }
    remove(e) {
        if (arguments.length > 1) {
            for (let n = 0; n < arguments.length; n++) this.remove(arguments[n]);
            return this
        }
        const t = this.children.indexOf(e);
        return t !== -1 && (e.parent = null, this.children.splice(t, 1), e.dispatchEvent(vk), dx.child = e, this.dispatchEvent(dx), dx.child = null), this
    }
    removeFromParent() {
        const e = this.parent;
        return e !== null && e.remove(this), this
    }
    clear() {
        return this.remove(...this.children)
    }
    attach(e) {
        return this.updateWorldMatrix(!0, !1), $o.copy(this.matrixWorld).invert(), e.parent !== null && (e.parent.updateWorldMatrix(!0, !1), $o.multiply(e.parent.matrixWorld)), e.applyMatrix4($o), e.removeFromParent(), e.parent = this, this.children.push(e), e.updateWorldMatrix(!1, !0), e.dispatchEvent(tE), Wu.child = e, this.dispatchEvent(Wu), Wu.child = null, this
    }
    getObjectById(e) {
        return this.getObjectByProperty("id", e)
    }
    getObjectByName(e) {
        return this.getObjectByProperty("name", e)
    }
    getObjectByProperty(e, t) {
        if (this[e] === t) return this;
        for (let n = 0, i = this.children.length; n < i; n++) {
            const o = this.children[n].getObjectByProperty(e, t);
            if (o !== void 0) return o
        }
    }
    getObjectsByProperty(e, t, n = []) {
        this[e] === t && n.push(this);
        const i = this.children;
        for (let s = 0, o = i.length; s < o; s++) i[s].getObjectsByProperty(e, t, n);
        return n
    }
    getWorldPosition(e) {
        return this.updateWorldMatrix(!0, !1), e.setFromMatrixPosition(this.matrixWorld)
    }
    getWorldQuaternion(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Yh, e, mk), e
    }
    getWorldScale(e) {
        return this.updateWorldMatrix(!0, !1), this.matrixWorld.decompose(Yh, gk, e), e
    }
    getWorldDirection(e) {
        this.updateWorldMatrix(!0, !1);
        const t = this.matrixWorld.elements;
        return e.set(t[8], t[9], t[10]).normalize()
    }
    raycast() {}
    traverse(e) {
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) t[n].traverse(e)
    }
    traverseVisible(e) {
        if (this.visible === !1) return;
        e(this);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) t[n].traverseVisible(e)
    }
    traverseAncestors(e) {
        const t = this.parent;
        t !== null && (e(t), t.traverseAncestors(e))
    }
    updateMatrix() {
        this.matrix.compose(this.position, this.quaternion, this.scale), this.matrixWorldNeedsUpdate = !0
    }
    updateMatrixWorld(e) {
        this.matrixAutoUpdate && this.updateMatrix(), (this.matrixWorldNeedsUpdate || e) && (this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), this.matrixWorldNeedsUpdate = !1, e = !0);
        const t = this.children;
        for (let n = 0, i = t.length; n < i; n++) t[n].updateMatrixWorld(e)
    }
    updateWorldMatrix(e, t) {
        const n = this.parent;
        if (e === !0 && n !== null && n.updateWorldMatrix(!0, !1), this.matrixAutoUpdate && this.updateMatrix(), this.matrixWorldAutoUpdate === !0 && (this.parent === null ? this.matrixWorld.copy(this.matrix) : this.matrixWorld.multiplyMatrices(this.parent.matrixWorld, this.matrix)), t === !0) {
            const i = this.children;
            for (let s = 0, o = i.length; s < o; s++) i[s].updateWorldMatrix(!1, !0)
        }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string",
            n = {};
        t && (e = {
            geometries: {},
            materials: {},
            textures: {},
            images: {},
            shapes: {},
            skeletons: {},
            animations: {},
            nodes: {}
        }, n.metadata = {
            version: 4.6,
            type: "Object",
            generator: "Object3D.toJSON"
        });
        const i = {};
        i.uuid = this.uuid, i.type = this.type, this.name !== "" && (i.name = this.name), this.castShadow === !0 && (i.castShadow = !0), this.receiveShadow === !0 && (i.receiveShadow = !0), this.visible === !1 && (i.visible = !1), this.frustumCulled === !1 && (i.frustumCulled = !1), this.renderOrder !== 0 && (i.renderOrder = this.renderOrder), Object.keys(this.userData).length > 0 && (i.userData = this.userData), i.layers = this.layers.mask, i.matrix = this.matrix.toArray(), i.up = this.up.toArray(), this.matrixAutoUpdate === !1 && (i.matrixAutoUpdate = !1), this.isInstancedMesh && (i.type = "InstancedMesh", i.count = this.count, i.instanceMatrix = this.instanceMatrix.toJSON(), this.instanceColor !== null && (i.instanceColor = this.instanceColor.toJSON())), this.isBatchedMesh && (i.type = "BatchedMesh", i.perObjectFrustumCulled = this.perObjectFrustumCulled, i.sortObjects = this.sortObjects, i.drawRanges = this._drawRanges, i.reservedRanges = this._reservedRanges, i.visibility = this._visibility, i.active = this._active, i.bounds = this._bounds.map(a => ({
            boxInitialized: a.boxInitialized,
            boxMin: a.box.min.toArray(),
            boxMax: a.box.max.toArray(),
            sphereInitialized: a.sphereInitialized,
            sphereRadius: a.sphere.radius,
            sphereCenter: a.sphere.center.toArray()
        })), i.maxInstanceCount = this._maxInstanceCount, i.maxVertexCount = this._maxVertexCount, i.maxIndexCount = this._maxIndexCount, i.geometryInitialized = this._geometryInitialized, i.geometryCount = this._geometryCount, i.matricesTexture = this._matricesTexture.toJSON(e), this._colorsTexture !== null && (i.colorsTexture = this._colorsTexture.toJSON(e)), this.boundingSphere !== null && (i.boundingSphere = {
            center: i.boundingSphere.center.toArray(),
            radius: i.boundingSphere.radius
        }), this.boundingBox !== null && (i.boundingBox = {
            min: i.boundingBox.min.toArray(),
            max: i.boundingBox.max.toArray()
        }));

        function s(a, l) {
            return a[l.uuid] === void 0 && (a[l.uuid] = l.toJSON(e)), l.uuid
        }
        if (this.isScene) this.background && (this.background.isColor ? i.background = this.background.toJSON() : this.background.isTexture && (i.background = this.background.toJSON(e).uuid)), this.environment && this.environment.isTexture && this.environment.isRenderTargetTexture !== !0 && (i.environment = this.environment.toJSON(e).uuid);
        else if (this.isMesh || this.isLine || this.isPoints) {
            i.geometry = s(e.geometries, this.geometry);
            const a = this.geometry.parameters;
            if (a !== void 0 && a.shapes !== void 0) {
                const l = a.shapes;
                if (Array.isArray(l))
                    for (let c = 0, u = l.length; c < u; c++) {
                        const f = l[c];
                        s(e.shapes, f)
                    } else s(e.shapes, l)
            }
        }
        if (this.isSkinnedMesh && (i.bindMode = this.bindMode, i.bindMatrix = this.bindMatrix.toArray(), this.skeleton !== void 0 && (s(e.skeletons, this.skeleton), i.skeleton = this.skeleton.uuid)), this.material !== void 0)
            if (Array.isArray(this.material)) {
                const a = [];
                for (let l = 0, c = this.material.length; l < c; l++) a.push(s(e.materials, this.material[l]));
                i.material = a
            } else i.material = s(e.materials, this.material);
        if (this.children.length > 0) {
            i.children = [];
            for (let a = 0; a < this.children.length; a++) i.children.push(this.children[a].toJSON(e).object)
        }
        if (this.animations.length > 0) {
            i.animations = [];
            for (let a = 0; a < this.animations.length; a++) {
                const l = this.animations[a];
                i.animations.push(s(e.animations, l))
            }
        }
        if (t) {
            const a = o(e.geometries),
                l = o(e.materials),
                c = o(e.textures),
                u = o(e.images),
                f = o(e.shapes),
                d = o(e.skeletons),
                m = o(e.animations),
                g = o(e.nodes);
            a.length > 0 && (n.geometries = a), l.length > 0 && (n.materials = l), c.length > 0 && (n.textures = c), u.length > 0 && (n.images = u), f.length > 0 && (n.shapes = f), d.length > 0 && (n.skeletons = d), m.length > 0 && (n.animations = m), g.length > 0 && (n.nodes = g)
        }
        return n.object = i, n;

        function o(a) {
            const l = [];
            for (const c in a) {
                const u = a[c];
                delete u.metadata, l.push(u)
            }
            return l
        }
    }
    clone(e) {
        return new this.constructor().copy(this, e)
    }
    copy(e, t = !0) {
        if (this.name = e.name, this.up.copy(e.up), this.position.copy(e.position), this.rotation.order = e.rotation.order, this.quaternion.copy(e.quaternion), this.scale.copy(e.scale), this.matrix.copy(e.matrix), this.matrixWorld.copy(e.matrixWorld), this.matrixAutoUpdate = e.matrixAutoUpdate, this.matrixWorldAutoUpdate = e.matrixWorldAutoUpdate, this.matrixWorldNeedsUpdate = e.matrixWorldNeedsUpdate, this.layers.mask = e.layers.mask, this.visible = e.visible, this.castShadow = e.castShadow, this.receiveShadow = e.receiveShadow, this.frustumCulled = e.frustumCulled, this.renderOrder = e.renderOrder, this.animations = e.animations.slice(), this.userData = JSON.parse(JSON.stringify(e.userData)), t === !0)
            for (let n = 0; n < e.children.length; n++) {
                const i = e.children[n];
                this.add(i.clone())
            }
        return this
    }
}
vn.DEFAULT_UP = new K(0, 1, 0);
vn.DEFAULT_MATRIX_AUTO_UPDATE = !0;
vn.DEFAULT_MATRIX_WORLD_AUTO_UPDATE = !0;
const ro = new K,
    ea = new K,
    px = new K,
    ta = new K,
    ju = new K,
    Xu = new K,
    nE = new K,
    mx = new K,
    gx = new K,
    vx = new K,
    yx = new An,
    _x = new An,
    xx = new An;
class Or {
    constructor(e = new K, t = new K, n = new K) {
        this.a = e, this.b = t, this.c = n
    }
    static getNormal(e, t, n, i) {
        i.subVectors(n, t), ro.subVectors(e, t), i.cross(ro);
        const s = i.lengthSq();
        return s > 0 ? i.multiplyScalar(1 / Math.sqrt(s)) : i.set(0, 0, 0)
    }
    static getBarycoord(e, t, n, i, s) {
        ro.subVectors(i, t), ea.subVectors(n, t), px.subVectors(e, t);
        const o = ro.dot(ro),
            a = ro.dot(ea),
            l = ro.dot(px),
            c = ea.dot(ea),
            u = ea.dot(px),
            f = o * c - a * a;
        if (f === 0) return s.set(0, 0, 0), null;
        const d = 1 / f,
            m = (c * l - a * u) * d,
            g = (o * u - a * l) * d;
        return s.set(1 - m - g, g, m)
    }
    static containsPoint(e, t, n, i) {
        return this.getBarycoord(e, t, n, i, ta) === null ? !1 : ta.x >= 0 && ta.y >= 0 && ta.x + ta.y <= 1
    }
    static getInterpolation(e, t, n, i, s, o, a, l) {
        return this.getBarycoord(e, t, n, i, ta) === null ? (l.x = 0, l.y = 0, "z" in l && (l.z = 0), "w" in l && (l.w = 0), null) : (l.setScalar(0), l.addScaledVector(s, ta.x), l.addScaledVector(o, ta.y), l.addScaledVector(a, ta.z), l)
    }
    static getInterpolatedAttribute(e, t, n, i, s, o) {
        return yx.setScalar(0), _x.setScalar(0), xx.setScalar(0), yx.fromBufferAttribute(e, t), _x.fromBufferAttribute(e, n), xx.fromBufferAttribute(e, i), o.setScalar(0), o.addScaledVector(yx, s.x), o.addScaledVector(_x, s.y), o.addScaledVector(xx, s.z), o
    }
    static isFrontFacing(e, t, n, i) {
        return ro.subVectors(n, t), ea.subVectors(e, t), ro.cross(ea).dot(i) < 0
    }
    set(e, t, n) {
        return this.a.copy(e), this.b.copy(t), this.c.copy(n), this
    }
    setFromPointsAndIndices(e, t, n, i) {
        return this.a.copy(e[t]), this.b.copy(e[n]), this.c.copy(e[i]), this
    }
    setFromAttributeAndIndices(e, t, n, i) {
        return this.a.fromBufferAttribute(e, t), this.b.fromBufferAttribute(e, n), this.c.fromBufferAttribute(e, i), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.a.copy(e.a), this.b.copy(e.b), this.c.copy(e.c), this
    }
    getArea() {
        return ro.subVectors(this.c, this.b), ea.subVectors(this.a, this.b), ro.cross(ea).length() * .5
    }
    getMidpoint(e) {
        return e.addVectors(this.a, this.b).add(this.c).multiplyScalar(1 / 3)
    }
    getNormal(e) {
        return Or.getNormal(this.a, this.b, this.c, e)
    }
    getPlane(e) {
        return e.setFromCoplanarPoints(this.a, this.b, this.c)
    }
    getBarycoord(e, t) {
        return Or.getBarycoord(e, this.a, this.b, this.c, t)
    }
    getInterpolation(e, t, n, i, s) {
        return Or.getInterpolation(e, this.a, this.b, this.c, t, n, i, s)
    }
    containsPoint(e) {
        return Or.containsPoint(e, this.a, this.b, this.c)
    }
    isFrontFacing(e) {
        return Or.isFrontFacing(this.a, this.b, this.c, e)
    }
    intersectsBox(e) {
        return e.intersectsTriangle(this)
    }
    closestPointToPoint(e, t) {
        const n = this.a,
            i = this.b,
            s = this.c;
        let o, a;
        ju.subVectors(i, n), Xu.subVectors(s, n), mx.subVectors(e, n);
        const l = ju.dot(mx),
            c = Xu.dot(mx);
        if (l <= 0 && c <= 0) return t.copy(n);
        gx.subVectors(e, i);
        const u = ju.dot(gx),
            f = Xu.dot(gx);
        if (u >= 0 && f <= u) return t.copy(i);
        const d = l * f - u * c;
        if (d <= 0 && l >= 0 && u <= 0) return o = l / (l - u), t.copy(n).addScaledVector(ju, o);
        vx.subVectors(e, s);
        const m = ju.dot(vx),
            g = Xu.dot(vx);
        if (g >= 0 && m <= g) return t.copy(s);
        const y = m * c - l * g;
        if (y <= 0 && c >= 0 && g <= 0) return a = c / (c - g), t.copy(n).addScaledVector(Xu, a);
        const v = u * g - m * f;
        if (v <= 0 && f - u >= 0 && m - g >= 0) return nE.subVectors(s, i), a = (f - u) / (f - u + (m - g)), t.copy(i).addScaledVector(nE, a);
        const _ = 1 / (v + y + d);
        return o = y * _, a = d * _, t.copy(n).addScaledVector(ju, o).addScaledVector(Xu, a)
    }
    equals(e) {
        return e.a.equals(this.a) && e.b.equals(this.b) && e.c.equals(this.c)
    }
}
const dB = {
        aliceblue: 15792383,
        antiquewhite: 16444375,
        aqua: 65535,
        aquamarine: 8388564,
        azure: 15794175,
        beige: 16119260,
        bisque: 16770244,
        black: 0,
        blanchedalmond: 16772045,
        blue: 255,
        blueviolet: 9055202,
        brown: 10824234,
        burlywood: 14596231,
        cadetblue: 6266528,
        chartreuse: 8388352,
        chocolate: 13789470,
        coral: 16744272,
        cornflowerblue: 6591981,
        cornsilk: 16775388,
        crimson: 14423100,
        cyan: 65535,
        darkblue: 139,
        darkcyan: 35723,
        darkgoldenrod: 12092939,
        darkgray: 11119017,
        darkgreen: 25600,
        darkgrey: 11119017,
        darkkhaki: 12433259,
        darkmagenta: 9109643,
        darkolivegreen: 5597999,
        darkorange: 16747520,
        darkorchid: 10040012,
        darkred: 9109504,
        darksalmon: 15308410,
        darkseagreen: 9419919,
        darkslateblue: 4734347,
        darkslategray: 3100495,
        darkslategrey: 3100495,
        darkturquoise: 52945,
        darkviolet: 9699539,
        deeppink: 16716947,
        deepskyblue: 49151,
        dimgray: 6908265,
        dimgrey: 6908265,
        dodgerblue: 2003199,
        firebrick: 11674146,
        floralwhite: 16775920,
        forestgreen: 2263842,
        fuchsia: 16711935,
        gainsboro: 14474460,
        ghostwhite: 16316671,
        gold: 16766720,
        goldenrod: 14329120,
        gray: 8421504,
        green: 32768,
        greenyellow: 11403055,
        grey: 8421504,
        honeydew: 15794160,
        hotpink: 16738740,
        indianred: 13458524,
        indigo: 4915330,
        ivory: 16777200,
        khaki: 15787660,
        lavender: 15132410,
        lavenderblush: 16773365,
        lawngreen: 8190976,
        lemonchiffon: 16775885,
        lightblue: 11393254,
        lightcoral: 15761536,
        lightcyan: 14745599,
        lightgoldenrodyellow: 16448210,
        lightgray: 13882323,
        lightgreen: 9498256,
        lightgrey: 13882323,
        lightpink: 16758465,
        lightsalmon: 16752762,
        lightseagreen: 2142890,
        lightskyblue: 8900346,
        lightslategray: 7833753,
        lightslategrey: 7833753,
        lightsteelblue: 11584734,
        lightyellow: 16777184,
        lime: 65280,
        limegreen: 3329330,
        linen: 16445670,
        magenta: 16711935,
        maroon: 8388608,
        mediumaquamarine: 6737322,
        mediumblue: 205,
        mediumorchid: 12211667,
        mediumpurple: 9662683,
        mediumseagreen: 3978097,
        mediumslateblue: 8087790,
        mediumspringgreen: 64154,
        mediumturquoise: 4772300,
        mediumvioletred: 13047173,
        midnightblue: 1644912,
        mintcream: 16121850,
        mistyrose: 16770273,
        moccasin: 16770229,
        navajowhite: 16768685,
        navy: 128,
        oldlace: 16643558,
        olive: 8421376,
        olivedrab: 7048739,
        orange: 16753920,
        orangered: 16729344,
        orchid: 14315734,
        palegoldenrod: 15657130,
        palegreen: 10025880,
        paleturquoise: 11529966,
        palevioletred: 14381203,
        papayawhip: 16773077,
        peachpuff: 16767673,
        peru: 13468991,
        pink: 16761035,
        plum: 14524637,
        powderblue: 11591910,
        purple: 8388736,
        rebeccapurple: 6697881,
        red: 16711680,
        rosybrown: 12357519,
        royalblue: 4286945,
        saddlebrown: 9127187,
        salmon: 16416882,
        sandybrown: 16032864,
        seagreen: 3050327,
        seashell: 16774638,
        sienna: 10506797,
        silver: 12632256,
        skyblue: 8900331,
        slateblue: 6970061,
        slategray: 7372944,
        slategrey: 7372944,
        snow: 16775930,
        springgreen: 65407,
        steelblue: 4620980,
        tan: 13808780,
        teal: 32896,
        thistle: 14204888,
        tomato: 16737095,
        turquoise: 4251856,
        violet: 15631086,
        wheat: 16113331,
        white: 16777215,
        whitesmoke: 16119285,
        yellow: 16776960,
        yellowgreen: 10145074
    },
    Va = {
        h: 0,
        s: 0,
        l: 0
    },
    Sg = {
        h: 0,
        s: 0,
        l: 0
    };

function Ax(r, e, t) {
    return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * 6 * (2 / 3 - t) : r
}
class rt {
    constructor(e, t, n) {
        return this.isColor = !0, this.r = 1, this.g = 1, this.b = 1, this.set(e, t, n)
    }
    set(e, t, n) {
        if (t === void 0 && n === void 0) {
            const i = e;
            i && i.isColor ? this.copy(i) : typeof i == "number" ? this.setHex(i) : typeof i == "string" && this.setStyle(i)
        } else this.setRGB(e, t, n);
        return this
    }
    setScalar(e) {
        return this.r = e, this.g = e, this.b = e, this
    }
    setHex(e, t = Jn) {
        return e = Math.floor(e), this.r = (e >> 16 & 255) / 255, this.g = (e >> 8 & 255) / 255, this.b = (e & 255) / 255, xn.toWorkingColorSpace(this, t), this
    }
    setRGB(e, t, n, i = xn.workingColorSpace) {
        return this.r = e, this.g = t, this.b = n, xn.toWorkingColorSpace(this, i), this
    }
    setHSL(e, t, n, i = xn.workingColorSpace) {
        if (e = VS(e, 1), t = fi(t, 0, 1), n = fi(n, 0, 1), t === 0) this.r = this.g = this.b = n;
        else {
            const s = n <= .5 ? n * (1 + t) : n + t - n * t,
                o = 2 * n - s;
            this.r = Ax(o, s, e + 1 / 3), this.g = Ax(o, s, e), this.b = Ax(o, s, e - 1 / 3)
        }
        return xn.toWorkingColorSpace(this, i), this
    }
    setStyle(e, t = Jn) {
        function n(s) {
            s !== void 0 && parseFloat(s) < 1 && console.warn("THREE.Color: Alpha component of " + e + " will be ignored.")
        }
        let i;
        if (i = /^(\w+)\(([^\)]*)\)/.exec(e)) {
            let s;
            const o = i[1],
                a = i[2];
            switch (o) {
                case "rgb":
                case "rgba":
                    if (s = /^\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(s[4]), this.setRGB(Math.min(255, parseInt(s[1], 10)) / 255, Math.min(255, parseInt(s[2], 10)) / 255, Math.min(255, parseInt(s[3], 10)) / 255, t);
                    if (s = /^\s*(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(s[4]), this.setRGB(Math.min(100, parseInt(s[1], 10)) / 100, Math.min(100, parseInt(s[2], 10)) / 100, Math.min(100, parseInt(s[3], 10)) / 100, t);
                    break;
                case "hsl":
                case "hsla":
                    if (s = /^\s*(\d*\.?\d+)\s*,\s*(\d*\.?\d+)\%\s*,\s*(\d*\.?\d+)\%\s*(?:,\s*(\d*\.?\d+)\s*)?$/.exec(a)) return n(s[4]), this.setHSL(parseFloat(s[1]) / 360, parseFloat(s[2]) / 100, parseFloat(s[3]) / 100, t);
                    break;
                default:
                    console.warn("THREE.Color: Unknown color model " + e)
            }
        } else if (i = /^\#([A-Fa-f\d]+)$/.exec(e)) {
            const s = i[1],
                o = s.length;
            if (o === 3) return this.setRGB(parseInt(s.charAt(0), 16) / 15, parseInt(s.charAt(1), 16) / 15, parseInt(s.charAt(2), 16) / 15, t);
            if (o === 6) return this.setHex(parseInt(s, 16), t);
            console.warn("THREE.Color: Invalid hex color " + e)
        } else if (e && e.length > 0) return this.setColorName(e, t);
        return this
    }
    setColorName(e, t = Jn) {
        const n = dB[e.toLowerCase()];
        return n !== void 0 ? this.setHex(n, t) : console.warn("THREE.Color: Unknown color " + e), this
    }
    clone() {
        return new this.constructor(this.r, this.g, this.b)
    }
    copy(e) {
        return this.r = e.r, this.g = e.g, this.b = e.b, this
    }
    copySRGBToLinear(e) {
        return this.r = ya(e.r), this.g = ya(e.g), this.b = ya(e.b), this
    }
    copyLinearToSRGB(e) {
        return this.r = Bf(e.r), this.g = Bf(e.g), this.b = Bf(e.b), this
    }
    convertSRGBToLinear() {
        return this.copySRGBToLinear(this), this
    }
    convertLinearToSRGB() {
        return this.copyLinearToSRGB(this), this
    }
    getHex(e = Jn) {
        return xn.fromWorkingColorSpace(ar.copy(this), e), Math.round(fi(ar.r * 255, 0, 255)) * 65536 + Math.round(fi(ar.g * 255, 0, 255)) * 256 + Math.round(fi(ar.b * 255, 0, 255))
    }
    getHexString(e = Jn) {
        return ("000000" + this.getHex(e).toString(16)).slice(-6)
    }
    getHSL(e, t = xn.workingColorSpace) {
        xn.fromWorkingColorSpace(ar.copy(this), t);
        const n = ar.r,
            i = ar.g,
            s = ar.b,
            o = Math.max(n, i, s),
            a = Math.min(n, i, s);
        let l, c;
        const u = (a + o) / 2;
        if (a === o) l = 0, c = 0;
        else {
            const f = o - a;
            switch (c = u <= .5 ? f / (o + a) : f / (2 - o - a), o) {
                case n:
                    l = (i - s) / f + (i < s ? 6 : 0);
                    break;
                case i:
                    l = (s - n) / f + 2;
                    break;
                case s:
                    l = (n - i) / f + 4;
                    break
            }
            l /= 6
        }
        return e.h = l, e.s = c, e.l = u, e
    }
    getRGB(e, t = xn.workingColorSpace) {
        return xn.fromWorkingColorSpace(ar.copy(this), t), e.r = ar.r, e.g = ar.g, e.b = ar.b, e
    }
    getStyle(e = Jn) {
        xn.fromWorkingColorSpace(ar.copy(this), e);
        const t = ar.r,
            n = ar.g,
            i = ar.b;
        return e !== Jn ? `color(${e} ${t.toFixed(3)} ${n.toFixed(3)} ${i.toFixed(3)})` : `rgb(${Math.round(t*255)},${Math.round(n*255)},${Math.round(i*255)})`
    }
    offsetHSL(e, t, n) {
        return this.getHSL(Va), this.setHSL(Va.h + e, Va.s + t, Va.l + n)
    }
    add(e) {
        return this.r += e.r, this.g += e.g, this.b += e.b, this
    }
    addColors(e, t) {
        return this.r = e.r + t.r, this.g = e.g + t.g, this.b = e.b + t.b, this
    }
    addScalar(e) {
        return this.r += e, this.g += e, this.b += e, this
    }
    sub(e) {
        return this.r = Math.max(0, this.r - e.r), this.g = Math.max(0, this.g - e.g), this.b = Math.max(0, this.b - e.b), this
    }
    multiply(e) {
        return this.r *= e.r, this.g *= e.g, this.b *= e.b, this
    }
    multiplyScalar(e) {
        return this.r *= e, this.g *= e, this.b *= e, this
    }
    lerp(e, t) {
        return this.r += (e.r - this.r) * t, this.g += (e.g - this.g) * t, this.b += (e.b - this.b) * t, this
    }
    lerpColors(e, t, n) {
        return this.r = e.r + (t.r - e.r) * n, this.g = e.g + (t.g - e.g) * n, this.b = e.b + (t.b - e.b) * n, this
    }
    lerpHSL(e, t) {
        this.getHSL(Va), e.getHSL(Sg);
        const n = Xd(Va.h, Sg.h, t),
            i = Xd(Va.s, Sg.s, t),
            s = Xd(Va.l, Sg.l, t);
        return this.setHSL(n, i, s), this
    }
    setFromVector3(e) {
        return this.r = e.x, this.g = e.y, this.b = e.z, this
    }
    applyMatrix3(e) {
        const t = this.r,
            n = this.g,
            i = this.b,
            s = e.elements;
        return this.r = s[0] * t + s[3] * n + s[6] * i, this.g = s[1] * t + s[4] * n + s[7] * i, this.b = s[2] * t + s[5] * n + s[8] * i, this
    }
    equals(e) {
        return e.r === this.r && e.g === this.g && e.b === this.b
    }
    fromArray(e, t = 0) {
        return this.r = e[t], this.g = e[t + 1], this.b = e[t + 2], this
    }
    toArray(e = [], t = 0) {
        return e[t] = this.r, e[t + 1] = this.g, e[t + 2] = this.b, e
    }
    fromBufferAttribute(e, t) {
        return this.r = e.getX(t), this.g = e.getY(t), this.b = e.getZ(t), this
    }
    toJSON() {
        return this.getHex()
    }*[Symbol.iterator]() {
        yield this.r, yield this.g, yield this.b
    }
}
const ar = new rt;
rt.NAMES = dB;
let yk = 0;
class mi extends ws {
    static get type() {
        return "Material"
    }
    get type() {
        return this.constructor.type
    }
    set type(e) {}
    constructor() {
        super(), this.isMaterial = !0, Object.defineProperty(this, "id", {
            value: yk++
        }), this.uuid = ys(), this.name = "", this.blending = Xc, this.side = Zs, this.vertexColors = !1, this.opacity = 1, this.transparent = !1, this.alphaHash = !1, this.blendSrc = q0, this.blendDst = Z0, this.blendEquation = tl, this.blendSrcAlpha = null, this.blendDstAlpha = null, this.blendEquationAlpha = null, this.blendColor = new rt(0, 0, 0), this.blendAlpha = 0, this.depthFunc = su, this.depthTest = !0, this.depthWrite = !0, this.stencilWriteMask = 255, this.stencilFunc = hA, this.stencilRef = 0, this.stencilFuncMask = 255, this.stencilFail = Mc, this.stencilZFail = Mc, this.stencilZPass = Mc, this.stencilWrite = !1, this.clippingPlanes = null, this.clipIntersection = !1, this.clipShadows = !1, this.shadowSide = null, this.colorWrite = !0, this.precision = null, this.polygonOffset = !1, this.polygonOffsetFactor = 0, this.polygonOffsetUnits = 0, this.dithering = !1, this.alphaToCoverage = !1, this.premultipliedAlpha = !1, this.forceSinglePass = !1, this.visible = !0, this.toneMapped = !0, this.userData = {}, this.version = 0, this._alphaTest = 0
    }
    get alphaTest() {
        return this._alphaTest
    }
    set alphaTest(e) {
        this._alphaTest > 0 != e > 0 && this.version++, this._alphaTest = e
    }
    onBeforeRender() {}
    onBeforeCompile() {}
    customProgramCacheKey() {
        return this.onBeforeCompile.toString()
    }
    setValues(e) {
        if (e !== void 0)
            for (const t in e) {
                const n = e[t];
                if (n === void 0) {
                    console.warn(`THREE.Material: parameter '${t}' has value of undefined.`);
                    continue
                }
                const i = this[t];
                if (i === void 0) {
                    console.warn(`THREE.Material: '${t}' is not a property of THREE.${this.type}.`);
                    continue
                }
                i && i.isColor ? i.set(n) : i && i.isVector3 && n && n.isVector3 ? i.copy(n) : this[t] = n
            }
    }
    toJSON(e) {
        const t = e === void 0 || typeof e == "string";
        t && (e = {
            textures: {},
            images: {}
        });
        const n = {
            metadata: {
                version: 4.6,
                type: "Material",
                generator: "Material.toJSON"
            }
        };
        n.uuid = this.uuid, n.type = this.type, this.name !== "" && (n.name = this.name), this.color && this.color.isColor && (n.color = this.color.getHex()), this.roughness !== void 0 && (n.roughness = this.roughness), this.metalness !== void 0 && (n.metalness = this.metalness), this.sheen !== void 0 && (n.sheen = this.sheen), this.sheenColor && this.sheenColor.isColor && (n.sheenColor = this.sheenColor.getHex()), this.sheenRoughness !== void 0 && (n.sheenRoughness = this.sheenRoughness), this.emissive && this.emissive.isColor && (n.emissive = this.emissive.getHex()), this.emissiveIntensity !== void 0 && this.emissiveIntensity !== 1 && (n.emissiveIntensity = this.emissiveIntensity), this.specular && this.specular.isColor && (n.specular = this.specular.getHex()), this.specularIntensity !== void 0 && (n.specularIntensity = this.specularIntensity), this.specularColor && this.specularColor.isColor && (n.specularColor = this.specularColor.getHex()), this.shininess !== void 0 && (n.shininess = this.shininess), this.clearcoat !== void 0 && (n.clearcoat = this.clearcoat), this.clearcoatRoughness !== void 0 && (n.clearcoatRoughness = this.clearcoatRoughness), this.clearcoatMap && this.clearcoatMap.isTexture && (n.clearcoatMap = this.clearcoatMap.toJSON(e).uuid), this.clearcoatRoughnessMap && this.clearcoatRoughnessMap.isTexture && (n.clearcoatRoughnessMap = this.clearcoatRoughnessMap.toJSON(e).uuid), this.clearcoatNormalMap && this.clearcoatNormalMap.isTexture && (n.clearcoatNormalMap = this.clearcoatNormalMap.toJSON(e).uuid, n.clearcoatNormalScale = this.clearcoatNormalScale.toArray()), this.dispersion !== void 0 && (n.dispersion = this.dispersion), this.iridescence !== void 0 && (n.iridescence = this.iridescence), this.iridescenceIOR !== void 0 && (n.iridescenceIOR = this.iridescenceIOR), this.iridescenceThicknessRange !== void 0 && (n.iridescenceThicknessRange = this.iridescenceThicknessRange), this.iridescenceMap && this.iridescenceMap.isTexture && (n.iridescenceMap = this.iridescenceMap.toJSON(e).uuid), this.iridescenceThicknessMap && this.iridescenceThicknessMap.isTexture && (n.iridescenceThicknessMap = this.iridescenceThicknessMap.toJSON(e).uuid), this.anisotropy !== void 0 && (n.anisotropy = this.anisotropy), this.anisotropyRotation !== void 0 && (n.anisotropyRotation = this.anisotropyRotation), this.anisotropyMap && this.anisotropyMap.isTexture && (n.anisotropyMap = this.anisotropyMap.toJSON(e).uuid), this.map && this.map.isTexture && (n.map = this.map.toJSON(e).uuid), this.matcap && this.matcap.isTexture && (n.matcap = this.matcap.toJSON(e).uuid), this.alphaMap && this.alphaMap.isTexture && (n.alphaMap = this.alphaMap.toJSON(e).uuid), this.lightMap && this.lightMap.isTexture && (n.lightMap = this.lightMap.toJSON(e).uuid, n.lightMapIntensity = this.lightMapIntensity), this.aoMap && this.aoMap.isTexture && (n.aoMap = this.aoMap.toJSON(e).uuid, n.aoMapIntensity = this.aoMapIntensity), this.bumpMap && this.bumpMap.isTexture && (n.bumpMap = this.bumpMap.toJSON(e).uuid, n.bumpScale = this.bumpScale), this.normalMap && this.normalMap.isTexture && (n.normalMap = this.normalMap.toJSON(e).uuid, n.normalMapType = this.normalMapType, n.normalScale = this.normalScale.toArray()), this.displacementMap && this.displacementMap.isTexture && (n.displacementMap = this.displacementMap.toJSON(e).uuid, n.displacementScale = this.displacementScale, n.displacementBias = this.displacementBias), this.roughnessMap && this.roughnessMap.isTexture && (n.roughnessMap = this.roughnessMap.toJSON(e).uuid), this.metalnessMap && this.metalnessMap.isTexture && (n.metalnessMap = this.metalnessMap.toJSON(e).uuid), this.emissiveMap && this.emissiveMap.isTexture && (n.emissiveMap = this.emissiveMap.toJSON(e).uuid), this.specularMap && this.specularMap.isTexture && (n.specularMap = this.specularMap.toJSON(e).uuid), this.specularIntensityMap && this.specularIntensityMap.isTexture && (n.specularIntensityMap = this.specularIntensityMap.toJSON(e).uuid), this.specularColorMap && this.specularColorMap.isTexture && (n.specularColorMap = this.specularColorMap.toJSON(e).uuid), this.envMap && this.envMap.isTexture && (n.envMap = this.envMap.toJSON(e).uuid, this.combine !== void 0 && (n.combine = this.combine)), this.envMapRotation !== void 0 && (n.envMapRotation = this.envMapRotation.toArray()), this.envMapIntensity !== void 0 && (n.envMapIntensity = this.envMapIntensity), this.reflectivity !== void 0 && (n.reflectivity = this.reflectivity), this.refractionRatio !== void 0 && (n.refractionRatio = this.refractionRatio), this.gradientMap && this.gradientMap.isTexture && (n.gradientMap = this.gradientMap.toJSON(e).uuid), this.transmission !== void 0 && (n.transmission = this.transmission), this.transmissionMap && this.transmissionMap.isTexture && (n.transmissionMap = this.transmissionMap.toJSON(e).uuid), this.thickness !== void 0 && (n.thickness = this.thickness), this.thicknessMap && this.thicknessMap.isTexture && (n.thicknessMap = this.thicknessMap.toJSON(e).uuid), this.attenuationDistance !== void 0 && this.attenuationDistance !== 1 / 0 && (n.attenuationDistance = this.attenuationDistance), this.attenuationColor !== void 0 && (n.attenuationColor = this.attenuationColor.getHex()), this.size !== void 0 && (n.size = this.size), this.shadowSide !== null && (n.shadowSide = this.shadowSide), this.sizeAttenuation !== void 0 && (n.sizeAttenuation = this.sizeAttenuation), this.blending !== Xc && (n.blending = this.blending), this.side !== Zs && (n.side = this.side), this.vertexColors === !0 && (n.vertexColors = !0), this.opacity < 1 && (n.opacity = this.opacity), this.transparent === !0 && (n.transparent = !0), this.blendSrc !== q0 && (n.blendSrc = this.blendSrc), this.blendDst !== Z0 && (n.blendDst = this.blendDst), this.blendEquation !== tl && (n.blendEquation = this.blendEquation), this.blendSrcAlpha !== null && (n.blendSrcAlpha = this.blendSrcAlpha), this.blendDstAlpha !== null && (n.blendDstAlpha = this.blendDstAlpha), this.blendEquationAlpha !== null && (n.blendEquationAlpha = this.blendEquationAlpha), this.blendColor && this.blendColor.isColor && (n.blendColor = this.blendColor.getHex()), this.blendAlpha !== 0 && (n.blendAlpha = this.blendAlpha), this.depthFunc !== su && (n.depthFunc = this.depthFunc), this.depthTest === !1 && (n.depthTest = this.depthTest), this.depthWrite === !1 && (n.depthWrite = this.depthWrite), this.colorWrite === !1 && (n.colorWrite = this.colorWrite), this.stencilWriteMask !== 255 && (n.stencilWriteMask = this.stencilWriteMask), this.stencilFunc !== hA && (n.stencilFunc = this.stencilFunc), this.stencilRef !== 0 && (n.stencilRef = this.stencilRef), this.stencilFuncMask !== 255 && (n.stencilFuncMask = this.stencilFuncMask), this.stencilFail !== Mc && (n.stencilFail = this.stencilFail), this.stencilZFail !== Mc && (n.stencilZFail = this.stencilZFail), this.stencilZPass !== Mc && (n.stencilZPass = this.stencilZPass), this.stencilWrite === !0 && (n.stencilWrite = this.stencilWrite), this.rotation !== void 0 && this.rotation !== 0 && (n.rotation = this.rotation), this.polygonOffset === !0 && (n.polygonOffset = !0), this.polygonOffsetFactor !== 0 && (n.polygonOffsetFactor = this.polygonOffsetFactor), this.polygonOffsetUnits !== 0 && (n.polygonOffsetUnits = this.polygonOffsetUnits), this.linewidth !== void 0 && this.linewidth !== 1 && (n.linewidth = this.linewidth), this.dashSize !== void 0 && (n.dashSize = this.dashSize), this.gapSize !== void 0 && (n.gapSize = this.gapSize), this.scale !== void 0 && (n.scale = this.scale), this.dithering === !0 && (n.dithering = !0), this.alphaTest > 0 && (n.alphaTest = this.alphaTest), this.alphaHash === !0 && (n.alphaHash = !0), this.alphaToCoverage === !0 && (n.alphaToCoverage = !0), this.premultipliedAlpha === !0 && (n.premultipliedAlpha = !0), this.forceSinglePass === !0 && (n.forceSinglePass = !0), this.wireframe === !0 && (n.wireframe = !0), this.wireframeLinewidth > 1 && (n.wireframeLinewidth = this.wireframeLinewidth), this.wireframeLinecap !== "round" && (n.wireframeLinecap = this.wireframeLinecap), this.wireframeLinejoin !== "round" && (n.wireframeLinejoin = this.wireframeLinejoin), this.flatShading === !0 && (n.flatShading = !0), this.visible === !1 && (n.visible = !1), this.toneMapped === !1 && (n.toneMapped = !1), this.fog === !1 && (n.fog = !1), Object.keys(this.userData).length > 0 && (n.userData = this.userData);

        function i(s) {
            const o = [];
            for (const a in s) {
                const l = s[a];
                delete l.metadata, o.push(l)
            }
            return o
        }
        if (t) {
            const s = i(e.textures),
                o = i(e.images);
            s.length > 0 && (n.textures = s), o.length > 0 && (n.images = o)
        }
        return n
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.name = e.name, this.blending = e.blending, this.side = e.side, this.vertexColors = e.vertexColors, this.opacity = e.opacity, this.transparent = e.transparent, this.blendSrc = e.blendSrc, this.blendDst = e.blendDst, this.blendEquation = e.blendEquation, this.blendSrcAlpha = e.blendSrcAlpha, this.blendDstAlpha = e.blendDstAlpha, this.blendEquationAlpha = e.blendEquationAlpha, this.blendColor.copy(e.blendColor), this.blendAlpha = e.blendAlpha, this.depthFunc = e.depthFunc, this.depthTest = e.depthTest, this.depthWrite = e.depthWrite, this.stencilWriteMask = e.stencilWriteMask, this.stencilFunc = e.stencilFunc, this.stencilRef = e.stencilRef, this.stencilFuncMask = e.stencilFuncMask, this.stencilFail = e.stencilFail, this.stencilZFail = e.stencilZFail, this.stencilZPass = e.stencilZPass, this.stencilWrite = e.stencilWrite;
        const t = e.clippingPlanes;
        let n = null;
        if (t !== null) {
            const i = t.length;
            n = new Array(i);
            for (let s = 0; s !== i; ++s) n[s] = t[s].clone()
        }
        return this.clippingPlanes = n, this.clipIntersection = e.clipIntersection, this.clipShadows = e.clipShadows, this.shadowSide = e.shadowSide, this.colorWrite = e.colorWrite, this.precision = e.precision, this.polygonOffset = e.polygonOffset, this.polygonOffsetFactor = e.polygonOffsetFactor, this.polygonOffsetUnits = e.polygonOffsetUnits, this.dithering = e.dithering, this.alphaTest = e.alphaTest, this.alphaHash = e.alphaHash, this.alphaToCoverage = e.alphaToCoverage, this.premultipliedAlpha = e.premultipliedAlpha, this.forceSinglePass = e.forceSinglePass, this.visible = e.visible, this.toneMapped = e.toneMapped, this.userData = JSON.parse(JSON.stringify(e.userData)), this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    onBuild() {
        console.warn("Material: onBuild() has been removed.")
    }
}
class Mi extends mi {
    static get type() {
        return "MeshBasicMaterial"
    }
    constructor(e) {
        super(), this.isMeshBasicMaterial = !0, this.color = new rt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new As, this.combine = zp, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
    }
}
const la = _k();

function _k() {
    const r = new ArrayBuffer(4),
        e = new Float32Array(r),
        t = new Uint32Array(r),
        n = new Uint32Array(512),
        i = new Uint32Array(512);
    for (let l = 0; l < 256; ++l) {
        const c = l - 127;
        c < -27 ? (n[l] = 0, n[l | 256] = 32768, i[l] = 24, i[l | 256] = 24) : c < -14 ? (n[l] = 1024 >> -c - 14, n[l | 256] = 1024 >> -c - 14 | 32768, i[l] = -c - 1, i[l | 256] = -c - 1) : c <= 15 ? (n[l] = c + 15 << 10, n[l | 256] = c + 15 << 10 | 32768, i[l] = 13, i[l | 256] = 13) : c < 128 ? (n[l] = 31744, n[l | 256] = 64512, i[l] = 24, i[l | 256] = 24) : (n[l] = 31744, n[l | 256] = 64512, i[l] = 13, i[l | 256] = 13)
    }
    const s = new Uint32Array(2048),
        o = new Uint32Array(64),
        a = new Uint32Array(64);
    for (let l = 1; l < 1024; ++l) {
        let c = l << 13,
            u = 0;
        for (; !(c & 8388608);) c <<= 1, u -= 8388608;
        c &= -8388609, u += 947912704, s[l] = c | u
    }
    for (let l = 1024; l < 2048; ++l) s[l] = 939524096 + (l - 1024 << 13);
    for (let l = 1; l < 31; ++l) o[l] = l << 23;
    o[31] = 1199570944, o[32] = 2147483648;
    for (let l = 33; l < 63; ++l) o[l] = 2147483648 + (l - 32 << 23);
    o[63] = 3347054592;
    for (let l = 1; l < 64; ++l) l !== 32 && (a[l] = 1024);
    return {
        floatView: e,
        uint32View: t,
        baseTable: n,
        shiftTable: i,
        mantissaTable: s,
        exponentTable: o,
        offsetTable: a
    }
}

function Wr(r) {
    Math.abs(r) > 65504 && console.warn("THREE.DataUtils.toHalfFloat(): Value out of range."), r = fi(r, -65504, 65504), la.floatView[0] = r;
    const e = la.uint32View[0],
        t = e >> 23 & 511;
    return la.baseTable[t] + ((e & 8388607) >> la.shiftTable[t])
}

function Sd(r) {
    const e = r >> 10;
    return la.uint32View[0] = la.mantissaTable[la.offsetTable[e] + (r & 1023)] + la.exponentTable[e], la.floatView[0]
}
const Lc = {
        toHalfFloat: Wr,
        fromHalfFloat: Sd
    },
    Ti = new K,
    Mg = new Ue;
class an {
    constructor(e, t, n = !1) {
        if (Array.isArray(e)) throw new TypeError("THREE.BufferAttribute: array should be a Typed Array.");
        this.isBufferAttribute = !0, this.name = "", this.array = e, this.itemSize = t, this.count = e !== void 0 ? e.length / t : 0, this.normalized = n, this.usage = mp, this.updateRanges = [], this.gpuType = Bn, this.version = 0
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e, this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.name = e.name, this.array = new e.array.constructor(e.array), this.itemSize = e.itemSize, this.count = e.count, this.normalized = e.normalized, this.usage = e.usage, this.gpuType = e.gpuType, this
    }
    copyAt(e, t, n) {
        e *= this.itemSize, n *= t.itemSize;
        for (let i = 0, s = this.itemSize; i < s; i++) this.array[e + i] = t.array[n + i];
        return this
    }
    copyArray(e) {
        return this.array.set(e), this
    }
    applyMatrix3(e) {
        if (this.itemSize === 2)
            for (let t = 0, n = this.count; t < n; t++) Mg.fromBufferAttribute(this, t), Mg.applyMatrix3(e), this.setXY(t, Mg.x, Mg.y);
        else if (this.itemSize === 3)
            for (let t = 0, n = this.count; t < n; t++) Ti.fromBufferAttribute(this, t), Ti.applyMatrix3(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
        return this
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.count; t < n; t++) Ti.fromBufferAttribute(this, t), Ti.applyMatrix4(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++) Ti.fromBufferAttribute(this, t), Ti.applyNormalMatrix(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++) Ti.fromBufferAttribute(this, t), Ti.transformDirection(e), this.setXYZ(t, Ti.x, Ti.y, Ti.z);
        return this
    }
    set(e, t = 0) {
        return this.array.set(e, t), this
    }
    getComponent(e, t) {
        let n = this.array[e * this.itemSize + t];
        return this.normalized && (n = Ur(n, this.array)), n
    }
    setComponent(e, t, n) {
        return this.normalized && (n = Kt(n, this.array)), this.array[e * this.itemSize + t] = n, this
    }
    getX(e) {
        let t = this.array[e * this.itemSize];
        return this.normalized && (t = Ur(t, this.array)), t
    }
    setX(e, t) {
        return this.normalized && (t = Kt(t, this.array)), this.array[e * this.itemSize] = t, this
    }
    getY(e) {
        let t = this.array[e * this.itemSize + 1];
        return this.normalized && (t = Ur(t, this.array)), t
    }
    setY(e, t) {
        return this.normalized && (t = Kt(t, this.array)), this.array[e * this.itemSize + 1] = t, this
    }
    getZ(e) {
        let t = this.array[e * this.itemSize + 2];
        return this.normalized && (t = Ur(t, this.array)), t
    }
    setZ(e, t) {
        return this.normalized && (t = Kt(t, this.array)), this.array[e * this.itemSize + 2] = t, this
    }
    getW(e) {
        let t = this.array[e * this.itemSize + 3];
        return this.normalized && (t = Ur(t, this.array)), t
    }
    setW(e, t) {
        return this.normalized && (t = Kt(t, this.array)), this.array[e * this.itemSize + 3] = t, this
    }
    setXY(e, t, n) {
        return e *= this.itemSize, this.normalized && (t = Kt(t, this.array), n = Kt(n, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this
    }
    setXYZ(e, t, n, i) {
        return e *= this.itemSize, this.normalized && (t = Kt(t, this.array), n = Kt(n, this.array), i = Kt(i, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this
    }
    setXYZW(e, t, n, i, s) {
        return e *= this.itemSize, this.normalized && (t = Kt(t, this.array), n = Kt(n, this.array), i = Kt(i, this.array), s = Kt(s, this.array)), this.array[e + 0] = t, this.array[e + 1] = n, this.array[e + 2] = i, this.array[e + 3] = s, this
    }
    onUpload(e) {
        return this.onUploadCallback = e, this
    }
    clone() {
        return new this.constructor(this.array, this.itemSize).copy(this)
    }
    toJSON() {
        const e = {
            itemSize: this.itemSize,
            type: this.array.constructor.name,
            array: Array.from(this.array),
            normalized: this.normalized
        };
        return this.name !== "" && (e.name = this.name), this.usage !== mp && (e.usage = this.usage), e
    }
}
class xk extends an {
    constructor(e, t, n) {
        super(new Int8Array(e), t, n)
    }
}
class Ak extends an {
    constructor(e, t, n) {
        super(new Uint8Array(e), t, n)
    }
}
class Sk extends an {
    constructor(e, t, n) {
        super(new Uint8ClampedArray(e), t, n)
    }
}
class Mk extends an {
    constructor(e, t, n) {
        super(new Int16Array(e), t, n)
    }
}
class jS extends an {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n)
    }
}
class wk extends an {
    constructor(e, t, n) {
        super(new Int32Array(e), t, n)
    }
}
class XS extends an {
    constructor(e, t, n) {
        super(new Uint32Array(e), t, n)
    }
}
class bk extends an {
    constructor(e, t, n) {
        super(new Uint16Array(e), t, n), this.isFloat16BufferAttribute = !0
    }
    getX(e) {
        let t = Sd(this.array[e * this.itemSize]);
        return this.normalized && (t = Ur(t, this.array)), t
    }
    setX(e, t) {
        return this.normalized && (t = Kt(t, this.array)), this.array[e * this.itemSize] = Wr(t), this
    }
    getY(e) {
        let t = Sd(this.array[e * this.itemSize + 1]);
        return this.normalized && (t = Ur(t, this.array)), t
    }
    setY(e, t) {
        return this.normalized && (t = Kt(t, this.array)), this.array[e * this.itemSize + 1] = Wr(t), this
    }
    getZ(e) {
        let t = Sd(this.array[e * this.itemSize + 2]);
        return this.normalized && (t = Ur(t, this.array)), t
    }
    setZ(e, t) {
        return this.normalized && (t = Kt(t, this.array)), this.array[e * this.itemSize + 2] = Wr(t), this
    }
    getW(e) {
        let t = Sd(this.array[e * this.itemSize + 3]);
        return this.normalized && (t = Ur(t, this.array)), t
    }
    setW(e, t) {
        return this.normalized && (t = Kt(t, this.array)), this.array[e * this.itemSize + 3] = Wr(t), this
    }
    setXY(e, t, n) {
        return e *= this.itemSize, this.normalized && (t = Kt(t, this.array), n = Kt(n, this.array)), this.array[e + 0] = Wr(t), this.array[e + 1] = Wr(n), this
    }
    setXYZ(e, t, n, i) {
        return e *= this.itemSize, this.normalized && (t = Kt(t, this.array), n = Kt(n, this.array), i = Kt(i, this.array)), this.array[e + 0] = Wr(t), this.array[e + 1] = Wr(n), this.array[e + 2] = Wr(i), this
    }
    setXYZW(e, t, n, i, s) {
        return e *= this.itemSize, this.normalized && (t = Kt(t, this.array), n = Kt(n, this.array), i = Kt(i, this.array), s = Kt(s, this.array)), this.array[e + 0] = Wr(t), this.array[e + 1] = Wr(n), this.array[e + 2] = Wr(i), this.array[e + 3] = Wr(s), this
    }
}
class Et extends an {
    constructor(e, t, n) {
        super(new Float32Array(e), t, n)
    }
}
let Tk = 0;
const Us = new Ot,
    Sx = new vn,
    Yu = new K,
    as = new Wi,
    Jh = new Wi,
    zi = new K;
class zt extends ws {
    constructor() {
        super(), this.isBufferGeometry = !0, Object.defineProperty(this, "id", {
            value: Tk++
        }), this.uuid = ys(), this.name = "", this.type = "BufferGeometry", this.index = null, this.indirect = null, this.attributes = {}, this.morphAttributes = {}, this.morphTargetsRelative = !1, this.groups = [], this.boundingBox = null, this.boundingSphere = null, this.drawRange = {
            start: 0,
            count: 1 / 0
        }, this.userData = {}
    }
    getIndex() {
        return this.index
    }
    setIndex(e) {
        return Array.isArray(e) ? this.index = new(cB(e) ? XS : jS)(e, 1) : this.index = e, this
    }
    setIndirect(e) {
        return this.indirect = e, this
    }
    getIndirect() {
        return this.indirect
    }
    getAttribute(e) {
        return this.attributes[e]
    }
    setAttribute(e, t) {
        return this.attributes[e] = t, this
    }
    deleteAttribute(e) {
        return delete this.attributes[e], this
    }
    hasAttribute(e) {
        return this.attributes[e] !== void 0
    }
    addGroup(e, t, n = 0) {
        this.groups.push({
            start: e,
            count: t,
            materialIndex: n
        })
    }
    clearGroups() {
        this.groups = []
    }
    setDrawRange(e, t) {
        this.drawRange.start = e, this.drawRange.count = t
    }
    applyMatrix4(e) {
        const t = this.attributes.position;
        t !== void 0 && (t.applyMatrix4(e), t.needsUpdate = !0);
        const n = this.attributes.normal;
        if (n !== void 0) {
            const s = new jt().getNormalMatrix(e);
            n.applyNormalMatrix(s), n.needsUpdate = !0
        }
        const i = this.attributes.tangent;
        return i !== void 0 && (i.transformDirection(e), i.needsUpdate = !0), this.boundingBox !== null && this.computeBoundingBox(), this.boundingSphere !== null && this.computeBoundingSphere(), this
    }
    applyQuaternion(e) {
        return Us.makeRotationFromQuaternion(e), this.applyMatrix4(Us), this
    }
    rotateX(e) {
        return Us.makeRotationX(e), this.applyMatrix4(Us), this
    }
    rotateY(e) {
        return Us.makeRotationY(e), this.applyMatrix4(Us), this
    }
    rotateZ(e) {
        return Us.makeRotationZ(e), this.applyMatrix4(Us), this
    }
    translate(e, t, n) {
        return Us.makeTranslation(e, t, n), this.applyMatrix4(Us), this
    }
    scale(e, t, n) {
        return Us.makeScale(e, t, n), this.applyMatrix4(Us), this
    }
    lookAt(e) {
        return Sx.lookAt(e), Sx.updateMatrix(), this.applyMatrix4(Sx.matrix), this
    }
    center() {
        return this.computeBoundingBox(), this.boundingBox.getCenter(Yu).negate(), this.translate(Yu.x, Yu.y, Yu.z), this
    }
    setFromPoints(e) {
        const t = this.getAttribute("position");
        if (t === void 0) {
            const n = [];
            for (let i = 0, s = e.length; i < s; i++) {
                const o = e[i];
                n.push(o.x, o.y, o.z || 0)
            }
            this.setAttribute("position", new Et(n, 3))
        } else {
            for (let n = 0, i = t.count; n < i; n++) {
                const s = e[n];
                t.setXYZ(n, s.x, s.y, s.z || 0)
            }
            e.length > t.count && console.warn("THREE.BufferGeometry: Buffer size too small for points data. Use .dispose() and create a new geometry."), t.needsUpdate = !0
        }
        return this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Wi);
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingBox(): GLBufferAttribute requires a manual bounding box.", this), this.boundingBox.set(new K(-1 / 0, -1 / 0, -1 / 0), new K(1 / 0, 1 / 0, 1 / 0));
            return
        }
        if (e !== void 0) {
            if (this.boundingBox.setFromBufferAttribute(e), t)
                for (let n = 0, i = t.length; n < i; n++) {
                    const s = t[n];
                    as.setFromBufferAttribute(s), this.morphTargetsRelative ? (zi.addVectors(this.boundingBox.min, as.min), this.boundingBox.expandByPoint(zi), zi.addVectors(this.boundingBox.max, as.max), this.boundingBox.expandByPoint(zi)) : (this.boundingBox.expandByPoint(as.min), this.boundingBox.expandByPoint(as.max))
                }
        } else this.boundingBox.makeEmpty();
        (isNaN(this.boundingBox.min.x) || isNaN(this.boundingBox.min.y) || isNaN(this.boundingBox.min.z)) && console.error('THREE.BufferGeometry.computeBoundingBox(): Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this)
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new ji);
        const e = this.attributes.position,
            t = this.morphAttributes.position;
        if (e && e.isGLBufferAttribute) {
            console.error("THREE.BufferGeometry.computeBoundingSphere(): GLBufferAttribute requires a manual bounding sphere.", this), this.boundingSphere.set(new K, 1 / 0);
            return
        }
        if (e) {
            const n = this.boundingSphere.center;
            if (as.setFromBufferAttribute(e), t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s];
                    Jh.setFromBufferAttribute(a), this.morphTargetsRelative ? (zi.addVectors(as.min, Jh.min), as.expandByPoint(zi), zi.addVectors(as.max, Jh.max), as.expandByPoint(zi)) : (as.expandByPoint(Jh.min), as.expandByPoint(Jh.max))
                }
            as.getCenter(n);
            let i = 0;
            for (let s = 0, o = e.count; s < o; s++) zi.fromBufferAttribute(e, s), i = Math.max(i, n.distanceToSquared(zi));
            if (t)
                for (let s = 0, o = t.length; s < o; s++) {
                    const a = t[s],
                        l = this.morphTargetsRelative;
                    for (let c = 0, u = a.count; c < u; c++) zi.fromBufferAttribute(a, c), l && (Yu.fromBufferAttribute(e, c), zi.add(Yu)), i = Math.max(i, n.distanceToSquared(zi))
                }
            this.boundingSphere.radius = Math.sqrt(i), isNaN(this.boundingSphere.radius) && console.error('THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this)
        }
    }
    computeTangents() {
        const e = this.index,
            t = this.attributes;
        if (e === null || t.position === void 0 || t.normal === void 0 || t.uv === void 0) {
            console.error("THREE.BufferGeometry: .computeTangents() failed. Missing required attributes (index, position, normal or uv)");
            return
        }
        const n = t.position,
            i = t.normal,
            s = t.uv;
        this.hasAttribute("tangent") === !1 && this.setAttribute("tangent", new an(new Float32Array(4 * n.count), 4));
        const o = this.getAttribute("tangent"),
            a = [],
            l = [];
        for (let P = 0; P < n.count; P++) a[P] = new K, l[P] = new K;
        const c = new K,
            u = new K,
            f = new K,
            d = new Ue,
            m = new Ue,
            g = new Ue,
            y = new K,
            v = new K;

        function _(P, b, T) {
            c.fromBufferAttribute(n, P), u.fromBufferAttribute(n, b), f.fromBufferAttribute(n, T), d.fromBufferAttribute(s, P), m.fromBufferAttribute(s, b), g.fromBufferAttribute(s, T), u.sub(c), f.sub(c), m.sub(d), g.sub(d);
            const L = 1 / (m.x * g.y - g.x * m.y);
            isFinite(L) && (y.copy(u).multiplyScalar(g.y).addScaledVector(f, -m.y).multiplyScalar(L), v.copy(f).multiplyScalar(m.x).addScaledVector(u, -g.x).multiplyScalar(L), a[P].add(y), a[b].add(y), a[T].add(y), l[P].add(v), l[b].add(v), l[T].add(v))
        }
        let A = this.groups;
        A.length === 0 && (A = [{
            start: 0,
            count: e.count
        }]);
        for (let P = 0, b = A.length; P < b; ++P) {
            const T = A[P],
                L = T.start,
                D = T.count;
            for (let V = L, H = L + D; V < H; V += 3) _(e.getX(V + 0), e.getX(V + 1), e.getX(V + 2))
        }
        const S = new K,
            M = new K,
            C = new K,
            E = new K;

        function R(P) {
            C.fromBufferAttribute(i, P), E.copy(C);
            const b = a[P];
            S.copy(b), S.sub(C.multiplyScalar(C.dot(b))).normalize(), M.crossVectors(E, b);
            const L = M.dot(l[P]) < 0 ? -1 : 1;
            o.setXYZW(P, S.x, S.y, S.z, L)
        }
        for (let P = 0, b = A.length; P < b; ++P) {
            const T = A[P],
                L = T.start,
                D = T.count;
            for (let V = L, H = L + D; V < H; V += 3) R(e.getX(V + 0)), R(e.getX(V + 1)), R(e.getX(V + 2))
        }
    }
    computeVertexNormals() {
        const e = this.index,
            t = this.getAttribute("position");
        if (t !== void 0) {
            let n = this.getAttribute("normal");
            if (n === void 0) n = new an(new Float32Array(t.count * 3), 3), this.setAttribute("normal", n);
            else
                for (let d = 0, m = n.count; d < m; d++) n.setXYZ(d, 0, 0, 0);
            const i = new K,
                s = new K,
                o = new K,
                a = new K,
                l = new K,
                c = new K,
                u = new K,
                f = new K;
            if (e)
                for (let d = 0, m = e.count; d < m; d += 3) {
                    const g = e.getX(d + 0),
                        y = e.getX(d + 1),
                        v = e.getX(d + 2);
                    i.fromBufferAttribute(t, g), s.fromBufferAttribute(t, y), o.fromBufferAttribute(t, v), u.subVectors(o, s), f.subVectors(i, s), u.cross(f), a.fromBufferAttribute(n, g), l.fromBufferAttribute(n, y), c.fromBufferAttribute(n, v), a.add(u), l.add(u), c.add(u), n.setXYZ(g, a.x, a.y, a.z), n.setXYZ(y, l.x, l.y, l.z), n.setXYZ(v, c.x, c.y, c.z)
                } else
                    for (let d = 0, m = t.count; d < m; d += 3) i.fromBufferAttribute(t, d + 0), s.fromBufferAttribute(t, d + 1), o.fromBufferAttribute(t, d + 2), u.subVectors(o, s), f.subVectors(i, s), u.cross(f), n.setXYZ(d + 0, u.x, u.y, u.z), n.setXYZ(d + 1, u.x, u.y, u.z), n.setXYZ(d + 2, u.x, u.y, u.z);
            this.normalizeNormals(), n.needsUpdate = !0
        }
    }
    normalizeNormals() {
        const e = this.attributes.normal;
        for (let t = 0, n = e.count; t < n; t++) zi.fromBufferAttribute(e, t), zi.normalize(), e.setXYZ(t, zi.x, zi.y, zi.z)
    }
    toNonIndexed() {
        function e(a, l) {
            const c = a.array,
                u = a.itemSize,
                f = a.normalized,
                d = new c.constructor(l.length * u);
            let m = 0,
                g = 0;
            for (let y = 0, v = l.length; y < v; y++) {
                a.isInterleavedBufferAttribute ? m = l[y] * a.data.stride + a.offset : m = l[y] * u;
                for (let _ = 0; _ < u; _++) d[g++] = c[m++]
            }
            return new an(d, u, f)
        }
        if (this.index === null) return console.warn("THREE.BufferGeometry.toNonIndexed(): BufferGeometry is already non-indexed."), this;
        const t = new zt,
            n = this.index.array,
            i = this.attributes;
        for (const a in i) {
            const l = i[a],
                c = e(l, n);
            t.setAttribute(a, c)
        }
        const s = this.morphAttributes;
        for (const a in s) {
            const l = [],
                c = s[a];
            for (let u = 0, f = c.length; u < f; u++) {
                const d = c[u],
                    m = e(d, n);
                l.push(m)
            }
            t.morphAttributes[a] = l
        }
        t.morphTargetsRelative = this.morphTargetsRelative;
        const o = this.groups;
        for (let a = 0, l = o.length; a < l; a++) {
            const c = o[a];
            t.addGroup(c.start, c.count, c.materialIndex)
        }
        return t
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "BufferGeometry",
                generator: "BufferGeometry.toJSON"
            }
        };
        if (e.uuid = this.uuid, e.type = this.type, this.name !== "" && (e.name = this.name), Object.keys(this.userData).length > 0 && (e.userData = this.userData), this.parameters !== void 0) {
            const l = this.parameters;
            for (const c in l) l[c] !== void 0 && (e[c] = l[c]);
            return e
        }
        e.data = {
            attributes: {}
        };
        const t = this.index;
        t !== null && (e.data.index = {
            type: t.array.constructor.name,
            array: Array.prototype.slice.call(t.array)
        });
        const n = this.attributes;
        for (const l in n) {
            const c = n[l];
            e.data.attributes[l] = c.toJSON(e.data)
        }
        const i = {};
        let s = !1;
        for (const l in this.morphAttributes) {
            const c = this.morphAttributes[l],
                u = [];
            for (let f = 0, d = c.length; f < d; f++) {
                const m = c[f];
                u.push(m.toJSON(e.data))
            }
            u.length > 0 && (i[l] = u, s = !0)
        }
        s && (e.data.morphAttributes = i, e.data.morphTargetsRelative = this.morphTargetsRelative);
        const o = this.groups;
        o.length > 0 && (e.data.groups = JSON.parse(JSON.stringify(o)));
        const a = this.boundingSphere;
        return a !== null && (e.data.boundingSphere = {
            center: a.center.toArray(),
            radius: a.radius
        }), e
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        this.index = null, this.attributes = {}, this.morphAttributes = {}, this.groups = [], this.boundingBox = null, this.boundingSphere = null;
        const t = {};
        this.name = e.name;
        const n = e.index;
        n !== null && this.setIndex(n.clone(t));
        const i = e.attributes;
        for (const c in i) {
            const u = i[c];
            this.setAttribute(c, u.clone(t))
        }
        const s = e.morphAttributes;
        for (const c in s) {
            const u = [],
                f = s[c];
            for (let d = 0, m = f.length; d < m; d++) u.push(f[d].clone(t));
            this.morphAttributes[c] = u
        }
        this.morphTargetsRelative = e.morphTargetsRelative;
        const o = e.groups;
        for (let c = 0, u = o.length; c < u; c++) {
            const f = o[c];
            this.addGroup(f.start, f.count, f.materialIndex)
        }
        const a = e.boundingBox;
        a !== null && (this.boundingBox = a.clone());
        const l = e.boundingSphere;
        return l !== null && (this.boundingSphere = l.clone()), this.drawRange.start = e.drawRange.start, this.drawRange.count = e.drawRange.count, this.userData = e.userData, this
    }
    dispose() {
        this.dispatchEvent({
            type: "dispose"
        })
    }
}
const iE = new Ot,
    sc = new Ll,
    wg = new ji,
    rE = new K,
    bg = new K,
    Tg = new K,
    Eg = new K,
    Mx = new K,
    Cg = new K,
    sE = new K,
    Rg = new K;
class Tn extends vn {
    constructor(e = new zt, t = new Mi) {
        super(), this.isMesh = !0, this.type = "Mesh", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t), e.morphTargetInfluences !== void 0 && (this.morphTargetInfluences = e.morphTargetInfluences.slice()), e.morphTargetDictionary !== void 0 && (this.morphTargetDictionary = Object.assign({}, e.morphTargetDictionary)), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
                }
            }
        }
    }
    getVertexPosition(e, t) {
        const n = this.geometry,
            i = n.attributes.position,
            s = n.morphAttributes.position,
            o = n.morphTargetsRelative;
        t.fromBufferAttribute(i, e);
        const a = this.morphTargetInfluences;
        if (s && a) {
            Cg.set(0, 0, 0);
            for (let l = 0, c = s.length; l < c; l++) {
                const u = a[l],
                    f = s[l];
                u !== 0 && (Mx.fromBufferAttribute(f, e), o ? Cg.addScaledVector(Mx, u) : Cg.addScaledVector(Mx.sub(t), u))
            }
            t.add(Cg)
        }
        return t
    }
    raycast(e, t) {
        const n = this.geometry,
            i = this.material,
            s = this.matrixWorld;
        i !== void 0 && (n.boundingSphere === null && n.computeBoundingSphere(), wg.copy(n.boundingSphere), wg.applyMatrix4(s), sc.copy(e.ray).recast(e.near), !(wg.containsPoint(sc.origin) === !1 && (sc.intersectSphere(wg, rE) === null || sc.origin.distanceToSquared(rE) > (e.far - e.near) ** 2)) && (iE.copy(s).invert(), sc.copy(e.ray).applyMatrix4(iE), !(n.boundingBox !== null && sc.intersectsBox(n.boundingBox) === !1) && this._computeIntersections(e, t, sc)))
    }
    _computeIntersections(e, t, n) {
        let i;
        const s = this.geometry,
            o = this.material,
            a = s.index,
            l = s.attributes.position,
            c = s.attributes.uv,
            u = s.attributes.uv1,
            f = s.attributes.normal,
            d = s.groups,
            m = s.drawRange;
        if (a !== null)
            if (Array.isArray(o))
                for (let g = 0, y = d.length; g < y; g++) {
                    const v = d[g],
                        _ = o[v.materialIndex],
                        A = Math.max(v.start, m.start),
                        S = Math.min(a.count, Math.min(v.start + v.count, m.start + m.count));
                    for (let M = A, C = S; M < C; M += 3) {
                        const E = a.getX(M),
                            R = a.getX(M + 1),
                            P = a.getX(M + 2);
                        i = Pg(this, _, e, n, c, u, f, E, R, P), i && (i.faceIndex = Math.floor(M / 3), i.face.materialIndex = v.materialIndex, t.push(i))
                    }
                } else {
                    const g = Math.max(0, m.start),
                        y = Math.min(a.count, m.start + m.count);
                    for (let v = g, _ = y; v < _; v += 3) {
                        const A = a.getX(v),
                            S = a.getX(v + 1),
                            M = a.getX(v + 2);
                        i = Pg(this, o, e, n, c, u, f, A, S, M), i && (i.faceIndex = Math.floor(v / 3), t.push(i))
                    }
                } else if (l !== void 0)
                    if (Array.isArray(o))
                        for (let g = 0, y = d.length; g < y; g++) {
                            const v = d[g],
                                _ = o[v.materialIndex],
                                A = Math.max(v.start, m.start),
                                S = Math.min(l.count, Math.min(v.start + v.count, m.start + m.count));
                            for (let M = A, C = S; M < C; M += 3) {
                                const E = M,
                                    R = M + 1,
                                    P = M + 2;
                                i = Pg(this, _, e, n, c, u, f, E, R, P), i && (i.faceIndex = Math.floor(M / 3), i.face.materialIndex = v.materialIndex, t.push(i))
                            }
                        } else {
                            const g = Math.max(0, m.start),
                                y = Math.min(l.count, m.start + m.count);
                            for (let v = g, _ = y; v < _; v += 3) {
                                const A = v,
                                    S = v + 1,
                                    M = v + 2;
                                i = Pg(this, o, e, n, c, u, f, A, S, M), i && (i.faceIndex = Math.floor(v / 3), t.push(i))
                            }
                        }
    }
}

function Ek(r, e, t, n, i, s, o, a) {
    let l;
    if (e.side === di ? l = n.intersectTriangle(o, s, i, !0, a) : l = n.intersectTriangle(i, s, o, e.side === Zs, a), l === null) return null;
    Rg.copy(a), Rg.applyMatrix4(r.matrixWorld);
    const c = t.ray.origin.distanceTo(Rg);
    return c < t.near || c > t.far ? null : {
        distance: c,
        point: Rg.clone(),
        object: r
    }
}

function Pg(r, e, t, n, i, s, o, a, l, c) {
    r.getVertexPosition(a, bg), r.getVertexPosition(l, Tg), r.getVertexPosition(c, Eg);
    const u = Ek(r, e, t, n, bg, Tg, Eg, sE);
    if (u) {
        const f = new K;
        Or.getBarycoord(sE, bg, Tg, Eg, f), i && (u.uv = Or.getInterpolatedAttribute(i, a, l, c, f, new Ue)), s && (u.uv1 = Or.getInterpolatedAttribute(s, a, l, c, f, new Ue)), o && (u.normal = Or.getInterpolatedAttribute(o, a, l, c, f, new K), u.normal.dot(n.direction) > 0 && u.normal.multiplyScalar(-1));
        const d = {
            a,
            b: l,
            c,
            normal: new K,
            materialIndex: 0
        };
        Or.getNormal(bg, Tg, Eg, d.normal), u.face = d, u.barycoord = f
    }
    return u
}
class pu extends zt {
    constructor(e = 1, t = 1, n = 1, i = 1, s = 1, o = 1) {
        super(), this.type = "BoxGeometry", this.parameters = {
            width: e,
            height: t,
            depth: n,
            widthSegments: i,
            heightSegments: s,
            depthSegments: o
        };
        const a = this;
        i = Math.floor(i), s = Math.floor(s), o = Math.floor(o);
        const l = [],
            c = [],
            u = [],
            f = [];
        let d = 0,
            m = 0;
        g("z", "y", "x", -1, -1, n, t, e, o, s, 0), g("z", "y", "x", 1, -1, n, t, -e, o, s, 1), g("x", "z", "y", 1, 1, e, n, t, i, o, 2), g("x", "z", "y", 1, -1, e, n, -t, i, o, 3), g("x", "y", "z", 1, -1, e, t, n, i, s, 4), g("x", "y", "z", -1, -1, e, t, -n, i, s, 5), this.setIndex(l), this.setAttribute("position", new Et(c, 3)), this.setAttribute("normal", new Et(u, 3)), this.setAttribute("uv", new Et(f, 2));

        function g(y, v, _, A, S, M, C, E, R, P, b) {
            const T = M / R,
                L = C / P,
                D = M / 2,
                V = C / 2,
                H = E / 2,
                q = R + 1,
                X = P + 1;
            let oe = 0,
                Y = 0;
            const Z = new K;
            for (let U = 0; U < X; U++) {
                const j = U * L - V;
                for (let te = 0; te < q; te++) {
                    const he = te * T - D;
                    Z[y] = he * A, Z[v] = j * S, Z[_] = H, c.push(Z.x, Z.y, Z.z), Z[y] = 0, Z[v] = 0, Z[_] = E > 0 ? 1 : -1, u.push(Z.x, Z.y, Z.z), f.push(te / R), f.push(1 - U / P), oe += 1
                }
            }
            for (let U = 0; U < P; U++)
                for (let j = 0; j < R; j++) {
                    const te = d + j + q * U,
                        he = d + j + q * (U + 1),
                        $ = d + (j + 1) + q * (U + 1),
                        ne = d + (j + 1) + q * U;
                    l.push(te, he, ne), l.push(he, $, ne), Y += 6
                }
            a.addGroup(m, Y, b), m += Y, d += oe
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new pu(e.width, e.height, e.depth, e.widthSegments, e.heightSegments, e.depthSegments)
    }
}

function $f(r) {
    const e = {};
    for (const t in r) {
        e[t] = {};
        for (const n in r[t]) {
            const i = r[t][n];
            i && (i.isColor || i.isMatrix3 || i.isMatrix4 || i.isVector2 || i.isVector3 || i.isVector4 || i.isTexture || i.isQuaternion) ? i.isRenderTargetTexture ? (console.warn("UniformsUtils: Textures of render targets cannot be cloned via cloneUniforms() or mergeUniforms()."), e[t][n] = null) : e[t][n] = i.clone() : Array.isArray(i) ? e[t][n] = i.slice() : e[t][n] = i
        }
    }
    return e
}

function Cr(r) {
    const e = {};
    for (let t = 0; t < r.length; t++) {
        const n = $f(r[t]);
        for (const i in n) e[i] = n[i]
    }
    return e
}

function Ck(r) {
    const e = [];
    for (let t = 0; t < r.length; t++) e.push(r[t].clone());
    return e
}

function pB(r) {
    const e = r.getRenderTarget();
    return e === null ? r.outputColorSpace : e.isXRRenderTarget === !0 ? e.texture.colorSpace : xn.workingColorSpace
}
const bl = {
    clone: $f,
    merge: Cr
};
var Rk = `void main() {
	gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
}`,
    Pk = `void main() {
	gl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );
}`;
class Fn extends mi {
    static get type() {
        return "ShaderMaterial"
    }
    constructor(e) {
        super(), this.isShaderMaterial = !0, this.defines = {}, this.uniforms = {}, this.uniformsGroups = [], this.vertexShader = Rk, this.fragmentShader = Pk, this.linewidth = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.fog = !1, this.lights = !1, this.clipping = !1, this.forceSinglePass = !0, this.extensions = {
            clipCullDistance: !1,
            multiDraw: !1
        }, this.defaultAttributeValues = {
            color: [1, 1, 1],
            uv: [0, 0],
            uv1: [0, 0]
        }, this.index0AttributeName = void 0, this.uniformsNeedUpdate = !1, this.glslVersion = null, e !== void 0 && this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.fragmentShader = e.fragmentShader, this.vertexShader = e.vertexShader, this.uniforms = $f(e.uniforms), this.uniformsGroups = Ck(e.uniformsGroups), this.defines = Object.assign({}, e.defines), this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.fog = e.fog, this.lights = e.lights, this.clipping = e.clipping, this.extensions = Object.assign({}, e.extensions), this.glslVersion = e.glslVersion, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        t.glslVersion = this.glslVersion, t.uniforms = {};
        for (const i in this.uniforms) {
            const o = this.uniforms[i].value;
            o && o.isTexture ? t.uniforms[i] = {
                type: "t",
                value: o.toJSON(e).uuid
            } : o && o.isColor ? t.uniforms[i] = {
                type: "c",
                value: o.getHex()
            } : o && o.isVector2 ? t.uniforms[i] = {
                type: "v2",
                value: o.toArray()
            } : o && o.isVector3 ? t.uniforms[i] = {
                type: "v3",
                value: o.toArray()
            } : o && o.isVector4 ? t.uniforms[i] = {
                type: "v4",
                value: o.toArray()
            } : o && o.isMatrix3 ? t.uniforms[i] = {
                type: "m3",
                value: o.toArray()
            } : o && o.isMatrix4 ? t.uniforms[i] = {
                type: "m4",
                value: o.toArray()
            } : t.uniforms[i] = {
                value: o
            }
        }
        Object.keys(this.defines).length > 0 && (t.defines = this.defines), t.vertexShader = this.vertexShader, t.fragmentShader = this.fragmentShader, t.lights = this.lights, t.clipping = this.clipping;
        const n = {};
        for (const i in this.extensions) this.extensions[i] === !0 && (n[i] = !0);
        return Object.keys(n).length > 0 && (t.extensions = n), t
    }
}
class Fl extends vn {
    constructor() {
        super(), this.isCamera = !0, this.type = "Camera", this.matrixWorldInverse = new Ot, this.projectionMatrix = new Ot, this.projectionMatrixInverse = new Ot, this.coordinateSystem = Io
    }
    copy(e, t) {
        return super.copy(e, t), this.matrixWorldInverse.copy(e.matrixWorldInverse), this.projectionMatrix.copy(e.projectionMatrix), this.projectionMatrixInverse.copy(e.projectionMatrixInverse), this.coordinateSystem = e.coordinateSystem, this
    }
    getWorldDirection(e) {
        return super.getWorldDirection(e).negate()
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    updateWorldMatrix(e, t) {
        super.updateWorldMatrix(e, t), this.matrixWorldInverse.copy(this.matrixWorld).invert()
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const Wa = new K,
    oE = new Ue,
    aE = new Ue;
let ri = class extends Fl {
    constructor(e = 50, t = 1, n = .1, i = 2e3) {
        super(), this.isPerspectiveCamera = !0, this.type = "PerspectiveCamera", this.fov = e, this.zoom = 1, this.near = n, this.far = i, this.focus = 10, this.aspect = t, this.view = null, this.filmGauge = 35, this.filmOffset = 0, this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t), this.fov = e.fov, this.zoom = e.zoom, this.near = e.near, this.far = e.far, this.focus = e.focus, this.aspect = e.aspect, this.view = e.view === null ? null : Object.assign({}, e.view), this.filmGauge = e.filmGauge, this.filmOffset = e.filmOffset, this
    }
    setFocalLength(e) {
        const t = .5 * this.getFilmHeight() / e;
        this.fov = Qf * 2 * Math.atan(t), this.updateProjectionMatrix()
    }
    getFocalLength() {
        const e = Math.tan(Jc * .5 * this.fov);
        return .5 * this.getFilmHeight() / e
    }
    getEffectiveFOV() {
        return Qf * 2 * Math.atan(Math.tan(Jc * .5 * this.fov) / this.zoom)
    }
    getFilmWidth() {
        return this.filmGauge * Math.min(this.aspect, 1)
    }
    getFilmHeight() {
        return this.filmGauge / Math.max(this.aspect, 1)
    }
    getViewBounds(e, t, n) {
        Wa.set(-1, -1, .5).applyMatrix4(this.projectionMatrixInverse), t.set(Wa.x, Wa.y).multiplyScalar(-e / Wa.z), Wa.set(1, 1, .5).applyMatrix4(this.projectionMatrixInverse), n.set(Wa.x, Wa.y).multiplyScalar(-e / Wa.z)
    }
    getViewSize(e, t) {
        return this.getViewBounds(e, oE, aE), t.subVectors(aE, oE)
    }
    setViewOffset(e, t, n, i, s, o) {
        this.aspect = e / t, this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = this.near;
        let t = e * Math.tan(Jc * .5 * this.fov) / this.zoom,
            n = 2 * t,
            i = this.aspect * n,
            s = -.5 * i;
        const o = this.view;
        if (this.view !== null && this.view.enabled) {
            const l = o.fullWidth,
                c = o.fullHeight;
            s += o.offsetX * i / l, t -= o.offsetY * n / c, i *= o.width / l, n *= o.height / c
        }
        const a = this.filmOffset;
        a !== 0 && (s += e * a / this.getFilmWidth()), this.projectionMatrix.makePerspective(s, s + i, t, t - n, e, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.fov = this.fov, t.object.zoom = this.zoom, t.object.near = this.near, t.object.far = this.far, t.object.focus = this.focus, t.object.aspect = this.aspect, this.view !== null && (t.object.view = Object.assign({}, this.view)), t.object.filmGauge = this.filmGauge, t.object.filmOffset = this.filmOffset, t
    }
};
const Ju = -90,
    Ku = 1;
class YS extends vn {
    constructor(e, t, n) {
        super(), this.type = "CubeCamera", this.renderTarget = n, this.coordinateSystem = null, this.activeMipmapLevel = 0;
        const i = new ri(Ju, Ku, e, t);
        i.layers = this.layers, this.add(i);
        const s = new ri(Ju, Ku, e, t);
        s.layers = this.layers, this.add(s);
        const o = new ri(Ju, Ku, e, t);
        o.layers = this.layers, this.add(o);
        const a = new ri(Ju, Ku, e, t);
        a.layers = this.layers, this.add(a);
        const l = new ri(Ju, Ku, e, t);
        l.layers = this.layers, this.add(l);
        const c = new ri(Ju, Ku, e, t);
        c.layers = this.layers, this.add(c)
    }
    updateCoordinateSystem() {
        const e = this.coordinateSystem,
            t = this.children.concat(),
            [n, i, s, o, a, l] = t;
        for (const c of t) this.remove(c);
        if (e === Io) n.up.set(0, 1, 0), n.lookAt(1, 0, 0), i.up.set(0, 1, 0), i.lookAt(-1, 0, 0), s.up.set(0, 0, -1), s.lookAt(0, 1, 0), o.up.set(0, 0, 1), o.lookAt(0, -1, 0), a.up.set(0, 1, 0), a.lookAt(0, 0, 1), l.up.set(0, 1, 0), l.lookAt(0, 0, -1);
        else if (e === gp) n.up.set(0, -1, 0), n.lookAt(-1, 0, 0), i.up.set(0, -1, 0), i.lookAt(1, 0, 0), s.up.set(0, 0, 1), s.lookAt(0, 1, 0), o.up.set(0, 0, -1), o.lookAt(0, -1, 0), a.up.set(0, -1, 0), a.lookAt(0, 0, 1), l.up.set(0, -1, 0), l.lookAt(0, 0, -1);
        else throw new Error("THREE.CubeCamera.updateCoordinateSystem(): Invalid coordinate system: " + e);
        for (const c of t) this.add(c), c.updateMatrixWorld()
    }
    update(e, t) {
        this.parent === null && this.updateMatrixWorld();
        const {
            renderTarget: n,
            activeMipmapLevel: i
        } = this;
        this.coordinateSystem !== e.coordinateSystem && (this.coordinateSystem = e.coordinateSystem, this.updateCoordinateSystem());
        const [s, o, a, l, c, u] = this.children, f = e.getRenderTarget(), d = e.getActiveCubeFace(), m = e.getActiveMipmapLevel(), g = e.xr.enabled;
        e.xr.enabled = !1;
        const y = n.texture.generateMipmaps;
        n.texture.generateMipmaps = !1, e.setRenderTarget(n, 0, i), e.render(t, s), e.setRenderTarget(n, 1, i), e.render(t, o), e.setRenderTarget(n, 2, i), e.render(t, a), e.setRenderTarget(n, 3, i), e.render(t, l), e.setRenderTarget(n, 4, i), e.render(t, c), n.texture.generateMipmaps = y, e.setRenderTarget(n, 5, i), e.render(t, u), e.setRenderTarget(f, d, m), e.xr.enabled = g, n.texture.needsPMREMUpdate = !0
    }
}
class jp extends gn {
    constructor(e, t, n, i, s, o, a, l, c, u) {
        e = e !== void 0 ? e : [], t = t !== void 0 ? t : ko, super(e, t, n, i, s, o, a, l, c, u), this.isCubeTexture = !0, this.flipY = !1
    }
    get images() {
        return this.image
    }
    set images(e) {
        this.image = e
    }
}
class py extends Zn {
    constructor(e = 1, t = {}) {
        super(e, e, t), this.isWebGLCubeRenderTarget = !0;
        const n = {
                width: e,
                height: e,
                depth: 1
            },
            i = [n, n, n, n, n, n];
        this.texture = new jp(i, t.mapping, t.wrapS, t.wrapT, t.magFilter, t.minFilter, t.format, t.type, t.anisotropy, t.colorSpace), this.texture.isRenderTargetTexture = !0, this.texture.generateMipmaps = t.generateMipmaps !== void 0 ? t.generateMipmaps : !1, this.texture.minFilter = t.minFilter !== void 0 ? t.minFilter : nn
    }
    fromEquirectangularTexture(e, t) {
        this.texture.type = t.type, this.texture.colorSpace = t.colorSpace, this.texture.generateMipmaps = t.generateMipmaps, this.texture.minFilter = t.minFilter, this.texture.magFilter = t.magFilter;
        const n = {
                uniforms: {
                    tEquirect: {
                        value: null
                    }
                },
                vertexShader: `

				varying vec3 vWorldDirection;

				vec3 transformDirection( in vec3 dir, in mat4 matrix ) {

					return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );

				}

				void main() {

					vWorldDirection = transformDirection( position, modelMatrix );

					#include <begin_vertex>
					#include <project_vertex>

				}
			`,
                fragmentShader: `

				uniform sampler2D tEquirect;

				varying vec3 vWorldDirection;

				#include <common>

				void main() {

					vec3 direction = normalize( vWorldDirection );

					vec2 sampleUV = equirectUv( direction );

					gl_FragColor = texture2D( tEquirect, sampleUV );

				}
			`
            },
            i = new pu(5, 5, 5),
            s = new Fn({
                name: "CubemapFromEquirect",
                uniforms: $f(n.uniforms),
                vertexShader: n.vertexShader,
                fragmentShader: n.fragmentShader,
                side: di,
                blending: pi
            });
        s.uniforms.tEquirect.value = t;
        const o = new Tn(i, s),
            a = t.minFilter;
        return t.minFilter === gs && (t.minFilter = nn), new YS(1, 10, this).update(e, o), t.minFilter = a, o.geometry.dispose(), o.material.dispose(), this
    }
    clear(e, t, n, i) {
        const s = e.getRenderTarget();
        for (let o = 0; o < 6; o++) e.setRenderTarget(this, o), e.clear(t, n, i);
        e.setRenderTarget(s)
    }
}
const wx = new K,
    Ik = new K,
    Bk = new jt;
class Br {
    constructor(e = new K(1, 0, 0), t = 0) {
        this.isPlane = !0, this.normal = e, this.constant = t
    }
    set(e, t) {
        return this.normal.copy(e), this.constant = t, this
    }
    setComponents(e, t, n, i) {
        return this.normal.set(e, t, n), this.constant = i, this
    }
    setFromNormalAndCoplanarPoint(e, t) {
        return this.normal.copy(e), this.constant = -t.dot(this.normal), this
    }
    setFromCoplanarPoints(e, t, n) {
        const i = wx.subVectors(n, t).cross(Ik.subVectors(e, t)).normalize();
        return this.setFromNormalAndCoplanarPoint(i, e), this
    }
    copy(e) {
        return this.normal.copy(e.normal), this.constant = e.constant, this
    }
    normalize() {
        const e = 1 / this.normal.length();
        return this.normal.multiplyScalar(e), this.constant *= e, this
    }
    negate() {
        return this.constant *= -1, this.normal.negate(), this
    }
    distanceToPoint(e) {
        return this.normal.dot(e) + this.constant
    }
    distanceToSphere(e) {
        return this.distanceToPoint(e.center) - e.radius
    }
    projectPoint(e, t) {
        return t.copy(e).addScaledVector(this.normal, -this.distanceToPoint(e))
    }
    intersectLine(e, t) {
        const n = e.delta(wx),
            i = this.normal.dot(n);
        if (i === 0) return this.distanceToPoint(e.start) === 0 ? t.copy(e.start) : null;
        const s = -(e.start.dot(this.normal) + this.constant) / i;
        return s < 0 || s > 1 ? null : t.copy(e.start).addScaledVector(n, s)
    }
    intersectsLine(e) {
        const t = this.distanceToPoint(e.start),
            n = this.distanceToPoint(e.end);
        return t < 0 && n > 0 || n < 0 && t > 0
    }
    intersectsBox(e) {
        return e.intersectsPlane(this)
    }
    intersectsSphere(e) {
        return e.intersectsPlane(this)
    }
    coplanarPoint(e) {
        return e.copy(this.normal).multiplyScalar(-this.constant)
    }
    applyMatrix4(e, t) {
        const n = t || Bk.getNormalMatrix(e),
            i = this.coplanarPoint(wx).applyMatrix4(e),
            s = this.normal.applyMatrix3(n).normalize();
        return this.constant = -i.dot(s), this
    }
    translate(e) {
        return this.constant -= e.dot(this.normal), this
    }
    equals(e) {
        return e.normal.equals(this.normal) && e.constant === this.constant
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const oc = new ji,
    Ig = new K;
class Xp {
    constructor(e = new Br, t = new Br, n = new Br, i = new Br, s = new Br, o = new Br) {
        this.planes = [e, t, n, i, s, o]
    }
    set(e, t, n, i, s, o) {
        const a = this.planes;
        return a[0].copy(e), a[1].copy(t), a[2].copy(n), a[3].copy(i), a[4].copy(s), a[5].copy(o), this
    }
    copy(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) t[n].copy(e.planes[n]);
        return this
    }
    setFromProjectionMatrix(e, t = Io) {
        const n = this.planes,
            i = e.elements,
            s = i[0],
            o = i[1],
            a = i[2],
            l = i[3],
            c = i[4],
            u = i[5],
            f = i[6],
            d = i[7],
            m = i[8],
            g = i[9],
            y = i[10],
            v = i[11],
            _ = i[12],
            A = i[13],
            S = i[14],
            M = i[15];
        if (n[0].setComponents(l - s, d - c, v - m, M - _).normalize(), n[1].setComponents(l + s, d + c, v + m, M + _).normalize(), n[2].setComponents(l + o, d + u, v + g, M + A).normalize(), n[3].setComponents(l - o, d - u, v - g, M - A).normalize(), n[4].setComponents(l - a, d - f, v - y, M - S).normalize(), t === Io) n[5].setComponents(l + a, d + f, v + y, M + S).normalize();
        else if (t === gp) n[5].setComponents(a, f, y, S).normalize();
        else throw new Error("THREE.Frustum.setFromProjectionMatrix(): Invalid coordinate system: " + t);
        return this
    }
    intersectsObject(e) {
        if (e.boundingSphere !== void 0) e.boundingSphere === null && e.computeBoundingSphere(), oc.copy(e.boundingSphere).applyMatrix4(e.matrixWorld);
        else {
            const t = e.geometry;
            t.boundingSphere === null && t.computeBoundingSphere(), oc.copy(t.boundingSphere).applyMatrix4(e.matrixWorld)
        }
        return this.intersectsSphere(oc)
    }
    intersectsSprite(e) {
        return oc.center.set(0, 0, 0), oc.radius = .7071067811865476, oc.applyMatrix4(e.matrixWorld), this.intersectsSphere(oc)
    }
    intersectsSphere(e) {
        const t = this.planes,
            n = e.center,
            i = -e.radius;
        for (let s = 0; s < 6; s++)
            if (t[s].distanceToPoint(n) < i) return !1;
        return !0
    }
    intersectsBox(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++) {
            const i = t[n];
            if (Ig.x = i.normal.x > 0 ? e.max.x : e.min.x, Ig.y = i.normal.y > 0 ? e.max.y : e.min.y, Ig.z = i.normal.z > 0 ? e.max.z : e.min.z, i.distanceToPoint(Ig) < 0) return !1
        }
        return !0
    }
    containsPoint(e) {
        const t = this.planes;
        for (let n = 0; n < 6; n++)
            if (t[n].distanceToPoint(e) < 0) return !1;
        return !0
    }
    clone() {
        return new this.constructor().copy(this)
    }
}

function mB() {
    let r = null,
        e = !1,
        t = null,
        n = null;

    function i(s, o) {
        t(s, o), n = r.requestAnimationFrame(i)
    }
    return {
        start: function() {
            e !== !0 && t !== null && (n = r.requestAnimationFrame(i), e = !0)
        },
        stop: function() {
            r.cancelAnimationFrame(n), e = !1
        },
        setAnimationLoop: function(s) {
            t = s
        },
        setContext: function(s) {
            r = s
        }
    }
}

function Dk(r) {
    const e = new WeakMap;

    function t(a, l) {
        const c = a.array,
            u = a.usage,
            f = c.byteLength,
            d = r.createBuffer();
        r.bindBuffer(l, d), r.bufferData(l, c, u), a.onUploadCallback();
        let m;
        if (c instanceof Float32Array) m = r.FLOAT;
        else if (c instanceof Uint16Array) a.isFloat16BufferAttribute ? m = r.HALF_FLOAT : m = r.UNSIGNED_SHORT;
        else if (c instanceof Int16Array) m = r.SHORT;
        else if (c instanceof Uint32Array) m = r.UNSIGNED_INT;
        else if (c instanceof Int32Array) m = r.INT;
        else if (c instanceof Int8Array) m = r.BYTE;
        else if (c instanceof Uint8Array) m = r.UNSIGNED_BYTE;
        else if (c instanceof Uint8ClampedArray) m = r.UNSIGNED_BYTE;
        else throw new Error("THREE.WebGLAttributes: Unsupported buffer data format: " + c);
        return {
            buffer: d,
            type: m,
            bytesPerElement: c.BYTES_PER_ELEMENT,
            version: a.version,
            size: f
        }
    }

    function n(a, l, c) {
        const u = l.array,
            f = l.updateRanges;
        if (r.bindBuffer(c, a), f.length === 0) r.bufferSubData(c, 0, u);
        else {
            f.sort((m, g) => m.start - g.start);
            let d = 0;
            for (let m = 1; m < f.length; m++) {
                const g = f[d],
                    y = f[m];
                y.start <= g.start + g.count + 1 ? g.count = Math.max(g.count, y.start + y.count - g.start) : (++d, f[d] = y)
            }
            f.length = d + 1;
            for (let m = 0, g = f.length; m < g; m++) {
                const y = f[m];
                r.bufferSubData(c, y.start * u.BYTES_PER_ELEMENT, u, y.start, y.count)
            }
            l.clearUpdateRanges()
        }
        l.onUploadCallback()
    }

    function i(a) {
        return a.isInterleavedBufferAttribute && (a = a.data), e.get(a)
    }

    function s(a) {
        a.isInterleavedBufferAttribute && (a = a.data);
        const l = e.get(a);
        l && (r.deleteBuffer(l.buffer), e.delete(a))
    }

    function o(a, l) {
        if (a.isInterleavedBufferAttribute && (a = a.data), a.isGLBufferAttribute) {
            const u = e.get(a);
            (!u || u.version < a.version) && e.set(a, {
                buffer: a.buffer,
                type: a.type,
                bytesPerElement: a.elementSize,
                version: a.version
            });
            return
        }
        const c = e.get(a);
        if (c === void 0) e.set(a, t(a, l));
        else if (c.version < a.version) {
            if (c.size !== a.array.byteLength) throw new Error("THREE.WebGLAttributes: The size of the buffer attribute's array buffer does not match the original size. Resizing buffer attributes is not supported.");
            n(c.buffer, a, l), c.version = a.version
        }
    }
    return {
        get: i,
        remove: s,
        update: o
    }
}
class bs extends zt {
    constructor(e = 1, t = 1, n = 1, i = 1) {
        super(), this.type = "PlaneGeometry", this.parameters = {
            width: e,
            height: t,
            widthSegments: n,
            heightSegments: i
        };
        const s = e / 2,
            o = t / 2,
            a = Math.floor(n),
            l = Math.floor(i),
            c = a + 1,
            u = l + 1,
            f = e / a,
            d = t / l,
            m = [],
            g = [],
            y = [],
            v = [];
        for (let _ = 0; _ < u; _++) {
            const A = _ * d - o;
            for (let S = 0; S < c; S++) {
                const M = S * f - s;
                g.push(M, -A, 0), y.push(0, 0, 1), v.push(S / a), v.push(1 - _ / l)
            }
        }
        for (let _ = 0; _ < l; _++)
            for (let A = 0; A < a; A++) {
                const S = A + c * _,
                    M = A + c * (_ + 1),
                    C = A + 1 + c * (_ + 1),
                    E = A + 1 + c * _;
                m.push(S, M, E), m.push(M, C, E)
            }
        this.setIndex(m), this.setAttribute("position", new Et(g, 3)), this.setAttribute("normal", new Et(y, 3)), this.setAttribute("uv", new Et(v, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new bs(e.width, e.height, e.widthSegments, e.heightSegments)
    }
}
var Lk = `#ifdef USE_ALPHAHASH
	if ( diffuseColor.a < getAlphaHashThreshold( vPosition ) ) discard;
#endif`,
    Fk = `#ifdef USE_ALPHAHASH
	const float ALPHA_HASH_SCALE = 0.05;
	float hash2D( vec2 value ) {
		return fract( 1.0e4 * sin( 17.0 * value.x + 0.1 * value.y ) * ( 0.1 + abs( sin( 13.0 * value.y + value.x ) ) ) );
	}
	float hash3D( vec3 value ) {
		return hash2D( vec2( hash2D( value.xy ), value.z ) );
	}
	float getAlphaHashThreshold( vec3 position ) {
		float maxDeriv = max(
			length( dFdx( position.xyz ) ),
			length( dFdy( position.xyz ) )
		);
		float pixScale = 1.0 / ( ALPHA_HASH_SCALE * maxDeriv );
		vec2 pixScales = vec2(
			exp2( floor( log2( pixScale ) ) ),
			exp2( ceil( log2( pixScale ) ) )
		);
		vec2 alpha = vec2(
			hash3D( floor( pixScales.x * position.xyz ) ),
			hash3D( floor( pixScales.y * position.xyz ) )
		);
		float lerpFactor = fract( log2( pixScale ) );
		float x = ( 1.0 - lerpFactor ) * alpha.x + lerpFactor * alpha.y;
		float a = min( lerpFactor, 1.0 - lerpFactor );
		vec3 cases = vec3(
			x * x / ( 2.0 * a * ( 1.0 - a ) ),
			( x - 0.5 * a ) / ( 1.0 - a ),
			1.0 - ( ( 1.0 - x ) * ( 1.0 - x ) / ( 2.0 * a * ( 1.0 - a ) ) )
		);
		float threshold = ( x < ( 1.0 - a ) )
			? ( ( x < a ) ? cases.x : cases.y )
			: cases.z;
		return clamp( threshold , 1.0e-6, 1.0 );
	}
#endif`,
    Uk = `#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, vAlphaMapUv ).g;
#endif`,
    Ok = `#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    Nk = `#ifdef USE_ALPHATEST
	#ifdef ALPHA_TO_COVERAGE
	diffuseColor.a = smoothstep( alphaTest, alphaTest + fwidth( diffuseColor.a ), diffuseColor.a );
	if ( diffuseColor.a == 0.0 ) discard;
	#else
	if ( diffuseColor.a < alphaTest ) discard;
	#endif
#endif`,
    kk = `#ifdef USE_ALPHATEST
	uniform float alphaTest;
#endif`,
    zk = `#ifdef USE_AOMAP
	float ambientOcclusion = ( texture2D( aoMap, vAoMapUv ).r - 1.0 ) * aoMapIntensity + 1.0;
	reflectedLight.indirectDiffuse *= ambientOcclusion;
	#if defined( USE_CLEARCOAT ) 
		clearcoatSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_SHEEN ) 
		sheenSpecularIndirect *= ambientOcclusion;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD )
		float dotNV = saturate( dot( geometryNormal, geometryViewDir ) );
		reflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.roughness );
	#endif
#endif`,
    Gk = `#ifdef USE_AOMAP
	uniform sampler2D aoMap;
	uniform float aoMapIntensity;
#endif`,
    Hk = `#ifdef USE_BATCHING
	#if ! defined( GL_ANGLE_multi_draw )
	#define gl_DrawID _gl_DrawID
	uniform int _gl_DrawID;
	#endif
	uniform highp sampler2D batchingTexture;
	uniform highp usampler2D batchingIdTexture;
	mat4 getBatchingMatrix( const in float i ) {
		int size = textureSize( batchingTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( batchingTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( batchingTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( batchingTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( batchingTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
	float getIndirectIndex( const in int i ) {
		int size = textureSize( batchingIdTexture, 0 ).x;
		int x = i % size;
		int y = i / size;
		return float( texelFetch( batchingIdTexture, ivec2( x, y ), 0 ).r );
	}
#endif
#ifdef USE_BATCHING_COLOR
	uniform sampler2D batchingColorTexture;
	vec3 getBatchingColor( const in float i ) {
		int size = textureSize( batchingColorTexture, 0 ).x;
		int j = int( i );
		int x = j % size;
		int y = j / size;
		return texelFetch( batchingColorTexture, ivec2( x, y ), 0 ).rgb;
	}
#endif`,
    Vk = `#ifdef USE_BATCHING
	mat4 batchingMatrix = getBatchingMatrix( getIndirectIndex( gl_DrawID ) );
#endif`,
    Wk = `vec3 transformed = vec3( position );
#ifdef USE_ALPHAHASH
	vPosition = vec3( position );
#endif`,
    jk = `vec3 objectNormal = vec3( normal );
#ifdef USE_TANGENT
	vec3 objectTangent = vec3( tangent.xyz );
#endif`,
    Xk = `float G_BlinnPhong_Implicit( ) {
	return 0.25;
}
float D_BlinnPhong( const in float shininess, const in float dotNH ) {
	return RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );
}
vec3 BRDF_BlinnPhong( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in vec3 specularColor, const in float shininess ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( specularColor, 1.0, dotVH );
	float G = G_BlinnPhong_Implicit( );
	float D = D_BlinnPhong( shininess, dotNH );
	return F * ( G * D );
} // validated`,
    Yk = `#ifdef USE_IRIDESCENCE
	const mat3 XYZ_TO_REC709 = mat3(
		 3.2404542, -0.9692660,  0.0556434,
		-1.5371385,  1.8760108, -0.2040259,
		-0.4985314,  0.0415560,  1.0572252
	);
	vec3 Fresnel0ToIor( vec3 fresnel0 ) {
		vec3 sqrtF0 = sqrt( fresnel0 );
		return ( vec3( 1.0 ) + sqrtF0 ) / ( vec3( 1.0 ) - sqrtF0 );
	}
	vec3 IorToFresnel0( vec3 transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - vec3( incidentIor ) ) / ( transmittedIor + vec3( incidentIor ) ) );
	}
	float IorToFresnel0( float transmittedIor, float incidentIor ) {
		return pow2( ( transmittedIor - incidentIor ) / ( transmittedIor + incidentIor ));
	}
	vec3 evalSensitivity( float OPD, vec3 shift ) {
		float phase = 2.0 * PI * OPD * 1.0e-9;
		vec3 val = vec3( 5.4856e-13, 4.4201e-13, 5.2481e-13 );
		vec3 pos = vec3( 1.6810e+06, 1.7953e+06, 2.2084e+06 );
		vec3 var = vec3( 4.3278e+09, 9.3046e+09, 6.6121e+09 );
		vec3 xyz = val * sqrt( 2.0 * PI * var ) * cos( pos * phase + shift ) * exp( - pow2( phase ) * var );
		xyz.x += 9.7470e-14 * sqrt( 2.0 * PI * 4.5282e+09 ) * cos( 2.2399e+06 * phase + shift[ 0 ] ) * exp( - 4.5282e+09 * pow2( phase ) );
		xyz /= 1.0685e-7;
		vec3 rgb = XYZ_TO_REC709 * xyz;
		return rgb;
	}
	vec3 evalIridescence( float outsideIOR, float eta2, float cosTheta1, float thinFilmThickness, vec3 baseF0 ) {
		vec3 I;
		float iridescenceIOR = mix( outsideIOR, eta2, smoothstep( 0.0, 0.03, thinFilmThickness ) );
		float sinTheta2Sq = pow2( outsideIOR / iridescenceIOR ) * ( 1.0 - pow2( cosTheta1 ) );
		float cosTheta2Sq = 1.0 - sinTheta2Sq;
		if ( cosTheta2Sq < 0.0 ) {
			return vec3( 1.0 );
		}
		float cosTheta2 = sqrt( cosTheta2Sq );
		float R0 = IorToFresnel0( iridescenceIOR, outsideIOR );
		float R12 = F_Schlick( R0, 1.0, cosTheta1 );
		float T121 = 1.0 - R12;
		float phi12 = 0.0;
		if ( iridescenceIOR < outsideIOR ) phi12 = PI;
		float phi21 = PI - phi12;
		vec3 baseIOR = Fresnel0ToIor( clamp( baseF0, 0.0, 0.9999 ) );		vec3 R1 = IorToFresnel0( baseIOR, iridescenceIOR );
		vec3 R23 = F_Schlick( R1, 1.0, cosTheta2 );
		vec3 phi23 = vec3( 0.0 );
		if ( baseIOR[ 0 ] < iridescenceIOR ) phi23[ 0 ] = PI;
		if ( baseIOR[ 1 ] < iridescenceIOR ) phi23[ 1 ] = PI;
		if ( baseIOR[ 2 ] < iridescenceIOR ) phi23[ 2 ] = PI;
		float OPD = 2.0 * iridescenceIOR * thinFilmThickness * cosTheta2;
		vec3 phi = vec3( phi21 ) + phi23;
		vec3 R123 = clamp( R12 * R23, 1e-5, 0.9999 );
		vec3 r123 = sqrt( R123 );
		vec3 Rs = pow2( T121 ) * R23 / ( vec3( 1.0 ) - R123 );
		vec3 C0 = R12 + Rs;
		I = C0;
		vec3 Cm = Rs - T121;
		for ( int m = 1; m <= 2; ++ m ) {
			Cm *= r123;
			vec3 Sm = 2.0 * evalSensitivity( float( m ) * OPD, float( m ) * phi );
			I += Cm * Sm;
		}
		return max( I, vec3( 0.0 ) );
	}
#endif`,
    Jk = `#ifdef USE_BUMPMAP
	uniform sampler2D bumpMap;
	uniform float bumpScale;
	vec2 dHdxy_fwd() {
		vec2 dSTdx = dFdx( vBumpMapUv );
		vec2 dSTdy = dFdy( vBumpMapUv );
		float Hll = bumpScale * texture2D( bumpMap, vBumpMapUv ).x;
		float dBx = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdx ).x - Hll;
		float dBy = bumpScale * texture2D( bumpMap, vBumpMapUv + dSTdy ).x - Hll;
		return vec2( dBx, dBy );
	}
	vec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy, float faceDirection ) {
		vec3 vSigmaX = normalize( dFdx( surf_pos.xyz ) );
		vec3 vSigmaY = normalize( dFdy( surf_pos.xyz ) );
		vec3 vN = surf_norm;
		vec3 R1 = cross( vSigmaY, vN );
		vec3 R2 = cross( vN, vSigmaX );
		float fDet = dot( vSigmaX, R1 ) * faceDirection;
		vec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );
		return normalize( abs( fDet ) * surf_norm - vGrad );
	}
#endif`,
    Kk = `#if NUM_CLIPPING_PLANES > 0
	vec4 plane;
	#ifdef ALPHA_TO_COVERAGE
		float distanceToPlane, distanceGradient;
		float clipOpacity = 1.0;
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
			distanceGradient = fwidth( distanceToPlane ) / 2.0;
			clipOpacity *= smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			if ( clipOpacity == 0.0 ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			float unionClipOpacity = 1.0;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				distanceToPlane = - dot( vClipPosition, plane.xyz ) + plane.w;
				distanceGradient = fwidth( distanceToPlane ) / 2.0;
				unionClipOpacity *= 1.0 - smoothstep( - distanceGradient, distanceGradient, distanceToPlane );
			}
			#pragma unroll_loop_end
			clipOpacity *= 1.0 - unionClipOpacity;
		#endif
		diffuseColor.a *= clipOpacity;
		if ( diffuseColor.a == 0.0 ) discard;
	#else
		#pragma unroll_loop_start
		for ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {
			plane = clippingPlanes[ i ];
			if ( dot( vClipPosition, plane.xyz ) > plane.w ) discard;
		}
		#pragma unroll_loop_end
		#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES
			bool clipped = true;
			#pragma unroll_loop_start
			for ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {
				plane = clippingPlanes[ i ];
				clipped = ( dot( vClipPosition, plane.xyz ) > plane.w ) && clipped;
			}
			#pragma unroll_loop_end
			if ( clipped ) discard;
		#endif
	#endif
#endif`,
    qk = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
	uniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];
#endif`,
    Zk = `#if NUM_CLIPPING_PLANES > 0
	varying vec3 vClipPosition;
#endif`,
    Qk = `#if NUM_CLIPPING_PLANES > 0
	vClipPosition = - mvPosition.xyz;
#endif`,
    $k = `#if defined( USE_COLOR_ALPHA )
	diffuseColor *= vColor;
#elif defined( USE_COLOR )
	diffuseColor.rgb *= vColor;
#endif`,
    ez = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR )
	varying vec3 vColor;
#endif`,
    tz = `#if defined( USE_COLOR_ALPHA )
	varying vec4 vColor;
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	varying vec3 vColor;
#endif`,
    nz = `#if defined( USE_COLOR_ALPHA )
	vColor = vec4( 1.0 );
#elif defined( USE_COLOR ) || defined( USE_INSTANCING_COLOR ) || defined( USE_BATCHING_COLOR )
	vColor = vec3( 1.0 );
#endif
#ifdef USE_COLOR
	vColor *= color;
#endif
#ifdef USE_INSTANCING_COLOR
	vColor.xyz *= instanceColor.xyz;
#endif
#ifdef USE_BATCHING_COLOR
	vec3 batchingColor = getBatchingColor( getIndirectIndex( gl_DrawID ) );
	vColor.xyz *= batchingColor.xyz;
#endif`,
    iz = `#define PI 3.141592653589793
#define PI2 6.283185307179586
#define PI_HALF 1.5707963267948966
#define RECIPROCAL_PI 0.3183098861837907
#define RECIPROCAL_PI2 0.15915494309189535
#define EPSILON 1e-6
#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
#define whiteComplement( a ) ( 1.0 - saturate( a ) )
float pow2( const in float x ) { return x*x; }
vec3 pow2( const in vec3 x ) { return x*x; }
float pow3( const in float x ) { return x*x*x; }
float pow4( const in float x ) { float x2 = x*x; return x2*x2; }
float max3( const in vec3 v ) { return max( max( v.x, v.y ), v.z ); }
float average( const in vec3 v ) { return dot( v, vec3( 0.3333333 ) ); }
highp float rand( const in vec2 uv ) {
	const highp float a = 12.9898, b = 78.233, c = 43758.5453;
	highp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );
	return fract( sin( sn ) * c );
}
#ifdef HIGH_PRECISION
	float precisionSafeLength( vec3 v ) { return length( v ); }
#else
	float precisionSafeLength( vec3 v ) {
		float maxComponent = max3( abs( v ) );
		return length( v / maxComponent ) * maxComponent;
	}
#endif
struct IncidentLight {
	vec3 color;
	vec3 direction;
	bool visible;
};
struct ReflectedLight {
	vec3 directDiffuse;
	vec3 directSpecular;
	vec3 indirectDiffuse;
	vec3 indirectSpecular;
};
#ifdef USE_ALPHAHASH
	varying vec3 vPosition;
#endif
vec3 transformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );
}
vec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {
	return normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );
}
mat3 transposeMat3( const in mat3 m ) {
	mat3 tmp;
	tmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );
	tmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );
	tmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );
	return tmp;
}
bool isPerspectiveMatrix( mat4 m ) {
	return m[ 2 ][ 3 ] == - 1.0;
}
vec2 equirectUv( in vec3 dir ) {
	float u = atan( dir.z, dir.x ) * RECIPROCAL_PI2 + 0.5;
	float v = asin( clamp( dir.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;
	return vec2( u, v );
}
vec3 BRDF_Lambert( const in vec3 diffuseColor ) {
	return RECIPROCAL_PI * diffuseColor;
}
vec3 F_Schlick( const in vec3 f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
}
float F_Schlick( const in float f0, const in float f90, const in float dotVH ) {
	float fresnel = exp2( ( - 5.55473 * dotVH - 6.98316 ) * dotVH );
	return f0 * ( 1.0 - fresnel ) + ( f90 * fresnel );
} // validated`,
    rz = `#ifdef ENVMAP_TYPE_CUBE_UV
	#define cubeUV_minMipLevel 4.0
	#define cubeUV_minTileSize 16.0
	float getFace( vec3 direction ) {
		vec3 absDirection = abs( direction );
		float face = - 1.0;
		if ( absDirection.x > absDirection.z ) {
			if ( absDirection.x > absDirection.y )
				face = direction.x > 0.0 ? 0.0 : 3.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		} else {
			if ( absDirection.z > absDirection.y )
				face = direction.z > 0.0 ? 2.0 : 5.0;
			else
				face = direction.y > 0.0 ? 1.0 : 4.0;
		}
		return face;
	}
	vec2 getUV( vec3 direction, float face ) {
		vec2 uv;
		if ( face == 0.0 ) {
			uv = vec2( direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 1.0 ) {
			uv = vec2( - direction.x, - direction.z ) / abs( direction.y );
		} else if ( face == 2.0 ) {
			uv = vec2( - direction.x, direction.y ) / abs( direction.z );
		} else if ( face == 3.0 ) {
			uv = vec2( - direction.z, direction.y ) / abs( direction.x );
		} else if ( face == 4.0 ) {
			uv = vec2( - direction.x, direction.z ) / abs( direction.y );
		} else {
			uv = vec2( direction.x, direction.y ) / abs( direction.z );
		}
		return 0.5 * ( uv + 1.0 );
	}
	vec3 bilinearCubeUV( sampler2D envMap, vec3 direction, float mipInt ) {
		float face = getFace( direction );
		float filterInt = max( cubeUV_minMipLevel - mipInt, 0.0 );
		mipInt = max( mipInt, cubeUV_minMipLevel );
		float faceSize = exp2( mipInt );
		highp vec2 uv = getUV( direction, face ) * ( faceSize - 2.0 ) + 1.0;
		if ( face > 2.0 ) {
			uv.y += faceSize;
			face -= 3.0;
		}
		uv.x += face * faceSize;
		uv.x += filterInt * 3.0 * cubeUV_minTileSize;
		uv.y += 4.0 * ( exp2( CUBEUV_MAX_MIP ) - faceSize );
		uv.x *= CUBEUV_TEXEL_WIDTH;
		uv.y *= CUBEUV_TEXEL_HEIGHT;
		#ifdef texture2DGradEXT
			return texture2DGradEXT( envMap, uv, vec2( 0.0 ), vec2( 0.0 ) ).rgb;
		#else
			return texture2D( envMap, uv ).rgb;
		#endif
	}
	#define cubeUV_r0 1.0
	#define cubeUV_m0 - 2.0
	#define cubeUV_r1 0.8
	#define cubeUV_m1 - 1.0
	#define cubeUV_r4 0.4
	#define cubeUV_m4 2.0
	#define cubeUV_r5 0.305
	#define cubeUV_m5 3.0
	#define cubeUV_r6 0.21
	#define cubeUV_m6 4.0
	float roughnessToMip( float roughness ) {
		float mip = 0.0;
		if ( roughness >= cubeUV_r1 ) {
			mip = ( cubeUV_r0 - roughness ) * ( cubeUV_m1 - cubeUV_m0 ) / ( cubeUV_r0 - cubeUV_r1 ) + cubeUV_m0;
		} else if ( roughness >= cubeUV_r4 ) {
			mip = ( cubeUV_r1 - roughness ) * ( cubeUV_m4 - cubeUV_m1 ) / ( cubeUV_r1 - cubeUV_r4 ) + cubeUV_m1;
		} else if ( roughness >= cubeUV_r5 ) {
			mip = ( cubeUV_r4 - roughness ) * ( cubeUV_m5 - cubeUV_m4 ) / ( cubeUV_r4 - cubeUV_r5 ) + cubeUV_m4;
		} else if ( roughness >= cubeUV_r6 ) {
			mip = ( cubeUV_r5 - roughness ) * ( cubeUV_m6 - cubeUV_m5 ) / ( cubeUV_r5 - cubeUV_r6 ) + cubeUV_m5;
		} else {
			mip = - 2.0 * log2( 1.16 * roughness );		}
		return mip;
	}
	vec4 textureCubeUV( sampler2D envMap, vec3 sampleDir, float roughness ) {
		float mip = clamp( roughnessToMip( roughness ), cubeUV_m0, CUBEUV_MAX_MIP );
		float mipF = fract( mip );
		float mipInt = floor( mip );
		vec3 color0 = bilinearCubeUV( envMap, sampleDir, mipInt );
		if ( mipF == 0.0 ) {
			return vec4( color0, 1.0 );
		} else {
			vec3 color1 = bilinearCubeUV( envMap, sampleDir, mipInt + 1.0 );
			return vec4( mix( color0, color1, mipF ), 1.0 );
		}
	}
#endif`,
    sz = `vec3 transformedNormal = objectNormal;
#ifdef USE_TANGENT
	vec3 transformedTangent = objectTangent;
#endif
#ifdef USE_BATCHING
	mat3 bm = mat3( batchingMatrix );
	transformedNormal /= vec3( dot( bm[ 0 ], bm[ 0 ] ), dot( bm[ 1 ], bm[ 1 ] ), dot( bm[ 2 ], bm[ 2 ] ) );
	transformedNormal = bm * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = bm * transformedTangent;
	#endif
#endif
#ifdef USE_INSTANCING
	mat3 im = mat3( instanceMatrix );
	transformedNormal /= vec3( dot( im[ 0 ], im[ 0 ] ), dot( im[ 1 ], im[ 1 ] ), dot( im[ 2 ], im[ 2 ] ) );
	transformedNormal = im * transformedNormal;
	#ifdef USE_TANGENT
		transformedTangent = im * transformedTangent;
	#endif
#endif
transformedNormal = normalMatrix * transformedNormal;
#ifdef FLIP_SIDED
	transformedNormal = - transformedNormal;
#endif
#ifdef USE_TANGENT
	transformedTangent = ( modelViewMatrix * vec4( transformedTangent, 0.0 ) ).xyz;
	#ifdef FLIP_SIDED
		transformedTangent = - transformedTangent;
	#endif
#endif`,
    oz = `#ifdef USE_DISPLACEMENTMAP
	uniform sampler2D displacementMap;
	uniform float displacementScale;
	uniform float displacementBias;
#endif`,
    az = `#ifdef USE_DISPLACEMENTMAP
	transformed += normalize( objectNormal ) * ( texture2D( displacementMap, vDisplacementMapUv ).x * displacementScale + displacementBias );
#endif`,
    lz = `#ifdef USE_EMISSIVEMAP
	vec4 emissiveColor = texture2D( emissiveMap, vEmissiveMapUv );
	#ifdef DECODE_VIDEO_TEXTURE_EMISSIVE
		emissiveColor = sRGBTransferEOTF( emissiveColor );
	#endif
	totalEmissiveRadiance *= emissiveColor.rgb;
#endif`,
    cz = `#ifdef USE_EMISSIVEMAP
	uniform sampler2D emissiveMap;
#endif`,
    uz = "gl_FragColor = linearToOutputTexel( gl_FragColor );",
    fz = `vec4 LinearTransferOETF( in vec4 value ) {
	return value;
}
vec4 sRGBTransferEOTF( in vec4 value ) {
	return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );
}
vec4 sRGBTransferOETF( in vec4 value ) {
	return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );
}`,
    hz = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vec3 cameraToFrag;
		if ( isOrthographic ) {
			cameraToFrag = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToFrag = normalize( vWorldPosition - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vec3 reflectVec = reflect( cameraToFrag, worldNormal );
		#else
			vec3 reflectVec = refract( cameraToFrag, worldNormal, refractionRatio );
		#endif
	#else
		vec3 reflectVec = vReflect;
	#endif
	#ifdef ENVMAP_TYPE_CUBE
		vec4 envColor = textureCube( envMap, envMapRotation * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );
	#else
		vec4 envColor = vec4( 0.0 );
	#endif
	#ifdef ENVMAP_BLENDING_MULTIPLY
		outgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_MIX )
		outgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );
	#elif defined( ENVMAP_BLENDING_ADD )
		outgoingLight += envColor.xyz * specularStrength * reflectivity;
	#endif
#endif`,
    dz = `#ifdef USE_ENVMAP
	uniform float envMapIntensity;
	uniform float flipEnvMap;
	uniform mat3 envMapRotation;
	#ifdef ENVMAP_TYPE_CUBE
		uniform samplerCube envMap;
	#else
		uniform sampler2D envMap;
	#endif
	
#endif`,
    pz = `#ifdef USE_ENVMAP
	uniform float reflectivity;
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		varying vec3 vWorldPosition;
		uniform float refractionRatio;
	#else
		varying vec3 vReflect;
	#endif
#endif`,
    mz = `#ifdef USE_ENVMAP
	#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( LAMBERT )
		#define ENV_WORLDPOS
	#endif
	#ifdef ENV_WORLDPOS
		
		varying vec3 vWorldPosition;
	#else
		varying vec3 vReflect;
		uniform float refractionRatio;
	#endif
#endif`,
    gz = `#ifdef USE_ENVMAP
	#ifdef ENV_WORLDPOS
		vWorldPosition = worldPosition.xyz;
	#else
		vec3 cameraToVertex;
		if ( isOrthographic ) {
			cameraToVertex = normalize( vec3( - viewMatrix[ 0 ][ 2 ], - viewMatrix[ 1 ][ 2 ], - viewMatrix[ 2 ][ 2 ] ) );
		} else {
			cameraToVertex = normalize( worldPosition.xyz - cameraPosition );
		}
		vec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
		#ifdef ENVMAP_MODE_REFLECTION
			vReflect = reflect( cameraToVertex, worldNormal );
		#else
			vReflect = refract( cameraToVertex, worldNormal, refractionRatio );
		#endif
	#endif
#endif`,
    vz = `#ifdef USE_FOG
	vFogDepth = - mvPosition.z;
#endif`,
    yz = `#ifdef USE_FOG
	varying float vFogDepth;
#endif`,
    _z = `#ifdef USE_FOG
	#ifdef FOG_EXP2
		float fogFactor = 1.0 - exp( - fogDensity * fogDensity * vFogDepth * vFogDepth );
	#else
		float fogFactor = smoothstep( fogNear, fogFar, vFogDepth );
	#endif
	gl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );
#endif`,
    xz = `#ifdef USE_FOG
	uniform vec3 fogColor;
	varying float vFogDepth;
	#ifdef FOG_EXP2
		uniform float fogDensity;
	#else
		uniform float fogNear;
		uniform float fogFar;
	#endif
#endif`,
    Az = `#ifdef USE_GRADIENTMAP
	uniform sampler2D gradientMap;
#endif
vec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {
	float dotNL = dot( normal, lightDirection );
	vec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );
	#ifdef USE_GRADIENTMAP
		return vec3( texture2D( gradientMap, coord ).r );
	#else
		vec2 fw = fwidth( coord ) * 0.5;
		return mix( vec3( 0.7 ), vec3( 1.0 ), smoothstep( 0.7 - fw.x, 0.7 + fw.x, coord.x ) );
	#endif
}`,
    Sz = `#ifdef USE_LIGHTMAP
	uniform sampler2D lightMap;
	uniform float lightMapIntensity;
#endif`,
    Mz = `LambertMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularStrength = specularStrength;`,
    wz = `varying vec3 vViewPosition;
struct LambertMaterial {
	vec3 diffuseColor;
	float specularStrength;
};
void RE_Direct_Lambert( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Lambert( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in LambertMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Lambert
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Lambert`,
    bz = `uniform bool receiveShadow;
uniform vec3 ambientLightColor;
#if defined( USE_LIGHT_PROBES )
	uniform vec3 lightProbe[ 9 ];
#endif
vec3 shGetIrradianceAt( in vec3 normal, in vec3 shCoefficients[ 9 ] ) {
	float x = normal.x, y = normal.y, z = normal.z;
	vec3 result = shCoefficients[ 0 ] * 0.886227;
	result += shCoefficients[ 1 ] * 2.0 * 0.511664 * y;
	result += shCoefficients[ 2 ] * 2.0 * 0.511664 * z;
	result += shCoefficients[ 3 ] * 2.0 * 0.511664 * x;
	result += shCoefficients[ 4 ] * 2.0 * 0.429043 * x * y;
	result += shCoefficients[ 5 ] * 2.0 * 0.429043 * y * z;
	result += shCoefficients[ 6 ] * ( 0.743125 * z * z - 0.247708 );
	result += shCoefficients[ 7 ] * 2.0 * 0.429043 * x * z;
	result += shCoefficients[ 8 ] * 0.429043 * ( x * x - y * y );
	return result;
}
vec3 getLightProbeIrradiance( const in vec3 lightProbe[ 9 ], const in vec3 normal ) {
	vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
	vec3 irradiance = shGetIrradianceAt( worldNormal, lightProbe );
	return irradiance;
}
vec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {
	vec3 irradiance = ambientLightColor;
	return irradiance;
}
float getDistanceAttenuation( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {
	float distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );
	if ( cutoffDistance > 0.0 ) {
		distanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );
	}
	return distanceFalloff;
}
float getSpotAttenuation( const in float coneCosine, const in float penumbraCosine, const in float angleCosine ) {
	return smoothstep( coneCosine, penumbraCosine, angleCosine );
}
#if NUM_DIR_LIGHTS > 0
	struct DirectionalLight {
		vec3 direction;
		vec3 color;
	};
	uniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];
	void getDirectionalLightInfo( const in DirectionalLight directionalLight, out IncidentLight light ) {
		light.color = directionalLight.color;
		light.direction = directionalLight.direction;
		light.visible = true;
	}
#endif
#if NUM_POINT_LIGHTS > 0
	struct PointLight {
		vec3 position;
		vec3 color;
		float distance;
		float decay;
	};
	uniform PointLight pointLights[ NUM_POINT_LIGHTS ];
	void getPointLightInfo( const in PointLight pointLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = pointLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float lightDistance = length( lVector );
		light.color = pointLight.color;
		light.color *= getDistanceAttenuation( lightDistance, pointLight.distance, pointLight.decay );
		light.visible = ( light.color != vec3( 0.0 ) );
	}
#endif
#if NUM_SPOT_LIGHTS > 0
	struct SpotLight {
		vec3 position;
		vec3 direction;
		vec3 color;
		float distance;
		float decay;
		float coneCos;
		float penumbraCos;
	};
	uniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];
	void getSpotLightInfo( const in SpotLight spotLight, const in vec3 geometryPosition, out IncidentLight light ) {
		vec3 lVector = spotLight.position - geometryPosition;
		light.direction = normalize( lVector );
		float angleCos = dot( light.direction, spotLight.direction );
		float spotAttenuation = getSpotAttenuation( spotLight.coneCos, spotLight.penumbraCos, angleCos );
		if ( spotAttenuation > 0.0 ) {
			float lightDistance = length( lVector );
			light.color = spotLight.color * spotAttenuation;
			light.color *= getDistanceAttenuation( lightDistance, spotLight.distance, spotLight.decay );
			light.visible = ( light.color != vec3( 0.0 ) );
		} else {
			light.color = vec3( 0.0 );
			light.visible = false;
		}
	}
#endif
#if NUM_RECT_AREA_LIGHTS > 0
	struct RectAreaLight {
		vec3 color;
		vec3 position;
		vec3 halfWidth;
		vec3 halfHeight;
	};
	uniform sampler2D ltc_1;	uniform sampler2D ltc_2;
	uniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];
#endif
#if NUM_HEMI_LIGHTS > 0
	struct HemisphereLight {
		vec3 direction;
		vec3 skyColor;
		vec3 groundColor;
	};
	uniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];
	vec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in vec3 normal ) {
		float dotNL = dot( normal, hemiLight.direction );
		float hemiDiffuseWeight = 0.5 * dotNL + 0.5;
		vec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );
		return irradiance;
	}
#endif`,
    Tz = `#ifdef USE_ENVMAP
	vec3 getIBLIrradiance( const in vec3 normal ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 worldNormal = inverseTransformDirection( normal, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * worldNormal, 1.0 );
			return PI * envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	vec3 getIBLRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness ) {
		#ifdef ENVMAP_TYPE_CUBE_UV
			vec3 reflectVec = reflect( - viewDir, normal );
			reflectVec = normalize( mix( reflectVec, normal, roughness * roughness) );
			reflectVec = inverseTransformDirection( reflectVec, viewMatrix );
			vec4 envMapColor = textureCubeUV( envMap, envMapRotation * reflectVec, roughness );
			return envMapColor.rgb * envMapIntensity;
		#else
			return vec3( 0.0 );
		#endif
	}
	#ifdef USE_ANISOTROPY
		vec3 getIBLAnisotropyRadiance( const in vec3 viewDir, const in vec3 normal, const in float roughness, const in vec3 bitangent, const in float anisotropy ) {
			#ifdef ENVMAP_TYPE_CUBE_UV
				vec3 bentNormal = cross( bitangent, viewDir );
				bentNormal = normalize( cross( bentNormal, bitangent ) );
				bentNormal = normalize( mix( bentNormal, normal, pow2( pow2( 1.0 - anisotropy * ( 1.0 - roughness ) ) ) ) );
				return getIBLRadiance( viewDir, bentNormal, roughness );
			#else
				return vec3( 0.0 );
			#endif
		}
	#endif
#endif`,
    Ez = `ToonMaterial material;
material.diffuseColor = diffuseColor.rgb;`,
    Cz = `varying vec3 vViewPosition;
struct ToonMaterial {
	vec3 diffuseColor;
};
void RE_Direct_Toon( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	vec3 irradiance = getGradientIrradiance( geometryNormal, directLight.direction ) * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Toon( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in ToonMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_Toon
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Toon`,
    Rz = `BlinnPhongMaterial material;
material.diffuseColor = diffuseColor.rgb;
material.specularColor = specular;
material.specularShininess = shininess;
material.specularStrength = specularStrength;`,
    Pz = `varying vec3 vViewPosition;
struct BlinnPhongMaterial {
	vec3 diffuseColor;
	vec3 specularColor;
	float specularShininess;
	float specularStrength;
};
void RE_Direct_BlinnPhong( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
	reflectedLight.directSpecular += irradiance * BRDF_BlinnPhong( directLight.direction, geometryViewDir, geometryNormal, material.specularColor, material.specularShininess ) * material.specularStrength;
}
void RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
#define RE_Direct				RE_Direct_BlinnPhong
#define RE_IndirectDiffuse		RE_IndirectDiffuse_BlinnPhong`,
    Iz = `PhysicalMaterial material;
material.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );
vec3 dxy = max( abs( dFdx( nonPerturbedNormal ) ), abs( dFdy( nonPerturbedNormal ) ) );
float geometryRoughness = max( max( dxy.x, dxy.y ), dxy.z );
material.roughness = max( roughnessFactor, 0.0525 );material.roughness += geometryRoughness;
material.roughness = min( material.roughness, 1.0 );
#ifdef IOR
	material.ior = ior;
	#ifdef USE_SPECULAR
		float specularIntensityFactor = specularIntensity;
		vec3 specularColorFactor = specularColor;
		#ifdef USE_SPECULAR_COLORMAP
			specularColorFactor *= texture2D( specularColorMap, vSpecularColorMapUv ).rgb;
		#endif
		#ifdef USE_SPECULAR_INTENSITYMAP
			specularIntensityFactor *= texture2D( specularIntensityMap, vSpecularIntensityMapUv ).a;
		#endif
		material.specularF90 = mix( specularIntensityFactor, 1.0, metalnessFactor );
	#else
		float specularIntensityFactor = 1.0;
		vec3 specularColorFactor = vec3( 1.0 );
		material.specularF90 = 1.0;
	#endif
	material.specularColor = mix( min( pow2( ( material.ior - 1.0 ) / ( material.ior + 1.0 ) ) * specularColorFactor, vec3( 1.0 ) ) * specularIntensityFactor, diffuseColor.rgb, metalnessFactor );
#else
	material.specularColor = mix( vec3( 0.04 ), diffuseColor.rgb, metalnessFactor );
	material.specularF90 = 1.0;
#endif
#ifdef USE_CLEARCOAT
	material.clearcoat = clearcoat;
	material.clearcoatRoughness = clearcoatRoughness;
	material.clearcoatF0 = vec3( 0.04 );
	material.clearcoatF90 = 1.0;
	#ifdef USE_CLEARCOATMAP
		material.clearcoat *= texture2D( clearcoatMap, vClearcoatMapUv ).x;
	#endif
	#ifdef USE_CLEARCOAT_ROUGHNESSMAP
		material.clearcoatRoughness *= texture2D( clearcoatRoughnessMap, vClearcoatRoughnessMapUv ).y;
	#endif
	material.clearcoat = saturate( material.clearcoat );	material.clearcoatRoughness = max( material.clearcoatRoughness, 0.0525 );
	material.clearcoatRoughness += geometryRoughness;
	material.clearcoatRoughness = min( material.clearcoatRoughness, 1.0 );
#endif
#ifdef USE_DISPERSION
	material.dispersion = dispersion;
#endif
#ifdef USE_IRIDESCENCE
	material.iridescence = iridescence;
	material.iridescenceIOR = iridescenceIOR;
	#ifdef USE_IRIDESCENCEMAP
		material.iridescence *= texture2D( iridescenceMap, vIridescenceMapUv ).r;
	#endif
	#ifdef USE_IRIDESCENCE_THICKNESSMAP
		material.iridescenceThickness = (iridescenceThicknessMaximum - iridescenceThicknessMinimum) * texture2D( iridescenceThicknessMap, vIridescenceThicknessMapUv ).g + iridescenceThicknessMinimum;
	#else
		material.iridescenceThickness = iridescenceThicknessMaximum;
	#endif
#endif
#ifdef USE_SHEEN
	material.sheenColor = sheenColor;
	#ifdef USE_SHEEN_COLORMAP
		material.sheenColor *= texture2D( sheenColorMap, vSheenColorMapUv ).rgb;
	#endif
	material.sheenRoughness = clamp( sheenRoughness, 0.07, 1.0 );
	#ifdef USE_SHEEN_ROUGHNESSMAP
		material.sheenRoughness *= texture2D( sheenRoughnessMap, vSheenRoughnessMapUv ).a;
	#endif
#endif
#ifdef USE_ANISOTROPY
	#ifdef USE_ANISOTROPYMAP
		mat2 anisotropyMat = mat2( anisotropyVector.x, anisotropyVector.y, - anisotropyVector.y, anisotropyVector.x );
		vec3 anisotropyPolar = texture2D( anisotropyMap, vAnisotropyMapUv ).rgb;
		vec2 anisotropyV = anisotropyMat * normalize( 2.0 * anisotropyPolar.rg - vec2( 1.0 ) ) * anisotropyPolar.b;
	#else
		vec2 anisotropyV = anisotropyVector;
	#endif
	material.anisotropy = length( anisotropyV );
	if( material.anisotropy == 0.0 ) {
		anisotropyV = vec2( 1.0, 0.0 );
	} else {
		anisotropyV /= material.anisotropy;
		material.anisotropy = saturate( material.anisotropy );
	}
	material.alphaT = mix( pow2( material.roughness ), 1.0, pow2( material.anisotropy ) );
	material.anisotropyT = tbn[ 0 ] * anisotropyV.x + tbn[ 1 ] * anisotropyV.y;
	material.anisotropyB = tbn[ 1 ] * anisotropyV.x - tbn[ 0 ] * anisotropyV.y;
#endif`,
    Bz = `struct PhysicalMaterial {
	vec3 diffuseColor;
	float roughness;
	vec3 specularColor;
	float specularF90;
	float dispersion;
	#ifdef USE_CLEARCOAT
		float clearcoat;
		float clearcoatRoughness;
		vec3 clearcoatF0;
		float clearcoatF90;
	#endif
	#ifdef USE_IRIDESCENCE
		float iridescence;
		float iridescenceIOR;
		float iridescenceThickness;
		vec3 iridescenceFresnel;
		vec3 iridescenceF0;
	#endif
	#ifdef USE_SHEEN
		vec3 sheenColor;
		float sheenRoughness;
	#endif
	#ifdef IOR
		float ior;
	#endif
	#ifdef USE_TRANSMISSION
		float transmission;
		float transmissionAlpha;
		float thickness;
		float attenuationDistance;
		vec3 attenuationColor;
	#endif
	#ifdef USE_ANISOTROPY
		float anisotropy;
		float alphaT;
		vec3 anisotropyT;
		vec3 anisotropyB;
	#endif
};
vec3 clearcoatSpecularDirect = vec3( 0.0 );
vec3 clearcoatSpecularIndirect = vec3( 0.0 );
vec3 sheenSpecularDirect = vec3( 0.0 );
vec3 sheenSpecularIndirect = vec3(0.0 );
vec3 Schlick_to_F0( const in vec3 f, const in float f90, const in float dotVH ) {
    float x = clamp( 1.0 - dotVH, 0.0, 1.0 );
    float x2 = x * x;
    float x5 = clamp( x * x2 * x2, 0.0, 0.9999 );
    return ( f - vec3( f90 ) * x5 ) / ( 1.0 - x5 );
}
float V_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {
	float a2 = pow2( alpha );
	float gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );
	float gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );
	return 0.5 / max( gv + gl, EPSILON );
}
float D_GGX( const in float alpha, const in float dotNH ) {
	float a2 = pow2( alpha );
	float denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;
	return RECIPROCAL_PI * a2 / pow2( denom );
}
#ifdef USE_ANISOTROPY
	float V_GGX_SmithCorrelated_Anisotropic( const in float alphaT, const in float alphaB, const in float dotTV, const in float dotBV, const in float dotTL, const in float dotBL, const in float dotNV, const in float dotNL ) {
		float gv = dotNL * length( vec3( alphaT * dotTV, alphaB * dotBV, dotNV ) );
		float gl = dotNV * length( vec3( alphaT * dotTL, alphaB * dotBL, dotNL ) );
		float v = 0.5 / ( gv + gl );
		return saturate(v);
	}
	float D_GGX_Anisotropic( const in float alphaT, const in float alphaB, const in float dotNH, const in float dotTH, const in float dotBH ) {
		float a2 = alphaT * alphaB;
		highp vec3 v = vec3( alphaB * dotTH, alphaT * dotBH, a2 * dotNH );
		highp float v2 = dot( v, v );
		float w2 = a2 / v2;
		return RECIPROCAL_PI * a2 * pow2 ( w2 );
	}
#endif
#ifdef USE_CLEARCOAT
	vec3 BRDF_GGX_Clearcoat( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material) {
		vec3 f0 = material.clearcoatF0;
		float f90 = material.clearcoatF90;
		float roughness = material.clearcoatRoughness;
		float alpha = pow2( roughness );
		vec3 halfDir = normalize( lightDir + viewDir );
		float dotNL = saturate( dot( normal, lightDir ) );
		float dotNV = saturate( dot( normal, viewDir ) );
		float dotNH = saturate( dot( normal, halfDir ) );
		float dotVH = saturate( dot( viewDir, halfDir ) );
		vec3 F = F_Schlick( f0, f90, dotVH );
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
		return F * ( V * D );
	}
#endif
vec3 BRDF_GGX( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, const in PhysicalMaterial material ) {
	vec3 f0 = material.specularColor;
	float f90 = material.specularF90;
	float roughness = material.roughness;
	float alpha = pow2( roughness );
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float dotVH = saturate( dot( viewDir, halfDir ) );
	vec3 F = F_Schlick( f0, f90, dotVH );
	#ifdef USE_IRIDESCENCE
		F = mix( F, material.iridescenceFresnel, material.iridescence );
	#endif
	#ifdef USE_ANISOTROPY
		float dotTL = dot( material.anisotropyT, lightDir );
		float dotTV = dot( material.anisotropyT, viewDir );
		float dotTH = dot( material.anisotropyT, halfDir );
		float dotBL = dot( material.anisotropyB, lightDir );
		float dotBV = dot( material.anisotropyB, viewDir );
		float dotBH = dot( material.anisotropyB, halfDir );
		float V = V_GGX_SmithCorrelated_Anisotropic( material.alphaT, alpha, dotTV, dotBV, dotTL, dotBL, dotNV, dotNL );
		float D = D_GGX_Anisotropic( material.alphaT, alpha, dotNH, dotTH, dotBH );
	#else
		float V = V_GGX_SmithCorrelated( alpha, dotNL, dotNV );
		float D = D_GGX( alpha, dotNH );
	#endif
	return F * ( V * D );
}
vec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {
	const float LUT_SIZE = 64.0;
	const float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;
	const float LUT_BIAS = 0.5 / LUT_SIZE;
	float dotNV = saturate( dot( N, V ) );
	vec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );
	uv = uv * LUT_SCALE + LUT_BIAS;
	return uv;
}
float LTC_ClippedSphereFormFactor( const in vec3 f ) {
	float l = length( f );
	return max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );
}
vec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {
	float x = dot( v1, v2 );
	float y = abs( x );
	float a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;
	float b = 3.4175940 + ( 4.1616724 + y ) * y;
	float v = a / b;
	float theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;
	return cross( v1, v2 ) * theta_sintheta;
}
vec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {
	vec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];
	vec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];
	vec3 lightNormal = cross( v1, v2 );
	if( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );
	vec3 T1, T2;
	T1 = normalize( V - N * dot( V, N ) );
	T2 = - cross( N, T1 );
	mat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );
	vec3 coords[ 4 ];
	coords[ 0 ] = mat * ( rectCoords[ 0 ] - P );
	coords[ 1 ] = mat * ( rectCoords[ 1 ] - P );
	coords[ 2 ] = mat * ( rectCoords[ 2 ] - P );
	coords[ 3 ] = mat * ( rectCoords[ 3 ] - P );
	coords[ 0 ] = normalize( coords[ 0 ] );
	coords[ 1 ] = normalize( coords[ 1 ] );
	coords[ 2 ] = normalize( coords[ 2 ] );
	coords[ 3 ] = normalize( coords[ 3 ] );
	vec3 vectorFormFactor = vec3( 0.0 );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );
	vectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );
	float result = LTC_ClippedSphereFormFactor( vectorFormFactor );
	return vec3( result );
}
#if defined( USE_SHEEN )
float D_Charlie( float roughness, float dotNH ) {
	float alpha = pow2( roughness );
	float invAlpha = 1.0 / alpha;
	float cos2h = dotNH * dotNH;
	float sin2h = max( 1.0 - cos2h, 0.0078125 );
	return ( 2.0 + invAlpha ) * pow( sin2h, invAlpha * 0.5 ) / ( 2.0 * PI );
}
float V_Neubelt( float dotNV, float dotNL ) {
	return saturate( 1.0 / ( 4.0 * ( dotNL + dotNV - dotNL * dotNV ) ) );
}
vec3 BRDF_Sheen( const in vec3 lightDir, const in vec3 viewDir, const in vec3 normal, vec3 sheenColor, const in float sheenRoughness ) {
	vec3 halfDir = normalize( lightDir + viewDir );
	float dotNL = saturate( dot( normal, lightDir ) );
	float dotNV = saturate( dot( normal, viewDir ) );
	float dotNH = saturate( dot( normal, halfDir ) );
	float D = D_Charlie( sheenRoughness, dotNH );
	float V = V_Neubelt( dotNV, dotNL );
	return sheenColor * ( D * V );
}
#endif
float IBLSheenBRDF( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	float r2 = roughness * roughness;
	float a = roughness < 0.25 ? -339.2 * r2 + 161.4 * roughness - 25.9 : -8.48 * r2 + 14.3 * roughness - 9.95;
	float b = roughness < 0.25 ? 44.0 * r2 - 23.7 * roughness + 3.26 : 1.97 * r2 - 3.27 * roughness + 0.72;
	float DG = exp( a * dotNV + b ) + ( roughness < 0.25 ? 0.0 : 0.1 * ( roughness - 0.25 ) );
	return saturate( DG * RECIPROCAL_PI );
}
vec2 DFGApprox( const in vec3 normal, const in vec3 viewDir, const in float roughness ) {
	float dotNV = saturate( dot( normal, viewDir ) );
	const vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );
	const vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );
	vec4 r = roughness * c0 + c1;
	float a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;
	vec2 fab = vec2( - 1.04, 1.04 ) * a004 + r.zw;
	return fab;
}
vec3 EnvironmentBRDF( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness ) {
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	return specularColor * fab.x + specularF90 * fab.y;
}
#ifdef USE_IRIDESCENCE
void computeMultiscatteringIridescence( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float iridescence, const in vec3 iridescenceF0, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#else
void computeMultiscattering( const in vec3 normal, const in vec3 viewDir, const in vec3 specularColor, const in float specularF90, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {
#endif
	vec2 fab = DFGApprox( normal, viewDir, roughness );
	#ifdef USE_IRIDESCENCE
		vec3 Fr = mix( specularColor, iridescenceF0, iridescence );
	#else
		vec3 Fr = specularColor;
	#endif
	vec3 FssEss = Fr * fab.x + specularF90 * fab.y;
	float Ess = fab.x + fab.y;
	float Ems = 1.0 - Ess;
	vec3 Favg = Fr + ( 1.0 - Fr ) * 0.047619;	vec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );
	singleScatter += FssEss;
	multiScatter += Fms * Ems;
}
#if NUM_RECT_AREA_LIGHTS > 0
	void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
		vec3 normal = geometryNormal;
		vec3 viewDir = geometryViewDir;
		vec3 position = geometryPosition;
		vec3 lightPos = rectAreaLight.position;
		vec3 halfWidth = rectAreaLight.halfWidth;
		vec3 halfHeight = rectAreaLight.halfHeight;
		vec3 lightColor = rectAreaLight.color;
		float roughness = material.roughness;
		vec3 rectCoords[ 4 ];
		rectCoords[ 0 ] = lightPos + halfWidth - halfHeight;		rectCoords[ 1 ] = lightPos - halfWidth - halfHeight;
		rectCoords[ 2 ] = lightPos - halfWidth + halfHeight;
		rectCoords[ 3 ] = lightPos + halfWidth + halfHeight;
		vec2 uv = LTC_Uv( normal, viewDir, roughness );
		vec4 t1 = texture2D( ltc_1, uv );
		vec4 t2 = texture2D( ltc_2, uv );
		mat3 mInv = mat3(
			vec3( t1.x, 0, t1.y ),
			vec3(    0, 1,    0 ),
			vec3( t1.z, 0, t1.w )
		);
		vec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );
		reflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );
		reflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );
	}
#endif
void RE_Direct_Physical( const in IncidentLight directLight, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	float dotNL = saturate( dot( geometryNormal, directLight.direction ) );
	vec3 irradiance = dotNL * directLight.color;
	#ifdef USE_CLEARCOAT
		float dotNLcc = saturate( dot( geometryClearcoatNormal, directLight.direction ) );
		vec3 ccIrradiance = dotNLcc * directLight.color;
		clearcoatSpecularDirect += ccIrradiance * BRDF_GGX_Clearcoat( directLight.direction, geometryViewDir, geometryClearcoatNormal, material );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularDirect += irradiance * BRDF_Sheen( directLight.direction, geometryViewDir, geometryNormal, material.sheenColor, material.sheenRoughness );
	#endif
	reflectedLight.directSpecular += irradiance * BRDF_GGX( directLight.direction, geometryViewDir, geometryNormal, material );
	reflectedLight.directDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {
	reflectedLight.indirectDiffuse += irradiance * BRDF_Lambert( material.diffuseColor );
}
void RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearcoatRadiance, const in vec3 geometryPosition, const in vec3 geometryNormal, const in vec3 geometryViewDir, const in vec3 geometryClearcoatNormal, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {
	#ifdef USE_CLEARCOAT
		clearcoatSpecularIndirect += clearcoatRadiance * EnvironmentBRDF( geometryClearcoatNormal, geometryViewDir, material.clearcoatF0, material.clearcoatF90, material.clearcoatRoughness );
	#endif
	#ifdef USE_SHEEN
		sheenSpecularIndirect += irradiance * material.sheenColor * IBLSheenBRDF( geometryNormal, geometryViewDir, material.sheenRoughness );
	#endif
	vec3 singleScattering = vec3( 0.0 );
	vec3 multiScattering = vec3( 0.0 );
	vec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;
	#ifdef USE_IRIDESCENCE
		computeMultiscatteringIridescence( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.iridescence, material.iridescenceFresnel, material.roughness, singleScattering, multiScattering );
	#else
		computeMultiscattering( geometryNormal, geometryViewDir, material.specularColor, material.specularF90, material.roughness, singleScattering, multiScattering );
	#endif
	vec3 totalScattering = singleScattering + multiScattering;
	vec3 diffuse = material.diffuseColor * ( 1.0 - max( max( totalScattering.r, totalScattering.g ), totalScattering.b ) );
	reflectedLight.indirectSpecular += radiance * singleScattering;
	reflectedLight.indirectSpecular += multiScattering * cosineWeightedIrradiance;
	reflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;
}
#define RE_Direct				RE_Direct_Physical
#define RE_Direct_RectArea		RE_Direct_RectArea_Physical
#define RE_IndirectDiffuse		RE_IndirectDiffuse_Physical
#define RE_IndirectSpecular		RE_IndirectSpecular_Physical
float computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {
	return saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );
}`,
    Dz = `
vec3 geometryPosition = - vViewPosition;
vec3 geometryNormal = normal;
vec3 geometryViewDir = ( isOrthographic ) ? vec3( 0, 0, 1 ) : normalize( vViewPosition );
vec3 geometryClearcoatNormal = vec3( 0.0 );
#ifdef USE_CLEARCOAT
	geometryClearcoatNormal = clearcoatNormal;
#endif
#ifdef USE_IRIDESCENCE
	float dotNVi = saturate( dot( normal, geometryViewDir ) );
	if ( material.iridescenceThickness == 0.0 ) {
		material.iridescence = 0.0;
	} else {
		material.iridescence = saturate( material.iridescence );
	}
	if ( material.iridescence > 0.0 ) {
		material.iridescenceFresnel = evalIridescence( 1.0, material.iridescenceIOR, dotNVi, material.iridescenceThickness, material.specularColor );
		material.iridescenceF0 = Schlick_to_F0( material.iridescenceFresnel, 1.0, dotNVi );
	}
#endif
IncidentLight directLight;
#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )
	PointLight pointLight;
	#if defined( USE_SHADOWMAP ) && NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {
		pointLight = pointLights[ i ];
		getPointLightInfo( pointLight, geometryPosition, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_POINT_LIGHT_SHADOWS )
		pointLightShadow = pointLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getPointShadow( pointShadowMap[ i ], pointLightShadow.shadowMapSize, pointLightShadow.shadowIntensity, pointLightShadow.shadowBias, pointLightShadow.shadowRadius, vPointShadowCoord[ i ], pointLightShadow.shadowCameraNear, pointLightShadow.shadowCameraFar ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )
	SpotLight spotLight;
	vec4 spotColor;
	vec3 spotLightCoord;
	bool inSpotLightMap;
	#if defined( USE_SHADOWMAP ) && NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {
		spotLight = spotLights[ i ];
		getSpotLightInfo( spotLight, geometryPosition, directLight );
		#if ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#define SPOT_LIGHT_MAP_INDEX UNROLLED_LOOP_INDEX
		#elif ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		#define SPOT_LIGHT_MAP_INDEX NUM_SPOT_LIGHT_MAPS
		#else
		#define SPOT_LIGHT_MAP_INDEX ( UNROLLED_LOOP_INDEX - NUM_SPOT_LIGHT_SHADOWS + NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS )
		#endif
		#if ( SPOT_LIGHT_MAP_INDEX < NUM_SPOT_LIGHT_MAPS )
			spotLightCoord = vSpotLightCoord[ i ].xyz / vSpotLightCoord[ i ].w;
			inSpotLightMap = all( lessThan( abs( spotLightCoord * 2. - 1. ), vec3( 1.0 ) ) );
			spotColor = texture2D( spotLightMap[ SPOT_LIGHT_MAP_INDEX ], spotLightCoord.xy );
			directLight.color = inSpotLightMap ? directLight.color * spotColor.rgb : directLight.color;
		#endif
		#undef SPOT_LIGHT_MAP_INDEX
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
		spotLightShadow = spotLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( spotShadowMap[ i ], spotLightShadow.shadowMapSize, spotLightShadow.shadowIntensity, spotLightShadow.shadowBias, spotLightShadow.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )
	DirectionalLight directionalLight;
	#if defined( USE_SHADOWMAP ) && NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLightShadow;
	#endif
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {
		directionalLight = directionalLights[ i ];
		getDirectionalLightInfo( directionalLight, directLight );
		#if defined( USE_SHADOWMAP ) && ( UNROLLED_LOOP_INDEX < NUM_DIR_LIGHT_SHADOWS )
		directionalLightShadow = directionalLightShadows[ i ];
		directLight.color *= ( directLight.visible && receiveShadow ) ? getShadow( directionalShadowMap[ i ], directionalLightShadow.shadowMapSize, directionalLightShadow.shadowIntensity, directionalLightShadow.shadowBias, directionalLightShadow.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
		#endif
		RE_Direct( directLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )
	RectAreaLight rectAreaLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {
		rectAreaLight = rectAreaLights[ i ];
		RE_Direct_RectArea( rectAreaLight, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
	}
	#pragma unroll_loop_end
#endif
#if defined( RE_IndirectDiffuse )
	vec3 iblIrradiance = vec3( 0.0 );
	vec3 irradiance = getAmbientLightIrradiance( ambientLightColor );
	#if defined( USE_LIGHT_PROBES )
		irradiance += getLightProbeIrradiance( lightProbe, geometryNormal );
	#endif
	#if ( NUM_HEMI_LIGHTS > 0 )
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {
			irradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometryNormal );
		}
		#pragma unroll_loop_end
	#endif
#endif
#if defined( RE_IndirectSpecular )
	vec3 radiance = vec3( 0.0 );
	vec3 clearcoatRadiance = vec3( 0.0 );
#endif`,
    Lz = `#if defined( RE_IndirectDiffuse )
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		vec3 lightMapIrradiance = lightMapTexel.rgb * lightMapIntensity;
		irradiance += lightMapIrradiance;
	#endif
	#if defined( USE_ENVMAP ) && defined( STANDARD ) && defined( ENVMAP_TYPE_CUBE_UV )
		iblIrradiance += getIBLIrradiance( geometryNormal );
	#endif
#endif
#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )
	#ifdef USE_ANISOTROPY
		radiance += getIBLAnisotropyRadiance( geometryViewDir, geometryNormal, material.roughness, material.anisotropyB, material.anisotropy );
	#else
		radiance += getIBLRadiance( geometryViewDir, geometryNormal, material.roughness );
	#endif
	#ifdef USE_CLEARCOAT
		clearcoatRadiance += getIBLRadiance( geometryViewDir, geometryClearcoatNormal, material.clearcoatRoughness );
	#endif
#endif`,
    Fz = `#if defined( RE_IndirectDiffuse )
	RE_IndirectDiffuse( irradiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif
#if defined( RE_IndirectSpecular )
	RE_IndirectSpecular( radiance, iblIrradiance, clearcoatRadiance, geometryPosition, geometryNormal, geometryViewDir, geometryClearcoatNormal, material, reflectedLight );
#endif`,
    Uz = `#if defined( USE_LOGDEPTHBUF )
	gl_FragDepth = vIsPerspective == 0.0 ? gl_FragCoord.z : log2( vFragDepth ) * logDepthBufFC * 0.5;
#endif`,
    Oz = `#if defined( USE_LOGDEPTHBUF )
	uniform float logDepthBufFC;
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    Nz = `#ifdef USE_LOGDEPTHBUF
	varying float vFragDepth;
	varying float vIsPerspective;
#endif`,
    kz = `#ifdef USE_LOGDEPTHBUF
	vFragDepth = 1.0 + gl_Position.w;
	vIsPerspective = float( isPerspectiveMatrix( projectionMatrix ) );
#endif`,
    zz = `#ifdef USE_MAP
	vec4 sampledDiffuseColor = texture2D( map, vMapUv );
	#ifdef DECODE_VIDEO_TEXTURE
		sampledDiffuseColor = sRGBTransferEOTF( sampledDiffuseColor );
	#endif
	diffuseColor *= sampledDiffuseColor;
#endif`,
    Gz = `#ifdef USE_MAP
	uniform sampler2D map;
#endif`,
    Hz = `#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
	#if defined( USE_POINTS_UV )
		vec2 uv = vUv;
	#else
		vec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;
	#endif
#endif
#ifdef USE_MAP
	diffuseColor *= texture2D( map, uv );
#endif
#ifdef USE_ALPHAMAP
	diffuseColor.a *= texture2D( alphaMap, uv ).g;
#endif`,
    Vz = `#if defined( USE_POINTS_UV )
	varying vec2 vUv;
#else
	#if defined( USE_MAP ) || defined( USE_ALPHAMAP )
		uniform mat3 uvTransform;
	#endif
#endif
#ifdef USE_MAP
	uniform sampler2D map;
#endif
#ifdef USE_ALPHAMAP
	uniform sampler2D alphaMap;
#endif`,
    Wz = `float metalnessFactor = metalness;
#ifdef USE_METALNESSMAP
	vec4 texelMetalness = texture2D( metalnessMap, vMetalnessMapUv );
	metalnessFactor *= texelMetalness.b;
#endif`,
    jz = `#ifdef USE_METALNESSMAP
	uniform sampler2D metalnessMap;
#endif`,
    Xz = `#ifdef USE_INSTANCING_MORPH
	float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	float morphTargetBaseInfluence = texelFetch( morphTexture, ivec2( 0, gl_InstanceID ), 0 ).r;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		morphTargetInfluences[i] =  texelFetch( morphTexture, ivec2( i + 1, gl_InstanceID ), 0 ).r;
	}
#endif`,
    Yz = `#if defined( USE_MORPHCOLORS )
	vColor *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		#if defined( USE_COLOR_ALPHA )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ) * morphTargetInfluences[ i ];
		#elif defined( USE_COLOR )
			if ( morphTargetInfluences[ i ] != 0.0 ) vColor += getMorph( gl_VertexID, i, 2 ).rgb * morphTargetInfluences[ i ];
		#endif
	}
#endif`,
    Jz = `#ifdef USE_MORPHNORMALS
	objectNormal *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) objectNormal += getMorph( gl_VertexID, i, 1 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
    Kz = `#ifdef USE_MORPHTARGETS
	#ifndef USE_INSTANCING_MORPH
		uniform float morphTargetBaseInfluence;
		uniform float morphTargetInfluences[ MORPHTARGETS_COUNT ];
	#endif
	uniform sampler2DArray morphTargetsTexture;
	uniform ivec2 morphTargetsTextureSize;
	vec4 getMorph( const in int vertexIndex, const in int morphTargetIndex, const in int offset ) {
		int texelIndex = vertexIndex * MORPHTARGETS_TEXTURE_STRIDE + offset;
		int y = texelIndex / morphTargetsTextureSize.x;
		int x = texelIndex - y * morphTargetsTextureSize.x;
		ivec3 morphUV = ivec3( x, y, morphTargetIndex );
		return texelFetch( morphTargetsTexture, morphUV, 0 );
	}
#endif`,
    qz = `#ifdef USE_MORPHTARGETS
	transformed *= morphTargetBaseInfluence;
	for ( int i = 0; i < MORPHTARGETS_COUNT; i ++ ) {
		if ( morphTargetInfluences[ i ] != 0.0 ) transformed += getMorph( gl_VertexID, i, 0 ).xyz * morphTargetInfluences[ i ];
	}
#endif`,
    Zz = `float faceDirection = gl_FrontFacing ? 1.0 : - 1.0;
#ifdef FLAT_SHADED
	vec3 fdx = dFdx( vViewPosition );
	vec3 fdy = dFdy( vViewPosition );
	vec3 normal = normalize( cross( fdx, fdy ) );
#else
	vec3 normal = normalize( vNormal );
	#ifdef DOUBLE_SIDED
		normal *= faceDirection;
	#endif
#endif
#if defined( USE_NORMALMAP_TANGENTSPACE ) || defined( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY )
	#ifdef USE_TANGENT
		mat3 tbn = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn = getTangentFrame( - vViewPosition, normal,
		#if defined( USE_NORMALMAP )
			vNormalMapUv
		#elif defined( USE_CLEARCOAT_NORMALMAP )
			vClearcoatNormalMapUv
		#else
			vUv
		#endif
		);
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn[0] *= faceDirection;
		tbn[1] *= faceDirection;
	#endif
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	#ifdef USE_TANGENT
		mat3 tbn2 = mat3( normalize( vTangent ), normalize( vBitangent ), normal );
	#else
		mat3 tbn2 = getTangentFrame( - vViewPosition, normal, vClearcoatNormalMapUv );
	#endif
	#if defined( DOUBLE_SIDED ) && ! defined( FLAT_SHADED )
		tbn2[0] *= faceDirection;
		tbn2[1] *= faceDirection;
	#endif
#endif
vec3 nonPerturbedNormal = normal;`,
    Qz = `#ifdef USE_NORMALMAP_OBJECTSPACE
	normal = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	#ifdef FLIP_SIDED
		normal = - normal;
	#endif
	#ifdef DOUBLE_SIDED
		normal = normal * faceDirection;
	#endif
	normal = normalize( normalMatrix * normal );
#elif defined( USE_NORMALMAP_TANGENTSPACE )
	vec3 mapN = texture2D( normalMap, vNormalMapUv ).xyz * 2.0 - 1.0;
	mapN.xy *= normalScale;
	normal = normalize( tbn * mapN );
#elif defined( USE_BUMPMAP )
	normal = perturbNormalArb( - vViewPosition, normal, dHdxy_fwd(), faceDirection );
#endif`,
    $z = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    e4 = `#ifndef FLAT_SHADED
	varying vec3 vNormal;
	#ifdef USE_TANGENT
		varying vec3 vTangent;
		varying vec3 vBitangent;
	#endif
#endif`,
    t4 = `#ifndef FLAT_SHADED
	vNormal = normalize( transformedNormal );
	#ifdef USE_TANGENT
		vTangent = normalize( transformedTangent );
		vBitangent = normalize( cross( vNormal, vTangent ) * tangent.w );
	#endif
#endif`,
    n4 = `#ifdef USE_NORMALMAP
	uniform sampler2D normalMap;
	uniform vec2 normalScale;
#endif
#ifdef USE_NORMALMAP_OBJECTSPACE
	uniform mat3 normalMatrix;
#endif
#if ! defined ( USE_TANGENT ) && ( defined ( USE_NORMALMAP_TANGENTSPACE ) || defined ( USE_CLEARCOAT_NORMALMAP ) || defined( USE_ANISOTROPY ) )
	mat3 getTangentFrame( vec3 eye_pos, vec3 surf_norm, vec2 uv ) {
		vec3 q0 = dFdx( eye_pos.xyz );
		vec3 q1 = dFdy( eye_pos.xyz );
		vec2 st0 = dFdx( uv.st );
		vec2 st1 = dFdy( uv.st );
		vec3 N = surf_norm;
		vec3 q1perp = cross( q1, N );
		vec3 q0perp = cross( N, q0 );
		vec3 T = q1perp * st0.x + q0perp * st1.x;
		vec3 B = q1perp * st0.y + q0perp * st1.y;
		float det = max( dot( T, T ), dot( B, B ) );
		float scale = ( det == 0.0 ) ? 0.0 : inversesqrt( det );
		return mat3( T * scale, B * scale, N );
	}
#endif`,
    i4 = `#ifdef USE_CLEARCOAT
	vec3 clearcoatNormal = nonPerturbedNormal;
#endif`,
    r4 = `#ifdef USE_CLEARCOAT_NORMALMAP
	vec3 clearcoatMapN = texture2D( clearcoatNormalMap, vClearcoatNormalMapUv ).xyz * 2.0 - 1.0;
	clearcoatMapN.xy *= clearcoatNormalScale;
	clearcoatNormal = normalize( tbn2 * clearcoatMapN );
#endif`,
    s4 = `#ifdef USE_CLEARCOATMAP
	uniform sampler2D clearcoatMap;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform sampler2D clearcoatNormalMap;
	uniform vec2 clearcoatNormalScale;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform sampler2D clearcoatRoughnessMap;
#endif`,
    o4 = `#ifdef USE_IRIDESCENCEMAP
	uniform sampler2D iridescenceMap;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform sampler2D iridescenceThicknessMap;
#endif`,
    a4 = `#ifdef OPAQUE
diffuseColor.a = 1.0;
#endif
#ifdef USE_TRANSMISSION
diffuseColor.a *= material.transmissionAlpha;
#endif
gl_FragColor = vec4( outgoingLight, diffuseColor.a );`,
    l4 = `vec3 packNormalToRGB( const in vec3 normal ) {
	return normalize( normal ) * 0.5 + 0.5;
}
vec3 unpackRGBToNormal( const in vec3 rgb ) {
	return 2.0 * rgb.xyz - 1.0;
}
const float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;const float ShiftRight8 = 1. / 256.;
const float Inv255 = 1. / 255.;
const vec4 PackFactors = vec4( 1.0, 256.0, 256.0 * 256.0, 256.0 * 256.0 * 256.0 );
const vec2 UnpackFactors2 = vec2( UnpackDownscale, 1.0 / PackFactors.g );
const vec3 UnpackFactors3 = vec3( UnpackDownscale / PackFactors.rg, 1.0 / PackFactors.b );
const vec4 UnpackFactors4 = vec4( UnpackDownscale / PackFactors.rgb, 1.0 / PackFactors.a );
vec4 packDepthToRGBA( const in float v ) {
	if( v <= 0.0 )
		return vec4( 0., 0., 0., 0. );
	if( v >= 1.0 )
		return vec4( 1., 1., 1., 1. );
	float vuf;
	float af = modf( v * PackFactors.a, vuf );
	float bf = modf( vuf * ShiftRight8, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec4( vuf * Inv255, gf * PackUpscale, bf * PackUpscale, af );
}
vec3 packDepthToRGB( const in float v ) {
	if( v <= 0.0 )
		return vec3( 0., 0., 0. );
	if( v >= 1.0 )
		return vec3( 1., 1., 1. );
	float vuf;
	float bf = modf( v * PackFactors.b, vuf );
	float gf = modf( vuf * ShiftRight8, vuf );
	return vec3( vuf * Inv255, gf * PackUpscale, bf );
}
vec2 packDepthToRG( const in float v ) {
	if( v <= 0.0 )
		return vec2( 0., 0. );
	if( v >= 1.0 )
		return vec2( 1., 1. );
	float vuf;
	float gf = modf( v * 256., vuf );
	return vec2( vuf * Inv255, gf );
}
float unpackRGBAToDepth( const in vec4 v ) {
	return dot( v, UnpackFactors4 );
}
float unpackRGBToDepth( const in vec3 v ) {
	return dot( v, UnpackFactors3 );
}
float unpackRGToDepth( const in vec2 v ) {
	return v.r * UnpackFactors2.r + v.g * UnpackFactors2.g;
}
vec4 pack2HalfToRGBA( const in vec2 v ) {
	vec4 r = vec4( v.x, fract( v.x * 255.0 ), v.y, fract( v.y * 255.0 ) );
	return vec4( r.x - r.y / 255.0, r.y, r.z - r.w / 255.0, r.w );
}
vec2 unpackRGBATo2Half( const in vec4 v ) {
	return vec2( v.x + ( v.y / 255.0 ), v.z + ( v.w / 255.0 ) );
}
float viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {
	return ( viewZ + near ) / ( near - far );
}
float orthographicDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return depth * ( near - far ) - near;
}
float viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {
	return ( ( near + viewZ ) * far ) / ( ( far - near ) * viewZ );
}
float perspectiveDepthToViewZ( const in float depth, const in float near, const in float far ) {
	return ( near * far ) / ( ( far - near ) * depth - far );
}`,
    c4 = `#ifdef PREMULTIPLIED_ALPHA
	gl_FragColor.rgb *= gl_FragColor.a;
#endif`,
    u4 = `vec4 mvPosition = vec4( transformed, 1.0 );
#ifdef USE_BATCHING
	mvPosition = batchingMatrix * mvPosition;
#endif
#ifdef USE_INSTANCING
	mvPosition = instanceMatrix * mvPosition;
#endif
mvPosition = modelViewMatrix * mvPosition;
gl_Position = projectionMatrix * mvPosition;`,
    f4 = `#ifdef DITHERING
	gl_FragColor.rgb = dithering( gl_FragColor.rgb );
#endif`,
    h4 = `#ifdef DITHERING
	vec3 dithering( vec3 color ) {
		float grid_position = rand( gl_FragCoord.xy );
		vec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );
		dither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );
		return color + dither_shift_RGB;
	}
#endif`,
    d4 = `float roughnessFactor = roughness;
#ifdef USE_ROUGHNESSMAP
	vec4 texelRoughness = texture2D( roughnessMap, vRoughnessMapUv );
	roughnessFactor *= texelRoughness.g;
#endif`,
    p4 = `#ifdef USE_ROUGHNESSMAP
	uniform sampler2D roughnessMap;
#endif`,
    m4 = `#if NUM_SPOT_LIGHT_COORDS > 0
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#if NUM_SPOT_LIGHT_MAPS > 0
	uniform sampler2D spotLightMap[ NUM_SPOT_LIGHT_MAPS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform sampler2D directionalShadowMap[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		uniform sampler2D spotShadowMap[ NUM_SPOT_LIGHT_SHADOWS ];
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform sampler2D pointShadowMap[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
	float texture2DCompare( sampler2D depths, vec2 uv, float compare ) {
		return step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );
	}
	vec2 texture2DDistribution( sampler2D shadow, vec2 uv ) {
		return unpackRGBATo2Half( texture2D( shadow, uv ) );
	}
	float VSMShadow (sampler2D shadow, vec2 uv, float compare ){
		float occlusion = 1.0;
		vec2 distribution = texture2DDistribution( shadow, uv );
		float hard_shadow = step( compare , distribution.x );
		if (hard_shadow != 1.0 ) {
			float distance = compare - distribution.x ;
			float variance = max( 0.00000, distribution.y * distribution.y );
			float softness_probability = variance / (variance + distance * distance );			softness_probability = clamp( ( softness_probability - 0.3 ) / ( 0.95 - 0.3 ), 0.0, 1.0 );			occlusion = clamp( max( hard_shadow, softness_probability ), 0.0, 1.0 );
		}
		return occlusion;
	}
	float getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord ) {
		float shadow = 1.0;
		shadowCoord.xyz /= shadowCoord.w;
		shadowCoord.z += shadowBias;
		bool inFrustum = shadowCoord.x >= 0.0 && shadowCoord.x <= 1.0 && shadowCoord.y >= 0.0 && shadowCoord.y <= 1.0;
		bool frustumTest = inFrustum && shadowCoord.z <= 1.0;
		if ( frustumTest ) {
		#if defined( SHADOWMAP_TYPE_PCF )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx0 = - texelSize.x * shadowRadius;
			float dy0 = - texelSize.y * shadowRadius;
			float dx1 = + texelSize.x * shadowRadius;
			float dy1 = + texelSize.y * shadowRadius;
			float dx2 = dx0 / 2.0;
			float dy2 = dy0 / 2.0;
			float dx3 = dx1 / 2.0;
			float dy3 = dy1 / 2.0;
			shadow = (
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy2 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx2, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx3, dy3 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )
			) * ( 1.0 / 17.0 );
		#elif defined( SHADOWMAP_TYPE_PCF_SOFT )
			vec2 texelSize = vec2( 1.0 ) / shadowMapSize;
			float dx = texelSize.x;
			float dy = texelSize.y;
			vec2 uv = shadowCoord.xy;
			vec2 f = fract( uv * shadowMapSize + 0.5 );
			uv -= f * texelSize;
			shadow = (
				texture2DCompare( shadowMap, uv, shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( dx, 0.0 ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + vec2( 0.0, dy ), shadowCoord.z ) +
				texture2DCompare( shadowMap, uv + texelSize, shadowCoord.z ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, 0.0 ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 0.0 ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( -dx, dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, dy ), shadowCoord.z ),
					 f.x ) +
				mix( texture2DCompare( shadowMap, uv + vec2( 0.0, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( 0.0, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( texture2DCompare( shadowMap, uv + vec2( dx, -dy ), shadowCoord.z ),
					 texture2DCompare( shadowMap, uv + vec2( dx, 2.0 * dy ), shadowCoord.z ),
					 f.y ) +
				mix( mix( texture2DCompare( shadowMap, uv + vec2( -dx, -dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, -dy ), shadowCoord.z ),
						  f.x ),
					 mix( texture2DCompare( shadowMap, uv + vec2( -dx, 2.0 * dy ), shadowCoord.z ),
						  texture2DCompare( shadowMap, uv + vec2( 2.0 * dx, 2.0 * dy ), shadowCoord.z ),
						  f.x ),
					 f.y )
			) * ( 1.0 / 9.0 );
		#elif defined( SHADOWMAP_TYPE_VSM )
			shadow = VSMShadow( shadowMap, shadowCoord.xy, shadowCoord.z );
		#else
			shadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );
		#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
	vec2 cubeToUV( vec3 v, float texelSizeY ) {
		vec3 absV = abs( v );
		float scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );
		absV *= scaleToCube;
		v *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );
		vec2 planar = v.xy;
		float almostATexel = 1.5 * texelSizeY;
		float almostOne = 1.0 - almostATexel;
		if ( absV.z >= almostOne ) {
			if ( v.z > 0.0 )
				planar.x = 4.0 - v.x;
		} else if ( absV.x >= almostOne ) {
			float signX = sign( v.x );
			planar.x = v.z * signX + 2.0 * signX;
		} else if ( absV.y >= almostOne ) {
			float signY = sign( v.y );
			planar.x = v.x + 2.0 * signY + 2.0;
			planar.y = v.z * signY - 2.0;
		}
		return vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );
	}
	float getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowIntensity, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {
		float shadow = 1.0;
		vec3 lightToPosition = shadowCoord.xyz;
		
		float lightToPositionLength = length( lightToPosition );
		if ( lightToPositionLength - shadowCameraFar <= 0.0 && lightToPositionLength - shadowCameraNear >= 0.0 ) {
			float dp = ( lightToPositionLength - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );			dp += shadowBias;
			vec3 bd3D = normalize( lightToPosition );
			vec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );
			#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT ) || defined( SHADOWMAP_TYPE_VSM )
				vec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;
				shadow = (
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +
					texture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )
				) * ( 1.0 / 9.0 );
			#else
				shadow = texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );
			#endif
		}
		return mix( 1.0, shadow, shadowIntensity );
	}
#endif`,
    g4 = `#if NUM_SPOT_LIGHT_COORDS > 0
	uniform mat4 spotLightMatrix[ NUM_SPOT_LIGHT_COORDS ];
	varying vec4 vSpotLightCoord[ NUM_SPOT_LIGHT_COORDS ];
#endif
#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
		uniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHT_SHADOWS ];
		varying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHT_SHADOWS ];
		struct DirectionalLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform DirectionalLightShadow directionalLightShadows[ NUM_DIR_LIGHT_SHADOWS ];
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
		struct SpotLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
		};
		uniform SpotLightShadow spotLightShadows[ NUM_SPOT_LIGHT_SHADOWS ];
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		uniform mat4 pointShadowMatrix[ NUM_POINT_LIGHT_SHADOWS ];
		varying vec4 vPointShadowCoord[ NUM_POINT_LIGHT_SHADOWS ];
		struct PointLightShadow {
			float shadowIntensity;
			float shadowBias;
			float shadowNormalBias;
			float shadowRadius;
			vec2 shadowMapSize;
			float shadowCameraNear;
			float shadowCameraFar;
		};
		uniform PointLightShadow pointLightShadows[ NUM_POINT_LIGHT_SHADOWS ];
	#endif
#endif`,
    v4 = `#if ( defined( USE_SHADOWMAP ) && ( NUM_DIR_LIGHT_SHADOWS > 0 || NUM_POINT_LIGHT_SHADOWS > 0 ) ) || ( NUM_SPOT_LIGHT_COORDS > 0 )
	vec3 shadowWorldNormal = inverseTransformDirection( transformedNormal, viewMatrix );
	vec4 shadowWorldPosition;
#endif
#if defined( USE_SHADOWMAP )
	#if NUM_DIR_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * directionalLightShadows[ i ].shadowNormalBias, 0 );
			vDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
		#pragma unroll_loop_start
		for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
			shadowWorldPosition = worldPosition + vec4( shadowWorldNormal * pointLightShadows[ i ].shadowNormalBias, 0 );
			vPointShadowCoord[ i ] = pointShadowMatrix[ i ] * shadowWorldPosition;
		}
		#pragma unroll_loop_end
	#endif
#endif
#if NUM_SPOT_LIGHT_COORDS > 0
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_COORDS; i ++ ) {
		shadowWorldPosition = worldPosition;
		#if ( defined( USE_SHADOWMAP ) && UNROLLED_LOOP_INDEX < NUM_SPOT_LIGHT_SHADOWS )
			shadowWorldPosition.xyz += shadowWorldNormal * spotLightShadows[ i ].shadowNormalBias;
		#endif
		vSpotLightCoord[ i ] = spotLightMatrix[ i ] * shadowWorldPosition;
	}
	#pragma unroll_loop_end
#endif`,
    y4 = `float getShadowMask() {
	float shadow = 1.0;
	#ifdef USE_SHADOWMAP
	#if NUM_DIR_LIGHT_SHADOWS > 0
	DirectionalLightShadow directionalLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_DIR_LIGHT_SHADOWS; i ++ ) {
		directionalLight = directionalLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowIntensity, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_SPOT_LIGHT_SHADOWS > 0
	SpotLightShadow spotLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_SPOT_LIGHT_SHADOWS; i ++ ) {
		spotLight = spotLightShadows[ i ];
		shadow *= receiveShadow ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowIntensity, spotLight.shadowBias, spotLight.shadowRadius, vSpotLightCoord[ i ] ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#if NUM_POINT_LIGHT_SHADOWS > 0
	PointLightShadow pointLight;
	#pragma unroll_loop_start
	for ( int i = 0; i < NUM_POINT_LIGHT_SHADOWS; i ++ ) {
		pointLight = pointLightShadows[ i ];
		shadow *= receiveShadow ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowIntensity, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;
	}
	#pragma unroll_loop_end
	#endif
	#endif
	return shadow;
}`,
    _4 = `#ifdef USE_SKINNING
	mat4 boneMatX = getBoneMatrix( skinIndex.x );
	mat4 boneMatY = getBoneMatrix( skinIndex.y );
	mat4 boneMatZ = getBoneMatrix( skinIndex.z );
	mat4 boneMatW = getBoneMatrix( skinIndex.w );
#endif`,
    x4 = `#ifdef USE_SKINNING
	uniform mat4 bindMatrix;
	uniform mat4 bindMatrixInverse;
	uniform highp sampler2D boneTexture;
	mat4 getBoneMatrix( const in float i ) {
		int size = textureSize( boneTexture, 0 ).x;
		int j = int( i ) * 4;
		int x = j % size;
		int y = j / size;
		vec4 v1 = texelFetch( boneTexture, ivec2( x, y ), 0 );
		vec4 v2 = texelFetch( boneTexture, ivec2( x + 1, y ), 0 );
		vec4 v3 = texelFetch( boneTexture, ivec2( x + 2, y ), 0 );
		vec4 v4 = texelFetch( boneTexture, ivec2( x + 3, y ), 0 );
		return mat4( v1, v2, v3, v4 );
	}
#endif`,
    A4 = `#ifdef USE_SKINNING
	vec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );
	vec4 skinned = vec4( 0.0 );
	skinned += boneMatX * skinVertex * skinWeight.x;
	skinned += boneMatY * skinVertex * skinWeight.y;
	skinned += boneMatZ * skinVertex * skinWeight.z;
	skinned += boneMatW * skinVertex * skinWeight.w;
	transformed = ( bindMatrixInverse * skinned ).xyz;
#endif`,
    S4 = `#ifdef USE_SKINNING
	mat4 skinMatrix = mat4( 0.0 );
	skinMatrix += skinWeight.x * boneMatX;
	skinMatrix += skinWeight.y * boneMatY;
	skinMatrix += skinWeight.z * boneMatZ;
	skinMatrix += skinWeight.w * boneMatW;
	skinMatrix = bindMatrixInverse * skinMatrix * bindMatrix;
	objectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;
	#ifdef USE_TANGENT
		objectTangent = vec4( skinMatrix * vec4( objectTangent, 0.0 ) ).xyz;
	#endif
#endif`,
    M4 = `float specularStrength;
#ifdef USE_SPECULARMAP
	vec4 texelSpecular = texture2D( specularMap, vSpecularMapUv );
	specularStrength = texelSpecular.r;
#else
	specularStrength = 1.0;
#endif`,
    w4 = `#ifdef USE_SPECULARMAP
	uniform sampler2D specularMap;
#endif`,
    b4 = `#if defined( TONE_MAPPING )
	gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );
#endif`,
    T4 = `#ifndef saturate
#define saturate( a ) clamp( a, 0.0, 1.0 )
#endif
uniform float toneMappingExposure;
vec3 LinearToneMapping( vec3 color ) {
	return saturate( toneMappingExposure * color );
}
vec3 ReinhardToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	return saturate( color / ( vec3( 1.0 ) + color ) );
}
vec3 CineonToneMapping( vec3 color ) {
	color *= toneMappingExposure;
	color = max( vec3( 0.0 ), color - 0.004 );
	return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );
}
vec3 RRTAndODTFit( vec3 v ) {
	vec3 a = v * ( v + 0.0245786 ) - 0.000090537;
	vec3 b = v * ( 0.983729 * v + 0.4329510 ) + 0.238081;
	return a / b;
}
vec3 ACESFilmicToneMapping( vec3 color ) {
	const mat3 ACESInputMat = mat3(
		vec3( 0.59719, 0.07600, 0.02840 ),		vec3( 0.35458, 0.90834, 0.13383 ),
		vec3( 0.04823, 0.01566, 0.83777 )
	);
	const mat3 ACESOutputMat = mat3(
		vec3(  1.60475, -0.10208, -0.00327 ),		vec3( -0.53108,  1.10813, -0.07276 ),
		vec3( -0.07367, -0.00605,  1.07602 )
	);
	color *= toneMappingExposure / 0.6;
	color = ACESInputMat * color;
	color = RRTAndODTFit( color );
	color = ACESOutputMat * color;
	return saturate( color );
}
const mat3 LINEAR_REC2020_TO_LINEAR_SRGB = mat3(
	vec3( 1.6605, - 0.1246, - 0.0182 ),
	vec3( - 0.5876, 1.1329, - 0.1006 ),
	vec3( - 0.0728, - 0.0083, 1.1187 )
);
const mat3 LINEAR_SRGB_TO_LINEAR_REC2020 = mat3(
	vec3( 0.6274, 0.0691, 0.0164 ),
	vec3( 0.3293, 0.9195, 0.0880 ),
	vec3( 0.0433, 0.0113, 0.8956 )
);
vec3 agxDefaultContrastApprox( vec3 x ) {
	vec3 x2 = x * x;
	vec3 x4 = x2 * x2;
	return + 15.5 * x4 * x2
		- 40.14 * x4 * x
		+ 31.96 * x4
		- 6.868 * x2 * x
		+ 0.4298 * x2
		+ 0.1191 * x
		- 0.00232;
}
vec3 AgXToneMapping( vec3 color ) {
	const mat3 AgXInsetMatrix = mat3(
		vec3( 0.856627153315983, 0.137318972929847, 0.11189821299995 ),
		vec3( 0.0951212405381588, 0.761241990602591, 0.0767994186031903 ),
		vec3( 0.0482516061458583, 0.101439036467562, 0.811302368396859 )
	);
	const mat3 AgXOutsetMatrix = mat3(
		vec3( 1.1271005818144368, - 0.1413297634984383, - 0.14132976349843826 ),
		vec3( - 0.11060664309660323, 1.157823702216272, - 0.11060664309660294 ),
		vec3( - 0.016493938717834573, - 0.016493938717834257, 1.2519364065950405 )
	);
	const float AgxMinEv = - 12.47393;	const float AgxMaxEv = 4.026069;
	color *= toneMappingExposure;
	color = LINEAR_SRGB_TO_LINEAR_REC2020 * color;
	color = AgXInsetMatrix * color;
	color = max( color, 1e-10 );	color = log2( color );
	color = ( color - AgxMinEv ) / ( AgxMaxEv - AgxMinEv );
	color = clamp( color, 0.0, 1.0 );
	color = agxDefaultContrastApprox( color );
	color = AgXOutsetMatrix * color;
	color = pow( max( vec3( 0.0 ), color ), vec3( 2.2 ) );
	color = LINEAR_REC2020_TO_LINEAR_SRGB * color;
	color = clamp( color, 0.0, 1.0 );
	return color;
}
vec3 NeutralToneMapping( vec3 color ) {
	const float StartCompression = 0.8 - 0.04;
	const float Desaturation = 0.15;
	color *= toneMappingExposure;
	float x = min( color.r, min( color.g, color.b ) );
	float offset = x < 0.08 ? x - 6.25 * x * x : 0.04;
	color -= offset;
	float peak = max( color.r, max( color.g, color.b ) );
	if ( peak < StartCompression ) return color;
	float d = 1. - StartCompression;
	float newPeak = 1. - d * d / ( peak + d - StartCompression );
	color *= newPeak / peak;
	float g = 1. - 1. / ( Desaturation * ( peak - newPeak ) + 1. );
	return mix( color, vec3( newPeak ), g );
}
vec3 CustomToneMapping( vec3 color ) { return color; }`,
    E4 = `#ifdef USE_TRANSMISSION
	material.transmission = transmission;
	material.transmissionAlpha = 1.0;
	material.thickness = thickness;
	material.attenuationDistance = attenuationDistance;
	material.attenuationColor = attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		material.transmission *= texture2D( transmissionMap, vTransmissionMapUv ).r;
	#endif
	#ifdef USE_THICKNESSMAP
		material.thickness *= texture2D( thicknessMap, vThicknessMapUv ).g;
	#endif
	vec3 pos = vWorldPosition;
	vec3 v = normalize( cameraPosition - pos );
	vec3 n = inverseTransformDirection( normal, viewMatrix );
	vec4 transmitted = getIBLVolumeRefraction(
		n, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
		pos, modelMatrix, viewMatrix, projectionMatrix, material.dispersion, material.ior, material.thickness,
		material.attenuationColor, material.attenuationDistance );
	material.transmissionAlpha = mix( material.transmissionAlpha, transmitted.a, material.transmission );
	totalDiffuse = mix( totalDiffuse, transmitted.rgb, material.transmission );
#endif`,
    C4 = `#ifdef USE_TRANSMISSION
	uniform float transmission;
	uniform float thickness;
	uniform float attenuationDistance;
	uniform vec3 attenuationColor;
	#ifdef USE_TRANSMISSIONMAP
		uniform sampler2D transmissionMap;
	#endif
	#ifdef USE_THICKNESSMAP
		uniform sampler2D thicknessMap;
	#endif
	uniform vec2 transmissionSamplerSize;
	uniform sampler2D transmissionSamplerMap;
	uniform mat4 modelMatrix;
	uniform mat4 projectionMatrix;
	varying vec3 vWorldPosition;
	float w0( float a ) {
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - a + 3.0 ) - 3.0 ) + 1.0 );
	}
	float w1( float a ) {
		return ( 1.0 / 6.0 ) * ( a *  a * ( 3.0 * a - 6.0 ) + 4.0 );
	}
	float w2( float a ){
		return ( 1.0 / 6.0 ) * ( a * ( a * ( - 3.0 * a + 3.0 ) + 3.0 ) + 1.0 );
	}
	float w3( float a ) {
		return ( 1.0 / 6.0 ) * ( a * a * a );
	}
	float g0( float a ) {
		return w0( a ) + w1( a );
	}
	float g1( float a ) {
		return w2( a ) + w3( a );
	}
	float h0( float a ) {
		return - 1.0 + w1( a ) / ( w0( a ) + w1( a ) );
	}
	float h1( float a ) {
		return 1.0 + w3( a ) / ( w2( a ) + w3( a ) );
	}
	vec4 bicubic( sampler2D tex, vec2 uv, vec4 texelSize, float lod ) {
		uv = uv * texelSize.zw + 0.5;
		vec2 iuv = floor( uv );
		vec2 fuv = fract( uv );
		float g0x = g0( fuv.x );
		float g1x = g1( fuv.x );
		float h0x = h0( fuv.x );
		float h1x = h1( fuv.x );
		float h0y = h0( fuv.y );
		float h1y = h1( fuv.y );
		vec2 p0 = ( vec2( iuv.x + h0x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p1 = ( vec2( iuv.x + h1x, iuv.y + h0y ) - 0.5 ) * texelSize.xy;
		vec2 p2 = ( vec2( iuv.x + h0x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		vec2 p3 = ( vec2( iuv.x + h1x, iuv.y + h1y ) - 0.5 ) * texelSize.xy;
		return g0( fuv.y ) * ( g0x * textureLod( tex, p0, lod ) + g1x * textureLod( tex, p1, lod ) ) +
			g1( fuv.y ) * ( g0x * textureLod( tex, p2, lod ) + g1x * textureLod( tex, p3, lod ) );
	}
	vec4 textureBicubic( sampler2D sampler, vec2 uv, float lod ) {
		vec2 fLodSize = vec2( textureSize( sampler, int( lod ) ) );
		vec2 cLodSize = vec2( textureSize( sampler, int( lod + 1.0 ) ) );
		vec2 fLodSizeInv = 1.0 / fLodSize;
		vec2 cLodSizeInv = 1.0 / cLodSize;
		vec4 fSample = bicubic( sampler, uv, vec4( fLodSizeInv, fLodSize ), floor( lod ) );
		vec4 cSample = bicubic( sampler, uv, vec4( cLodSizeInv, cLodSize ), ceil( lod ) );
		return mix( fSample, cSample, fract( lod ) );
	}
	vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
		vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
		vec3 modelScale;
		modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
		modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
		modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
		return normalize( refractionVector ) * thickness * modelScale;
	}
	float applyIorToRoughness( const in float roughness, const in float ior ) {
		return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
	}
	vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
		float lod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );
		return textureBicubic( transmissionSamplerMap, fragCoord.xy, lod );
	}
	vec3 volumeAttenuation( const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
		if ( isinf( attenuationDistance ) ) {
			return vec3( 1.0 );
		} else {
			vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
			vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance );			return transmittance;
		}
	}
	vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
		const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
		const in mat4 viewMatrix, const in mat4 projMatrix, const in float dispersion, const in float ior, const in float thickness,
		const in vec3 attenuationColor, const in float attenuationDistance ) {
		vec4 transmittedLight;
		vec3 transmittance;
		#ifdef USE_DISPERSION
			float halfSpread = ( ior - 1.0 ) * 0.025 * dispersion;
			vec3 iors = vec3( ior - halfSpread, ior, ior + halfSpread );
			for ( int i = 0; i < 3; i ++ ) {
				vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, iors[ i ], modelMatrix );
				vec3 refractedRayExit = position + transmissionRay;
		
				vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
				vec2 refractionCoords = ndcPos.xy / ndcPos.w;
				refractionCoords += 1.0;
				refractionCoords /= 2.0;
		
				vec4 transmissionSample = getTransmissionSample( refractionCoords, roughness, iors[ i ] );
				transmittedLight[ i ] = transmissionSample[ i ];
				transmittedLight.a += transmissionSample.a;
				transmittance[ i ] = diffuseColor[ i ] * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance )[ i ];
			}
			transmittedLight.a /= 3.0;
		
		#else
		
			vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
			vec3 refractedRayExit = position + transmissionRay;
			vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
			vec2 refractionCoords = ndcPos.xy / ndcPos.w;
			refractionCoords += 1.0;
			refractionCoords /= 2.0;
			transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
			transmittance = diffuseColor * volumeAttenuation( length( transmissionRay ), attenuationColor, attenuationDistance );
		
		#endif
		vec3 attenuatedColor = transmittance * transmittedLight.rgb;
		vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
		float transmittanceFactor = ( transmittance.r + transmittance.g + transmittance.b ) / 3.0;
		return vec4( ( 1.0 - F ) * attenuatedColor, 1.0 - ( 1.0 - transmittedLight.a ) * transmittanceFactor );
	}
#endif`,
    R4 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_SPECULARMAP
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    P4 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	varying vec2 vUv;
#endif
#ifdef USE_MAP
	uniform mat3 mapTransform;
	varying vec2 vMapUv;
#endif
#ifdef USE_ALPHAMAP
	uniform mat3 alphaMapTransform;
	varying vec2 vAlphaMapUv;
#endif
#ifdef USE_LIGHTMAP
	uniform mat3 lightMapTransform;
	varying vec2 vLightMapUv;
#endif
#ifdef USE_AOMAP
	uniform mat3 aoMapTransform;
	varying vec2 vAoMapUv;
#endif
#ifdef USE_BUMPMAP
	uniform mat3 bumpMapTransform;
	varying vec2 vBumpMapUv;
#endif
#ifdef USE_NORMALMAP
	uniform mat3 normalMapTransform;
	varying vec2 vNormalMapUv;
#endif
#ifdef USE_DISPLACEMENTMAP
	uniform mat3 displacementMapTransform;
	varying vec2 vDisplacementMapUv;
#endif
#ifdef USE_EMISSIVEMAP
	uniform mat3 emissiveMapTransform;
	varying vec2 vEmissiveMapUv;
#endif
#ifdef USE_METALNESSMAP
	uniform mat3 metalnessMapTransform;
	varying vec2 vMetalnessMapUv;
#endif
#ifdef USE_ROUGHNESSMAP
	uniform mat3 roughnessMapTransform;
	varying vec2 vRoughnessMapUv;
#endif
#ifdef USE_ANISOTROPYMAP
	uniform mat3 anisotropyMapTransform;
	varying vec2 vAnisotropyMapUv;
#endif
#ifdef USE_CLEARCOATMAP
	uniform mat3 clearcoatMapTransform;
	varying vec2 vClearcoatMapUv;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	uniform mat3 clearcoatNormalMapTransform;
	varying vec2 vClearcoatNormalMapUv;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	uniform mat3 clearcoatRoughnessMapTransform;
	varying vec2 vClearcoatRoughnessMapUv;
#endif
#ifdef USE_SHEEN_COLORMAP
	uniform mat3 sheenColorMapTransform;
	varying vec2 vSheenColorMapUv;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	uniform mat3 sheenRoughnessMapTransform;
	varying vec2 vSheenRoughnessMapUv;
#endif
#ifdef USE_IRIDESCENCEMAP
	uniform mat3 iridescenceMapTransform;
	varying vec2 vIridescenceMapUv;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	uniform mat3 iridescenceThicknessMapTransform;
	varying vec2 vIridescenceThicknessMapUv;
#endif
#ifdef USE_SPECULARMAP
	uniform mat3 specularMapTransform;
	varying vec2 vSpecularMapUv;
#endif
#ifdef USE_SPECULAR_COLORMAP
	uniform mat3 specularColorMapTransform;
	varying vec2 vSpecularColorMapUv;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	uniform mat3 specularIntensityMapTransform;
	varying vec2 vSpecularIntensityMapUv;
#endif
#ifdef USE_TRANSMISSIONMAP
	uniform mat3 transmissionMapTransform;
	varying vec2 vTransmissionMapUv;
#endif
#ifdef USE_THICKNESSMAP
	uniform mat3 thicknessMapTransform;
	varying vec2 vThicknessMapUv;
#endif`,
    I4 = `#if defined( USE_UV ) || defined( USE_ANISOTROPY )
	vUv = vec3( uv, 1 ).xy;
#endif
#ifdef USE_MAP
	vMapUv = ( mapTransform * vec3( MAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ALPHAMAP
	vAlphaMapUv = ( alphaMapTransform * vec3( ALPHAMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_LIGHTMAP
	vLightMapUv = ( lightMapTransform * vec3( LIGHTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_AOMAP
	vAoMapUv = ( aoMapTransform * vec3( AOMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_BUMPMAP
	vBumpMapUv = ( bumpMapTransform * vec3( BUMPMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_NORMALMAP
	vNormalMapUv = ( normalMapTransform * vec3( NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_DISPLACEMENTMAP
	vDisplacementMapUv = ( displacementMapTransform * vec3( DISPLACEMENTMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_EMISSIVEMAP
	vEmissiveMapUv = ( emissiveMapTransform * vec3( EMISSIVEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_METALNESSMAP
	vMetalnessMapUv = ( metalnessMapTransform * vec3( METALNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ROUGHNESSMAP
	vRoughnessMapUv = ( roughnessMapTransform * vec3( ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_ANISOTROPYMAP
	vAnisotropyMapUv = ( anisotropyMapTransform * vec3( ANISOTROPYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOATMAP
	vClearcoatMapUv = ( clearcoatMapTransform * vec3( CLEARCOATMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_NORMALMAP
	vClearcoatNormalMapUv = ( clearcoatNormalMapTransform * vec3( CLEARCOAT_NORMALMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_CLEARCOAT_ROUGHNESSMAP
	vClearcoatRoughnessMapUv = ( clearcoatRoughnessMapTransform * vec3( CLEARCOAT_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCEMAP
	vIridescenceMapUv = ( iridescenceMapTransform * vec3( IRIDESCENCEMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_IRIDESCENCE_THICKNESSMAP
	vIridescenceThicknessMapUv = ( iridescenceThicknessMapTransform * vec3( IRIDESCENCE_THICKNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_COLORMAP
	vSheenColorMapUv = ( sheenColorMapTransform * vec3( SHEEN_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SHEEN_ROUGHNESSMAP
	vSheenRoughnessMapUv = ( sheenRoughnessMapTransform * vec3( SHEEN_ROUGHNESSMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULARMAP
	vSpecularMapUv = ( specularMapTransform * vec3( SPECULARMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_COLORMAP
	vSpecularColorMapUv = ( specularColorMapTransform * vec3( SPECULAR_COLORMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_SPECULAR_INTENSITYMAP
	vSpecularIntensityMapUv = ( specularIntensityMapTransform * vec3( SPECULAR_INTENSITYMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_TRANSMISSIONMAP
	vTransmissionMapUv = ( transmissionMapTransform * vec3( TRANSMISSIONMAP_UV, 1 ) ).xy;
#endif
#ifdef USE_THICKNESSMAP
	vThicknessMapUv = ( thicknessMapTransform * vec3( THICKNESSMAP_UV, 1 ) ).xy;
#endif`,
    B4 = `#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP ) || defined ( USE_TRANSMISSION ) || NUM_SPOT_LIGHT_COORDS > 0
	vec4 worldPosition = vec4( transformed, 1.0 );
	#ifdef USE_BATCHING
		worldPosition = batchingMatrix * worldPosition;
	#endif
	#ifdef USE_INSTANCING
		worldPosition = instanceMatrix * worldPosition;
	#endif
	worldPosition = modelMatrix * worldPosition;
#endif`;
const D4 = `varying vec2 vUv;
uniform mat3 uvTransform;
void main() {
	vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	gl_Position = vec4( position.xy, 1.0, 1.0 );
}`,
    L4 = `uniform sampler2D t2D;
uniform float backgroundIntensity;
varying vec2 vUv;
void main() {
	vec4 texColor = texture2D( t2D, vUv );
	#ifdef DECODE_VIDEO_TEXTURE
		texColor = vec4( mix( pow( texColor.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), texColor.rgb * 0.0773993808, vec3( lessThanEqual( texColor.rgb, vec3( 0.04045 ) ) ) ), texColor.w );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    F4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    U4 = `#ifdef ENVMAP_TYPE_CUBE
	uniform samplerCube envMap;
#elif defined( ENVMAP_TYPE_CUBE_UV )
	uniform sampler2D envMap;
#endif
uniform float flipEnvMap;
uniform float backgroundBlurriness;
uniform float backgroundIntensity;
uniform mat3 backgroundRotation;
varying vec3 vWorldDirection;
#include <cube_uv_reflection_fragment>
void main() {
	#ifdef ENVMAP_TYPE_CUBE
		vec4 texColor = textureCube( envMap, backgroundRotation * vec3( flipEnvMap * vWorldDirection.x, vWorldDirection.yz ) );
	#elif defined( ENVMAP_TYPE_CUBE_UV )
		vec4 texColor = textureCubeUV( envMap, backgroundRotation * vWorldDirection, backgroundBlurriness );
	#else
		vec4 texColor = vec4( 0.0, 0.0, 0.0, 1.0 );
	#endif
	texColor.rgb *= backgroundIntensity;
	gl_FragColor = texColor;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    O4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
	gl_Position.z = gl_Position.w;
}`,
    N4 = `uniform samplerCube tCube;
uniform float tFlip;
uniform float opacity;
varying vec3 vWorldDirection;
void main() {
	vec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );
	gl_FragColor = texColor;
	gl_FragColor.a *= opacity;
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    k4 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
varying vec2 vHighPrecisionZW;
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vHighPrecisionZW = gl_Position.zw;
}`,
    z4 = `#if DEPTH_PACKING == 3200
	uniform float opacity;
#endif
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
varying vec2 vHighPrecisionZW;
void main() {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#if DEPTH_PACKING == 3200
		diffuseColor.a = opacity;
	#endif
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <logdepthbuf_fragment>
	float fragCoordZ = 0.5 * vHighPrecisionZW[0] / vHighPrecisionZW[1] + 0.5;
	#if DEPTH_PACKING == 3200
		gl_FragColor = vec4( vec3( 1.0 - fragCoordZ ), opacity );
	#elif DEPTH_PACKING == 3201
		gl_FragColor = packDepthToRGBA( fragCoordZ );
	#elif DEPTH_PACKING == 3202
		gl_FragColor = vec4( packDepthToRGB( fragCoordZ ), 1.0 );
	#elif DEPTH_PACKING == 3203
		gl_FragColor = vec4( packDepthToRG( fragCoordZ ), 0.0, 1.0 );
	#endif
}`,
    G4 = `#define DISTANCE
varying vec3 vWorldPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <skinbase_vertex>
	#include <morphinstance_vertex>
	#ifdef USE_DISPLACEMENTMAP
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <worldpos_vertex>
	#include <clipping_planes_vertex>
	vWorldPosition = worldPosition.xyz;
}`,
    H4 = `#define DISTANCE
uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec3 vWorldPosition;
#include <common>
#include <packing>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <clipping_planes_pars_fragment>
void main () {
	vec4 diffuseColor = vec4( 1.0 );
	#include <clipping_planes_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	float dist = length( vWorldPosition - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist );
	gl_FragColor = packDepthToRGBA( dist );
}`,
    V4 = `varying vec3 vWorldDirection;
#include <common>
void main() {
	vWorldDirection = transformDirection( position, modelMatrix );
	#include <begin_vertex>
	#include <project_vertex>
}`,
    W4 = `uniform sampler2D tEquirect;
varying vec3 vWorldDirection;
#include <common>
void main() {
	vec3 direction = normalize( vWorldDirection );
	vec2 sampleUV = equirectUv( direction );
	gl_FragColor = texture2D( tEquirect, sampleUV );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
}`,
    j4 = `uniform float scale;
attribute float lineDistance;
varying float vLineDistance;
#include <common>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	vLineDistance = scale * lineDistance;
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    X4 = `uniform vec3 diffuse;
uniform float opacity;
uniform float dashSize;
uniform float totalSize;
varying float vLineDistance;
#include <common>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	if ( mod( vLineDistance, totalSize ) > dashSize ) {
		discard;
	}
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    Y4 = `#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#if defined ( USE_ENVMAP ) || defined ( USE_SKINNING )
		#include <beginnormal_vertex>
		#include <morphnormal_vertex>
		#include <skinbase_vertex>
		#include <skinnormal_vertex>
		#include <defaultnormal_vertex>
	#endif
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <fog_vertex>
}`,
    J4 = `uniform vec3 diffuse;
uniform float opacity;
#ifndef FLAT_SHADED
	varying vec3 vNormal;
#endif
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	#ifdef USE_LIGHTMAP
		vec4 lightMapTexel = texture2D( lightMap, vLightMapUv );
		reflectedLight.indirectDiffuse += lightMapTexel.rgb * lightMapIntensity * RECIPROCAL_PI;
	#else
		reflectedLight.indirectDiffuse += vec3( 1.0 );
	#endif
	#include <aomap_fragment>
	reflectedLight.indirectDiffuse *= diffuseColor.rgb;
	vec3 outgoingLight = reflectedLight.indirectDiffuse;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    K4 = `#define LAMBERT
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    q4 = `#define LAMBERT
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_lambert_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_lambert_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    Z4 = `#define MATCAP
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <color_pars_vertex>
#include <displacementmap_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
	vViewPosition = - mvPosition.xyz;
}`,
    Q4 = `#define MATCAP
uniform vec3 diffuse;
uniform float opacity;
uniform sampler2D matcap;
varying vec3 vViewPosition;
#include <common>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	vec3 viewDir = normalize( vViewPosition );
	vec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );
	vec3 y = cross( viewDir, x );
	vec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;
	#ifdef USE_MATCAP
		vec4 matcapColor = texture2D( matcap, uv );
	#else
		vec4 matcapColor = vec4( vec3( mix( 0.2, 0.8, uv.y ) ), 1.0 );
	#endif
	vec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    $4 = `#define NORMAL
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	vViewPosition = - mvPosition.xyz;
#endif
}`,
    eG = `#define NORMAL
uniform float opacity;
#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP_TANGENTSPACE )
	varying vec3 vViewPosition;
#endif
#include <packing>
#include <uv_pars_fragment>
#include <normal_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( 0.0, 0.0, 0.0, opacity );
	#include <clipping_planes_fragment>
	#include <logdepthbuf_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	gl_FragColor = vec4( packNormalToRGB( normal ), diffuseColor.a );
	#ifdef OPAQUE
		gl_FragColor.a = 1.0;
	#endif
}`,
    tG = `#define PHONG
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <envmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <envmap_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    nG = `#define PHONG
uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_phong_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <specularmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <specularmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_phong_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;
	#include <envmap_fragment>
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    iG = `#define STANDARD
varying vec3 vViewPosition;
#ifdef USE_TRANSMISSION
	varying vec3 vWorldPosition;
#endif
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
#ifdef USE_TRANSMISSION
	vWorldPosition = worldPosition.xyz;
#endif
}`,
    rG = `#define STANDARD
#ifdef PHYSICAL
	#define IOR
	#define USE_SPECULAR
#endif
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float roughness;
uniform float metalness;
uniform float opacity;
#ifdef IOR
	uniform float ior;
#endif
#ifdef USE_SPECULAR
	uniform float specularIntensity;
	uniform vec3 specularColor;
	#ifdef USE_SPECULAR_COLORMAP
		uniform sampler2D specularColorMap;
	#endif
	#ifdef USE_SPECULAR_INTENSITYMAP
		uniform sampler2D specularIntensityMap;
	#endif
#endif
#ifdef USE_CLEARCOAT
	uniform float clearcoat;
	uniform float clearcoatRoughness;
#endif
#ifdef USE_DISPERSION
	uniform float dispersion;
#endif
#ifdef USE_IRIDESCENCE
	uniform float iridescence;
	uniform float iridescenceIOR;
	uniform float iridescenceThicknessMinimum;
	uniform float iridescenceThicknessMaximum;
#endif
#ifdef USE_SHEEN
	uniform vec3 sheenColor;
	uniform float sheenRoughness;
	#ifdef USE_SHEEN_COLORMAP
		uniform sampler2D sheenColorMap;
	#endif
	#ifdef USE_SHEEN_ROUGHNESSMAP
		uniform sampler2D sheenRoughnessMap;
	#endif
#endif
#ifdef USE_ANISOTROPY
	uniform vec2 anisotropyVector;
	#ifdef USE_ANISOTROPYMAP
		uniform sampler2D anisotropyMap;
	#endif
#endif
varying vec3 vViewPosition;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <iridescence_fragment>
#include <cube_uv_reflection_fragment>
#include <envmap_common_pars_fragment>
#include <envmap_physical_pars_fragment>
#include <fog_pars_fragment>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_physical_pars_fragment>
#include <transmission_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <clearcoat_pars_fragment>
#include <iridescence_pars_fragment>
#include <roughnessmap_pars_fragment>
#include <metalnessmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <roughnessmap_fragment>
	#include <metalnessmap_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <clearcoat_normal_fragment_begin>
	#include <clearcoat_normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_physical_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 totalDiffuse = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse;
	vec3 totalSpecular = reflectedLight.directSpecular + reflectedLight.indirectSpecular;
	#include <transmission_fragment>
	vec3 outgoingLight = totalDiffuse + totalSpecular + totalEmissiveRadiance;
	#ifdef USE_SHEEN
		float sheenEnergyComp = 1.0 - 0.157 * max3( material.sheenColor );
		outgoingLight = outgoingLight * sheenEnergyComp + sheenSpecularDirect + sheenSpecularIndirect;
	#endif
	#ifdef USE_CLEARCOAT
		float dotNVcc = saturate( dot( geometryClearcoatNormal, geometryViewDir ) );
		vec3 Fcc = F_Schlick( material.clearcoatF0, material.clearcoatF90, dotNVcc );
		outgoingLight = outgoingLight * ( 1.0 - material.clearcoat * Fcc ) + ( clearcoatSpecularDirect + clearcoatSpecularIndirect ) * material.clearcoat;
	#endif
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    sG = `#define TOON
varying vec3 vViewPosition;
#include <common>
#include <batching_pars_vertex>
#include <uv_pars_vertex>
#include <displacementmap_pars_vertex>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <normal_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <shadowmap_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <normal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <displacementmap_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	vViewPosition = - mvPosition.xyz;
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    oG = `#define TOON
uniform vec3 diffuse;
uniform vec3 emissive;
uniform float opacity;
#include <common>
#include <packing>
#include <dithering_pars_fragment>
#include <color_pars_fragment>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <aomap_pars_fragment>
#include <lightmap_pars_fragment>
#include <emissivemap_pars_fragment>
#include <gradientmap_pars_fragment>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <normal_pars_fragment>
#include <lights_toon_pars_fragment>
#include <shadowmap_pars_fragment>
#include <bumpmap_pars_fragment>
#include <normalmap_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	ReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );
	vec3 totalEmissiveRadiance = emissive;
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <color_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	#include <normal_fragment_begin>
	#include <normal_fragment_maps>
	#include <emissivemap_fragment>
	#include <lights_toon_fragment>
	#include <lights_fragment_begin>
	#include <lights_fragment_maps>
	#include <lights_fragment_end>
	#include <aomap_fragment>
	vec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
	#include <dithering_fragment>
}`,
    aG = `uniform float size;
uniform float scale;
#include <common>
#include <color_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
#ifdef USE_POINTS_UV
	varying vec2 vUv;
	uniform mat3 uvTransform;
#endif
void main() {
	#ifdef USE_POINTS_UV
		vUv = ( uvTransform * vec3( uv, 1 ) ).xy;
	#endif
	#include <color_vertex>
	#include <morphinstance_vertex>
	#include <morphcolor_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <project_vertex>
	gl_PointSize = size;
	#ifdef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );
	#endif
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <worldpos_vertex>
	#include <fog_vertex>
}`,
    lG = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <color_pars_fragment>
#include <map_particle_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_particle_fragment>
	#include <color_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
	#include <premultiplied_alpha_fragment>
}`,
    cG = `#include <common>
#include <batching_pars_vertex>
#include <fog_pars_vertex>
#include <morphtarget_pars_vertex>
#include <skinning_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <shadowmap_pars_vertex>
void main() {
	#include <batching_vertex>
	#include <beginnormal_vertex>
	#include <morphinstance_vertex>
	#include <morphnormal_vertex>
	#include <skinbase_vertex>
	#include <skinnormal_vertex>
	#include <defaultnormal_vertex>
	#include <begin_vertex>
	#include <morphtarget_vertex>
	#include <skinning_vertex>
	#include <project_vertex>
	#include <logdepthbuf_vertex>
	#include <worldpos_vertex>
	#include <shadowmap_vertex>
	#include <fog_vertex>
}`,
    uG = `uniform vec3 color;
uniform float opacity;
#include <common>
#include <packing>
#include <fog_pars_fragment>
#include <bsdfs>
#include <lights_pars_begin>
#include <logdepthbuf_pars_fragment>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
void main() {
	#include <logdepthbuf_fragment>
	gl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
    fG = `uniform float rotation;
uniform vec2 center;
#include <common>
#include <uv_pars_vertex>
#include <fog_pars_vertex>
#include <logdepthbuf_pars_vertex>
#include <clipping_planes_pars_vertex>
void main() {
	#include <uv_vertex>
	vec4 mvPosition = modelViewMatrix[ 3 ];
	vec2 scale = vec2( length( modelMatrix[ 0 ].xyz ), length( modelMatrix[ 1 ].xyz ) );
	#ifndef USE_SIZEATTENUATION
		bool isPerspective = isPerspectiveMatrix( projectionMatrix );
		if ( isPerspective ) scale *= - mvPosition.z;
	#endif
	vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;
	vec2 rotatedPosition;
	rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
	rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
	mvPosition.xy += rotatedPosition;
	gl_Position = projectionMatrix * mvPosition;
	#include <logdepthbuf_vertex>
	#include <clipping_planes_vertex>
	#include <fog_vertex>
}`,
    hG = `uniform vec3 diffuse;
uniform float opacity;
#include <common>
#include <uv_pars_fragment>
#include <map_pars_fragment>
#include <alphamap_pars_fragment>
#include <alphatest_pars_fragment>
#include <alphahash_pars_fragment>
#include <fog_pars_fragment>
#include <logdepthbuf_pars_fragment>
#include <clipping_planes_pars_fragment>
void main() {
	vec4 diffuseColor = vec4( diffuse, opacity );
	#include <clipping_planes_fragment>
	vec3 outgoingLight = vec3( 0.0 );
	#include <logdepthbuf_fragment>
	#include <map_fragment>
	#include <alphamap_fragment>
	#include <alphatest_fragment>
	#include <alphahash_fragment>
	outgoingLight = diffuseColor.rgb;
	#include <opaque_fragment>
	#include <tonemapping_fragment>
	#include <colorspace_fragment>
	#include <fog_fragment>
}`,
    Jt = {
        alphahash_fragment: Lk,
        alphahash_pars_fragment: Fk,
        alphamap_fragment: Uk,
        alphamap_pars_fragment: Ok,
        alphatest_fragment: Nk,
        alphatest_pars_fragment: kk,
        aomap_fragment: zk,
        aomap_pars_fragment: Gk,
        batching_pars_vertex: Hk,
        batching_vertex: Vk,
        begin_vertex: Wk,
        beginnormal_vertex: jk,
        bsdfs: Xk,
        iridescence_fragment: Yk,
        bumpmap_pars_fragment: Jk,
        clipping_planes_fragment: Kk,
        clipping_planes_pars_fragment: qk,
        clipping_planes_pars_vertex: Zk,
        clipping_planes_vertex: Qk,
        color_fragment: $k,
        color_pars_fragment: ez,
        color_pars_vertex: tz,
        color_vertex: nz,
        common: iz,
        cube_uv_reflection_fragment: rz,
        defaultnormal_vertex: sz,
        displacementmap_pars_vertex: oz,
        displacementmap_vertex: az,
        emissivemap_fragment: lz,
        emissivemap_pars_fragment: cz,
        colorspace_fragment: uz,
        colorspace_pars_fragment: fz,
        envmap_fragment: hz,
        envmap_common_pars_fragment: dz,
        envmap_pars_fragment: pz,
        envmap_pars_vertex: mz,
        envmap_physical_pars_fragment: Tz,
        envmap_vertex: gz,
        fog_vertex: vz,
        fog_pars_vertex: yz,
        fog_fragment: _z,
        fog_pars_fragment: xz,
        gradientmap_pars_fragment: Az,
        lightmap_pars_fragment: Sz,
        lights_lambert_fragment: Mz,
        lights_lambert_pars_fragment: wz,
        lights_pars_begin: bz,
        lights_toon_fragment: Ez,
        lights_toon_pars_fragment: Cz,
        lights_phong_fragment: Rz,
        lights_phong_pars_fragment: Pz,
        lights_physical_fragment: Iz,
        lights_physical_pars_fragment: Bz,
        lights_fragment_begin: Dz,
        lights_fragment_maps: Lz,
        lights_fragment_end: Fz,
        logdepthbuf_fragment: Uz,
        logdepthbuf_pars_fragment: Oz,
        logdepthbuf_pars_vertex: Nz,
        logdepthbuf_vertex: kz,
        map_fragment: zz,
        map_pars_fragment: Gz,
        map_particle_fragment: Hz,
        map_particle_pars_fragment: Vz,
        metalnessmap_fragment: Wz,
        metalnessmap_pars_fragment: jz,
        morphinstance_vertex: Xz,
        morphcolor_vertex: Yz,
        morphnormal_vertex: Jz,
        morphtarget_pars_vertex: Kz,
        morphtarget_vertex: qz,
        normal_fragment_begin: Zz,
        normal_fragment_maps: Qz,
        normal_pars_fragment: $z,
        normal_pars_vertex: e4,
        normal_vertex: t4,
        normalmap_pars_fragment: n4,
        clearcoat_normal_fragment_begin: i4,
        clearcoat_normal_fragment_maps: r4,
        clearcoat_pars_fragment: s4,
        iridescence_pars_fragment: o4,
        opaque_fragment: a4,
        packing: l4,
        premultiplied_alpha_fragment: c4,
        project_vertex: u4,
        dithering_fragment: f4,
        dithering_pars_fragment: h4,
        roughnessmap_fragment: d4,
        roughnessmap_pars_fragment: p4,
        shadowmap_pars_fragment: m4,
        shadowmap_pars_vertex: g4,
        shadowmap_vertex: v4,
        shadowmask_pars_fragment: y4,
        skinbase_vertex: _4,
        skinning_pars_vertex: x4,
        skinning_vertex: A4,
        skinnormal_vertex: S4,
        specularmap_fragment: M4,
        specularmap_pars_fragment: w4,
        tonemapping_fragment: b4,
        tonemapping_pars_fragment: T4,
        transmission_fragment: E4,
        transmission_pars_fragment: C4,
        uv_pars_fragment: R4,
        uv_pars_vertex: P4,
        uv_vertex: I4,
        worldpos_vertex: B4,
        background_vert: D4,
        background_frag: L4,
        backgroundCube_vert: F4,
        backgroundCube_frag: U4,
        cube_vert: O4,
        cube_frag: N4,
        depth_vert: k4,
        depth_frag: z4,
        distanceRGBA_vert: G4,
        distanceRGBA_frag: H4,
        equirect_vert: V4,
        equirect_frag: W4,
        linedashed_vert: j4,
        linedashed_frag: X4,
        meshbasic_vert: Y4,
        meshbasic_frag: J4,
        meshlambert_vert: K4,
        meshlambert_frag: q4,
        meshmatcap_vert: Z4,
        meshmatcap_frag: Q4,
        meshnormal_vert: $4,
        meshnormal_frag: eG,
        meshphong_vert: tG,
        meshphong_frag: nG,
        meshphysical_vert: iG,
        meshphysical_frag: rG,
        meshtoon_vert: sG,
        meshtoon_frag: oG,
        points_vert: aG,
        points_frag: lG,
        shadow_vert: cG,
        shadow_frag: uG,
        sprite_vert: fG,
        sprite_frag: hG
    },
    dt = {
        common: {
            diffuse: {
                value: new rt(16777215)
            },
            opacity: {
                value: 1
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new jt
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new jt
            },
            alphaTest: {
                value: 0
            }
        },
        specularmap: {
            specularMap: {
                value: null
            },
            specularMapTransform: {
                value: new jt
            }
        },
        envmap: {
            envMap: {
                value: null
            },
            envMapRotation: {
                value: new jt
            },
            flipEnvMap: {
                value: -1
            },
            reflectivity: {
                value: 1
            },
            ior: {
                value: 1.5
            },
            refractionRatio: {
                value: .98
            }
        },
        aomap: {
            aoMap: {
                value: null
            },
            aoMapIntensity: {
                value: 1
            },
            aoMapTransform: {
                value: new jt
            }
        },
        lightmap: {
            lightMap: {
                value: null
            },
            lightMapIntensity: {
                value: 1
            },
            lightMapTransform: {
                value: new jt
            }
        },
        bumpmap: {
            bumpMap: {
                value: null
            },
            bumpMapTransform: {
                value: new jt
            },
            bumpScale: {
                value: 1
            }
        },
        normalmap: {
            normalMap: {
                value: null
            },
            normalMapTransform: {
                value: new jt
            },
            normalScale: {
                value: new Ue(1, 1)
            }
        },
        displacementmap: {
            displacementMap: {
                value: null
            },
            displacementMapTransform: {
                value: new jt
            },
            displacementScale: {
                value: 1
            },
            displacementBias: {
                value: 0
            }
        },
        emissivemap: {
            emissiveMap: {
                value: null
            },
            emissiveMapTransform: {
                value: new jt
            }
        },
        metalnessmap: {
            metalnessMap: {
                value: null
            },
            metalnessMapTransform: {
                value: new jt
            }
        },
        roughnessmap: {
            roughnessMap: {
                value: null
            },
            roughnessMapTransform: {
                value: new jt
            }
        },
        gradientmap: {
            gradientMap: {
                value: null
            }
        },
        fog: {
            fogDensity: {
                value: 25e-5
            },
            fogNear: {
                value: 1
            },
            fogFar: {
                value: 2e3
            },
            fogColor: {
                value: new rt(16777215)
            }
        },
        lights: {
            ambientLightColor: {
                value: []
            },
            lightProbe: {
                value: []
            },
            directionalLights: {
                value: [],
                properties: {
                    direction: {},
                    color: {}
                }
            },
            directionalLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            directionalShadowMap: {
                value: []
            },
            directionalShadowMatrix: {
                value: []
            },
            spotLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    direction: {},
                    distance: {},
                    coneCos: {},
                    penumbraCos: {},
                    decay: {}
                }
            },
            spotLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {}
                }
            },
            spotLightMap: {
                value: []
            },
            spotShadowMap: {
                value: []
            },
            spotLightMatrix: {
                value: []
            },
            pointLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    decay: {},
                    distance: {}
                }
            },
            pointLightShadows: {
                value: [],
                properties: {
                    shadowIntensity: 1,
                    shadowBias: {},
                    shadowNormalBias: {},
                    shadowRadius: {},
                    shadowMapSize: {},
                    shadowCameraNear: {},
                    shadowCameraFar: {}
                }
            },
            pointShadowMap: {
                value: []
            },
            pointShadowMatrix: {
                value: []
            },
            hemisphereLights: {
                value: [],
                properties: {
                    direction: {},
                    skyColor: {},
                    groundColor: {}
                }
            },
            rectAreaLights: {
                value: [],
                properties: {
                    color: {},
                    position: {},
                    width: {},
                    height: {}
                }
            },
            ltc_1: {
                value: null
            },
            ltc_2: {
                value: null
            }
        },
        points: {
            diffuse: {
                value: new rt(16777215)
            },
            opacity: {
                value: 1
            },
            size: {
                value: 1
            },
            scale: {
                value: 1
            },
            map: {
                value: null
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new jt
            },
            alphaTest: {
                value: 0
            },
            uvTransform: {
                value: new jt
            }
        },
        sprite: {
            diffuse: {
                value: new rt(16777215)
            },
            opacity: {
                value: 1
            },
            center: {
                value: new Ue(.5, .5)
            },
            rotation: {
                value: 0
            },
            map: {
                value: null
            },
            mapTransform: {
                value: new jt
            },
            alphaMap: {
                value: null
            },
            alphaMapTransform: {
                value: new jt
            },
            alphaTest: {
                value: 0
            }
        }
    },
    Vs = {
        basic: {
            uniforms: Cr([dt.common, dt.specularmap, dt.envmap, dt.aomap, dt.lightmap, dt.fog]),
            vertexShader: Jt.meshbasic_vert,
            fragmentShader: Jt.meshbasic_frag
        },
        lambert: {
            uniforms: Cr([dt.common, dt.specularmap, dt.envmap, dt.aomap, dt.lightmap, dt.emissivemap, dt.bumpmap, dt.normalmap, dt.displacementmap, dt.fog, dt.lights, {
                emissive: {
                    value: new rt(0)
                }
            }]),
            vertexShader: Jt.meshlambert_vert,
            fragmentShader: Jt.meshlambert_frag
        },
        phong: {
            uniforms: Cr([dt.common, dt.specularmap, dt.envmap, dt.aomap, dt.lightmap, dt.emissivemap, dt.bumpmap, dt.normalmap, dt.displacementmap, dt.fog, dt.lights, {
                emissive: {
                    value: new rt(0)
                },
                specular: {
                    value: new rt(1118481)
                },
                shininess: {
                    value: 30
                }
            }]),
            vertexShader: Jt.meshphong_vert,
            fragmentShader: Jt.meshphong_frag
        },
        standard: {
            uniforms: Cr([dt.common, dt.envmap, dt.aomap, dt.lightmap, dt.emissivemap, dt.bumpmap, dt.normalmap, dt.displacementmap, dt.roughnessmap, dt.metalnessmap, dt.fog, dt.lights, {
                emissive: {
                    value: new rt(0)
                },
                roughness: {
                    value: 1
                },
                metalness: {
                    value: 0
                },
                envMapIntensity: {
                    value: 1
                }
            }]),
            vertexShader: Jt.meshphysical_vert,
            fragmentShader: Jt.meshphysical_frag
        },
        toon: {
            uniforms: Cr([dt.common, dt.aomap, dt.lightmap, dt.emissivemap, dt.bumpmap, dt.normalmap, dt.displacementmap, dt.gradientmap, dt.fog, dt.lights, {
                emissive: {
                    value: new rt(0)
                }
            }]),
            vertexShader: Jt.meshtoon_vert,
            fragmentShader: Jt.meshtoon_frag
        },
        matcap: {
            uniforms: Cr([dt.common, dt.bumpmap, dt.normalmap, dt.displacementmap, dt.fog, {
                matcap: {
                    value: null
                }
            }]),
            vertexShader: Jt.meshmatcap_vert,
            fragmentShader: Jt.meshmatcap_frag
        },
        points: {
            uniforms: Cr([dt.points, dt.fog]),
            vertexShader: Jt.points_vert,
            fragmentShader: Jt.points_frag
        },
        dashed: {
            uniforms: Cr([dt.common, dt.fog, {
                scale: {
                    value: 1
                },
                dashSize: {
                    value: 1
                },
                totalSize: {
                    value: 2
                }
            }]),
            vertexShader: Jt.linedashed_vert,
            fragmentShader: Jt.linedashed_frag
        },
        depth: {
            uniforms: Cr([dt.common, dt.displacementmap]),
            vertexShader: Jt.depth_vert,
            fragmentShader: Jt.depth_frag
        },
        normal: {
            uniforms: Cr([dt.common, dt.bumpmap, dt.normalmap, dt.displacementmap, {
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Jt.meshnormal_vert,
            fragmentShader: Jt.meshnormal_frag
        },
        sprite: {
            uniforms: Cr([dt.sprite, dt.fog]),
            vertexShader: Jt.sprite_vert,
            fragmentShader: Jt.sprite_frag
        },
        background: {
            uniforms: {
                uvTransform: {
                    value: new jt
                },
                t2D: {
                    value: null
                },
                backgroundIntensity: {
                    value: 1
                }
            },
            vertexShader: Jt.background_vert,
            fragmentShader: Jt.background_frag
        },
        backgroundCube: {
            uniforms: {
                envMap: {
                    value: null
                },
                flipEnvMap: {
                    value: -1
                },
                backgroundBlurriness: {
                    value: 0
                },
                backgroundIntensity: {
                    value: 1
                },
                backgroundRotation: {
                    value: new jt
                }
            },
            vertexShader: Jt.backgroundCube_vert,
            fragmentShader: Jt.backgroundCube_frag
        },
        cube: {
            uniforms: {
                tCube: {
                    value: null
                },
                tFlip: {
                    value: -1
                },
                opacity: {
                    value: 1
                }
            },
            vertexShader: Jt.cube_vert,
            fragmentShader: Jt.cube_frag
        },
        equirect: {
            uniforms: {
                tEquirect: {
                    value: null
                }
            },
            vertexShader: Jt.equirect_vert,
            fragmentShader: Jt.equirect_frag
        },
        distanceRGBA: {
            uniforms: Cr([dt.common, dt.displacementmap, {
                referencePosition: {
                    value: new K
                },
                nearDistance: {
                    value: 1
                },
                farDistance: {
                    value: 1e3
                }
            }]),
            vertexShader: Jt.distanceRGBA_vert,
            fragmentShader: Jt.distanceRGBA_frag
        },
        shadow: {
            uniforms: Cr([dt.lights, dt.fog, {
                color: {
                    value: new rt(0)
                },
                opacity: {
                    value: 1
                }
            }]),
            vertexShader: Jt.shadow_vert,
            fragmentShader: Jt.shadow_frag
        }
    };
Vs.physical = {
    uniforms: Cr([Vs.standard.uniforms, {
        clearcoat: {
            value: 0
        },
        clearcoatMap: {
            value: null
        },
        clearcoatMapTransform: {
            value: new jt
        },
        clearcoatNormalMap: {
            value: null
        },
        clearcoatNormalMapTransform: {
            value: new jt
        },
        clearcoatNormalScale: {
            value: new Ue(1, 1)
        },
        clearcoatRoughness: {
            value: 0
        },
        clearcoatRoughnessMap: {
            value: null
        },
        clearcoatRoughnessMapTransform: {
            value: new jt
        },
        dispersion: {
            value: 0
        },
        iridescence: {
            value: 0
        },
        iridescenceMap: {
            value: null
        },
        iridescenceMapTransform: {
            value: new jt
        },
        iridescenceIOR: {
            value: 1.3
        },
        iridescenceThicknessMinimum: {
            value: 100
        },
        iridescenceThicknessMaximum: {
            value: 400
        },
        iridescenceThicknessMap: {
            value: null
        },
        iridescenceThicknessMapTransform: {
            value: new jt
        },
        sheen: {
            value: 0
        },
        sheenColor: {
            value: new rt(0)
        },
        sheenColorMap: {
            value: null
        },
        sheenColorMapTransform: {
            value: new jt
        },
        sheenRoughness: {
            value: 1
        },
        sheenRoughnessMap: {
            value: null
        },
        sheenRoughnessMapTransform: {
            value: new jt
        },
        transmission: {
            value: 0
        },
        transmissionMap: {
            value: null
        },
        transmissionMapTransform: {
            value: new jt
        },
        transmissionSamplerSize: {
            value: new Ue
        },
        transmissionSamplerMap: {
            value: null
        },
        thickness: {
            value: 0
        },
        thicknessMap: {
            value: null
        },
        thicknessMapTransform: {
            value: new jt
        },
        attenuationDistance: {
            value: 0
        },
        attenuationColor: {
            value: new rt(0)
        },
        specularColor: {
            value: new rt(1, 1, 1)
        },
        specularColorMap: {
            value: null
        },
        specularColorMapTransform: {
            value: new jt
        },
        specularIntensity: {
            value: 1
        },
        specularIntensityMap: {
            value: null
        },
        specularIntensityMapTransform: {
            value: new jt
        },
        anisotropyVector: {
            value: new Ue
        },
        anisotropyMap: {
            value: null
        },
        anisotropyMapTransform: {
            value: new jt
        }
    }]),
    vertexShader: Jt.meshphysical_vert,
    fragmentShader: Jt.meshphysical_frag
};
const Bg = {
        r: 0,
        b: 0,
        g: 0
    },
    ac = new As,
    dG = new Ot;

function pG(r, e, t, n, i, s, o) {
    const a = new rt(0);
    let l = s === !0 ? 0 : 1,
        c, u, f = null,
        d = 0,
        m = null;

    function g(A) {
        let S = A.isScene === !0 ? A.background : null;
        return S && S.isTexture && (S = (A.backgroundBlurriness > 0 ? t : e).get(S)), S
    }

    function y(A) {
        let S = !1;
        const M = g(A);
        M === null ? _(a, l) : M && M.isColor && (_(M, 1), S = !0);
        const C = r.xr.getEnvironmentBlendMode();
        C === "additive" ? n.buffers.color.setClear(0, 0, 0, 1, o) : C === "alpha-blend" && n.buffers.color.setClear(0, 0, 0, 0, o), (r.autoClear || S) && (n.buffers.depth.setTest(!0), n.buffers.depth.setMask(!0), n.buffers.color.setMask(!0), r.clear(r.autoClearColor, r.autoClearDepth, r.autoClearStencil))
    }

    function v(A, S) {
        const M = g(S);
        M && (M.isCubeTexture || M.mapping === ah) ? (u === void 0 && (u = new Tn(new pu(1, 1, 1), new Fn({
            name: "BackgroundCubeMaterial",
            uniforms: $f(Vs.backgroundCube.uniforms),
            vertexShader: Vs.backgroundCube.vertexShader,
            fragmentShader: Vs.backgroundCube.fragmentShader,
            side: di,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), u.geometry.deleteAttribute("normal"), u.geometry.deleteAttribute("uv"), u.onBeforeRender = function(C, E, R) {
            this.matrixWorld.copyPosition(R.matrixWorld)
        }, Object.defineProperty(u.material, "envMap", {
            get: function() {
                return this.uniforms.envMap.value
            }
        }), i.update(u)), ac.copy(S.backgroundRotation), ac.x *= -1, ac.y *= -1, ac.z *= -1, M.isCubeTexture && M.isRenderTargetTexture === !1 && (ac.y *= -1, ac.z *= -1), u.material.uniforms.envMap.value = M, u.material.uniforms.flipEnvMap.value = M.isCubeTexture && M.isRenderTargetTexture === !1 ? -1 : 1, u.material.uniforms.backgroundBlurriness.value = S.backgroundBlurriness, u.material.uniforms.backgroundIntensity.value = S.backgroundIntensity, u.material.uniforms.backgroundRotation.value.setFromMatrix4(dG.makeRotationFromEuler(ac)), u.material.toneMapped = xn.getTransfer(M.colorSpace) !== Ln, (f !== M || d !== M.version || m !== r.toneMapping) && (u.material.needsUpdate = !0, f = M, d = M.version, m = r.toneMapping), u.layers.enableAll(), A.unshift(u, u.geometry, u.material, 0, 0, null)) : M && M.isTexture && (c === void 0 && (c = new Tn(new bs(2, 2), new Fn({
            name: "BackgroundMaterial",
            uniforms: $f(Vs.background.uniforms),
            vertexShader: Vs.background.vertexShader,
            fragmentShader: Vs.background.fragmentShader,
            side: Zs,
            depthTest: !1,
            depthWrite: !1,
            fog: !1
        })), c.geometry.deleteAttribute("normal"), Object.defineProperty(c.material, "map", {
            get: function() {
                return this.uniforms.t2D.value
            }
        }), i.update(c)), c.material.uniforms.t2D.value = M, c.material.uniforms.backgroundIntensity.value = S.backgroundIntensity, c.material.toneMapped = xn.getTransfer(M.colorSpace) !== Ln, M.matrixAutoUpdate === !0 && M.updateMatrix(), c.material.uniforms.uvTransform.value.copy(M.matrix), (f !== M || d !== M.version || m !== r.toneMapping) && (c.material.needsUpdate = !0, f = M, d = M.version, m = r.toneMapping), c.layers.enableAll(), A.unshift(c, c.geometry, c.material, 0, 0, null))
    }

    function _(A, S) {
        A.getRGB(Bg, pB(r)), n.buffers.color.setClear(Bg.r, Bg.g, Bg.b, S, o)
    }
    return {
        getClearColor: function() {
            return a
        },
        setClearColor: function(A, S = 1) {
            a.set(A), l = S, _(a, l)
        },
        getClearAlpha: function() {
            return l
        },
        setClearAlpha: function(A) {
            l = A, _(a, l)
        },
        render: y,
        addToRenderList: v
    }
}

function mG(r, e) {
    const t = r.getParameter(r.MAX_VERTEX_ATTRIBS),
        n = {},
        i = d(null);
    let s = i,
        o = !1;

    function a(T, L, D, V, H) {
        let q = !1;
        const X = f(V, D, L);
        s !== X && (s = X, c(s.object)), q = m(T, V, D, H), q && g(T, V, D, H), H !== null && e.update(H, r.ELEMENT_ARRAY_BUFFER), (q || o) && (o = !1, M(T, L, D, V), H !== null && r.bindBuffer(r.ELEMENT_ARRAY_BUFFER, e.get(H).buffer))
    }

    function l() {
        return r.createVertexArray()
    }

    function c(T) {
        return r.bindVertexArray(T)
    }

    function u(T) {
        return r.deleteVertexArray(T)
    }

    function f(T, L, D) {
        const V = D.wireframe === !0;
        let H = n[T.id];
        H === void 0 && (H = {}, n[T.id] = H);
        let q = H[L.id];
        q === void 0 && (q = {}, H[L.id] = q);
        let X = q[V];
        return X === void 0 && (X = d(l()), q[V] = X), X
    }

    function d(T) {
        const L = [],
            D = [],
            V = [];
        for (let H = 0; H < t; H++) L[H] = 0, D[H] = 0, V[H] = 0;
        return {
            geometry: null,
            program: null,
            wireframe: !1,
            newAttributes: L,
            enabledAttributes: D,
            attributeDivisors: V,
            object: T,
            attributes: {},
            index: null
        }
    }

    function m(T, L, D, V) {
        const H = s.attributes,
            q = L.attributes;
        let X = 0;
        const oe = D.getAttributes();
        for (const Y in oe)
            if (oe[Y].location >= 0) {
                const U = H[Y];
                let j = q[Y];
                if (j === void 0 && (Y === "instanceMatrix" && T.instanceMatrix && (j = T.instanceMatrix), Y === "instanceColor" && T.instanceColor && (j = T.instanceColor)), U === void 0 || U.attribute !== j || j && U.data !== j.data) return !0;
                X++
            }
        return s.attributesNum !== X || s.index !== V
    }

    function g(T, L, D, V) {
        const H = {},
            q = L.attributes;
        let X = 0;
        const oe = D.getAttributes();
        for (const Y in oe)
            if (oe[Y].location >= 0) {
                let U = q[Y];
                U === void 0 && (Y === "instanceMatrix" && T.instanceMatrix && (U = T.instanceMatrix), Y === "instanceColor" && T.instanceColor && (U = T.instanceColor));
                const j = {};
                j.attribute = U, U && U.data && (j.data = U.data), H[Y] = j, X++
            }
        s.attributes = H, s.attributesNum = X, s.index = V
    }

    function y() {
        const T = s.newAttributes;
        for (let L = 0, D = T.length; L < D; L++) T[L] = 0
    }

    function v(T) {
        _(T, 0)
    }

    function _(T, L) {
        const D = s.newAttributes,
            V = s.enabledAttributes,
            H = s.attributeDivisors;
        D[T] = 1, V[T] === 0 && (r.enableVertexAttribArray(T), V[T] = 1), H[T] !== L && (r.vertexAttribDivisor(T, L), H[T] = L)
    }

    function A() {
        const T = s.newAttributes,
            L = s.enabledAttributes;
        for (let D = 0, V = L.length; D < V; D++) L[D] !== T[D] && (r.disableVertexAttribArray(D), L[D] = 0)
    }

    function S(T, L, D, V, H, q, X) {
        X === !0 ? r.vertexAttribIPointer(T, L, D, H, q) : r.vertexAttribPointer(T, L, D, V, H, q)
    }

    function M(T, L, D, V) {
        y();
        const H = V.attributes,
            q = D.getAttributes(),
            X = L.defaultAttributeValues;
        for (const oe in q) {
            const Y = q[oe];
            if (Y.location >= 0) {
                let Z = H[oe];
                if (Z === void 0 && (oe === "instanceMatrix" && T.instanceMatrix && (Z = T.instanceMatrix), oe === "instanceColor" && T.instanceColor && (Z = T.instanceColor)), Z !== void 0) {
                    const U = Z.normalized,
                        j = Z.itemSize,
                        te = e.get(Z);
                    if (te === void 0) continue;
                    const he = te.buffer,
                        $ = te.type,
                        ne = te.bytesPerElement,
                        me = $ === r.INT || $ === r.UNSIGNED_INT || Z.gpuType === Gp;
                    if (Z.isInterleavedBufferAttribute) {
                        const ce = Z.data,
                            _e = ce.stride,
                            Oe = Z.offset;
                        if (ce.isInstancedInterleavedBuffer) {
                            for (let ke = 0; ke < Y.locationSize; ke++) _(Y.location + ke, ce.meshPerAttribute);
                            T.isInstancedMesh !== !0 && V._maxInstanceCount === void 0 && (V._maxInstanceCount = ce.meshPerAttribute * ce.count)
                        } else
                            for (let ke = 0; ke < Y.locationSize; ke++) v(Y.location + ke);
                        r.bindBuffer(r.ARRAY_BUFFER, he);
                        for (let ke = 0; ke < Y.locationSize; ke++) S(Y.location + ke, j / Y.locationSize, $, U, _e * ne, (Oe + j / Y.locationSize * ke) * ne, me)
                    } else {
                        if (Z.isInstancedBufferAttribute) {
                            for (let ce = 0; ce < Y.locationSize; ce++) _(Y.location + ce, Z.meshPerAttribute);
                            T.isInstancedMesh !== !0 && V._maxInstanceCount === void 0 && (V._maxInstanceCount = Z.meshPerAttribute * Z.count)
                        } else
                            for (let ce = 0; ce < Y.locationSize; ce++) v(Y.location + ce);
                        r.bindBuffer(r.ARRAY_BUFFER, he);
                        for (let ce = 0; ce < Y.locationSize; ce++) S(Y.location + ce, j / Y.locationSize, $, U, j * ne, j / Y.locationSize * ce * ne, me)
                    }
                } else if (X !== void 0) {
                    const U = X[oe];
                    if (U !== void 0) switch (U.length) {
                        case 2:
                            r.vertexAttrib2fv(Y.location, U);
                            break;
                        case 3:
                            r.vertexAttrib3fv(Y.location, U);
                            break;
                        case 4:
                            r.vertexAttrib4fv(Y.location, U);
                            break;
                        default:
                            r.vertexAttrib1fv(Y.location, U)
                    }
                }
            }
        }
        A()
    }

    function C() {
        P();
        for (const T in n) {
            const L = n[T];
            for (const D in L) {
                const V = L[D];
                for (const H in V) u(V[H].object), delete V[H];
                delete L[D]
            }
            delete n[T]
        }
    }

    function E(T) {
        if (n[T.id] === void 0) return;
        const L = n[T.id];
        for (const D in L) {
            const V = L[D];
            for (const H in V) u(V[H].object), delete V[H];
            delete L[D]
        }
        delete n[T.id]
    }

    function R(T) {
        for (const L in n) {
            const D = n[L];
            if (D[T.id] === void 0) continue;
            const V = D[T.id];
            for (const H in V) u(V[H].object), delete V[H];
            delete D[T.id]
        }
    }

    function P() {
        b(), o = !0, s !== i && (s = i, c(s.object))
    }

    function b() {
        i.geometry = null, i.program = null, i.wireframe = !1
    }
    return {
        setup: a,
        reset: P,
        resetDefaultState: b,
        dispose: C,
        releaseStatesOfGeometry: E,
        releaseStatesOfProgram: R,
        initAttributes: y,
        enableAttribute: v,
        disableUnusedAttributes: A
    }
}

function gG(r, e, t) {
    let n;

    function i(c) {
        n = c
    }

    function s(c, u) {
        r.drawArrays(n, c, u), t.update(u, n, 1)
    }

    function o(c, u, f) {
        f !== 0 && (r.drawArraysInstanced(n, c, u, f), t.update(u, n, f))
    }

    function a(c, u, f) {
        if (f === 0) return;
        e.get("WEBGL_multi_draw").multiDrawArraysWEBGL(n, c, 0, u, 0, f);
        let m = 0;
        for (let g = 0; g < f; g++) m += u[g];
        t.update(m, n, 1)
    }

    function l(c, u, f, d) {
        if (f === 0) return;
        const m = e.get("WEBGL_multi_draw");
        if (m === null)
            for (let g = 0; g < c.length; g++) o(c[g], u[g], d[g]);
        else {
            m.multiDrawArraysInstancedWEBGL(n, c, 0, u, 0, d, 0, f);
            let g = 0;
            for (let y = 0; y < f; y++) g += u[y] * d[y];
            t.update(g, n, 1)
        }
    }
    this.setMode = i, this.render = s, this.renderInstances = o, this.renderMultiDraw = a, this.renderMultiDrawInstances = l
}

function vG(r, e, t, n) {
    let i;

    function s() {
        if (i !== void 0) return i;
        if (e.has("EXT_texture_filter_anisotropic") === !0) {
            const R = e.get("EXT_texture_filter_anisotropic");
            i = r.getParameter(R.MAX_TEXTURE_MAX_ANISOTROPY_EXT)
        } else i = 0;
        return i
    }

    function o(R) {
        return !(R !== kn && n.convert(R) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_FORMAT))
    }

    function a(R) {
        const P = R === Ri && (e.has("EXT_color_buffer_half_float") || e.has("EXT_color_buffer_float"));
        return !(R !== Yi && n.convert(R) !== r.getParameter(r.IMPLEMENTATION_COLOR_READ_TYPE) && R !== Bn && !P)
    }

    function l(R) {
        if (R === "highp") {
            if (r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.HIGH_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.HIGH_FLOAT).precision > 0) return "highp";
            R = "mediump"
        }
        return R === "mediump" && r.getShaderPrecisionFormat(r.VERTEX_SHADER, r.MEDIUM_FLOAT).precision > 0 && r.getShaderPrecisionFormat(r.FRAGMENT_SHADER, r.MEDIUM_FLOAT).precision > 0 ? "mediump" : "lowp"
    }
    let c = t.precision !== void 0 ? t.precision : "highp";
    const u = l(c);
    u !== c && (console.warn("THREE.WebGLRenderer:", c, "not supported, using", u, "instead."), c = u);
    const f = t.logarithmicDepthBuffer === !0,
        d = t.reverseDepthBuffer === !0 && e.has("EXT_clip_control"),
        m = r.getParameter(r.MAX_TEXTURE_IMAGE_UNITS),
        g = r.getParameter(r.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
        y = r.getParameter(r.MAX_TEXTURE_SIZE),
        v = r.getParameter(r.MAX_CUBE_MAP_TEXTURE_SIZE),
        _ = r.getParameter(r.MAX_VERTEX_ATTRIBS),
        A = r.getParameter(r.MAX_VERTEX_UNIFORM_VECTORS),
        S = r.getParameter(r.MAX_VARYING_VECTORS),
        M = r.getParameter(r.MAX_FRAGMENT_UNIFORM_VECTORS),
        C = g > 0,
        E = r.getParameter(r.MAX_SAMPLES);
    return {
        isWebGL2: !0,
        getMaxAnisotropy: s,
        getMaxPrecision: l,
        textureFormatReadable: o,
        textureTypeReadable: a,
        precision: c,
        logarithmicDepthBuffer: f,
        reverseDepthBuffer: d,
        maxTextures: m,
        maxVertexTextures: g,
        maxTextureSize: y,
        maxCubemapSize: v,
        maxAttributes: _,
        maxVertexUniforms: A,
        maxVaryings: S,
        maxFragmentUniforms: M,
        vertexTextures: C,
        maxSamples: E
    }
}

function yG(r) {
    const e = this;
    let t = null,
        n = 0,
        i = !1,
        s = !1;
    const o = new Br,
        a = new jt,
        l = {
            value: null,
            needsUpdate: !1
        };
    this.uniform = l, this.numPlanes = 0, this.numIntersection = 0, this.init = function(f, d) {
        const m = f.length !== 0 || d || n !== 0 || i;
        return i = d, n = f.length, m
    }, this.beginShadows = function() {
        s = !0, u(null)
    }, this.endShadows = function() {
        s = !1
    }, this.setGlobalState = function(f, d) {
        t = u(f, d, 0)
    }, this.setState = function(f, d, m) {
        const g = f.clippingPlanes,
            y = f.clipIntersection,
            v = f.clipShadows,
            _ = r.get(f);
        if (!i || g === null || g.length === 0 || s && !v) s ? u(null) : c();
        else {
            const A = s ? 0 : n,
                S = A * 4;
            let M = _.clippingState || null;
            l.value = M, M = u(g, d, S, m);
            for (let C = 0; C !== S; ++C) M[C] = t[C];
            _.clippingState = M, this.numIntersection = y ? this.numPlanes : 0, this.numPlanes += A
        }
    };

    function c() {
        l.value !== t && (l.value = t, l.needsUpdate = n > 0), e.numPlanes = n, e.numIntersection = 0
    }

    function u(f, d, m, g) {
        const y = f !== null ? f.length : 0;
        let v = null;
        if (y !== 0) {
            if (v = l.value, g !== !0 || v === null) {
                const _ = m + y * 4,
                    A = d.matrixWorldInverse;
                a.getNormalMatrix(A), (v === null || v.length < _) && (v = new Float32Array(_));
                for (let S = 0, M = m; S !== y; ++S, M += 4) o.copy(f[S]).applyMatrix4(A, a), o.normal.toArray(v, M), v[M + 3] = o.constant
            }
            l.value = v, l.needsUpdate = !0
        }
        return e.numPlanes = y, e.numIntersection = 0, v
    }
}

function _G(r) {
    let e = new WeakMap;

    function t(o, a) {
        return a === ou ? o.mapping = ko : a === dp && (o.mapping = Al), o
    }

    function n(o) {
        if (o && o.isTexture) {
            const a = o.mapping;
            if (a === ou || a === dp)
                if (e.has(o)) {
                    const l = e.get(o).texture;
                    return t(l, o.mapping)
                } else {
                    const l = o.image;
                    if (l && l.height > 0) {
                        const c = new py(l.height);
                        return c.fromEquirectangularTexture(r, o), e.set(o, c), o.addEventListener("dispose", i), t(c.texture, o.mapping)
                    } else return null
                }
        }
        return o
    }

    function i(o) {
        const a = o.target;
        a.removeEventListener("dispose", i);
        const l = e.get(a);
        l !== void 0 && (e.delete(a), l.dispose())
    }

    function s() {
        e = new WeakMap
    }
    return {
        get: n,
        dispose: s
    }
}
let Ca = class extends Fl {
    constructor(e = -1, t = 1, n = 1, i = -1, s = .1, o = 2e3) {
        super(), this.isOrthographicCamera = !0, this.type = "OrthographicCamera", this.zoom = 1, this.view = null, this.left = e, this.right = t, this.top = n, this.bottom = i, this.near = s, this.far = o, this.updateProjectionMatrix()
    }
    copy(e, t) {
        return super.copy(e, t), this.left = e.left, this.right = e.right, this.top = e.top, this.bottom = e.bottom, this.near = e.near, this.far = e.far, this.zoom = e.zoom, this.view = e.view === null ? null : Object.assign({}, e.view), this
    }
    setViewOffset(e, t, n, i, s, o) {
        this.view === null && (this.view = {
            enabled: !0,
            fullWidth: 1,
            fullHeight: 1,
            offsetX: 0,
            offsetY: 0,
            width: 1,
            height: 1
        }), this.view.enabled = !0, this.view.fullWidth = e, this.view.fullHeight = t, this.view.offsetX = n, this.view.offsetY = i, this.view.width = s, this.view.height = o, this.updateProjectionMatrix()
    }
    clearViewOffset() {
        this.view !== null && (this.view.enabled = !1), this.updateProjectionMatrix()
    }
    updateProjectionMatrix() {
        const e = (this.right - this.left) / (2 * this.zoom),
            t = (this.top - this.bottom) / (2 * this.zoom),
            n = (this.right + this.left) / 2,
            i = (this.top + this.bottom) / 2;
        let s = n - e,
            o = n + e,
            a = i + t,
            l = i - t;
        if (this.view !== null && this.view.enabled) {
            const c = (this.right - this.left) / this.view.fullWidth / this.zoom,
                u = (this.top - this.bottom) / this.view.fullHeight / this.zoom;
            s += c * this.view.offsetX, o = s + c * this.view.width, a -= u * this.view.offsetY, l = a - u * this.view.height
        }
        this.projectionMatrix.makeOrthographic(s, o, a, l, this.near, this.far, this.coordinateSystem), this.projectionMatrixInverse.copy(this.projectionMatrix).invert()
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.zoom = this.zoom, t.object.left = this.left, t.object.right = this.right, t.object.top = this.top, t.object.bottom = this.bottom, t.object.near = this.near, t.object.far = this.far, this.view !== null && (t.object.view = Object.assign({}, this.view)), t
    }
};
const gf = 4,
    lE = [.125, .215, .35, .446, .526, .582],
    Ec = 20,
    bx = new Ca,
    cE = new rt;
let Tx = null,
    Ex = 0,
    Cx = 0,
    Rx = !1;
const wc = (1 + Math.sqrt(5)) / 2,
    qu = 1 / wc,
    uE = [new K(-wc, qu, 0), new K(wc, qu, 0), new K(-qu, 0, wc), new K(qu, 0, wc), new K(0, wc, -qu), new K(0, wc, qu), new K(-1, 1, -1), new K(1, 1, -1), new K(-1, 1, 1), new K(1, 1, 1)];
class pA {
    constructor(e) {
        this._renderer = e, this._pingPongRenderTarget = null, this._lodMax = 0, this._cubeSize = 0, this._lodPlanes = [], this._sizeLods = [], this._sigmas = [], this._blurMaterial = null, this._cubemapMaterial = null, this._equirectMaterial = null, this._compileMaterial(this._blurMaterial)
    }
    fromScene(e, t = 0, n = .1, i = 100) {
        Tx = this._renderer.getRenderTarget(), Ex = this._renderer.getActiveCubeFace(), Cx = this._renderer.getActiveMipmapLevel(), Rx = this._renderer.xr.enabled, this._renderer.xr.enabled = !1, this._setSize(256);
        const s = this._allocateTargets();
        return s.depthBuffer = !0, this._sceneToCubeUV(e, n, i, s), t > 0 && this._blur(s, 0, 0, t), this._applyPMREM(s), this._cleanup(s), s
    }
    fromEquirectangular(e, t = null) {
        return this._fromTexture(e, t)
    }
    fromCubemap(e, t = null) {
        return this._fromTexture(e, t)
    }
    compileCubemapShader() {
        this._cubemapMaterial === null && (this._cubemapMaterial = dE(), this._compileMaterial(this._cubemapMaterial))
    }
    compileEquirectangularShader() {
        this._equirectMaterial === null && (this._equirectMaterial = hE(), this._compileMaterial(this._equirectMaterial))
    }
    dispose() {
        this._dispose(), this._cubemapMaterial !== null && this._cubemapMaterial.dispose(), this._equirectMaterial !== null && this._equirectMaterial.dispose()
    }
    _setSize(e) {
        this._lodMax = Math.floor(Math.log2(e)), this._cubeSize = Math.pow(2, this._lodMax)
    }
    _dispose() {
        this._blurMaterial !== null && this._blurMaterial.dispose(), this._pingPongRenderTarget !== null && this._pingPongRenderTarget.dispose();
        for (let e = 0; e < this._lodPlanes.length; e++) this._lodPlanes[e].dispose()
    }
    _cleanup(e) {
        this._renderer.setRenderTarget(Tx, Ex, Cx), this._renderer.xr.enabled = Rx, e.scissorTest = !1, Dg(e, 0, 0, e.width, e.height)
    }
    _fromTexture(e, t) {
        e.mapping === ko || e.mapping === Al ? this._setSize(e.image.length === 0 ? 16 : e.image[0].width || e.image[0].image.width) : this._setSize(e.image.width / 4), Tx = this._renderer.getRenderTarget(), Ex = this._renderer.getActiveCubeFace(), Cx = this._renderer.getActiveMipmapLevel(), Rx = this._renderer.xr.enabled, this._renderer.xr.enabled = !1;
        const n = t || this._allocateTargets();
        return this._textureToCubeUV(e, n), this._applyPMREM(n), this._cleanup(n), n
    }
    _allocateTargets() {
        const e = 3 * Math.max(this._cubeSize, 112),
            t = 4 * this._cubeSize,
            n = {
                magFilter: nn,
                minFilter: nn,
                generateMipmaps: !1,
                type: Ri,
                format: kn,
                colorSpace: Qs,
                depthBuffer: !1
            },
            i = fE(e, t, n);
        if (this._pingPongRenderTarget === null || this._pingPongRenderTarget.width !== e || this._pingPongRenderTarget.height !== t) {
            this._pingPongRenderTarget !== null && this._dispose(), this._pingPongRenderTarget = fE(e, t, n);
            const {
                _lodMax: s
            } = this;
            ({
                sizeLods: this._sizeLods,
                lodPlanes: this._lodPlanes,
                sigmas: this._sigmas
            } = xG(s)), this._blurMaterial = AG(s, e, t)
        }
        return i
    }
    _compileMaterial(e) {
        const t = new Tn(this._lodPlanes[0], e);
        this._renderer.compile(t, bx)
    }
    _sceneToCubeUV(e, t, n, i) {
        const a = new ri(90, 1, t, n),
            l = [1, -1, 1, 1, 1, 1],
            c = [1, 1, 1, -1, -1, -1],
            u = this._renderer,
            f = u.autoClear,
            d = u.toneMapping;
        u.getClearColor(cE), u.toneMapping = Js, u.autoClear = !1;
        const m = new Mi({
                name: "PMREM.Background",
                side: di,
                depthWrite: !1,
                depthTest: !1
            }),
            g = new Tn(new pu, m);
        let y = !1;
        const v = e.background;
        v ? v.isColor && (m.color.copy(v), e.background = null, y = !0) : (m.color.copy(cE), y = !0);
        for (let _ = 0; _ < 6; _++) {
            const A = _ % 3;
            A === 0 ? (a.up.set(0, l[_], 0), a.lookAt(c[_], 0, 0)) : A === 1 ? (a.up.set(0, 0, l[_]), a.lookAt(0, c[_], 0)) : (a.up.set(0, l[_], 0), a.lookAt(0, 0, c[_]));
            const S = this._cubeSize;
            Dg(i, A * S, _ > 2 ? S : 0, S, S), u.setRenderTarget(i), y && u.render(g, a), u.render(e, a)
        }
        g.geometry.dispose(), g.material.dispose(), u.toneMapping = d, u.autoClear = f, e.background = v
    }
    _textureToCubeUV(e, t) {
        const n = this._renderer,
            i = e.mapping === ko || e.mapping === Al;
        i ? (this._cubemapMaterial === null && (this._cubemapMaterial = dE()), this._cubemapMaterial.uniforms.flipEnvMap.value = e.isRenderTargetTexture === !1 ? -1 : 1) : this._equirectMaterial === null && (this._equirectMaterial = hE());
        const s = i ? this._cubemapMaterial : this._equirectMaterial,
            o = new Tn(this._lodPlanes[0], s),
            a = s.uniforms;
        a.envMap.value = e;
        const l = this._cubeSize;
        Dg(t, 0, 0, 3 * l, 2 * l), n.setRenderTarget(t), n.render(o, bx)
    }
    _applyPMREM(e) {
        const t = this._renderer,
            n = t.autoClear;
        t.autoClear = !1;
        const i = this._lodPlanes.length;
        for (let s = 1; s < i; s++) {
            const o = Math.sqrt(this._sigmas[s] * this._sigmas[s] - this._sigmas[s - 1] * this._sigmas[s - 1]),
                a = uE[(i - s - 1) % uE.length];
            this._blur(e, s - 1, s, o, a)
        }
        t.autoClear = n
    }
    _blur(e, t, n, i, s) {
        const o = this._pingPongRenderTarget;
        this._halfBlur(e, o, t, n, i, "latitudinal", s), this._halfBlur(o, e, n, n, i, "longitudinal", s)
    }
    _halfBlur(e, t, n, i, s, o, a) {
        const l = this._renderer,
            c = this._blurMaterial;
        o !== "latitudinal" && o !== "longitudinal" && console.error("blur direction must be either latitudinal or longitudinal!");
        const u = 3,
            f = new Tn(this._lodPlanes[i], c),
            d = c.uniforms,
            m = this._sizeLods[n] - 1,
            g = isFinite(s) ? Math.PI / (2 * m) : 2 * Math.PI / (2 * Ec - 1),
            y = s / g,
            v = isFinite(s) ? 1 + Math.floor(u * y) : Ec;
        v > Ec && console.warn(`sigmaRadians, ${s}, is too large and will clip, as it requested ${v} samples when the maximum is set to ${Ec}`);
        const _ = [];
        let A = 0;
        for (let R = 0; R < Ec; ++R) {
            const P = R / y,
                b = Math.exp(-P * P / 2);
            _.push(b), R === 0 ? A += b : R < v && (A += 2 * b)
        }
        for (let R = 0; R < _.length; R++) _[R] = _[R] / A;
        d.envMap.value = e.texture, d.samples.value = v, d.weights.value = _, d.latitudinal.value = o === "latitudinal", a && (d.poleAxis.value = a);
        const {
            _lodMax: S
        } = this;
        d.dTheta.value = g, d.mipInt.value = S - n;
        const M = this._sizeLods[i],
            C = 3 * M * (i > S - gf ? i - S + gf : 0),
            E = 4 * (this._cubeSize - M);
        Dg(t, C, E, 3 * M, 2 * M), l.setRenderTarget(t), l.render(f, bx)
    }
}

function xG(r) {
    const e = [],
        t = [],
        n = [];
    let i = r;
    const s = r - gf + 1 + lE.length;
    for (let o = 0; o < s; o++) {
        const a = Math.pow(2, i);
        t.push(a);
        let l = 1 / a;
        o > r - gf ? l = lE[o - r + gf - 1] : o === 0 && (l = 0), n.push(l);
        const c = 1 / (a - 2),
            u = -c,
            f = 1 + c,
            d = [u, u, f, u, f, f, u, u, f, f, u, f],
            m = 6,
            g = 6,
            y = 3,
            v = 2,
            _ = 1,
            A = new Float32Array(y * g * m),
            S = new Float32Array(v * g * m),
            M = new Float32Array(_ * g * m);
        for (let E = 0; E < m; E++) {
            const R = E % 3 * 2 / 3 - 1,
                P = E > 2 ? 0 : -1,
                b = [R, P, 0, R + 2 / 3, P, 0, R + 2 / 3, P + 1, 0, R, P, 0, R + 2 / 3, P + 1, 0, R, P + 1, 0];
            A.set(b, y * g * E), S.set(d, v * g * E);
            const T = [E, E, E, E, E, E];
            M.set(T, _ * g * E)
        }
        const C = new zt;
        C.setAttribute("position", new an(A, y)), C.setAttribute("uv", new an(S, v)), C.setAttribute("faceIndex", new an(M, _)), e.push(C), i > gf && i--
    }
    return {
        lodPlanes: e,
        sizeLods: t,
        sigmas: n
    }
}

function fE(r, e, t) {
    const n = new Zn(r, e, t);
    return n.texture.mapping = ah, n.texture.name = "PMREM.cubeUv", n.scissorTest = !0, n
}

function Dg(r, e, t, n, i) {
    r.viewport.set(e, t, n, i), r.scissor.set(e, t, n, i)
}

function AG(r, e, t) {
    const n = new Float32Array(Ec),
        i = new K(0, 1, 0);
    return new Fn({
        name: "SphericalGaussianBlur",
        defines: {
            n: Ec,
            CUBEUV_TEXEL_WIDTH: 1 / e,
            CUBEUV_TEXEL_HEIGHT: 1 / t,
            CUBEUV_MAX_MIP: `${r}.0`
        },
        uniforms: {
            envMap: {
                value: null
            },
            samples: {
                value: 1
            },
            weights: {
                value: n
            },
            latitudinal: {
                value: !1
            },
            dTheta: {
                value: 0
            },
            mipInt: {
                value: 0
            },
            poleAxis: {
                value: i
            }
        },
        vertexShader: JS(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;
			uniform int samples;
			uniform float weights[ n ];
			uniform bool latitudinal;
			uniform float dTheta;
			uniform float mipInt;
			uniform vec3 poleAxis;

			#define ENVMAP_TYPE_CUBE_UV
			#include <cube_uv_reflection_fragment>

			vec3 getSample( float theta, vec3 axis ) {

				float cosTheta = cos( theta );
				// Rodrigues' axis-angle rotation
				vec3 sampleDirection = vOutputDirection * cosTheta
					+ cross( axis, vOutputDirection ) * sin( theta )
					+ axis * dot( axis, vOutputDirection ) * ( 1.0 - cosTheta );

				return bilinearCubeUV( envMap, sampleDirection, mipInt );

			}

			void main() {

				vec3 axis = latitudinal ? poleAxis : cross( poleAxis, vOutputDirection );

				if ( all( equal( axis, vec3( 0.0 ) ) ) ) {

					axis = vec3( vOutputDirection.z, 0.0, - vOutputDirection.x );

				}

				axis = normalize( axis );

				gl_FragColor = vec4( 0.0, 0.0, 0.0, 1.0 );
				gl_FragColor.rgb += weights[ 0 ] * getSample( 0.0, axis );

				for ( int i = 1; i < n; i++ ) {

					if ( i >= samples ) {

						break;

					}

					float theta = dTheta * float( i );
					gl_FragColor.rgb += weights[ i ] * getSample( -1.0 * theta, axis );
					gl_FragColor.rgb += weights[ i ] * getSample( theta, axis );

				}

			}
		`,
        blending: pi,
        depthTest: !1,
        depthWrite: !1
    })
}

function hE() {
    return new Fn({
        name: "EquirectangularToCubeUV",
        uniforms: {
            envMap: {
                value: null
            }
        },
        vertexShader: JS(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			varying vec3 vOutputDirection;

			uniform sampler2D envMap;

			#include <common>

			void main() {

				vec3 outputDirection = normalize( vOutputDirection );
				vec2 uv = equirectUv( outputDirection );

				gl_FragColor = vec4( texture2D ( envMap, uv ).rgb, 1.0 );

			}
		`,
        blending: pi,
        depthTest: !1,
        depthWrite: !1
    })
}

function dE() {
    return new Fn({
        name: "CubemapToCubeUV",
        uniforms: {
            envMap: {
                value: null
            },
            flipEnvMap: {
                value: -1
            }
        },
        vertexShader: JS(),
        fragmentShader: `

			precision mediump float;
			precision mediump int;

			uniform float flipEnvMap;

			varying vec3 vOutputDirection;

			uniform samplerCube envMap;

			void main() {

				gl_FragColor = textureCube( envMap, vec3( flipEnvMap * vOutputDirection.x, vOutputDirection.yz ) );

			}
		`,
        blending: pi,
        depthTest: !1,
        depthWrite: !1
    })
}

function JS() {
    return `

		precision mediump float;
		precision mediump int;

		attribute float faceIndex;

		varying vec3 vOutputDirection;

		// RH coordinate system; PMREM face-indexing convention
		vec3 getDirection( vec2 uv, float face ) {

			uv = 2.0 * uv - 1.0;

			vec3 direction = vec3( uv, 1.0 );

			if ( face == 0.0 ) {

				direction = direction.zyx; // ( 1, v, u ) pos x

			} else if ( face == 1.0 ) {

				direction = direction.xzy;
				direction.xz *= -1.0; // ( -u, 1, -v ) pos y

			} else if ( face == 2.0 ) {

				direction.x *= -1.0; // ( -u, v, 1 ) pos z

			} else if ( face == 3.0 ) {

				direction = direction.zyx;
				direction.xz *= -1.0; // ( -1, v, -u ) neg x

			} else if ( face == 4.0 ) {

				direction = direction.xzy;
				direction.xy *= -1.0; // ( -u, -1, v ) neg y

			} else if ( face == 5.0 ) {

				direction.z *= -1.0; // ( u, v, -1 ) neg z

			}

			return direction;

		}

		void main() {

			vOutputDirection = getDirection( uv, faceIndex );
			gl_Position = vec4( position, 1.0 );

		}
	`
}

function SG(r) {
    let e = new WeakMap,
        t = null;

    function n(a) {
        if (a && a.isTexture) {
            const l = a.mapping,
                c = l === ou || l === dp,
                u = l === ko || l === Al;
            if (c || u) {
                let f = e.get(a);
                const d = f !== void 0 ? f.texture.pmremVersion : 0;
                if (a.isRenderTargetTexture && a.pmremVersion !== d) return t === null && (t = new pA(r)), f = c ? t.fromEquirectangular(a, f) : t.fromCubemap(a, f), f.texture.pmremVersion = a.pmremVersion, e.set(a, f), f.texture;
                if (f !== void 0) return f.texture; {
                    const m = a.image;
                    return c && m && m.height > 0 || u && m && i(m) ? (t === null && (t = new pA(r)), f = c ? t.fromEquirectangular(a) : t.fromCubemap(a), f.texture.pmremVersion = a.pmremVersion, e.set(a, f), a.addEventListener("dispose", s), f.texture) : null
                }
            }
        }
        return a
    }

    function i(a) {
        let l = 0;
        const c = 6;
        for (let u = 0; u < c; u++) a[u] !== void 0 && l++;
        return l === c
    }

    function s(a) {
        const l = a.target;
        l.removeEventListener("dispose", s);
        const c = e.get(l);
        c !== void 0 && (e.delete(l), c.dispose())
    }

    function o() {
        e = new WeakMap, t !== null && (t.dispose(), t = null)
    }
    return {
        get: n,
        dispose: o
    }
}

function MG(r) {
    const e = {};

    function t(n) {
        if (e[n] !== void 0) return e[n];
        let i;
        switch (n) {
            case "WEBGL_depth_texture":
                i = r.getExtension("WEBGL_depth_texture") || r.getExtension("MOZ_WEBGL_depth_texture") || r.getExtension("WEBKIT_WEBGL_depth_texture");
                break;
            case "EXT_texture_filter_anisotropic":
                i = r.getExtension("EXT_texture_filter_anisotropic") || r.getExtension("MOZ_EXT_texture_filter_anisotropic") || r.getExtension("WEBKIT_EXT_texture_filter_anisotropic");
                break;
            case "WEBGL_compressed_texture_s3tc":
                i = r.getExtension("WEBGL_compressed_texture_s3tc") || r.getExtension("MOZ_WEBGL_compressed_texture_s3tc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc");
                break;
            case "WEBGL_compressed_texture_pvrtc":
                i = r.getExtension("WEBGL_compressed_texture_pvrtc") || r.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc");
                break;
            default:
                i = r.getExtension(n)
        }
        return e[n] = i, i
    }
    return {
        has: function(n) {
            return t(n) !== null
        },
        init: function() {
            t("EXT_color_buffer_float"), t("WEBGL_clip_cull_distance"), t("OES_texture_float_linear"), t("EXT_color_buffer_half_float"), t("WEBGL_multisampled_render_to_texture"), t("WEBGL_render_shared_exponent")
        },
        get: function(n) {
            const i = t(n);
            return i === null && Ad("THREE.WebGLRenderer: " + n + " extension not supported."), i
        }
    }
}

function wG(r, e, t, n) {
    const i = {},
        s = new WeakMap;

    function o(f) {
        const d = f.target;
        d.index !== null && e.remove(d.index);
        for (const g in d.attributes) e.remove(d.attributes[g]);
        for (const g in d.morphAttributes) {
            const y = d.morphAttributes[g];
            for (let v = 0, _ = y.length; v < _; v++) e.remove(y[v])
        }
        d.removeEventListener("dispose", o), delete i[d.id];
        const m = s.get(d);
        m && (e.remove(m), s.delete(d)), n.releaseStatesOfGeometry(d), d.isInstancedBufferGeometry === !0 && delete d._maxInstanceCount, t.memory.geometries--
    }

    function a(f, d) {
        return i[d.id] === !0 || (d.addEventListener("dispose", o), i[d.id] = !0, t.memory.geometries++), d
    }

    function l(f) {
        const d = f.attributes;
        for (const g in d) e.update(d[g], r.ARRAY_BUFFER);
        const m = f.morphAttributes;
        for (const g in m) {
            const y = m[g];
            for (let v = 0, _ = y.length; v < _; v++) e.update(y[v], r.ARRAY_BUFFER)
        }
    }

    function c(f) {
        const d = [],
            m = f.index,
            g = f.attributes.position;
        let y = 0;
        if (m !== null) {
            const A = m.array;
            y = m.version;
            for (let S = 0, M = A.length; S < M; S += 3) {
                const C = A[S + 0],
                    E = A[S + 1],
                    R = A[S + 2];
                d.push(C, E, E, R, R, C)
            }
        } else if (g !== void 0) {
            const A = g.array;
            y = g.version;
            for (let S = 0, M = A.length / 3 - 1; S < M; S += 3) {
                const C = S + 0,
                    E = S + 1,
                    R = S + 2;
                d.push(C, E, E, R, R, C)
            }
        } else return;
        const v = new(cB(d) ? XS : jS)(d, 1);
        v.version = y;
        const _ = s.get(f);
        _ && e.remove(_), s.set(f, v)
    }

    function u(f) {
        const d = s.get(f);
        if (d) {
            const m = f.index;
            m !== null && d.version < m.version && c(f)
        } else c(f);
        return s.get(f)
    }
    return {
        get: a,
        update: l,
        getWireframeAttribute: u
    }
}

function bG(r, e, t) {
    let n;

    function i(d) {
        n = d
    }
    let s, o;

    function a(d) {
        s = d.type, o = d.bytesPerElement
    }

    function l(d, m) {
        r.drawElements(n, m, s, d * o), t.update(m, n, 1)
    }

    function c(d, m, g) {
        g !== 0 && (r.drawElementsInstanced(n, m, s, d * o, g), t.update(m, n, g))
    }

    function u(d, m, g) {
        if (g === 0) return;
        e.get("WEBGL_multi_draw").multiDrawElementsWEBGL(n, m, 0, s, d, 0, g);
        let v = 0;
        for (let _ = 0; _ < g; _++) v += m[_];
        t.update(v, n, 1)
    }

    function f(d, m, g, y) {
        if (g === 0) return;
        const v = e.get("WEBGL_multi_draw");
        if (v === null)
            for (let _ = 0; _ < d.length; _++) c(d[_] / o, m[_], y[_]);
        else {
            v.multiDrawElementsInstancedWEBGL(n, m, 0, s, d, 0, y, 0, g);
            let _ = 0;
            for (let A = 0; A < g; A++) _ += m[A] * y[A];
            t.update(_, n, 1)
        }
    }
    this.setMode = i, this.setIndex = a, this.render = l, this.renderInstances = c, this.renderMultiDraw = u, this.renderMultiDrawInstances = f
}

function TG(r) {
    const e = {
            geometries: 0,
            textures: 0
        },
        t = {
            frame: 0,
            calls: 0,
            triangles: 0,
            points: 0,
            lines: 0
        };

    function n(s, o, a) {
        switch (t.calls++, o) {
            case r.TRIANGLES:
                t.triangles += a * (s / 3);
                break;
            case r.LINES:
                t.lines += a * (s / 2);
                break;
            case r.LINE_STRIP:
                t.lines += a * (s - 1);
                break;
            case r.LINE_LOOP:
                t.lines += a * s;
                break;
            case r.POINTS:
                t.points += a * s;
                break;
            default:
                console.error("THREE.WebGLInfo: Unknown draw mode:", o);
                break
        }
    }

    function i() {
        t.calls = 0, t.triangles = 0, t.points = 0, t.lines = 0
    }
    return {
        memory: e,
        render: t,
        programs: null,
        autoReset: !0,
        reset: i,
        update: n
    }
}

function EG(r, e, t) {
    const n = new WeakMap,
        i = new An;

    function s(o, a, l) {
        const c = o.morphTargetInfluences,
            u = a.morphAttributes.position || a.morphAttributes.normal || a.morphAttributes.color,
            f = u !== void 0 ? u.length : 0;
        let d = n.get(a);
        if (d === void 0 || d.count !== f) {
            let b = function() {
                R.dispose(), n.delete(a), a.removeEventListener("dispose", b)
            };
            d !== void 0 && d.texture.dispose();
            const m = a.morphAttributes.position !== void 0,
                g = a.morphAttributes.normal !== void 0,
                y = a.morphAttributes.color !== void 0,
                v = a.morphAttributes.position || [],
                _ = a.morphAttributes.normal || [],
                A = a.morphAttributes.color || [];
            let S = 0;
            m === !0 && (S = 1), g === !0 && (S = 2), y === !0 && (S = 3);
            let M = a.attributes.position.count * S,
                C = 1;
            M > e.maxTextureSize && (C = Math.ceil(M / e.maxTextureSize), M = e.maxTextureSize);
            const E = new Float32Array(M * C * 4 * f),
                R = new dy(E, M, C, f);
            R.type = Bn, R.needsUpdate = !0;
            const P = S * 4;
            for (let T = 0; T < f; T++) {
                const L = v[T],
                    D = _[T],
                    V = A[T],
                    H = M * C * 4 * T;
                for (let q = 0; q < L.count; q++) {
                    const X = q * P;
                    m === !0 && (i.fromBufferAttribute(L, q), E[H + X + 0] = i.x, E[H + X + 1] = i.y, E[H + X + 2] = i.z, E[H + X + 3] = 0), g === !0 && (i.fromBufferAttribute(D, q), E[H + X + 4] = i.x, E[H + X + 5] = i.y, E[H + X + 6] = i.z, E[H + X + 7] = 0), y === !0 && (i.fromBufferAttribute(V, q), E[H + X + 8] = i.x, E[H + X + 9] = i.y, E[H + X + 10] = i.z, E[H + X + 11] = V.itemSize === 4 ? i.w : 1)
                }
            }
            d = {
                count: f,
                texture: R,
                size: new Ue(M, C)
            }, n.set(a, d), a.addEventListener("dispose", b)
        }
        if (o.isInstancedMesh === !0 && o.morphTexture !== null) l.getUniforms().setValue(r, "morphTexture", o.morphTexture, t);
        else {
            let m = 0;
            for (let y = 0; y < c.length; y++) m += c[y];
            const g = a.morphTargetsRelative ? 1 : 1 - m;
            l.getUniforms().setValue(r, "morphTargetBaseInfluence", g), l.getUniforms().setValue(r, "morphTargetInfluences", c)
        }
        l.getUniforms().setValue(r, "morphTargetsTexture", d.texture, t), l.getUniforms().setValue(r, "morphTargetsTextureSize", d.size)
    }
    return {
        update: s
    }
}

function CG(r, e, t, n) {
    let i = new WeakMap;

    function s(l) {
        const c = n.render.frame,
            u = l.geometry,
            f = e.get(l, u);
        if (i.get(f) !== c && (e.update(f), i.set(f, c)), l.isInstancedMesh && (l.hasEventListener("dispose", a) === !1 && l.addEventListener("dispose", a), i.get(l) !== c && (t.update(l.instanceMatrix, r.ARRAY_BUFFER), l.instanceColor !== null && t.update(l.instanceColor, r.ARRAY_BUFFER), i.set(l, c))), l.isSkinnedMesh) {
            const d = l.skeleton;
            i.get(d) !== c && (d.update(), i.set(d, c))
        }
        return f
    }

    function o() {
        i = new WeakMap
    }

    function a(l) {
        const c = l.target;
        c.removeEventListener("dispose", a), t.remove(c.instanceMatrix), c.instanceColor !== null && t.remove(c.instanceColor)
    }
    return {
        update: s,
        dispose: o
    }
}
class Yp extends gn {
    constructor(e, t, n, i, s, o, a, l, c, u = Yc) {
        if (u !== Yc && u !== wl) throw new Error("DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat");
        n === void 0 && u === Yc && (n = fo), n === void 0 && u === wl && (n = Ml), super(null, i, s, o, a, l, u, n, c), this.isDepthTexture = !0, this.image = {
            width: e,
            height: t
        }, this.magFilter = a !== void 0 ? a : bn, this.minFilter = l !== void 0 ? l : bn, this.flipY = !1, this.generateMipmaps = !1, this.compareFunction = null
    }
    copy(e) {
        return super.copy(e), this.compareFunction = e.compareFunction, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.compareFunction !== null && (t.compareFunction = this.compareFunction), t
    }
}
const gB = new gn,
    pE = new Yp(1, 1),
    vB = new dy,
    yB = new WS,
    _B = new jp,
    mE = [],
    gE = [],
    vE = new Float32Array(16),
    yE = new Float32Array(9),
    _E = new Float32Array(4);

function lh(r, e, t) {
    const n = r[0];
    if (n <= 0 || n > 0) return r;
    const i = e * t;
    let s = mE[i];
    if (s === void 0 && (s = new Float32Array(i), mE[i] = s), e !== 0) {
        n.toArray(s, 0);
        for (let o = 1, a = 0; o !== e; ++o) a += t, r[o].toArray(s, a)
    }
    return s
}

function Li(r, e) {
    if (r.length !== e.length) return !1;
    for (let t = 0, n = r.length; t < n; t++)
        if (r[t] !== e[t]) return !1;
    return !0
}

function Fi(r, e) {
    for (let t = 0, n = e.length; t < n; t++) r[t] = e[t]
}

function my(r, e) {
    let t = gE[e];
    t === void 0 && (t = new Int32Array(e), gE[e] = t);
    for (let n = 0; n !== e; ++n) t[n] = r.allocateTextureUnit();
    return t
}

function RG(r, e) {
    const t = this.cache;
    t[0] !== e && (r.uniform1f(this.addr, e), t[0] = e)
}

function PG(r, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2f(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (Li(t, e)) return;
        r.uniform2fv(this.addr, e), Fi(t, e)
    }
}

function IG(r, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3f(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else if (e.r !== void 0)(t[0] !== e.r || t[1] !== e.g || t[2] !== e.b) && (r.uniform3f(this.addr, e.r, e.g, e.b), t[0] = e.r, t[1] = e.g, t[2] = e.b);
    else {
        if (Li(t, e)) return;
        r.uniform3fv(this.addr, e), Fi(t, e)
    }
}

function BG(r, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4f(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (Li(t, e)) return;
        r.uniform4fv(this.addr, e), Fi(t, e)
    }
}

function DG(r, e) {
    const t = this.cache,
        n = e.elements;
    if (n === void 0) {
        if (Li(t, e)) return;
        r.uniformMatrix2fv(this.addr, !1, e), Fi(t, e)
    } else {
        if (Li(t, n)) return;
        _E.set(n), r.uniformMatrix2fv(this.addr, !1, _E), Fi(t, n)
    }
}

function LG(r, e) {
    const t = this.cache,
        n = e.elements;
    if (n === void 0) {
        if (Li(t, e)) return;
        r.uniformMatrix3fv(this.addr, !1, e), Fi(t, e)
    } else {
        if (Li(t, n)) return;
        yE.set(n), r.uniformMatrix3fv(this.addr, !1, yE), Fi(t, n)
    }
}

function FG(r, e) {
    const t = this.cache,
        n = e.elements;
    if (n === void 0) {
        if (Li(t, e)) return;
        r.uniformMatrix4fv(this.addr, !1, e), Fi(t, e)
    } else {
        if (Li(t, n)) return;
        vE.set(n), r.uniformMatrix4fv(this.addr, !1, vE), Fi(t, n)
    }
}

function UG(r, e) {
    const t = this.cache;
    t[0] !== e && (r.uniform1i(this.addr, e), t[0] = e)
}

function OG(r, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2i(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (Li(t, e)) return;
        r.uniform2iv(this.addr, e), Fi(t, e)
    }
}

function NG(r, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3i(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
        if (Li(t, e)) return;
        r.uniform3iv(this.addr, e), Fi(t, e)
    }
}

function kG(r, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4i(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (Li(t, e)) return;
        r.uniform4iv(this.addr, e), Fi(t, e)
    }
}

function zG(r, e) {
    const t = this.cache;
    t[0] !== e && (r.uniform1ui(this.addr, e), t[0] = e)
}

function GG(r, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y) && (r.uniform2ui(this.addr, e.x, e.y), t[0] = e.x, t[1] = e.y);
    else {
        if (Li(t, e)) return;
        r.uniform2uiv(this.addr, e), Fi(t, e)
    }
}

function HG(r, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z) && (r.uniform3ui(this.addr, e.x, e.y, e.z), t[0] = e.x, t[1] = e.y, t[2] = e.z);
    else {
        if (Li(t, e)) return;
        r.uniform3uiv(this.addr, e), Fi(t, e)
    }
}

function VG(r, e) {
    const t = this.cache;
    if (e.x !== void 0)(t[0] !== e.x || t[1] !== e.y || t[2] !== e.z || t[3] !== e.w) && (r.uniform4ui(this.addr, e.x, e.y, e.z, e.w), t[0] = e.x, t[1] = e.y, t[2] = e.z, t[3] = e.w);
    else {
        if (Li(t, e)) return;
        r.uniform4uiv(this.addr, e), Fi(t, e)
    }
}

function WG(r, e, t) {
    const n = this.cache,
        i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i);
    let s;
    this.type === r.SAMPLER_2D_SHADOW ? (pE.compareFunction = HS, s = pE) : s = gB, t.setTexture2D(e || s, i)
}

function jG(r, e, t) {
    const n = this.cache,
        i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture3D(e || yB, i)
}

function XG(r, e, t) {
    const n = this.cache,
        i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTextureCube(e || _B, i)
}

function YG(r, e, t) {
    const n = this.cache,
        i = t.allocateTextureUnit();
    n[0] !== i && (r.uniform1i(this.addr, i), n[0] = i), t.setTexture2DArray(e || vB, i)
}

function JG(r) {
    switch (r) {
        case 5126:
            return RG;
        case 35664:
            return PG;
        case 35665:
            return IG;
        case 35666:
            return BG;
        case 35674:
            return DG;
        case 35675:
            return LG;
        case 35676:
            return FG;
        case 5124:
        case 35670:
            return UG;
        case 35667:
        case 35671:
            return OG;
        case 35668:
        case 35672:
            return NG;
        case 35669:
        case 35673:
            return kG;
        case 5125:
            return zG;
        case 36294:
            return GG;
        case 36295:
            return HG;
        case 36296:
            return VG;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return WG;
        case 35679:
        case 36299:
        case 36307:
            return jG;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return XG;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return YG
    }
}

function KG(r, e) {
    r.uniform1fv(this.addr, e)
}

function qG(r, e) {
    const t = lh(e, this.size, 2);
    r.uniform2fv(this.addr, t)
}

function ZG(r, e) {
    const t = lh(e, this.size, 3);
    r.uniform3fv(this.addr, t)
}

function QG(r, e) {
    const t = lh(e, this.size, 4);
    r.uniform4fv(this.addr, t)
}

function $G(r, e) {
    const t = lh(e, this.size, 4);
    r.uniformMatrix2fv(this.addr, !1, t)
}

function eH(r, e) {
    const t = lh(e, this.size, 9);
    r.uniformMatrix3fv(this.addr, !1, t)
}

function tH(r, e) {
    const t = lh(e, this.size, 16);
    r.uniformMatrix4fv(this.addr, !1, t)
}

function nH(r, e) {
    r.uniform1iv(this.addr, e)
}

function iH(r, e) {
    r.uniform2iv(this.addr, e)
}

function rH(r, e) {
    r.uniform3iv(this.addr, e)
}

function sH(r, e) {
    r.uniform4iv(this.addr, e)
}

function oH(r, e) {
    r.uniform1uiv(this.addr, e)
}

function aH(r, e) {
    r.uniform2uiv(this.addr, e)
}

function lH(r, e) {
    r.uniform3uiv(this.addr, e)
}

function cH(r, e) {
    r.uniform4uiv(this.addr, e)
}

function uH(r, e, t) {
    const n = this.cache,
        i = e.length,
        s = my(t, i);
    Li(n, s) || (r.uniform1iv(this.addr, s), Fi(n, s));
    for (let o = 0; o !== i; ++o) t.setTexture2D(e[o] || gB, s[o])
}

function fH(r, e, t) {
    const n = this.cache,
        i = e.length,
        s = my(t, i);
    Li(n, s) || (r.uniform1iv(this.addr, s), Fi(n, s));
    for (let o = 0; o !== i; ++o) t.setTexture3D(e[o] || yB, s[o])
}

function hH(r, e, t) {
    const n = this.cache,
        i = e.length,
        s = my(t, i);
    Li(n, s) || (r.uniform1iv(this.addr, s), Fi(n, s));
    for (let o = 0; o !== i; ++o) t.setTextureCube(e[o] || _B, s[o])
}

function dH(r, e, t) {
    const n = this.cache,
        i = e.length,
        s = my(t, i);
    Li(n, s) || (r.uniform1iv(this.addr, s), Fi(n, s));
    for (let o = 0; o !== i; ++o) t.setTexture2DArray(e[o] || vB, s[o])
}

function pH(r) {
    switch (r) {
        case 5126:
            return KG;
        case 35664:
            return qG;
        case 35665:
            return ZG;
        case 35666:
            return QG;
        case 35674:
            return $G;
        case 35675:
            return eH;
        case 35676:
            return tH;
        case 5124:
        case 35670:
            return nH;
        case 35667:
        case 35671:
            return iH;
        case 35668:
        case 35672:
            return rH;
        case 35669:
        case 35673:
            return sH;
        case 5125:
            return oH;
        case 36294:
            return aH;
        case 36295:
            return lH;
        case 36296:
            return cH;
        case 35678:
        case 36198:
        case 36298:
        case 36306:
        case 35682:
            return uH;
        case 35679:
        case 36299:
        case 36307:
            return fH;
        case 35680:
        case 36300:
        case 36308:
        case 36293:
            return hH;
        case 36289:
        case 36303:
        case 36311:
        case 36292:
            return dH
    }
}
class mH {
    constructor(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.setValue = JG(t.type)
    }
}
class gH {
    constructor(e, t, n) {
        this.id = e, this.addr = n, this.cache = [], this.type = t.type, this.size = t.size, this.setValue = pH(t.type)
    }
}
class vH {
    constructor(e) {
        this.id = e, this.seq = [], this.map = {}
    }
    setValue(e, t, n) {
        const i = this.seq;
        for (let s = 0, o = i.length; s !== o; ++s) {
            const a = i[s];
            a.setValue(e, t[a.id], n)
        }
    }
}
const Px = /(\w+)(\])?(\[|\.)?/g;

function xE(r, e) {
    r.seq.push(e), r.map[e.id] = e
}

function yH(r, e, t) {
    const n = r.name,
        i = n.length;
    for (Px.lastIndex = 0;;) {
        const s = Px.exec(n),
            o = Px.lastIndex;
        let a = s[1];
        const l = s[2] === "]",
            c = s[3];
        if (l && (a = a | 0), c === void 0 || c === "[" && o + 2 === i) {
            xE(t, c === void 0 ? new mH(a, r, e) : new gH(a, r, e));
            break
        } else {
            let f = t.map[a];
            f === void 0 && (f = new vH(a), xE(t, f)), t = f
        }
    }
}
class I0 {
    constructor(e, t) {
        this.seq = [], this.map = {};
        const n = e.getProgramParameter(t, e.ACTIVE_UNIFORMS);
        for (let i = 0; i < n; ++i) {
            const s = e.getActiveUniform(t, i),
                o = e.getUniformLocation(t, s.name);
            yH(s, o, this)
        }
    }
    setValue(e, t, n, i) {
        const s = this.map[t];
        s !== void 0 && s.setValue(e, n, i)
    }
    setOptional(e, t, n) {
        const i = t[n];
        i !== void 0 && this.setValue(e, n, i)
    }
    static upload(e, t, n, i) {
        for (let s = 0, o = t.length; s !== o; ++s) {
            const a = t[s],
                l = n[a.id];
            l.needsUpdate !== !1 && a.setValue(e, l.value, i)
        }
    }
    static seqWithValue(e, t) {
        const n = [];
        for (let i = 0, s = e.length; i !== s; ++i) {
            const o = e[i];
            o.id in t && n.push(o)
        }
        return n
    }
}

function AE(r, e, t) {
    const n = r.createShader(e);
    return r.shaderSource(n, t), r.compileShader(n), n
}
const _H = 37297;
let xH = 0;

function AH(r, e) {
    const t = r.split(`
`),
        n = [],
        i = Math.max(e - 6, 0),
        s = Math.min(e + 6, t.length);
    for (let o = i; o < s; o++) {
        const a = o + 1;
        n.push(`${a===e?">":" "} ${a}: ${t[o]}`)
    }
    return n.join(`
`)
}
const SE = new jt;

function SH(r) {
    xn._getMatrix(SE, xn.workingColorSpace, r);
    const e = `mat3( ${SE.elements.map(t=>t.toFixed(4))} )`;
    switch (xn.getTransfer(r)) {
        case Wp:
            return [e, "LinearTransferOETF"];
        case Ln:
            return [e, "sRGBTransferOETF"];
        default:
            return console.warn("THREE.WebGLProgram: Unsupported color space: ", r), [e, "LinearTransferOETF"]
    }
}

function ME(r, e, t) {
    const n = r.getShaderParameter(e, r.COMPILE_STATUS),
        i = r.getShaderInfoLog(e).trim();
    if (n && i === "") return "";
    const s = /ERROR: 0:(\d+)/.exec(i);
    if (s) {
        const o = parseInt(s[1]);
        return t.toUpperCase() + `

` + i + `

` + AH(r.getShaderSource(e), o)
    } else return i
}

function MH(r, e) {
    const t = SH(e);
    return [`vec4 ${r}( vec4 value ) {`, `	return ${t[1]}( vec4( value.rgb * ${t[0]}, value.a ) );`, "}"].join(`
`)
}

function wH(r, e) {
    let t;
    switch (e) {
        case WI:
            t = "Linear";
            break;
        case jI:
            t = "Reinhard";
            break;
        case XI:
            t = "Cineon";
            break;
        case ry:
            t = "ACESFilmic";
            break;
        case JI:
            t = "AgX";
            break;
        case KI:
            t = "Neutral";
            break;
        case YI:
            t = "Custom";
            break;
        default:
            console.warn("THREE.WebGLProgram: Unsupported toneMapping:", e), t = "Linear"
    }
    return "vec3 " + r + "( vec3 color ) { return " + t + "ToneMapping( color ); }"
}
const Lg = new K;

function bH() {
    xn.getLuminanceCoefficients(Lg);
    const r = Lg.x.toFixed(4),
        e = Lg.y.toFixed(4),
        t = Lg.z.toFixed(4);
    return ["float luminance( const in vec3 rgb ) {", `	const vec3 weights = vec3( ${r}, ${e}, ${t} );`, "	return dot( weights, rgb );", "}"].join(`
`)
}

function TH(r) {
    return [r.extensionClipCullDistance ? "#extension GL_ANGLE_clip_cull_distance : require" : "", r.extensionMultiDraw ? "#extension GL_ANGLE_multi_draw : require" : ""].filter(Md).join(`
`)
}

function EH(r) {
    const e = [];
    for (const t in r) {
        const n = r[t];
        n !== !1 && e.push("#define " + t + " " + n)
    }
    return e.join(`
`)
}

function CH(r, e) {
    const t = {},
        n = r.getProgramParameter(e, r.ACTIVE_ATTRIBUTES);
    for (let i = 0; i < n; i++) {
        const s = r.getActiveAttrib(e, i),
            o = s.name;
        let a = 1;
        s.type === r.FLOAT_MAT2 && (a = 2), s.type === r.FLOAT_MAT3 && (a = 3), s.type === r.FLOAT_MAT4 && (a = 4), t[o] = {
            type: s.type,
            location: r.getAttribLocation(e, o),
            locationSize: a
        }
    }
    return t
}

function Md(r) {
    return r !== ""
}

function wE(r, e) {
    const t = e.numSpotLightShadows + e.numSpotLightMaps - e.numSpotLightShadowsWithMaps;
    return r.replace(/NUM_DIR_LIGHTS/g, e.numDirLights).replace(/NUM_SPOT_LIGHTS/g, e.numSpotLights).replace(/NUM_SPOT_LIGHT_MAPS/g, e.numSpotLightMaps).replace(/NUM_SPOT_LIGHT_COORDS/g, t).replace(/NUM_RECT_AREA_LIGHTS/g, e.numRectAreaLights).replace(/NUM_POINT_LIGHTS/g, e.numPointLights).replace(/NUM_HEMI_LIGHTS/g, e.numHemiLights).replace(/NUM_DIR_LIGHT_SHADOWS/g, e.numDirLightShadows).replace(/NUM_SPOT_LIGHT_SHADOWS_WITH_MAPS/g, e.numSpotLightShadowsWithMaps).replace(/NUM_SPOT_LIGHT_SHADOWS/g, e.numSpotLightShadows).replace(/NUM_POINT_LIGHT_SHADOWS/g, e.numPointLightShadows)
}

function bE(r, e) {
    return r.replace(/NUM_CLIPPING_PLANES/g, e.numClippingPlanes).replace(/UNION_CLIPPING_PLANES/g, e.numClippingPlanes - e.numClipIntersection)
}
const RH = /^[ \t]*#include +<([\w\d./]+)>/gm;

function mA(r) {
    return r.replace(RH, IH)
}
const PH = new Map;

function IH(r, e) {
    let t = Jt[e];
    if (t === void 0) {
        const n = PH.get(e);
        if (n !== void 0) t = Jt[n], console.warn('THREE.WebGLRenderer: Shader chunk "%s" has been deprecated. Use "%s" instead.', e, n);
        else throw new Error("Can not resolve #include <" + e + ">")
    }
    return mA(t)
}
const BH = /#pragma unroll_loop_start\s+for\s*\(\s*int\s+i\s*=\s*(\d+)\s*;\s*i\s*<\s*(\d+)\s*;\s*i\s*\+\+\s*\)\s*{([\s\S]+?)}\s+#pragma unroll_loop_end/g;

function TE(r) {
    return r.replace(BH, DH)
}

function DH(r, e, t, n) {
    let i = "";
    for (let s = parseInt(e); s < parseInt(t); s++) i += n.replace(/\[\s*i\s*\]/g, "[ " + s + " ]").replace(/UNROLLED_LOOP_INDEX/g, s);
    return i
}

function EE(r) {
    let e = `precision ${r.precision} float;
	precision ${r.precision} int;
	precision ${r.precision} sampler2D;
	precision ${r.precision} samplerCube;
	precision ${r.precision} sampler3D;
	precision ${r.precision} sampler2DArray;
	precision ${r.precision} sampler2DShadow;
	precision ${r.precision} samplerCubeShadow;
	precision ${r.precision} sampler2DArrayShadow;
	precision ${r.precision} isampler2D;
	precision ${r.precision} isampler3D;
	precision ${r.precision} isamplerCube;
	precision ${r.precision} isampler2DArray;
	precision ${r.precision} usampler2D;
	precision ${r.precision} usampler3D;
	precision ${r.precision} usamplerCube;
	precision ${r.precision} usampler2DArray;
	`;
    return r.precision === "highp" ? e += `
#define HIGH_PRECISION` : r.precision === "mediump" ? e += `
#define MEDIUM_PRECISION` : r.precision === "lowp" && (e += `
#define LOW_PRECISION`), e
}

function LH(r) {
    let e = "SHADOWMAP_TYPE_BASIC";
    return r.shadowMapType === iy ? e = "SHADOWMAP_TYPE_PCF" : r.shadowMapType === zd ? e = "SHADOWMAP_TYPE_PCF_SOFT" : r.shadowMapType === lo && (e = "SHADOWMAP_TYPE_VSM"), e
}

function FH(r) {
    let e = "ENVMAP_TYPE_CUBE";
    if (r.envMap) switch (r.envMapMode) {
        case ko:
        case Al:
            e = "ENVMAP_TYPE_CUBE";
            break;
        case ah:
            e = "ENVMAP_TYPE_CUBE_UV";
            break
    }
    return e
}

function UH(r) {
    let e = "ENVMAP_MODE_REFLECTION";
    if (r.envMap) switch (r.envMapMode) {
        case Al:
            e = "ENVMAP_MODE_REFRACTION";
            break
    }
    return e
}

function OH(r) {
    let e = "ENVMAP_BLENDING_NONE";
    if (r.envMap) switch (r.combine) {
        case zp:
            e = "ENVMAP_BLENDING_MULTIPLY";
            break;
        case HI:
            e = "ENVMAP_BLENDING_MIX";
            break;
        case VI:
            e = "ENVMAP_BLENDING_ADD";
            break
    }
    return e
}

function NH(r) {
    const e = r.envMapCubeUVHeight;
    if (e === null) return null;
    const t = Math.log2(e) - 2,
        n = 1 / e;
    return {
        texelWidth: 1 / (3 * Math.max(Math.pow(2, t), 7 * 16)),
        texelHeight: n,
        maxMip: t
    }
}

function kH(r, e, t, n) {
    const i = r.getContext(),
        s = t.defines;
    let o = t.vertexShader,
        a = t.fragmentShader;
    const l = LH(t),
        c = FH(t),
        u = UH(t),
        f = OH(t),
        d = NH(t),
        m = TH(t),
        g = EH(s),
        y = i.createProgram();
    let v, _, A = t.glslVersion ? "#version " + t.glslVersion + `
` : "";
    t.isRawShaderMaterial ? (v = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g].filter(Md).join(`
`), v.length > 0 && (v += `
`), _ = ["#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g].filter(Md).join(`
`), _.length > 0 && (_ += `
`)) : (v = [EE(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g, t.extensionClipCullDistance ? "#define USE_CLIP_DISTANCE" : "", t.batching ? "#define USE_BATCHING" : "", t.batchingColor ? "#define USE_BATCHING_COLOR" : "", t.instancing ? "#define USE_INSTANCING" : "", t.instancingColor ? "#define USE_INSTANCING_COLOR" : "", t.instancingMorph ? "#define USE_INSTANCING_MORPH" : "", t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.map ? "#define USE_MAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + u : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.displacementMap ? "#define USE_DISPLACEMENTMAP" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.mapUv ? "#define MAP_UV " + t.mapUv : "", t.alphaMapUv ? "#define ALPHAMAP_UV " + t.alphaMapUv : "", t.lightMapUv ? "#define LIGHTMAP_UV " + t.lightMapUv : "", t.aoMapUv ? "#define AOMAP_UV " + t.aoMapUv : "", t.emissiveMapUv ? "#define EMISSIVEMAP_UV " + t.emissiveMapUv : "", t.bumpMapUv ? "#define BUMPMAP_UV " + t.bumpMapUv : "", t.normalMapUv ? "#define NORMALMAP_UV " + t.normalMapUv : "", t.displacementMapUv ? "#define DISPLACEMENTMAP_UV " + t.displacementMapUv : "", t.metalnessMapUv ? "#define METALNESSMAP_UV " + t.metalnessMapUv : "", t.roughnessMapUv ? "#define ROUGHNESSMAP_UV " + t.roughnessMapUv : "", t.anisotropyMapUv ? "#define ANISOTROPYMAP_UV " + t.anisotropyMapUv : "", t.clearcoatMapUv ? "#define CLEARCOATMAP_UV " + t.clearcoatMapUv : "", t.clearcoatNormalMapUv ? "#define CLEARCOAT_NORMALMAP_UV " + t.clearcoatNormalMapUv : "", t.clearcoatRoughnessMapUv ? "#define CLEARCOAT_ROUGHNESSMAP_UV " + t.clearcoatRoughnessMapUv : "", t.iridescenceMapUv ? "#define IRIDESCENCEMAP_UV " + t.iridescenceMapUv : "", t.iridescenceThicknessMapUv ? "#define IRIDESCENCE_THICKNESSMAP_UV " + t.iridescenceThicknessMapUv : "", t.sheenColorMapUv ? "#define SHEEN_COLORMAP_UV " + t.sheenColorMapUv : "", t.sheenRoughnessMapUv ? "#define SHEEN_ROUGHNESSMAP_UV " + t.sheenRoughnessMapUv : "", t.specularMapUv ? "#define SPECULARMAP_UV " + t.specularMapUv : "", t.specularColorMapUv ? "#define SPECULAR_COLORMAP_UV " + t.specularColorMapUv : "", t.specularIntensityMapUv ? "#define SPECULAR_INTENSITYMAP_UV " + t.specularIntensityMapUv : "", t.transmissionMapUv ? "#define TRANSMISSIONMAP_UV " + t.transmissionMapUv : "", t.thicknessMapUv ? "#define THICKNESSMAP_UV " + t.thicknessMapUv : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.skinning ? "#define USE_SKINNING" : "", t.morphTargets ? "#define USE_MORPHTARGETS" : "", t.morphNormals && t.flatShading === !1 ? "#define USE_MORPHNORMALS" : "", t.morphColors ? "#define USE_MORPHCOLORS" : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_TEXTURE_STRIDE " + t.morphTextureStride : "", t.morphTargetsCount > 0 ? "#define MORPHTARGETS_COUNT " + t.morphTargetsCount : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.sizeAttenuation ? "#define USE_SIZEATTENUATION" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 modelMatrix;", "uniform mat4 modelViewMatrix;", "uniform mat4 projectionMatrix;", "uniform mat4 viewMatrix;", "uniform mat3 normalMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", "#ifdef USE_INSTANCING", "	attribute mat4 instanceMatrix;", "#endif", "#ifdef USE_INSTANCING_COLOR", "	attribute vec3 instanceColor;", "#endif", "#ifdef USE_INSTANCING_MORPH", "	uniform sampler2D morphTexture;", "#endif", "attribute vec3 position;", "attribute vec3 normal;", "attribute vec2 uv;", "#ifdef USE_UV1", "	attribute vec2 uv1;", "#endif", "#ifdef USE_UV2", "	attribute vec2 uv2;", "#endif", "#ifdef USE_UV3", "	attribute vec2 uv3;", "#endif", "#ifdef USE_TANGENT", "	attribute vec4 tangent;", "#endif", "#if defined( USE_COLOR_ALPHA )", "	attribute vec4 color;", "#elif defined( USE_COLOR )", "	attribute vec3 color;", "#endif", "#ifdef USE_SKINNING", "	attribute vec4 skinIndex;", "	attribute vec4 skinWeight;", "#endif", `
`].filter(Md).join(`
`), _ = [EE(t), "#define SHADER_TYPE " + t.shaderType, "#define SHADER_NAME " + t.shaderName, g, t.useFog && t.fog ? "#define USE_FOG" : "", t.useFog && t.fogExp2 ? "#define FOG_EXP2" : "", t.alphaToCoverage ? "#define ALPHA_TO_COVERAGE" : "", t.map ? "#define USE_MAP" : "", t.matcap ? "#define USE_MATCAP" : "", t.envMap ? "#define USE_ENVMAP" : "", t.envMap ? "#define " + c : "", t.envMap ? "#define " + u : "", t.envMap ? "#define " + f : "", d ? "#define CUBEUV_TEXEL_WIDTH " + d.texelWidth : "", d ? "#define CUBEUV_TEXEL_HEIGHT " + d.texelHeight : "", d ? "#define CUBEUV_MAX_MIP " + d.maxMip + ".0" : "", t.lightMap ? "#define USE_LIGHTMAP" : "", t.aoMap ? "#define USE_AOMAP" : "", t.bumpMap ? "#define USE_BUMPMAP" : "", t.normalMap ? "#define USE_NORMALMAP" : "", t.normalMapObjectSpace ? "#define USE_NORMALMAP_OBJECTSPACE" : "", t.normalMapTangentSpace ? "#define USE_NORMALMAP_TANGENTSPACE" : "", t.emissiveMap ? "#define USE_EMISSIVEMAP" : "", t.anisotropy ? "#define USE_ANISOTROPY" : "", t.anisotropyMap ? "#define USE_ANISOTROPYMAP" : "", t.clearcoat ? "#define USE_CLEARCOAT" : "", t.clearcoatMap ? "#define USE_CLEARCOATMAP" : "", t.clearcoatRoughnessMap ? "#define USE_CLEARCOAT_ROUGHNESSMAP" : "", t.clearcoatNormalMap ? "#define USE_CLEARCOAT_NORMALMAP" : "", t.dispersion ? "#define USE_DISPERSION" : "", t.iridescence ? "#define USE_IRIDESCENCE" : "", t.iridescenceMap ? "#define USE_IRIDESCENCEMAP" : "", t.iridescenceThicknessMap ? "#define USE_IRIDESCENCE_THICKNESSMAP" : "", t.specularMap ? "#define USE_SPECULARMAP" : "", t.specularColorMap ? "#define USE_SPECULAR_COLORMAP" : "", t.specularIntensityMap ? "#define USE_SPECULAR_INTENSITYMAP" : "", t.roughnessMap ? "#define USE_ROUGHNESSMAP" : "", t.metalnessMap ? "#define USE_METALNESSMAP" : "", t.alphaMap ? "#define USE_ALPHAMAP" : "", t.alphaTest ? "#define USE_ALPHATEST" : "", t.alphaHash ? "#define USE_ALPHAHASH" : "", t.sheen ? "#define USE_SHEEN" : "", t.sheenColorMap ? "#define USE_SHEEN_COLORMAP" : "", t.sheenRoughnessMap ? "#define USE_SHEEN_ROUGHNESSMAP" : "", t.transmission ? "#define USE_TRANSMISSION" : "", t.transmissionMap ? "#define USE_TRANSMISSIONMAP" : "", t.thicknessMap ? "#define USE_THICKNESSMAP" : "", t.vertexTangents && t.flatShading === !1 ? "#define USE_TANGENT" : "", t.vertexColors || t.instancingColor || t.batchingColor ? "#define USE_COLOR" : "", t.vertexAlphas ? "#define USE_COLOR_ALPHA" : "", t.vertexUv1s ? "#define USE_UV1" : "", t.vertexUv2s ? "#define USE_UV2" : "", t.vertexUv3s ? "#define USE_UV3" : "", t.pointsUvs ? "#define USE_POINTS_UV" : "", t.gradientMap ? "#define USE_GRADIENTMAP" : "", t.flatShading ? "#define FLAT_SHADED" : "", t.doubleSided ? "#define DOUBLE_SIDED" : "", t.flipSided ? "#define FLIP_SIDED" : "", t.shadowMapEnabled ? "#define USE_SHADOWMAP" : "", t.shadowMapEnabled ? "#define " + l : "", t.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : "", t.numLightProbes > 0 ? "#define USE_LIGHT_PROBES" : "", t.decodeVideoTexture ? "#define DECODE_VIDEO_TEXTURE" : "", t.decodeVideoTextureEmissive ? "#define DECODE_VIDEO_TEXTURE_EMISSIVE" : "", t.logarithmicDepthBuffer ? "#define USE_LOGDEPTHBUF" : "", t.reverseDepthBuffer ? "#define USE_REVERSEDEPTHBUF" : "", "uniform mat4 viewMatrix;", "uniform vec3 cameraPosition;", "uniform bool isOrthographic;", t.toneMapping !== Js ? "#define TONE_MAPPING" : "", t.toneMapping !== Js ? Jt.tonemapping_pars_fragment : "", t.toneMapping !== Js ? wH("toneMapping", t.toneMapping) : "", t.dithering ? "#define DITHERING" : "", t.opaque ? "#define OPAQUE" : "", Jt.colorspace_pars_fragment, MH("linearToOutputTexel", t.outputColorSpace), bH(), t.useDepthPacking ? "#define DEPTH_PACKING " + t.depthPacking : "", `
`].filter(Md).join(`
`)), o = mA(o), o = wE(o, t), o = bE(o, t), a = mA(a), a = wE(a, t), a = bE(a, t), o = TE(o), a = TE(a), t.isRawShaderMaterial !== !0 && (A = `#version 300 es
`, v = [m, "#define attribute in", "#define varying out", "#define texture2D texture"].join(`
`) + `
` + v, _ = ["#define varying in", t.glslVersion === dA ? "" : "layout(location = 0) out highp vec4 pc_fragColor;", t.glslVersion === dA ? "" : "#define gl_FragColor pc_fragColor", "#define gl_FragDepthEXT gl_FragDepth", "#define texture2D texture", "#define textureCube texture", "#define texture2DProj textureProj", "#define texture2DLodEXT textureLod", "#define texture2DProjLodEXT textureProjLod", "#define textureCubeLodEXT textureLod", "#define texture2DGradEXT textureGrad", "#define texture2DProjGradEXT textureProjGrad", "#define textureCubeGradEXT textureGrad"].join(`
`) + `
` + _);
    const S = A + v + o,
        M = A + _ + a,
        C = AE(i, i.VERTEX_SHADER, S),
        E = AE(i, i.FRAGMENT_SHADER, M);
    i.attachShader(y, C), i.attachShader(y, E), t.index0AttributeName !== void 0 ? i.bindAttribLocation(y, 0, t.index0AttributeName) : t.morphTargets === !0 && i.bindAttribLocation(y, 0, "position"), i.linkProgram(y);

    function R(L) {
        if (r.debug.checkShaderErrors) {
            const D = i.getProgramInfoLog(y).trim(),
                V = i.getShaderInfoLog(C).trim(),
                H = i.getShaderInfoLog(E).trim();
            let q = !0,
                X = !0;
            if (i.getProgramParameter(y, i.LINK_STATUS) === !1)
                if (q = !1, typeof r.debug.onShaderError == "function") r.debug.onShaderError(i, y, C, E);
                else {
                    const oe = ME(i, C, "vertex"),
                        Y = ME(i, E, "fragment");
                    console.error("THREE.WebGLProgram: Shader Error " + i.getError() + " - VALIDATE_STATUS " + i.getProgramParameter(y, i.VALIDATE_STATUS) + `

Material Name: ` + L.name + `
Material Type: ` + L.type + `

Program Info Log: ` + D + `
` + oe + `
` + Y)
                }
            else D !== "" ? console.warn("THREE.WebGLProgram: Program Info Log:", D) : (V === "" || H === "") && (X = !1);
            X && (L.diagnostics = {
                runnable: q,
                programLog: D,
                vertexShader: {
                    log: V,
                    prefix: v
                },
                fragmentShader: {
                    log: H,
                    prefix: _
                }
            })
        }
        i.deleteShader(C), i.deleteShader(E), P = new I0(i, y), b = CH(i, y)
    }
    let P;
    this.getUniforms = function() {
        return P === void 0 && R(this), P
    };
    let b;
    this.getAttributes = function() {
        return b === void 0 && R(this), b
    };
    let T = t.rendererExtensionParallelShaderCompile === !1;
    return this.isReady = function() {
        return T === !1 && (T = i.getProgramParameter(y, _H)), T
    }, this.destroy = function() {
        n.releaseStatesOfProgram(this), i.deleteProgram(y), this.program = void 0
    }, this.type = t.shaderType, this.name = t.shaderName, this.id = xH++, this.cacheKey = e, this.usedTimes = 1, this.program = y, this.vertexShader = C, this.fragmentShader = E, this
}
let zH = 0;
class GH {
    constructor() {
        this.shaderCache = new Map, this.materialCache = new Map
    }
    update(e) {
        const t = e.vertexShader,
            n = e.fragmentShader,
            i = this._getShaderStage(t),
            s = this._getShaderStage(n),
            o = this._getShaderCacheForMaterial(e);
        return o.has(i) === !1 && (o.add(i), i.usedTimes++), o.has(s) === !1 && (o.add(s), s.usedTimes++), this
    }
    remove(e) {
        const t = this.materialCache.get(e);
        for (const n of t) n.usedTimes--, n.usedTimes === 0 && this.shaderCache.delete(n.code);
        return this.materialCache.delete(e), this
    }
    getVertexShaderID(e) {
        return this._getShaderStage(e.vertexShader).id
    }
    getFragmentShaderID(e) {
        return this._getShaderStage(e.fragmentShader).id
    }
    dispose() {
        this.shaderCache.clear(), this.materialCache.clear()
    }
    _getShaderCacheForMaterial(e) {
        const t = this.materialCache;
        let n = t.get(e);
        return n === void 0 && (n = new Set, t.set(e, n)), n
    }
    _getShaderStage(e) {
        const t = this.shaderCache;
        let n = t.get(e);
        return n === void 0 && (n = new HH(e), t.set(e, n)), n
    }
}
class HH {
    constructor(e) {
        this.id = zH++, this.code = e, this.usedTimes = 0
    }
}

function VH(r, e, t, n, i, s, o) {
    const a = new Kc,
        l = new GH,
        c = new Set,
        u = [],
        f = i.logarithmicDepthBuffer,
        d = i.vertexTextures;
    let m = i.precision;
    const g = {
        MeshDepthMaterial: "depth",
        MeshDistanceMaterial: "distanceRGBA",
        MeshNormalMaterial: "normal",
        MeshBasicMaterial: "basic",
        MeshLambertMaterial: "lambert",
        MeshPhongMaterial: "phong",
        MeshToonMaterial: "toon",
        MeshStandardMaterial: "physical",
        MeshPhysicalMaterial: "physical",
        MeshMatcapMaterial: "matcap",
        LineBasicMaterial: "basic",
        LineDashedMaterial: "dashed",
        PointsMaterial: "points",
        ShadowMaterial: "shadow",
        SpriteMaterial: "sprite"
    };

    function y(b) {
        return c.add(b), b === 0 ? "uv" : `uv${b}`
    }

    function v(b, T, L, D, V) {
        const H = D.fog,
            q = V.geometry,
            X = b.isMeshStandardMaterial ? D.environment : null,
            oe = (b.isMeshStandardMaterial ? t : e).get(b.envMap || X),
            Y = oe && oe.mapping === ah ? oe.image.height : null,
            Z = g[b.type];
        b.precision !== null && (m = i.getMaxPrecision(b.precision), m !== b.precision && console.warn("THREE.WebGLProgram.getParameters:", b.precision, "not supported, using", m, "instead."));
        const U = q.morphAttributes.position || q.morphAttributes.normal || q.morphAttributes.color,
            j = U !== void 0 ? U.length : 0;
        let te = 0;
        q.morphAttributes.position !== void 0 && (te = 1), q.morphAttributes.normal !== void 0 && (te = 2), q.morphAttributes.color !== void 0 && (te = 3);
        let he, $, ne, me;
        if (Z) {
            const tt = Vs[Z];
            he = tt.vertexShader, $ = tt.fragmentShader
        } else he = b.vertexShader, $ = b.fragmentShader, l.update(b), ne = l.getVertexShaderID(b), me = l.getFragmentShaderID(b);
        const ce = r.getRenderTarget(),
            _e = r.state.buffers.depth.getReversed(),
            Oe = V.isInstancedMesh === !0,
            ke = V.isBatchedMesh === !0,
            Ee = !!b.map,
            pe = !!b.matcap,
            xe = !!oe,
            J = !!b.aoMap,
            De = !!b.lightMap,
            Ce = !!b.bumpMap,
            se = !!b.normalMap,
            Se = !!b.displacementMap,
            Xe = !!b.emissiveMap,
            Le = !!b.metalnessMap,
            k = !!b.roughnessMap,
            z = b.anisotropy > 0,
            ue = b.clearcoat > 0,
            ye = b.dispersion > 0,
            ge = b.iridescence > 0,
            Re = b.sheen > 0,
            Be = b.transmission > 0,
            Fe = z && !!b.anisotropyMap,
            Ne = ue && !!b.clearcoatMap,
            ot = ue && !!b.clearcoatNormalMap,
            je = ue && !!b.clearcoatRoughnessMap,
            Ze = ge && !!b.iridescenceMap,
            it = ge && !!b.iridescenceThicknessMap,
            $e = Re && !!b.sheenColorMap,
            We = Re && !!b.sheenRoughnessMap,
            yt = !!b.specularMap,
            at = !!b.specularColorMap,
            Mt = !!b.specularIntensityMap,
            ae = Be && !!b.transmissionMap,
            ve = Be && !!b.thicknessMap,
            we = !!b.gradientMap,
            He = !!b.alphaMap,
            Je = b.alphaTest > 0,
            Ye = !!b.alphaHash,
            mt = !!b.extensions;
        let Pt = Js;
        b.toneMapped && (ce === null || ce.isXRRenderTarget === !0) && (Pt = r.toneMapping);
        const St = {
            shaderID: Z,
            shaderType: b.type,
            shaderName: b.name,
            vertexShader: he,
            fragmentShader: $,
            defines: b.defines,
            customVertexShaderID: ne,
            customFragmentShaderID: me,
            isRawShaderMaterial: b.isRawShaderMaterial === !0,
            glslVersion: b.glslVersion,
            precision: m,
            batching: ke,
            batchingColor: ke && V._colorsTexture !== null,
            instancing: Oe,
            instancingColor: Oe && V.instanceColor !== null,
            instancingMorph: Oe && V.morphTexture !== null,
            supportsVertexTextures: d,
            outputColorSpace: ce === null ? r.outputColorSpace : ce.isXRRenderTarget === !0 ? ce.texture.colorSpace : Qs,
            alphaToCoverage: !!b.alphaToCoverage,
            map: Ee,
            matcap: pe,
            envMap: xe,
            envMapMode: xe && oe.mapping,
            envMapCubeUVHeight: Y,
            aoMap: J,
            lightMap: De,
            bumpMap: Ce,
            normalMap: se,
            displacementMap: d && Se,
            emissiveMap: Xe,
            normalMapObjectSpace: se && b.normalMapType === tB,
            normalMapTangentSpace: se && b.normalMapType === Dl,
            metalnessMap: Le,
            roughnessMap: k,
            anisotropy: z,
            anisotropyMap: Fe,
            clearcoat: ue,
            clearcoatMap: Ne,
            clearcoatNormalMap: ot,
            clearcoatRoughnessMap: je,
            dispersion: ye,
            iridescence: ge,
            iridescenceMap: Ze,
            iridescenceThicknessMap: it,
            sheen: Re,
            sheenColorMap: $e,
            sheenRoughnessMap: We,
            specularMap: yt,
            specularColorMap: at,
            specularIntensityMap: Mt,
            transmission: Be,
            transmissionMap: ae,
            thicknessMap: ve,
            gradientMap: we,
            opaque: b.transparent === !1 && b.blending === Xc && b.alphaToCoverage === !1,
            alphaMap: He,
            alphaTest: Je,
            alphaHash: Ye,
            combine: b.combine,
            mapUv: Ee && y(b.map.channel),
            aoMapUv: J && y(b.aoMap.channel),
            lightMapUv: De && y(b.lightMap.channel),
            bumpMapUv: Ce && y(b.bumpMap.channel),
            normalMapUv: se && y(b.normalMap.channel),
            displacementMapUv: Se && y(b.displacementMap.channel),
            emissiveMapUv: Xe && y(b.emissiveMap.channel),
            metalnessMapUv: Le && y(b.metalnessMap.channel),
            roughnessMapUv: k && y(b.roughnessMap.channel),
            anisotropyMapUv: Fe && y(b.anisotropyMap.channel),
            clearcoatMapUv: Ne && y(b.clearcoatMap.channel),
            clearcoatNormalMapUv: ot && y(b.clearcoatNormalMap.channel),
            clearcoatRoughnessMapUv: je && y(b.clearcoatRoughnessMap.channel),
            iridescenceMapUv: Ze && y(b.iridescenceMap.channel),
            iridescenceThicknessMapUv: it && y(b.iridescenceThicknessMap.channel),
            sheenColorMapUv: $e && y(b.sheenColorMap.channel),
            sheenRoughnessMapUv: We && y(b.sheenRoughnessMap.channel),
            specularMapUv: yt && y(b.specularMap.channel),
            specularColorMapUv: at && y(b.specularColorMap.channel),
            specularIntensityMapUv: Mt && y(b.specularIntensityMap.channel),
            transmissionMapUv: ae && y(b.transmissionMap.channel),
            thicknessMapUv: ve && y(b.thicknessMap.channel),
            alphaMapUv: He && y(b.alphaMap.channel),
            vertexTangents: !!q.attributes.tangent && (se || z),
            vertexColors: b.vertexColors,
            vertexAlphas: b.vertexColors === !0 && !!q.attributes.color && q.attributes.color.itemSize === 4,
            pointsUvs: V.isPoints === !0 && !!q.attributes.uv && (Ee || He),
            fog: !!H,
            useFog: b.fog === !0,
            fogExp2: !!H && H.isFogExp2,
            flatShading: b.flatShading === !0,
            sizeAttenuation: b.sizeAttenuation === !0,
            logarithmicDepthBuffer: f,
            reverseDepthBuffer: _e,
            skinning: V.isSkinnedMesh === !0,
            morphTargets: q.morphAttributes.position !== void 0,
            morphNormals: q.morphAttributes.normal !== void 0,
            morphColors: q.morphAttributes.color !== void 0,
            morphTargetsCount: j,
            morphTextureStride: te,
            numDirLights: T.directional.length,
            numPointLights: T.point.length,
            numSpotLights: T.spot.length,
            numSpotLightMaps: T.spotLightMap.length,
            numRectAreaLights: T.rectArea.length,
            numHemiLights: T.hemi.length,
            numDirLightShadows: T.directionalShadowMap.length,
            numPointLightShadows: T.pointShadowMap.length,
            numSpotLightShadows: T.spotShadowMap.length,
            numSpotLightShadowsWithMaps: T.numSpotLightShadowsWithMaps,
            numLightProbes: T.numLightProbes,
            numClippingPlanes: o.numPlanes,
            numClipIntersection: o.numIntersection,
            dithering: b.dithering,
            shadowMapEnabled: r.shadowMap.enabled && L.length > 0,
            shadowMapType: r.shadowMap.type,
            toneMapping: Pt,
            decodeVideoTexture: Ee && b.map.isVideoTexture === !0 && xn.getTransfer(b.map.colorSpace) === Ln,
            decodeVideoTextureEmissive: Xe && b.emissiveMap.isVideoTexture === !0 && xn.getTransfer(b.emissiveMap.colorSpace) === Ln,
            premultipliedAlpha: b.premultipliedAlpha,
            doubleSided: b.side === hn,
            flipSided: b.side === di,
            useDepthPacking: b.depthPacking >= 0,
            depthPacking: b.depthPacking || 0,
            index0AttributeName: b.index0AttributeName,
            extensionClipCullDistance: mt && b.extensions.clipCullDistance === !0 && n.has("WEBGL_clip_cull_distance"),
            extensionMultiDraw: (mt && b.extensions.multiDraw === !0 || ke) && n.has("WEBGL_multi_draw"),
            rendererExtensionParallelShaderCompile: n.has("KHR_parallel_shader_compile"),
            customProgramCacheKey: b.customProgramCacheKey()
        };
        return St.vertexUv1s = c.has(1), St.vertexUv2s = c.has(2), St.vertexUv3s = c.has(3), c.clear(), St
    }

    function _(b) {
        const T = [];
        if (b.shaderID ? T.push(b.shaderID) : (T.push(b.customVertexShaderID), T.push(b.customFragmentShaderID)), b.defines !== void 0)
            for (const L in b.defines) T.push(L), T.push(b.defines[L]);
        return b.isRawShaderMaterial === !1 && (A(T, b), S(T, b), T.push(r.outputColorSpace)), T.push(b.customProgramCacheKey), T.join()
    }

    function A(b, T) {
        b.push(T.precision), b.push(T.outputColorSpace), b.push(T.envMapMode), b.push(T.envMapCubeUVHeight), b.push(T.mapUv), b.push(T.alphaMapUv), b.push(T.lightMapUv), b.push(T.aoMapUv), b.push(T.bumpMapUv), b.push(T.normalMapUv), b.push(T.displacementMapUv), b.push(T.emissiveMapUv), b.push(T.metalnessMapUv), b.push(T.roughnessMapUv), b.push(T.anisotropyMapUv), b.push(T.clearcoatMapUv), b.push(T.clearcoatNormalMapUv), b.push(T.clearcoatRoughnessMapUv), b.push(T.iridescenceMapUv), b.push(T.iridescenceThicknessMapUv), b.push(T.sheenColorMapUv), b.push(T.sheenRoughnessMapUv), b.push(T.specularMapUv), b.push(T.specularColorMapUv), b.push(T.specularIntensityMapUv), b.push(T.transmissionMapUv), b.push(T.thicknessMapUv), b.push(T.combine), b.push(T.fogExp2), b.push(T.sizeAttenuation), b.push(T.morphTargetsCount), b.push(T.morphAttributeCount), b.push(T.numDirLights), b.push(T.numPointLights), b.push(T.numSpotLights), b.push(T.numSpotLightMaps), b.push(T.numHemiLights), b.push(T.numRectAreaLights), b.push(T.numDirLightShadows), b.push(T.numPointLightShadows), b.push(T.numSpotLightShadows), b.push(T.numSpotLightShadowsWithMaps), b.push(T.numLightProbes), b.push(T.shadowMapType), b.push(T.toneMapping), b.push(T.numClippingPlanes), b.push(T.numClipIntersection), b.push(T.depthPacking)
    }

    function S(b, T) {
        a.disableAll(), T.supportsVertexTextures && a.enable(0), T.instancing && a.enable(1), T.instancingColor && a.enable(2), T.instancingMorph && a.enable(3), T.matcap && a.enable(4), T.envMap && a.enable(5), T.normalMapObjectSpace && a.enable(6), T.normalMapTangentSpace && a.enable(7), T.clearcoat && a.enable(8), T.iridescence && a.enable(9), T.alphaTest && a.enable(10), T.vertexColors && a.enable(11), T.vertexAlphas && a.enable(12), T.vertexUv1s && a.enable(13), T.vertexUv2s && a.enable(14), T.vertexUv3s && a.enable(15), T.vertexTangents && a.enable(16), T.anisotropy && a.enable(17), T.alphaHash && a.enable(18), T.batching && a.enable(19), T.dispersion && a.enable(20), T.batchingColor && a.enable(21), b.push(a.mask), a.disableAll(), T.fog && a.enable(0), T.useFog && a.enable(1), T.flatShading && a.enable(2), T.logarithmicDepthBuffer && a.enable(3), T.reverseDepthBuffer && a.enable(4), T.skinning && a.enable(5), T.morphTargets && a.enable(6), T.morphNormals && a.enable(7), T.morphColors && a.enable(8), T.premultipliedAlpha && a.enable(9), T.shadowMapEnabled && a.enable(10), T.doubleSided && a.enable(11), T.flipSided && a.enable(12), T.useDepthPacking && a.enable(13), T.dithering && a.enable(14), T.transmission && a.enable(15), T.sheen && a.enable(16), T.opaque && a.enable(17), T.pointsUvs && a.enable(18), T.decodeVideoTexture && a.enable(19), T.decodeVideoTextureEmissive && a.enable(20), T.alphaToCoverage && a.enable(21), b.push(a.mask)
    }

    function M(b) {
        const T = g[b.type];
        let L;
        if (T) {
            const D = Vs[T];
            L = bl.clone(D.uniforms)
        } else L = b.uniforms;
        return L
    }

    function C(b, T) {
        let L;
        for (let D = 0, V = u.length; D < V; D++) {
            const H = u[D];
            if (H.cacheKey === T) {
                L = H, ++L.usedTimes;
                break
            }
        }
        return L === void 0 && (L = new kH(r, T, b, s), u.push(L)), L
    }

    function E(b) {
        if (--b.usedTimes === 0) {
            const T = u.indexOf(b);
            u[T] = u[u.length - 1], u.pop(), b.destroy()
        }
    }

    function R(b) {
        l.remove(b)
    }

    function P() {
        l.dispose()
    }
    return {
        getParameters: v,
        getProgramCacheKey: _,
        getUniforms: M,
        acquireProgram: C,
        releaseProgram: E,
        releaseShaderCache: R,
        programs: u,
        dispose: P
    }
}

function WH() {
    let r = new WeakMap;

    function e(o) {
        return r.has(o)
    }

    function t(o) {
        let a = r.get(o);
        return a === void 0 && (a = {}, r.set(o, a)), a
    }

    function n(o) {
        r.delete(o)
    }

    function i(o, a, l) {
        r.get(o)[a] = l
    }

    function s() {
        r = new WeakMap
    }
    return {
        has: e,
        get: t,
        remove: n,
        update: i,
        dispose: s
    }
}

function jH(r, e) {
    return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.material.id !== e.material.id ? r.material.id - e.material.id : r.z !== e.z ? r.z - e.z : r.id - e.id
}

function CE(r, e) {
    return r.groupOrder !== e.groupOrder ? r.groupOrder - e.groupOrder : r.renderOrder !== e.renderOrder ? r.renderOrder - e.renderOrder : r.z !== e.z ? e.z - r.z : r.id - e.id
}

function RE() {
    const r = [];
    let e = 0;
    const t = [],
        n = [],
        i = [];

    function s() {
        e = 0, t.length = 0, n.length = 0, i.length = 0
    }

    function o(f, d, m, g, y, v) {
        let _ = r[e];
        return _ === void 0 ? (_ = {
            id: f.id,
            object: f,
            geometry: d,
            material: m,
            groupOrder: g,
            renderOrder: f.renderOrder,
            z: y,
            group: v
        }, r[e] = _) : (_.id = f.id, _.object = f, _.geometry = d, _.material = m, _.groupOrder = g, _.renderOrder = f.renderOrder, _.z = y, _.group = v), e++, _
    }

    function a(f, d, m, g, y, v) {
        const _ = o(f, d, m, g, y, v);
        m.transmission > 0 ? n.push(_) : m.transparent === !0 ? i.push(_) : t.push(_)
    }

    function l(f, d, m, g, y, v) {
        const _ = o(f, d, m, g, y, v);
        m.transmission > 0 ? n.unshift(_) : m.transparent === !0 ? i.unshift(_) : t.unshift(_)
    }

    function c(f, d) {
        t.length > 1 && t.sort(f || jH), n.length > 1 && n.sort(d || CE), i.length > 1 && i.sort(d || CE)
    }

    function u() {
        for (let f = e, d = r.length; f < d; f++) {
            const m = r[f];
            if (m.id === null) break;
            m.id = null, m.object = null, m.geometry = null, m.material = null, m.group = null
        }
    }
    return {
        opaque: t,
        transmissive: n,
        transparent: i,
        init: s,
        push: a,
        unshift: l,
        finish: u,
        sort: c
    }
}

function XH() {
    let r = new WeakMap;

    function e(n, i) {
        const s = r.get(n);
        let o;
        return s === void 0 ? (o = new RE, r.set(n, [o])) : i >= s.length ? (o = new RE, s.push(o)) : o = s[i], o
    }

    function t() {
        r = new WeakMap
    }
    return {
        get: e,
        dispose: t
    }
}

function YH() {
    const r = {};
    return {
        get: function(e) {
            if (r[e.id] !== void 0) return r[e.id];
            let t;
            switch (e.type) {
                case "DirectionalLight":
                    t = {
                        direction: new K,
                        color: new rt
                    };
                    break;
                case "SpotLight":
                    t = {
                        position: new K,
                        direction: new K,
                        color: new rt,
                        distance: 0,
                        coneCos: 0,
                        penumbraCos: 0,
                        decay: 0
                    };
                    break;
                case "PointLight":
                    t = {
                        position: new K,
                        color: new rt,
                        distance: 0,
                        decay: 0
                    };
                    break;
                case "HemisphereLight":
                    t = {
                        direction: new K,
                        skyColor: new rt,
                        groundColor: new rt
                    };
                    break;
                case "RectAreaLight":
                    t = {
                        color: new rt,
                        position: new K,
                        halfWidth: new K,
                        halfHeight: new K
                    };
                    break
            }
            return r[e.id] = t, t
        }
    }
}

function JH() {
    const r = {};
    return {
        get: function(e) {
            if (r[e.id] !== void 0) return r[e.id];
            let t;
            switch (e.type) {
                case "DirectionalLight":
                    t = {
                        shadowIntensity: 1,
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ue
                    };
                    break;
                case "SpotLight":
                    t = {
                        shadowIntensity: 1,
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ue
                    };
                    break;
                case "PointLight":
                    t = {
                        shadowIntensity: 1,
                        shadowBias: 0,
                        shadowNormalBias: 0,
                        shadowRadius: 1,
                        shadowMapSize: new Ue,
                        shadowCameraNear: 1,
                        shadowCameraFar: 1e3
                    };
                    break
            }
            return r[e.id] = t, t
        }
    }
}
let KH = 0;

function qH(r, e) {
    return (e.castShadow ? 2 : 0) - (r.castShadow ? 2 : 0) + (e.map ? 1 : 0) - (r.map ? 1 : 0)
}

function ZH(r) {
    const e = new YH,
        t = JH(),
        n = {
            version: 0,
            hash: {
                directionalLength: -1,
                pointLength: -1,
                spotLength: -1,
                rectAreaLength: -1,
                hemiLength: -1,
                numDirectionalShadows: -1,
                numPointShadows: -1,
                numSpotShadows: -1,
                numSpotMaps: -1,
                numLightProbes: -1
            },
            ambient: [0, 0, 0],
            probe: [],
            directional: [],
            directionalShadow: [],
            directionalShadowMap: [],
            directionalShadowMatrix: [],
            spot: [],
            spotLightMap: [],
            spotShadow: [],
            spotShadowMap: [],
            spotLightMatrix: [],
            rectArea: [],
            rectAreaLTC1: null,
            rectAreaLTC2: null,
            point: [],
            pointShadow: [],
            pointShadowMap: [],
            pointShadowMatrix: [],
            hemi: [],
            numSpotLightShadowsWithMaps: 0,
            numLightProbes: 0
        };
    for (let c = 0; c < 9; c++) n.probe.push(new K);
    const i = new K,
        s = new Ot,
        o = new Ot;

    function a(c) {
        let u = 0,
            f = 0,
            d = 0;
        for (let b = 0; b < 9; b++) n.probe[b].set(0, 0, 0);
        let m = 0,
            g = 0,
            y = 0,
            v = 0,
            _ = 0,
            A = 0,
            S = 0,
            M = 0,
            C = 0,
            E = 0,
            R = 0;
        c.sort(qH);
        for (let b = 0, T = c.length; b < T; b++) {
            const L = c[b],
                D = L.color,
                V = L.intensity,
                H = L.distance,
                q = L.shadow && L.shadow.map ? L.shadow.map.texture : null;
            if (L.isAmbientLight) u += D.r * V, f += D.g * V, d += D.b * V;
            else if (L.isLightProbe) {
                for (let X = 0; X < 9; X++) n.probe[X].addScaledVector(L.sh.coefficients[X], V);
                R++
            } else if (L.isDirectionalLight) {
                const X = e.get(L);
                if (X.color.copy(L.color).multiplyScalar(L.intensity), L.castShadow) {
                    const oe = L.shadow,
                        Y = t.get(L);
                    Y.shadowIntensity = oe.intensity, Y.shadowBias = oe.bias, Y.shadowNormalBias = oe.normalBias, Y.shadowRadius = oe.radius, Y.shadowMapSize = oe.mapSize, n.directionalShadow[m] = Y, n.directionalShadowMap[m] = q, n.directionalShadowMatrix[m] = L.shadow.matrix, A++
                }
                n.directional[m] = X, m++
            } else if (L.isSpotLight) {
                const X = e.get(L);
                X.position.setFromMatrixPosition(L.matrixWorld), X.color.copy(D).multiplyScalar(V), X.distance = H, X.coneCos = Math.cos(L.angle), X.penumbraCos = Math.cos(L.angle * (1 - L.penumbra)), X.decay = L.decay, n.spot[y] = X;
                const oe = L.shadow;
                if (L.map && (n.spotLightMap[C] = L.map, C++, oe.updateMatrices(L), L.castShadow && E++), n.spotLightMatrix[y] = oe.matrix, L.castShadow) {
                    const Y = t.get(L);
                    Y.shadowIntensity = oe.intensity, Y.shadowBias = oe.bias, Y.shadowNormalBias = oe.normalBias, Y.shadowRadius = oe.radius, Y.shadowMapSize = oe.mapSize, n.spotShadow[y] = Y, n.spotShadowMap[y] = q, M++
                }
                y++
            } else if (L.isRectAreaLight) {
                const X = e.get(L);
                X.color.copy(D).multiplyScalar(V), X.halfWidth.set(L.width * .5, 0, 0), X.halfHeight.set(0, L.height * .5, 0), n.rectArea[v] = X, v++
            } else if (L.isPointLight) {
                const X = e.get(L);
                if (X.color.copy(L.color).multiplyScalar(L.intensity), X.distance = L.distance, X.decay = L.decay, L.castShadow) {
                    const oe = L.shadow,
                        Y = t.get(L);
                    Y.shadowIntensity = oe.intensity, Y.shadowBias = oe.bias, Y.shadowNormalBias = oe.normalBias, Y.shadowRadius = oe.radius, Y.shadowMapSize = oe.mapSize, Y.shadowCameraNear = oe.camera.near, Y.shadowCameraFar = oe.camera.far, n.pointShadow[g] = Y, n.pointShadowMap[g] = q, n.pointShadowMatrix[g] = L.shadow.matrix, S++
                }
                n.point[g] = X, g++
            } else if (L.isHemisphereLight) {
                const X = e.get(L);
                X.skyColor.copy(L.color).multiplyScalar(V), X.groundColor.copy(L.groundColor).multiplyScalar(V), n.hemi[_] = X, _++
            }
        }
        v > 0 && (r.has("OES_texture_float_linear") === !0 ? (n.rectAreaLTC1 = dt.LTC_FLOAT_1, n.rectAreaLTC2 = dt.LTC_FLOAT_2) : (n.rectAreaLTC1 = dt.LTC_HALF_1, n.rectAreaLTC2 = dt.LTC_HALF_2)), n.ambient[0] = u, n.ambient[1] = f, n.ambient[2] = d;
        const P = n.hash;
        (P.directionalLength !== m || P.pointLength !== g || P.spotLength !== y || P.rectAreaLength !== v || P.hemiLength !== _ || P.numDirectionalShadows !== A || P.numPointShadows !== S || P.numSpotShadows !== M || P.numSpotMaps !== C || P.numLightProbes !== R) && (n.directional.length = m, n.spot.length = y, n.rectArea.length = v, n.point.length = g, n.hemi.length = _, n.directionalShadow.length = A, n.directionalShadowMap.length = A, n.pointShadow.length = S, n.pointShadowMap.length = S, n.spotShadow.length = M, n.spotShadowMap.length = M, n.directionalShadowMatrix.length = A, n.pointShadowMatrix.length = S, n.spotLightMatrix.length = M + C - E, n.spotLightMap.length = C, n.numSpotLightShadowsWithMaps = E, n.numLightProbes = R, P.directionalLength = m, P.pointLength = g, P.spotLength = y, P.rectAreaLength = v, P.hemiLength = _, P.numDirectionalShadows = A, P.numPointShadows = S, P.numSpotShadows = M, P.numSpotMaps = C, P.numLightProbes = R, n.version = KH++)
    }

    function l(c, u) {
        let f = 0,
            d = 0,
            m = 0,
            g = 0,
            y = 0;
        const v = u.matrixWorldInverse;
        for (let _ = 0, A = c.length; _ < A; _++) {
            const S = c[_];
            if (S.isDirectionalLight) {
                const M = n.directional[f];
                M.direction.setFromMatrixPosition(S.matrixWorld), i.setFromMatrixPosition(S.target.matrixWorld), M.direction.sub(i), M.direction.transformDirection(v), f++
            } else if (S.isSpotLight) {
                const M = n.spot[m];
                M.position.setFromMatrixPosition(S.matrixWorld), M.position.applyMatrix4(v), M.direction.setFromMatrixPosition(S.matrixWorld), i.setFromMatrixPosition(S.target.matrixWorld), M.direction.sub(i), M.direction.transformDirection(v), m++
            } else if (S.isRectAreaLight) {
                const M = n.rectArea[g];
                M.position.setFromMatrixPosition(S.matrixWorld), M.position.applyMatrix4(v), o.identity(), s.copy(S.matrixWorld), s.premultiply(v), o.extractRotation(s), M.halfWidth.set(S.width * .5, 0, 0), M.halfHeight.set(0, S.height * .5, 0), M.halfWidth.applyMatrix4(o), M.halfHeight.applyMatrix4(o), g++
            } else if (S.isPointLight) {
                const M = n.point[d];
                M.position.setFromMatrixPosition(S.matrixWorld), M.position.applyMatrix4(v), d++
            } else if (S.isHemisphereLight) {
                const M = n.hemi[y];
                M.direction.setFromMatrixPosition(S.matrixWorld), M.direction.transformDirection(v), y++
            }
        }
    }
    return {
        setup: a,
        setupView: l,
        state: n
    }
}

function PE(r) {
    const e = new ZH(r),
        t = [],
        n = [];

    function i(u) {
        c.camera = u, t.length = 0, n.length = 0
    }

    function s(u) {
        t.push(u)
    }

    function o(u) {
        n.push(u)
    }

    function a() {
        e.setup(t)
    }

    function l(u) {
        e.setupView(t, u)
    }
    const c = {
        lightsArray: t,
        shadowsArray: n,
        camera: null,
        lights: e,
        transmissionRenderTarget: {}
    };
    return {
        init: i,
        state: c,
        setupLights: a,
        setupLightsView: l,
        pushLight: s,
        pushShadow: o
    }
}

function QH(r) {
    let e = new WeakMap;

    function t(i, s = 0) {
        const o = e.get(i);
        let a;
        return o === void 0 ? (a = new PE(r), e.set(i, [a])) : s >= o.length ? (a = new PE(r), o.push(a)) : a = o[s], a
    }

    function n() {
        e = new WeakMap
    }
    return {
        get: t,
        dispose: n
    }
}
class gy extends mi {
    static get type() {
        return "MeshDepthMaterial"
    }
    constructor(e) {
        super(), this.isMeshDepthMaterial = !0, this.depthPacking = Bl, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.depthPacking = e.depthPacking, this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this
    }
}
class vy extends mi {
    static get type() {
        return "MeshDistanceMaterial"
    }
    constructor(e) {
        super(), this.isMeshDistanceMaterial = !0, this.map = null, this.alphaMap = null, this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.map = e.map, this.alphaMap = e.alphaMap, this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this
    }
}
const $H = `void main() {
	gl_Position = vec4( position, 1.0 );
}`,
    e5 = `uniform sampler2D shadow_pass;
uniform vec2 resolution;
uniform float radius;
#include <packing>
void main() {
	const float samples = float( VSM_SAMPLES );
	float mean = 0.0;
	float squared_mean = 0.0;
	float uvStride = samples <= 1.0 ? 0.0 : 2.0 / ( samples - 1.0 );
	float uvStart = samples <= 1.0 ? 0.0 : - 1.0;
	for ( float i = 0.0; i < samples; i ++ ) {
		float uvOffset = uvStart + i * uvStride;
		#ifdef HORIZONTAL_PASS
			vec2 distribution = unpackRGBATo2Half( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( uvOffset, 0.0 ) * radius ) / resolution ) );
			mean += distribution.x;
			squared_mean += distribution.y * distribution.y + distribution.x * distribution.x;
		#else
			float depth = unpackRGBAToDepth( texture2D( shadow_pass, ( gl_FragCoord.xy + vec2( 0.0, uvOffset ) * radius ) / resolution ) );
			mean += depth;
			squared_mean += depth * depth;
		#endif
	}
	mean = mean / samples;
	squared_mean = squared_mean / samples;
	float std_dev = sqrt( squared_mean - mean * mean );
	gl_FragColor = pack2HalfToRGBA( vec2( mean, std_dev ) );
}`;

function t5(r, e, t) {
    let n = new Xp;
    const i = new Ue,
        s = new Ue,
        o = new An,
        a = new gy({
            depthPacking: GS
        }),
        l = new vy,
        c = {},
        u = t.maxTextureSize,
        f = {
            [Zs]: di,
            [di]: Zs,
            [hn]: hn
        },
        d = new Fn({
            defines: {
                VSM_SAMPLES: 8
            },
            uniforms: {
                shadow_pass: {
                    value: null
                },
                resolution: {
                    value: new Ue
                },
                radius: {
                    value: 4
                }
            },
            vertexShader: $H,
            fragmentShader: e5
        }),
        m = d.clone();
    m.defines.HORIZONTAL_PASS = 1;
    const g = new zt;
    g.setAttribute("position", new an(new Float32Array([-1, -1, .5, 3, -1, .5, -1, 3, .5]), 3));
    const y = new Tn(g, d),
        v = this;
    this.enabled = !1, this.autoUpdate = !0, this.needsUpdate = !1, this.type = iy;
    let _ = this.type;
    this.render = function(E, R, P) {
        if (v.enabled === !1 || v.autoUpdate === !1 && v.needsUpdate === !1 || E.length === 0) return;
        const b = r.getRenderTarget(),
            T = r.getActiveCubeFace(),
            L = r.getActiveMipmapLevel(),
            D = r.state;
        D.setBlending(pi), D.buffers.color.setClear(1, 1, 1, 1), D.buffers.depth.setTest(!0), D.setScissorTest(!1);
        const V = _ !== lo && this.type === lo,
            H = _ === lo && this.type !== lo;
        for (let q = 0, X = E.length; q < X; q++) {
            const oe = E[q],
                Y = oe.shadow;
            if (Y === void 0) {
                console.warn("THREE.WebGLShadowMap:", oe, "has no shadow.");
                continue
            }
            if (Y.autoUpdate === !1 && Y.needsUpdate === !1) continue;
            i.copy(Y.mapSize);
            const Z = Y.getFrameExtents();
            if (i.multiply(Z), s.copy(Y.mapSize), (i.x > u || i.y > u) && (i.x > u && (s.x = Math.floor(u / Z.x), i.x = s.x * Z.x, Y.mapSize.x = s.x), i.y > u && (s.y = Math.floor(u / Z.y), i.y = s.y * Z.y, Y.mapSize.y = s.y)), Y.map === null || V === !0 || H === !0) {
                const j = this.type !== lo ? {
                    minFilter: bn,
                    magFilter: bn
                } : {};
                Y.map !== null && Y.map.dispose(), Y.map = new Zn(i.x, i.y, j), Y.map.texture.name = oe.name + ".shadowMap", Y.camera.updateProjectionMatrix()
            }
            r.setRenderTarget(Y.map), r.clear();
            const U = Y.getViewportCount();
            for (let j = 0; j < U; j++) {
                const te = Y.getViewport(j);
                o.set(s.x * te.x, s.y * te.y, s.x * te.z, s.y * te.w), D.viewport(o), Y.updateMatrices(oe, j), n = Y.getFrustum(), M(R, P, Y.camera, oe, this.type)
            }
            Y.isPointLightShadow !== !0 && this.type === lo && A(Y, P), Y.needsUpdate = !1
        }
        _ = this.type, v.needsUpdate = !1, r.setRenderTarget(b, T, L)
    };

    function A(E, R) {
        const P = e.update(y);
        d.defines.VSM_SAMPLES !== E.blurSamples && (d.defines.VSM_SAMPLES = E.blurSamples, m.defines.VSM_SAMPLES = E.blurSamples, d.needsUpdate = !0, m.needsUpdate = !0), E.mapPass === null && (E.mapPass = new Zn(i.x, i.y)), d.uniforms.shadow_pass.value = E.map.texture, d.uniforms.resolution.value = E.mapSize, d.uniforms.radius.value = E.radius, r.setRenderTarget(E.mapPass), r.clear(), r.renderBufferDirect(R, null, P, d, y, null), m.uniforms.shadow_pass.value = E.mapPass.texture, m.uniforms.resolution.value = E.mapSize, m.uniforms.radius.value = E.radius, r.setRenderTarget(E.map), r.clear(), r.renderBufferDirect(R, null, P, m, y, null)
    }

    function S(E, R, P, b) {
        let T = null;
        const L = P.isPointLight === !0 ? E.customDistanceMaterial : E.customDepthMaterial;
        if (L !== void 0) T = L;
        else if (T = P.isPointLight === !0 ? l : a, r.localClippingEnabled && R.clipShadows === !0 && Array.isArray(R.clippingPlanes) && R.clippingPlanes.length !== 0 || R.displacementMap && R.displacementScale !== 0 || R.alphaMap && R.alphaTest > 0 || R.map && R.alphaTest > 0) {
            const D = T.uuid,
                V = R.uuid;
            let H = c[D];
            H === void 0 && (H = {}, c[D] = H);
            let q = H[V];
            q === void 0 && (q = T.clone(), H[V] = q, R.addEventListener("dispose", C)), T = q
        }
        if (T.visible = R.visible, T.wireframe = R.wireframe, b === lo ? T.side = R.shadowSide !== null ? R.shadowSide : R.side : T.side = R.shadowSide !== null ? R.shadowSide : f[R.side], T.alphaMap = R.alphaMap, T.alphaTest = R.alphaTest, T.map = R.map, T.clipShadows = R.clipShadows, T.clippingPlanes = R.clippingPlanes, T.clipIntersection = R.clipIntersection, T.displacementMap = R.displacementMap, T.displacementScale = R.displacementScale, T.displacementBias = R.displacementBias, T.wireframeLinewidth = R.wireframeLinewidth, T.linewidth = R.linewidth, P.isPointLight === !0 && T.isMeshDistanceMaterial === !0) {
            const D = r.properties.get(T);
            D.light = P
        }
        return T
    }

    function M(E, R, P, b, T) {
        if (E.visible === !1) return;
        if (E.layers.test(R.layers) && (E.isMesh || E.isLine || E.isPoints) && (E.castShadow || E.receiveShadow && T === lo) && (!E.frustumCulled || n.intersectsObject(E))) {
            E.modelViewMatrix.multiplyMatrices(P.matrixWorldInverse, E.matrixWorld);
            const V = e.update(E),
                H = E.material;
            if (Array.isArray(H)) {
                const q = V.groups;
                for (let X = 0, oe = q.length; X < oe; X++) {
                    const Y = q[X],
                        Z = H[Y.materialIndex];
                    if (Z && Z.visible) {
                        const U = S(E, Z, b, T);
                        E.onBeforeShadow(r, E, R, P, V, U, Y), r.renderBufferDirect(P, null, V, U, E, Y), E.onAfterShadow(r, E, R, P, V, U, Y)
                    }
                }
            } else if (H.visible) {
                const q = S(E, H, b, T);
                E.onBeforeShadow(r, E, R, P, V, q, null), r.renderBufferDirect(P, null, V, q, E, null), E.onAfterShadow(r, E, R, P, V, q, null)
            }
        }
        const D = E.children;
        for (let V = 0, H = D.length; V < H; V++) M(D[V], R, P, b, T)
    }

    function C(E) {
        E.target.removeEventListener("dispose", C);
        for (const P in c) {
            const b = c[P],
                T = E.target.uuid;
            T in b && (b[T].dispose(), delete b[T])
        }
    }
}
const n5 = {
    [Q0]: $0,
    [ev]: iv,
    [tv]: rv,
    [su]: nv,
    [$0]: Q0,
    [iv]: ev,
    [rv]: tv,
    [nv]: su
};

function i5(r, e) {
    function t() {
        let ae = !1;
        const ve = new An;
        let we = null;
        const He = new An(0, 0, 0, 0);
        return {
            setMask: function(Je) {
                we !== Je && !ae && (r.colorMask(Je, Je, Je, Je), we = Je)
            },
            setLocked: function(Je) {
                ae = Je
            },
            setClear: function(Je, Ye, mt, Pt, St) {
                St === !0 && (Je *= Pt, Ye *= Pt, mt *= Pt), ve.set(Je, Ye, mt, Pt), He.equals(ve) === !1 && (r.clearColor(Je, Ye, mt, Pt), He.copy(ve))
            },
            reset: function() {
                ae = !1, we = null, He.set(-1, 0, 0, 0)
            }
        }
    }

    function n() {
        let ae = !1,
            ve = !1,
            we = null,
            He = null,
            Je = null;
        return {
            setReversed: function(Ye) {
                if (ve !== Ye) {
                    const mt = e.get("EXT_clip_control");
                    ve ? mt.clipControlEXT(mt.LOWER_LEFT_EXT, mt.ZERO_TO_ONE_EXT) : mt.clipControlEXT(mt.LOWER_LEFT_EXT, mt.NEGATIVE_ONE_TO_ONE_EXT);
                    const Pt = Je;
                    Je = null, this.setClear(Pt)
                }
                ve = Ye
            },
            getReversed: function() {
                return ve
            },
            setTest: function(Ye) {
                Ye ? ce(r.DEPTH_TEST) : _e(r.DEPTH_TEST)
            },
            setMask: function(Ye) {
                we !== Ye && !ae && (r.depthMask(Ye), we = Ye)
            },
            setFunc: function(Ye) {
                if (ve && (Ye = n5[Ye]), He !== Ye) {
                    switch (Ye) {
                        case Q0:
                            r.depthFunc(r.NEVER);
                            break;
                        case $0:
                            r.depthFunc(r.ALWAYS);
                            break;
                        case ev:
                            r.depthFunc(r.LESS);
                            break;
                        case su:
                            r.depthFunc(r.LEQUAL);
                            break;
                        case tv:
                            r.depthFunc(r.EQUAL);
                            break;
                        case nv:
                            r.depthFunc(r.GEQUAL);
                            break;
                        case iv:
                            r.depthFunc(r.GREATER);
                            break;
                        case rv:
                            r.depthFunc(r.NOTEQUAL);
                            break;
                        default:
                            r.depthFunc(r.LEQUAL)
                    }
                    He = Ye
                }
            },
            setLocked: function(Ye) {
                ae = Ye
            },
            setClear: function(Ye) {
                Je !== Ye && (ve && (Ye = 1 - Ye), r.clearDepth(Ye), Je = Ye)
            },
            reset: function() {
                ae = !1, we = null, He = null, Je = null, ve = !1
            }
        }
    }

    function i() {
        let ae = !1,
            ve = null,
            we = null,
            He = null,
            Je = null,
            Ye = null,
            mt = null,
            Pt = null,
            St = null;
        return {
            setTest: function(tt) {
                ae || (tt ? ce(r.STENCIL_TEST) : _e(r.STENCIL_TEST))
            },
            setMask: function(tt) {
                ve !== tt && !ae && (r.stencilMask(tt), ve = tt)
            },
            setFunc: function(tt, ut, Rt) {
                (we !== tt || He !== ut || Je !== Rt) && (r.stencilFunc(tt, ut, Rt), we = tt, He = ut, Je = Rt)
            },
            setOp: function(tt, ut, Rt) {
                (Ye !== tt || mt !== ut || Pt !== Rt) && (r.stencilOp(tt, ut, Rt), Ye = tt, mt = ut, Pt = Rt)
            },
            setLocked: function(tt) {
                ae = tt
            },
            setClear: function(tt) {
                St !== tt && (r.clearStencil(tt), St = tt)
            },
            reset: function() {
                ae = !1, ve = null, we = null, He = null, Je = null, Ye = null, mt = null, Pt = null, St = null
            }
        }
    }
    const s = new t,
        o = new n,
        a = new i,
        l = new WeakMap,
        c = new WeakMap;
    let u = {},
        f = {},
        d = new WeakMap,
        m = [],
        g = null,
        y = !1,
        v = null,
        _ = null,
        A = null,
        S = null,
        M = null,
        C = null,
        E = null,
        R = new rt(0, 0, 0),
        P = 0,
        b = !1,
        T = null,
        L = null,
        D = null,
        V = null,
        H = null;
    const q = r.getParameter(r.MAX_COMBINED_TEXTURE_IMAGE_UNITS);
    let X = !1,
        oe = 0;
    const Y = r.getParameter(r.VERSION);
    Y.indexOf("WebGL") !== -1 ? (oe = parseFloat(/^WebGL (\d)/.exec(Y)[1]), X = oe >= 1) : Y.indexOf("OpenGL ES") !== -1 && (oe = parseFloat(/^OpenGL ES (\d)/.exec(Y)[1]), X = oe >= 2);
    let Z = null,
        U = {};
    const j = r.getParameter(r.SCISSOR_BOX),
        te = r.getParameter(r.VIEWPORT),
        he = new An().fromArray(j),
        $ = new An().fromArray(te);

    function ne(ae, ve, we, He) {
        const Je = new Uint8Array(4),
            Ye = r.createTexture();
        r.bindTexture(ae, Ye), r.texParameteri(ae, r.TEXTURE_MIN_FILTER, r.NEAREST), r.texParameteri(ae, r.TEXTURE_MAG_FILTER, r.NEAREST);
        for (let mt = 0; mt < we; mt++) ae === r.TEXTURE_3D || ae === r.TEXTURE_2D_ARRAY ? r.texImage3D(ve, 0, r.RGBA, 1, 1, He, 0, r.RGBA, r.UNSIGNED_BYTE, Je) : r.texImage2D(ve + mt, 0, r.RGBA, 1, 1, 0, r.RGBA, r.UNSIGNED_BYTE, Je);
        return Ye
    }
    const me = {};
    me[r.TEXTURE_2D] = ne(r.TEXTURE_2D, r.TEXTURE_2D, 1), me[r.TEXTURE_CUBE_MAP] = ne(r.TEXTURE_CUBE_MAP, r.TEXTURE_CUBE_MAP_POSITIVE_X, 6), me[r.TEXTURE_2D_ARRAY] = ne(r.TEXTURE_2D_ARRAY, r.TEXTURE_2D_ARRAY, 1, 1), me[r.TEXTURE_3D] = ne(r.TEXTURE_3D, r.TEXTURE_3D, 1, 1), s.setClear(0, 0, 0, 1), o.setClear(1), a.setClear(0), ce(r.DEPTH_TEST), o.setFunc(su), Ce(!1), se(oA), ce(r.CULL_FACE), J(pi);

    function ce(ae) {
        u[ae] !== !0 && (r.enable(ae), u[ae] = !0)
    }

    function _e(ae) {
        u[ae] !== !1 && (r.disable(ae), u[ae] = !1)
    }

    function Oe(ae, ve) {
        return f[ae] !== ve ? (r.bindFramebuffer(ae, ve), f[ae] = ve, ae === r.DRAW_FRAMEBUFFER && (f[r.FRAMEBUFFER] = ve), ae === r.FRAMEBUFFER && (f[r.DRAW_FRAMEBUFFER] = ve), !0) : !1
    }

    function ke(ae, ve) {
        let we = m,
            He = !1;
        if (ae) {
            we = d.get(ve), we === void 0 && (we = [], d.set(ve, we));
            const Je = ae.textures;
            if (we.length !== Je.length || we[0] !== r.COLOR_ATTACHMENT0) {
                for (let Ye = 0, mt = Je.length; Ye < mt; Ye++) we[Ye] = r.COLOR_ATTACHMENT0 + Ye;
                we.length = Je.length, He = !0
            }
        } else we[0] !== r.BACK && (we[0] = r.BACK, He = !0);
        He && r.drawBuffers(we)
    }

    function Ee(ae) {
        return g !== ae ? (r.useProgram(ae), g = ae, !0) : !1
    }
    const pe = {
        [tl]: r.FUNC_ADD,
        [bI]: r.FUNC_SUBTRACT,
        [TI]: r.FUNC_REVERSE_SUBTRACT
    };
    pe[EI] = r.MIN, pe[CI] = r.MAX;
    const xe = {
        [RI]: r.ZERO,
        [PI]: r.ONE,
        [II]: r.SRC_COLOR,
        [q0]: r.SRC_ALPHA,
        [OI]: r.SRC_ALPHA_SATURATE,
        [FI]: r.DST_COLOR,
        [DI]: r.DST_ALPHA,
        [BI]: r.ONE_MINUS_SRC_COLOR,
        [Z0]: r.ONE_MINUS_SRC_ALPHA,
        [UI]: r.ONE_MINUS_DST_COLOR,
        [LI]: r.ONE_MINUS_DST_ALPHA,
        [NI]: r.CONSTANT_COLOR,
        [kI]: r.ONE_MINUS_CONSTANT_COLOR,
        [zI]: r.CONSTANT_ALPHA,
        [GI]: r.ONE_MINUS_CONSTANT_ALPHA
    };

    function J(ae, ve, we, He, Je, Ye, mt, Pt, St, tt) {
        if (ae === pi) {
            y === !0 && (_e(r.BLEND), y = !1);
            return
        }
        if (y === !1 && (ce(r.BLEND), y = !0), ae !== wI) {
            if (ae !== v || tt !== b) {
                if ((_ !== tl || M !== tl) && (r.blendEquation(r.FUNC_ADD), _ = tl, M = tl), tt) switch (ae) {
                    case Xc:
                        r.blendFuncSeparate(r.ONE, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                        break;
                    case aA:
                        r.blendFunc(r.ONE, r.ONE);
                        break;
                    case lA:
                        r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                        break;
                    case cA:
                        r.blendFuncSeparate(r.ZERO, r.SRC_COLOR, r.ZERO, r.SRC_ALPHA);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", ae);
                        break
                } else switch (ae) {
                    case Xc:
                        r.blendFuncSeparate(r.SRC_ALPHA, r.ONE_MINUS_SRC_ALPHA, r.ONE, r.ONE_MINUS_SRC_ALPHA);
                        break;
                    case aA:
                        r.blendFunc(r.SRC_ALPHA, r.ONE);
                        break;
                    case lA:
                        r.blendFuncSeparate(r.ZERO, r.ONE_MINUS_SRC_COLOR, r.ZERO, r.ONE);
                        break;
                    case cA:
                        r.blendFunc(r.ZERO, r.SRC_COLOR);
                        break;
                    default:
                        console.error("THREE.WebGLState: Invalid blending: ", ae);
                        break
                }
                A = null, S = null, C = null, E = null, R.set(0, 0, 0), P = 0, v = ae, b = tt
            }
            return
        }
        Je = Je || ve, Ye = Ye || we, mt = mt || He, (ve !== _ || Je !== M) && (r.blendEquationSeparate(pe[ve], pe[Je]), _ = ve, M = Je), (we !== A || He !== S || Ye !== C || mt !== E) && (r.blendFuncSeparate(xe[we], xe[He], xe[Ye], xe[mt]), A = we, S = He, C = Ye, E = mt), (Pt.equals(R) === !1 || St !== P) && (r.blendColor(Pt.r, Pt.g, Pt.b, St), R.copy(Pt), P = St), v = ae, b = !1
    }

    function De(ae, ve) {
        ae.side === hn ? _e(r.CULL_FACE) : ce(r.CULL_FACE);
        let we = ae.side === di;
        ve && (we = !we), Ce(we), ae.blending === Xc && ae.transparent === !1 ? J(pi) : J(ae.blending, ae.blendEquation, ae.blendSrc, ae.blendDst, ae.blendEquationAlpha, ae.blendSrcAlpha, ae.blendDstAlpha, ae.blendColor, ae.blendAlpha, ae.premultipliedAlpha), o.setFunc(ae.depthFunc), o.setTest(ae.depthTest), o.setMask(ae.depthWrite), s.setMask(ae.colorWrite);
        const He = ae.stencilWrite;
        a.setTest(He), He && (a.setMask(ae.stencilWriteMask), a.setFunc(ae.stencilFunc, ae.stencilRef, ae.stencilFuncMask), a.setOp(ae.stencilFail, ae.stencilZFail, ae.stencilZPass)), Xe(ae.polygonOffset, ae.polygonOffsetFactor, ae.polygonOffsetUnits), ae.alphaToCoverage === !0 ? ce(r.SAMPLE_ALPHA_TO_COVERAGE) : _e(r.SAMPLE_ALPHA_TO_COVERAGE)
    }

    function Ce(ae) {
        T !== ae && (ae ? r.frontFace(r.CW) : r.frontFace(r.CCW), T = ae)
    }

    function se(ae) {
        ae !== AI ? (ce(r.CULL_FACE), ae !== L && (ae === oA ? r.cullFace(r.BACK) : ae === SI ? r.cullFace(r.FRONT) : r.cullFace(r.FRONT_AND_BACK))) : _e(r.CULL_FACE), L = ae
    }

    function Se(ae) {
        ae !== D && (X && r.lineWidth(ae), D = ae)
    }

    function Xe(ae, ve, we) {
        ae ? (ce(r.POLYGON_OFFSET_FILL), (V !== ve || H !== we) && (r.polygonOffset(ve, we), V = ve, H = we)) : _e(r.POLYGON_OFFSET_FILL)
    }

    function Le(ae) {
        ae ? ce(r.SCISSOR_TEST) : _e(r.SCISSOR_TEST)
    }

    function k(ae) {
        ae === void 0 && (ae = r.TEXTURE0 + q - 1), Z !== ae && (r.activeTexture(ae), Z = ae)
    }

    function z(ae, ve, we) {
        we === void 0 && (Z === null ? we = r.TEXTURE0 + q - 1 : we = Z);
        let He = U[we];
        He === void 0 && (He = {
            type: void 0,
            texture: void 0
        }, U[we] = He), (He.type !== ae || He.texture !== ve) && (Z !== we && (r.activeTexture(we), Z = we), r.bindTexture(ae, ve || me[ae]), He.type = ae, He.texture = ve)
    }

    function ue() {
        const ae = U[Z];
        ae !== void 0 && ae.type !== void 0 && (r.bindTexture(ae.type, null), ae.type = void 0, ae.texture = void 0)
    }

    function ye() {
        try {
            r.compressedTexImage2D.apply(r, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }

    function ge() {
        try {
            r.compressedTexImage3D.apply(r, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }

    function Re() {
        try {
            r.texSubImage2D.apply(r, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }

    function Be() {
        try {
            r.texSubImage3D.apply(r, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }

    function Fe() {
        try {
            r.compressedTexSubImage2D.apply(r, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }

    function Ne() {
        try {
            r.compressedTexSubImage3D.apply(r, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }

    function ot() {
        try {
            r.texStorage2D.apply(r, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }

    function je() {
        try {
            r.texStorage3D.apply(r, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }

    function Ze() {
        try {
            r.texImage2D.apply(r, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }

    function it() {
        try {
            r.texImage3D.apply(r, arguments)
        } catch (ae) {
            console.error("THREE.WebGLState:", ae)
        }
    }

    function $e(ae) {
        he.equals(ae) === !1 && (r.scissor(ae.x, ae.y, ae.z, ae.w), he.copy(ae))
    }

    function We(ae) {
        $.equals(ae) === !1 && (r.viewport(ae.x, ae.y, ae.z, ae.w), $.copy(ae))
    }

    function yt(ae, ve) {
        let we = c.get(ve);
        we === void 0 && (we = new WeakMap, c.set(ve, we));
        let He = we.get(ae);
        He === void 0 && (He = r.getUniformBlockIndex(ve, ae.name), we.set(ae, He))
    }

    function at(ae, ve) {
        const He = c.get(ve).get(ae);
        l.get(ve) !== He && (r.uniformBlockBinding(ve, He, ae.__bindingPointIndex), l.set(ve, He))
    }

    function Mt() {
        r.disable(r.BLEND), r.disable(r.CULL_FACE), r.disable(r.DEPTH_TEST), r.disable(r.POLYGON_OFFSET_FILL), r.disable(r.SCISSOR_TEST), r.disable(r.STENCIL_TEST), r.disable(r.SAMPLE_ALPHA_TO_COVERAGE), r.blendEquation(r.FUNC_ADD), r.blendFunc(r.ONE, r.ZERO), r.blendFuncSeparate(r.ONE, r.ZERO, r.ONE, r.ZERO), r.blendColor(0, 0, 0, 0), r.colorMask(!0, !0, !0, !0), r.clearColor(0, 0, 0, 0), r.depthMask(!0), r.depthFunc(r.LESS), o.setReversed(!1), r.clearDepth(1), r.stencilMask(4294967295), r.stencilFunc(r.ALWAYS, 0, 4294967295), r.stencilOp(r.KEEP, r.KEEP, r.KEEP), r.clearStencil(0), r.cullFace(r.BACK), r.frontFace(r.CCW), r.polygonOffset(0, 0), r.activeTexture(r.TEXTURE0), r.bindFramebuffer(r.FRAMEBUFFER, null), r.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), r.bindFramebuffer(r.READ_FRAMEBUFFER, null), r.useProgram(null), r.lineWidth(1), r.scissor(0, 0, r.canvas.width, r.canvas.height), r.viewport(0, 0, r.canvas.width, r.canvas.height), u = {}, Z = null, U = {}, f = {}, d = new WeakMap, m = [], g = null, y = !1, v = null, _ = null, A = null, S = null, M = null, C = null, E = null, R = new rt(0, 0, 0), P = 0, b = !1, T = null, L = null, D = null, V = null, H = null, he.set(0, 0, r.canvas.width, r.canvas.height), $.set(0, 0, r.canvas.width, r.canvas.height), s.reset(), o.reset(), a.reset()
    }
    return {
        buffers: {
            color: s,
            depth: o,
            stencil: a
        },
        enable: ce,
        disable: _e,
        bindFramebuffer: Oe,
        drawBuffers: ke,
        useProgram: Ee,
        setBlending: J,
        setMaterial: De,
        setFlipSided: Ce,
        setCullFace: se,
        setLineWidth: Se,
        setPolygonOffset: Xe,
        setScissorTest: Le,
        activeTexture: k,
        bindTexture: z,
        unbindTexture: ue,
        compressedTexImage2D: ye,
        compressedTexImage3D: ge,
        texImage2D: Ze,
        texImage3D: it,
        updateUBOMapping: yt,
        uniformBlockBinding: at,
        texStorage2D: ot,
        texStorage3D: je,
        texSubImage2D: Re,
        texSubImage3D: Be,
        compressedTexSubImage2D: Fe,
        compressedTexSubImage3D: Ne,
        scissor: $e,
        viewport: We,
        reset: Mt
    }
}

function r5(r, e) {
    const t = r.image && r.image.width ? r.image.width / r.image.height : 1;
    return t > e ? (r.repeat.x = 1, r.repeat.y = t / e, r.offset.x = 0, r.offset.y = (1 - r.repeat.y) / 2) : (r.repeat.x = e / t, r.repeat.y = 1, r.offset.x = (1 - r.repeat.x) / 2, r.offset.y = 0), r
}

function s5(r, e) {
    const t = r.image && r.image.width ? r.image.width / r.image.height : 1;
    return t > e ? (r.repeat.x = e / t, r.repeat.y = 1, r.offset.x = (1 - r.repeat.x) / 2, r.offset.y = 0) : (r.repeat.x = 1, r.repeat.y = t / e, r.offset.x = 0, r.offset.y = (1 - r.repeat.y) / 2), r
}

function o5(r) {
    return r.repeat.x = 1, r.repeat.y = 1, r.offset.x = 0, r.offset.y = 0, r
}

function gA(r, e, t, n) {
    const i = a5(n);
    switch (t) {
        case DS:
            return r * e;
        case FS:
            return r * e;
        case US:
            return r * e * 2;
        case Hp:
            return r * e / i.components * i.byteLength;
        case Vp:
            return r * e / i.components * i.byteLength;
        case OS:
            return r * e * 2 / i.components * i.byteLength;
        case uy:
            return r * e * 2 / i.components * i.byteLength;
        case LS:
            return r * e * 3 / i.components * i.byteLength;
        case kn:
            return r * e * 4 / i.components * i.byteLength;
        case fy:
            return r * e * 4 / i.components * i.byteLength;
        case Gd:
        case Hd:
            return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
        case Vd:
        case Wd:
            return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
        case ov:
        case lv:
            return Math.max(r, 16) * Math.max(e, 8) / 4;
        case sv:
        case av:
            return Math.max(r, 8) * Math.max(e, 8) / 2;
        case cv:
        case uv:
            return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 8;
        case fv:
            return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
        case hv:
            return Math.floor((r + 3) / 4) * Math.floor((e + 3) / 4) * 16;
        case dv:
            return Math.floor((r + 4) / 5) * Math.floor((e + 3) / 4) * 16;
        case pv:
            return Math.floor((r + 4) / 5) * Math.floor((e + 4) / 5) * 16;
        case mv:
            return Math.floor((r + 5) / 6) * Math.floor((e + 4) / 5) * 16;
        case gv:
            return Math.floor((r + 5) / 6) * Math.floor((e + 5) / 6) * 16;
        case vv:
            return Math.floor((r + 7) / 8) * Math.floor((e + 4) / 5) * 16;
        case yv:
            return Math.floor((r + 7) / 8) * Math.floor((e + 5) / 6) * 16;
        case _v:
            return Math.floor((r + 7) / 8) * Math.floor((e + 7) / 8) * 16;
        case xv:
            return Math.floor((r + 9) / 10) * Math.floor((e + 4) / 5) * 16;
        case Av:
            return Math.floor((r + 9) / 10) * Math.floor((e + 5) / 6) * 16;
        case Sv:
            return Math.floor((r + 9) / 10) * Math.floor((e + 7) / 8) * 16;
        case Mv:
            return Math.floor((r + 9) / 10) * Math.floor((e + 9) / 10) * 16;
        case wv:
            return Math.floor((r + 11) / 12) * Math.floor((e + 9) / 10) * 16;
        case bv:
            return Math.floor((r + 11) / 12) * Math.floor((e + 11) / 12) * 16;
        case jd:
        case Tv:
        case Ev:
            return Math.ceil(r / 4) * Math.ceil(e / 4) * 16;
        case NS:
        case Cv:
            return Math.ceil(r / 4) * Math.ceil(e / 4) * 8;
        case Rv:
        case Pv:
            return Math.ceil(r / 4) * Math.ceil(e / 4) * 16
    }
    throw new Error(`Unable to determine texture byte length for ${t} format.`)
}

function a5(r) {
    switch (r) {
        case Yi:
        case oy:
            return {
                byteLength: 1,
                components: 1
            };
        case Kf:
        case ay:
        case Ri:
            return {
                byteLength: 2,
                components: 1
            };
        case ly:
        case cy:
            return {
                byteLength: 2,
                components: 4
            };
        case fo:
        case Gp:
        case Bn:
            return {
                byteLength: 4,
                components: 1
            };
        case BS:
            return {
                byteLength: 4,
                components: 3
            }
    }
    throw new Error(`Unknown texture type ${r}.`)
}
const l5 = {
    contain: r5,
    cover: s5,
    fill: o5,
    getByteLength: gA
};

function c5(r, e, t, n, i, s, o) {
    const a = e.has("WEBGL_multisampled_render_to_texture") ? e.get("WEBGL_multisampled_render_to_texture") : null,
        l = typeof navigator > "u" ? !1 : /OculusBrowser/g.test(navigator.userAgent),
        c = new Ue,
        u = new WeakMap;
    let f;
    const d = new WeakMap;
    let m = !1;
    try {
        m = typeof OffscreenCanvas < "u" && new OffscreenCanvas(1, 1).getContext("2d") !== null
    } catch {}

    function g(k, z) {
        return m ? new OffscreenCanvas(k, z) : vp("canvas")
    }

    function y(k, z, ue) {
        let ye = 1;
        const ge = Le(k);
        if ((ge.width > ue || ge.height > ue) && (ye = ue / Math.max(ge.width, ge.height)), ye < 1)
            if (typeof HTMLImageElement < "u" && k instanceof HTMLImageElement || typeof HTMLCanvasElement < "u" && k instanceof HTMLCanvasElement || typeof ImageBitmap < "u" && k instanceof ImageBitmap || typeof VideoFrame < "u" && k instanceof VideoFrame) {
                const Re = Math.floor(ye * ge.width),
                    Be = Math.floor(ye * ge.height);
                f === void 0 && (f = g(Re, Be));
                const Fe = z ? g(Re, Be) : f;
                return Fe.width = Re, Fe.height = Be, Fe.getContext("2d").drawImage(k, 0, 0, Re, Be), console.warn("THREE.WebGLRenderer: Texture has been resized from (" + ge.width + "x" + ge.height + ") to (" + Re + "x" + Be + ")."), Fe
            } else return "data" in k && console.warn("THREE.WebGLRenderer: Image in DataTexture is too big (" + ge.width + "x" + ge.height + ")."), k;
        return k
    }

    function v(k) {
        return k.generateMipmaps
    }

    function _(k) {
        r.generateMipmap(k)
    }

    function A(k) {
        return k.isWebGLCubeRenderTarget ? r.TEXTURE_CUBE_MAP : k.isWebGL3DRenderTarget ? r.TEXTURE_3D : k.isWebGLArrayRenderTarget || k.isCompressedArrayTexture ? r.TEXTURE_2D_ARRAY : r.TEXTURE_2D
    }

    function S(k, z, ue, ye, ge = !1) {
        if (k !== null) {
            if (r[k] !== void 0) return r[k];
            console.warn("THREE.WebGLRenderer: Attempt to use non-existing WebGL internal format '" + k + "'")
        }
        let Re = z;
        if (z === r.RED && (ue === r.FLOAT && (Re = r.R32F), ue === r.HALF_FLOAT && (Re = r.R16F), ue === r.UNSIGNED_BYTE && (Re = r.R8)), z === r.RED_INTEGER && (ue === r.UNSIGNED_BYTE && (Re = r.R8UI), ue === r.UNSIGNED_SHORT && (Re = r.R16UI), ue === r.UNSIGNED_INT && (Re = r.R32UI), ue === r.BYTE && (Re = r.R8I), ue === r.SHORT && (Re = r.R16I), ue === r.INT && (Re = r.R32I)), z === r.RG && (ue === r.FLOAT && (Re = r.RG32F), ue === r.HALF_FLOAT && (Re = r.RG16F), ue === r.UNSIGNED_BYTE && (Re = r.RG8)), z === r.RG_INTEGER && (ue === r.UNSIGNED_BYTE && (Re = r.RG8UI), ue === r.UNSIGNED_SHORT && (Re = r.RG16UI), ue === r.UNSIGNED_INT && (Re = r.RG32UI), ue === r.BYTE && (Re = r.RG8I), ue === r.SHORT && (Re = r.RG16I), ue === r.INT && (Re = r.RG32I)), z === r.RGB_INTEGER && (ue === r.UNSIGNED_BYTE && (Re = r.RGB8UI), ue === r.UNSIGNED_SHORT && (Re = r.RGB16UI), ue === r.UNSIGNED_INT && (Re = r.RGB32UI), ue === r.BYTE && (Re = r.RGB8I), ue === r.SHORT && (Re = r.RGB16I), ue === r.INT && (Re = r.RGB32I)), z === r.RGBA_INTEGER && (ue === r.UNSIGNED_BYTE && (Re = r.RGBA8UI), ue === r.UNSIGNED_SHORT && (Re = r.RGBA16UI), ue === r.UNSIGNED_INT && (Re = r.RGBA32UI), ue === r.BYTE && (Re = r.RGBA8I), ue === r.SHORT && (Re = r.RGBA16I), ue === r.INT && (Re = r.RGBA32I)), z === r.RGB && ue === r.UNSIGNED_INT_5_9_9_9_REV && (Re = r.RGB9_E5), z === r.RGBA) {
            const Be = ge ? Wp : xn.getTransfer(ye);
            ue === r.FLOAT && (Re = r.RGBA32F), ue === r.HALF_FLOAT && (Re = r.RGBA16F), ue === r.UNSIGNED_BYTE && (Re = Be === Ln ? r.SRGB8_ALPHA8 : r.RGBA8), ue === r.UNSIGNED_SHORT_4_4_4_4 && (Re = r.RGBA4), ue === r.UNSIGNED_SHORT_5_5_5_1 && (Re = r.RGB5_A1)
        }
        return (Re === r.R16F || Re === r.R32F || Re === r.RG16F || Re === r.RG32F || Re === r.RGBA16F || Re === r.RGBA32F) && e.get("EXT_color_buffer_float"), Re
    }

    function M(k, z) {
        let ue;
        return k ? z === null || z === fo || z === Ml ? ue = r.DEPTH24_STENCIL8 : z === Bn ? ue = r.DEPTH32F_STENCIL8 : z === Kf && (ue = r.DEPTH24_STENCIL8, console.warn("DepthTexture: 16 bit depth attachment is not supported with stencil. Using 24-bit attachment.")) : z === null || z === fo || z === Ml ? ue = r.DEPTH_COMPONENT24 : z === Bn ? ue = r.DEPTH_COMPONENT32F : z === Kf && (ue = r.DEPTH_COMPONENT16), ue
    }

    function C(k, z) {
        return v(k) === !0 || k.isFramebufferTexture && k.minFilter !== bn && k.minFilter !== nn ? Math.log2(Math.max(z.width, z.height)) + 1 : k.mipmaps !== void 0 && k.mipmaps.length > 0 ? k.mipmaps.length : k.isCompressedTexture && Array.isArray(k.image) ? z.mipmaps.length : 1
    }

    function E(k) {
        const z = k.target;
        z.removeEventListener("dispose", E), P(z), z.isVideoTexture && u.delete(z)
    }

    function R(k) {
        const z = k.target;
        z.removeEventListener("dispose", R), T(z)
    }

    function P(k) {
        const z = n.get(k);
        if (z.__webglInit === void 0) return;
        const ue = k.source,
            ye = d.get(ue);
        if (ye) {
            const ge = ye[z.__cacheKey];
            ge.usedTimes--, ge.usedTimes === 0 && b(k), Object.keys(ye).length === 0 && d.delete(ue)
        }
        n.remove(k)
    }

    function b(k) {
        const z = n.get(k);
        r.deleteTexture(z.__webglTexture);
        const ue = k.source,
            ye = d.get(ue);
        delete ye[z.__cacheKey], o.memory.textures--
    }

    function T(k) {
        const z = n.get(k);
        if (k.depthTexture && (k.depthTexture.dispose(), n.remove(k.depthTexture)), k.isWebGLCubeRenderTarget)
            for (let ye = 0; ye < 6; ye++) {
                if (Array.isArray(z.__webglFramebuffer[ye]))
                    for (let ge = 0; ge < z.__webglFramebuffer[ye].length; ge++) r.deleteFramebuffer(z.__webglFramebuffer[ye][ge]);
                else r.deleteFramebuffer(z.__webglFramebuffer[ye]);
                z.__webglDepthbuffer && r.deleteRenderbuffer(z.__webglDepthbuffer[ye])
            } else {
                if (Array.isArray(z.__webglFramebuffer))
                    for (let ye = 0; ye < z.__webglFramebuffer.length; ye++) r.deleteFramebuffer(z.__webglFramebuffer[ye]);
                else r.deleteFramebuffer(z.__webglFramebuffer);
                if (z.__webglDepthbuffer && r.deleteRenderbuffer(z.__webglDepthbuffer), z.__webglMultisampledFramebuffer && r.deleteFramebuffer(z.__webglMultisampledFramebuffer), z.__webglColorRenderbuffer)
                    for (let ye = 0; ye < z.__webglColorRenderbuffer.length; ye++) z.__webglColorRenderbuffer[ye] && r.deleteRenderbuffer(z.__webglColorRenderbuffer[ye]);
                z.__webglDepthRenderbuffer && r.deleteRenderbuffer(z.__webglDepthRenderbuffer)
            }
        const ue = k.textures;
        for (let ye = 0, ge = ue.length; ye < ge; ye++) {
            const Re = n.get(ue[ye]);
            Re.__webglTexture && (r.deleteTexture(Re.__webglTexture), o.memory.textures--), n.remove(ue[ye])
        }
        n.remove(k)
    }
    let L = 0;

    function D() {
        L = 0
    }

    function V() {
        const k = L;
        return k >= i.maxTextures && console.warn("THREE.WebGLTextures: Trying to use " + k + " texture units while this GPU supports only " + i.maxTextures), L += 1, k
    }

    function H(k) {
        const z = [];
        return z.push(k.wrapS), z.push(k.wrapT), z.push(k.wrapR || 0), z.push(k.magFilter), z.push(k.minFilter), z.push(k.anisotropy), z.push(k.internalFormat), z.push(k.format), z.push(k.type), z.push(k.generateMipmaps), z.push(k.premultiplyAlpha), z.push(k.flipY), z.push(k.unpackAlignment), z.push(k.colorSpace), z.join()
    }

    function q(k, z) {
        const ue = n.get(k);
        if (k.isVideoTexture && Se(k), k.isRenderTargetTexture === !1 && k.version > 0 && ue.__version !== k.version) {
            const ye = k.image;
            if (ye === null) console.warn("THREE.WebGLRenderer: Texture marked for update but no image data found.");
            else if (ye.complete === !1) console.warn("THREE.WebGLRenderer: Texture marked for update but image is incomplete");
            else {
                $(ue, k, z);
                return
            }
        }
        t.bindTexture(r.TEXTURE_2D, ue.__webglTexture, r.TEXTURE0 + z)
    }

    function X(k, z) {
        const ue = n.get(k);
        if (k.version > 0 && ue.__version !== k.version) {
            $(ue, k, z);
            return
        }
        t.bindTexture(r.TEXTURE_2D_ARRAY, ue.__webglTexture, r.TEXTURE0 + z)
    }

    function oe(k, z) {
        const ue = n.get(k);
        if (k.version > 0 && ue.__version !== k.version) {
            $(ue, k, z);
            return
        }
        t.bindTexture(r.TEXTURE_3D, ue.__webglTexture, r.TEXTURE0 + z)
    }

    function Y(k, z) {
        const ue = n.get(k);
        if (k.version > 0 && ue.__version !== k.version) {
            ne(ue, k, z);
            return
        }
        t.bindTexture(r.TEXTURE_CUBE_MAP, ue.__webglTexture, r.TEXTURE0 + z)
    }
    const Z = {
            [Sl]: r.REPEAT,
            [Nn]: r.CLAMP_TO_EDGE,
            [au]: r.MIRRORED_REPEAT
        },
        U = {
            [bn]: r.NEAREST,
            [sy]: r.NEAREST_MIPMAP_NEAREST,
            [Pc]: r.NEAREST_MIPMAP_LINEAR,
            [nn]: r.LINEAR,
            [If]: r.LINEAR_MIPMAP_NEAREST,
            [gs]: r.LINEAR_MIPMAP_LINEAR
        },
        j = {
            [nB]: r.NEVER,
            [lB]: r.ALWAYS,
            [iB]: r.LESS,
            [HS]: r.LEQUAL,
            [rB]: r.EQUAL,
            [aB]: r.GEQUAL,
            [sB]: r.GREATER,
            [oB]: r.NOTEQUAL
        };

    function te(k, z) {
        if (z.type === Bn && e.has("OES_texture_float_linear") === !1 && (z.magFilter === nn || z.magFilter === If || z.magFilter === Pc || z.magFilter === gs || z.minFilter === nn || z.minFilter === If || z.minFilter === Pc || z.minFilter === gs) && console.warn("THREE.WebGLRenderer: Unable to use linear filtering with floating point textures. OES_texture_float_linear not supported on this device."), r.texParameteri(k, r.TEXTURE_WRAP_S, Z[z.wrapS]), r.texParameteri(k, r.TEXTURE_WRAP_T, Z[z.wrapT]), (k === r.TEXTURE_3D || k === r.TEXTURE_2D_ARRAY) && r.texParameteri(k, r.TEXTURE_WRAP_R, Z[z.wrapR]), r.texParameteri(k, r.TEXTURE_MAG_FILTER, U[z.magFilter]), r.texParameteri(k, r.TEXTURE_MIN_FILTER, U[z.minFilter]), z.compareFunction && (r.texParameteri(k, r.TEXTURE_COMPARE_MODE, r.COMPARE_REF_TO_TEXTURE), r.texParameteri(k, r.TEXTURE_COMPARE_FUNC, j[z.compareFunction])), e.has("EXT_texture_filter_anisotropic") === !0) {
            if (z.magFilter === bn || z.minFilter !== Pc && z.minFilter !== gs || z.type === Bn && e.has("OES_texture_float_linear") === !1) return;
            if (z.anisotropy > 1 || n.get(z).__currentAnisotropy) {
                const ue = e.get("EXT_texture_filter_anisotropic");
                r.texParameterf(k, ue.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(z.anisotropy, i.getMaxAnisotropy())), n.get(z).__currentAnisotropy = z.anisotropy
            }
        }
    }

    function he(k, z) {
        let ue = !1;
        k.__webglInit === void 0 && (k.__webglInit = !0, z.addEventListener("dispose", E));
        const ye = z.source;
        let ge = d.get(ye);
        ge === void 0 && (ge = {}, d.set(ye, ge));
        const Re = H(z);
        if (Re !== k.__cacheKey) {
            ge[Re] === void 0 && (ge[Re] = {
                texture: r.createTexture(),
                usedTimes: 0
            }, o.memory.textures++, ue = !0), ge[Re].usedTimes++;
            const Be = ge[k.__cacheKey];
            Be !== void 0 && (ge[k.__cacheKey].usedTimes--, Be.usedTimes === 0 && b(z)), k.__cacheKey = Re, k.__webglTexture = ge[Re].texture
        }
        return ue
    }

    function $(k, z, ue) {
        let ye = r.TEXTURE_2D;
        (z.isDataArrayTexture || z.isCompressedArrayTexture) && (ye = r.TEXTURE_2D_ARRAY), z.isData3DTexture && (ye = r.TEXTURE_3D);
        const ge = he(k, z),
            Re = z.source;
        t.bindTexture(ye, k.__webglTexture, r.TEXTURE0 + ue);
        const Be = n.get(Re);
        if (Re.version !== Be.__version || ge === !0) {
            t.activeTexture(r.TEXTURE0 + ue);
            const Fe = xn.getPrimaries(xn.workingColorSpace),
                Ne = z.colorSpace === uo ? null : xn.getPrimaries(z.colorSpace),
                ot = z.colorSpace === uo || Fe === Ne ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, z.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, z.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, z.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, ot);
            let je = y(z.image, !1, i.maxTextureSize);
            je = Xe(z, je);
            const Ze = s.convert(z.format, z.colorSpace),
                it = s.convert(z.type);
            let $e = S(z.internalFormat, Ze, it, z.colorSpace, z.isVideoTexture);
            te(ye, z);
            let We;
            const yt = z.mipmaps,
                at = z.isVideoTexture !== !0,
                Mt = Be.__version === void 0 || ge === !0,
                ae = Re.dataReady,
                ve = C(z, je);
            if (z.isDepthTexture) $e = M(z.format === wl, z.type), Mt && (at ? t.texStorage2D(r.TEXTURE_2D, 1, $e, je.width, je.height) : t.texImage2D(r.TEXTURE_2D, 0, $e, je.width, je.height, 0, Ze, it, null));
            else if (z.isDataTexture)
                if (yt.length > 0) {
                    at && Mt && t.texStorage2D(r.TEXTURE_2D, ve, $e, yt[0].width, yt[0].height);
                    for (let we = 0, He = yt.length; we < He; we++) We = yt[we], at ? ae && t.texSubImage2D(r.TEXTURE_2D, we, 0, 0, We.width, We.height, Ze, it, We.data) : t.texImage2D(r.TEXTURE_2D, we, $e, We.width, We.height, 0, Ze, it, We.data);
                    z.generateMipmaps = !1
                } else at ? (Mt && t.texStorage2D(r.TEXTURE_2D, ve, $e, je.width, je.height), ae && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, je.width, je.height, Ze, it, je.data)) : t.texImage2D(r.TEXTURE_2D, 0, $e, je.width, je.height, 0, Ze, it, je.data);
            else if (z.isCompressedTexture)
                if (z.isCompressedArrayTexture) {
                    at && Mt && t.texStorage3D(r.TEXTURE_2D_ARRAY, ve, $e, yt[0].width, yt[0].height, je.depth);
                    for (let we = 0, He = yt.length; we < He; we++)
                        if (We = yt[we], z.format !== kn)
                            if (Ze !== null)
                                if (at) {
                                    if (ae)
                                        if (z.layerUpdates.size > 0) {
                                            const Je = gA(We.width, We.height, z.format, z.type);
                                            for (const Ye of z.layerUpdates) {
                                                const mt = We.data.subarray(Ye * Je / We.data.BYTES_PER_ELEMENT, (Ye + 1) * Je / We.data.BYTES_PER_ELEMENT);
                                                t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, we, 0, 0, Ye, We.width, We.height, 1, Ze, mt)
                                            }
                                            z.clearLayerUpdates()
                                        } else t.compressedTexSubImage3D(r.TEXTURE_2D_ARRAY, we, 0, 0, 0, We.width, We.height, je.depth, Ze, We.data)
                                } else t.compressedTexImage3D(r.TEXTURE_2D_ARRAY, we, $e, We.width, We.height, je.depth, 0, We.data, 0, 0);
                    else console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()");
                    else at ? ae && t.texSubImage3D(r.TEXTURE_2D_ARRAY, we, 0, 0, 0, We.width, We.height, je.depth, Ze, it, We.data) : t.texImage3D(r.TEXTURE_2D_ARRAY, we, $e, We.width, We.height, je.depth, 0, Ze, it, We.data)
                } else {
                    at && Mt && t.texStorage2D(r.TEXTURE_2D, ve, $e, yt[0].width, yt[0].height);
                    for (let we = 0, He = yt.length; we < He; we++) We = yt[we], z.format !== kn ? Ze !== null ? at ? ae && t.compressedTexSubImage2D(r.TEXTURE_2D, we, 0, 0, We.width, We.height, Ze, We.data) : t.compressedTexImage2D(r.TEXTURE_2D, we, $e, We.width, We.height, 0, We.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()") : at ? ae && t.texSubImage2D(r.TEXTURE_2D, we, 0, 0, We.width, We.height, Ze, it, We.data) : t.texImage2D(r.TEXTURE_2D, we, $e, We.width, We.height, 0, Ze, it, We.data)
                }
            else if (z.isDataArrayTexture)
                if (at) {
                    if (Mt && t.texStorage3D(r.TEXTURE_2D_ARRAY, ve, $e, je.width, je.height, je.depth), ae)
                        if (z.layerUpdates.size > 0) {
                            const we = gA(je.width, je.height, z.format, z.type);
                            for (const He of z.layerUpdates) {
                                const Je = je.data.subarray(He * we / je.data.BYTES_PER_ELEMENT, (He + 1) * we / je.data.BYTES_PER_ELEMENT);
                                t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, He, je.width, je.height, 1, Ze, it, Je)
                            }
                            z.clearLayerUpdates()
                        } else t.texSubImage3D(r.TEXTURE_2D_ARRAY, 0, 0, 0, 0, je.width, je.height, je.depth, Ze, it, je.data)
                } else t.texImage3D(r.TEXTURE_2D_ARRAY, 0, $e, je.width, je.height, je.depth, 0, Ze, it, je.data);
            else if (z.isData3DTexture) at ? (Mt && t.texStorage3D(r.TEXTURE_3D, ve, $e, je.width, je.height, je.depth), ae && t.texSubImage3D(r.TEXTURE_3D, 0, 0, 0, 0, je.width, je.height, je.depth, Ze, it, je.data)) : t.texImage3D(r.TEXTURE_3D, 0, $e, je.width, je.height, je.depth, 0, Ze, it, je.data);
            else if (z.isFramebufferTexture) {
                if (Mt)
                    if (at) t.texStorage2D(r.TEXTURE_2D, ve, $e, je.width, je.height);
                    else {
                        let we = je.width,
                            He = je.height;
                        for (let Je = 0; Je < ve; Je++) t.texImage2D(r.TEXTURE_2D, Je, $e, we, He, 0, Ze, it, null), we >>= 1, He >>= 1
                    }
            } else if (yt.length > 0) {
                if (at && Mt) {
                    const we = Le(yt[0]);
                    t.texStorage2D(r.TEXTURE_2D, ve, $e, we.width, we.height)
                }
                for (let we = 0, He = yt.length; we < He; we++) We = yt[we], at ? ae && t.texSubImage2D(r.TEXTURE_2D, we, 0, 0, Ze, it, We) : t.texImage2D(r.TEXTURE_2D, we, $e, Ze, it, We);
                z.generateMipmaps = !1
            } else if (at) {
                if (Mt) {
                    const we = Le(je);
                    t.texStorage2D(r.TEXTURE_2D, ve, $e, we.width, we.height)
                }
                ae && t.texSubImage2D(r.TEXTURE_2D, 0, 0, 0, Ze, it, je)
            } else t.texImage2D(r.TEXTURE_2D, 0, $e, Ze, it, je);
            v(z) && _(ye), Be.__version = Re.version, z.onUpdate && z.onUpdate(z)
        }
        k.__version = z.version
    }

    function ne(k, z, ue) {
        if (z.image.length !== 6) return;
        const ye = he(k, z),
            ge = z.source;
        t.bindTexture(r.TEXTURE_CUBE_MAP, k.__webglTexture, r.TEXTURE0 + ue);
        const Re = n.get(ge);
        if (ge.version !== Re.__version || ye === !0) {
            t.activeTexture(r.TEXTURE0 + ue);
            const Be = xn.getPrimaries(xn.workingColorSpace),
                Fe = z.colorSpace === uo ? null : xn.getPrimaries(z.colorSpace),
                Ne = z.colorSpace === uo || Be === Fe ? r.NONE : r.BROWSER_DEFAULT_WEBGL;
            r.pixelStorei(r.UNPACK_FLIP_Y_WEBGL, z.flipY), r.pixelStorei(r.UNPACK_PREMULTIPLY_ALPHA_WEBGL, z.premultiplyAlpha), r.pixelStorei(r.UNPACK_ALIGNMENT, z.unpackAlignment), r.pixelStorei(r.UNPACK_COLORSPACE_CONVERSION_WEBGL, Ne);
            const ot = z.isCompressedTexture || z.image[0].isCompressedTexture,
                je = z.image[0] && z.image[0].isDataTexture,
                Ze = [];
            for (let He = 0; He < 6; He++) !ot && !je ? Ze[He] = y(z.image[He], !0, i.maxCubemapSize) : Ze[He] = je ? z.image[He].image : z.image[He], Ze[He] = Xe(z, Ze[He]);
            const it = Ze[0],
                $e = s.convert(z.format, z.colorSpace),
                We = s.convert(z.type),
                yt = S(z.internalFormat, $e, We, z.colorSpace),
                at = z.isVideoTexture !== !0,
                Mt = Re.__version === void 0 || ye === !0,
                ae = ge.dataReady;
            let ve = C(z, it);
            te(r.TEXTURE_CUBE_MAP, z);
            let we;
            if (ot) {
                at && Mt && t.texStorage2D(r.TEXTURE_CUBE_MAP, ve, yt, it.width, it.height);
                for (let He = 0; He < 6; He++) {
                    we = Ze[He].mipmaps;
                    for (let Je = 0; Je < we.length; Je++) {
                        const Ye = we[Je];
                        z.format !== kn ? $e !== null ? at ? ae && t.compressedTexSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + He, Je, 0, 0, Ye.width, Ye.height, $e, Ye.data) : t.compressedTexImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + He, Je, yt, Ye.width, Ye.height, 0, Ye.data) : console.warn("THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()") : at ? ae && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + He, Je, 0, 0, Ye.width, Ye.height, $e, We, Ye.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + He, Je, yt, Ye.width, Ye.height, 0, $e, We, Ye.data)
                    }
                }
            } else {
                if (we = z.mipmaps, at && Mt) {
                    we.length > 0 && ve++;
                    const He = Le(Ze[0]);
                    t.texStorage2D(r.TEXTURE_CUBE_MAP, ve, yt, He.width, He.height)
                }
                for (let He = 0; He < 6; He++)
                    if (je) {
                        at ? ae && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + He, 0, 0, 0, Ze[He].width, Ze[He].height, $e, We, Ze[He].data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + He, 0, yt, Ze[He].width, Ze[He].height, 0, $e, We, Ze[He].data);
                        for (let Je = 0; Je < we.length; Je++) {
                            const mt = we[Je].image[He].image;
                            at ? ae && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + He, Je + 1, 0, 0, mt.width, mt.height, $e, We, mt.data) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + He, Je + 1, yt, mt.width, mt.height, 0, $e, We, mt.data)
                        }
                    } else {
                        at ? ae && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + He, 0, 0, 0, $e, We, Ze[He]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + He, 0, yt, $e, We, Ze[He]);
                        for (let Je = 0; Je < we.length; Je++) {
                            const Ye = we[Je];
                            at ? ae && t.texSubImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + He, Je + 1, 0, 0, $e, We, Ye.image[He]) : t.texImage2D(r.TEXTURE_CUBE_MAP_POSITIVE_X + He, Je + 1, yt, $e, We, Ye.image[He])
                        }
                    }
            }
            v(z) && _(r.TEXTURE_CUBE_MAP), Re.__version = ge.version, z.onUpdate && z.onUpdate(z)
        }
        k.__version = z.version
    }

    function me(k, z, ue, ye, ge, Re) {
        const Be = s.convert(ue.format, ue.colorSpace),
            Fe = s.convert(ue.type),
            Ne = S(ue.internalFormat, Be, Fe, ue.colorSpace),
            ot = n.get(z),
            je = n.get(ue);
        if (je.__renderTarget = z, !ot.__hasExternalTextures) {
            const Ze = Math.max(1, z.width >> Re),
                it = Math.max(1, z.height >> Re);
            ge === r.TEXTURE_3D || ge === r.TEXTURE_2D_ARRAY ? t.texImage3D(ge, Re, Ne, Ze, it, z.depth, 0, Be, Fe, null) : t.texImage2D(ge, Re, Ne, Ze, it, 0, Be, Fe, null)
        }
        t.bindFramebuffer(r.FRAMEBUFFER, k), se(z) ? a.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, ye, ge, je.__webglTexture, 0, Ce(z)) : (ge === r.TEXTURE_2D || ge >= r.TEXTURE_CUBE_MAP_POSITIVE_X && ge <= r.TEXTURE_CUBE_MAP_NEGATIVE_Z) && r.framebufferTexture2D(r.FRAMEBUFFER, ye, ge, je.__webglTexture, Re), t.bindFramebuffer(r.FRAMEBUFFER, null)
    }

    function ce(k, z, ue) {
        if (r.bindRenderbuffer(r.RENDERBUFFER, k), z.depthBuffer) {
            const ye = z.depthTexture,
                ge = ye && ye.isDepthTexture ? ye.type : null,
                Re = M(z.stencilBuffer, ge),
                Be = z.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                Fe = Ce(z);
            se(z) ? a.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, Fe, Re, z.width, z.height) : ue ? r.renderbufferStorageMultisample(r.RENDERBUFFER, Fe, Re, z.width, z.height) : r.renderbufferStorage(r.RENDERBUFFER, Re, z.width, z.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, Be, r.RENDERBUFFER, k)
        } else {
            const ye = z.textures;
            for (let ge = 0; ge < ye.length; ge++) {
                const Re = ye[ge],
                    Be = s.convert(Re.format, Re.colorSpace),
                    Fe = s.convert(Re.type),
                    Ne = S(Re.internalFormat, Be, Fe, Re.colorSpace),
                    ot = Ce(z);
                ue && se(z) === !1 ? r.renderbufferStorageMultisample(r.RENDERBUFFER, ot, Ne, z.width, z.height) : se(z) ? a.renderbufferStorageMultisampleEXT(r.RENDERBUFFER, ot, Ne, z.width, z.height) : r.renderbufferStorage(r.RENDERBUFFER, Ne, z.width, z.height)
            }
        }
        r.bindRenderbuffer(r.RENDERBUFFER, null)
    }

    function _e(k, z) {
        if (z && z.isWebGLCubeRenderTarget) throw new Error("Depth Texture with cube render targets is not supported");
        if (t.bindFramebuffer(r.FRAMEBUFFER, k), !(z.depthTexture && z.depthTexture.isDepthTexture)) throw new Error("renderTarget.depthTexture must be an instance of THREE.DepthTexture");
        const ye = n.get(z.depthTexture);
        ye.__renderTarget = z, (!ye.__webglTexture || z.depthTexture.image.width !== z.width || z.depthTexture.image.height !== z.height) && (z.depthTexture.image.width = z.width, z.depthTexture.image.height = z.height, z.depthTexture.needsUpdate = !0), q(z.depthTexture, 0);
        const ge = ye.__webglTexture,
            Re = Ce(z);
        if (z.depthTexture.format === Yc) se(z) ? a.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ge, 0, Re) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_ATTACHMENT, r.TEXTURE_2D, ge, 0);
        else if (z.depthTexture.format === wl) se(z) ? a.framebufferTexture2DMultisampleEXT(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ge, 0, Re) : r.framebufferTexture2D(r.FRAMEBUFFER, r.DEPTH_STENCIL_ATTACHMENT, r.TEXTURE_2D, ge, 0);
        else throw new Error("Unknown depthTexture format")
    }

    function Oe(k) {
        const z = n.get(k),
            ue = k.isWebGLCubeRenderTarget === !0;
        if (z.__boundDepthTexture !== k.depthTexture) {
            const ye = k.depthTexture;
            if (z.__depthDisposeCallback && z.__depthDisposeCallback(), ye) {
                const ge = () => {
                    delete z.__boundDepthTexture, delete z.__depthDisposeCallback, ye.removeEventListener("dispose", ge)
                };
                ye.addEventListener("dispose", ge), z.__depthDisposeCallback = ge
            }
            z.__boundDepthTexture = ye
        }
        if (k.depthTexture && !z.__autoAllocateDepthBuffer) {
            if (ue) throw new Error("target.depthTexture not supported in Cube render targets");
            _e(z.__webglFramebuffer, k)
        } else if (ue) {
            z.__webglDepthbuffer = [];
            for (let ye = 0; ye < 6; ye++)
                if (t.bindFramebuffer(r.FRAMEBUFFER, z.__webglFramebuffer[ye]), z.__webglDepthbuffer[ye] === void 0) z.__webglDepthbuffer[ye] = r.createRenderbuffer(), ce(z.__webglDepthbuffer[ye], k, !1);
                else {
                    const ge = k.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                        Re = z.__webglDepthbuffer[ye];
                    r.bindRenderbuffer(r.RENDERBUFFER, Re), r.framebufferRenderbuffer(r.FRAMEBUFFER, ge, r.RENDERBUFFER, Re)
                }
        } else if (t.bindFramebuffer(r.FRAMEBUFFER, z.__webglFramebuffer), z.__webglDepthbuffer === void 0) z.__webglDepthbuffer = r.createRenderbuffer(), ce(z.__webglDepthbuffer, k, !1);
        else {
            const ye = k.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                ge = z.__webglDepthbuffer;
            r.bindRenderbuffer(r.RENDERBUFFER, ge), r.framebufferRenderbuffer(r.FRAMEBUFFER, ye, r.RENDERBUFFER, ge)
        }
        t.bindFramebuffer(r.FRAMEBUFFER, null)
    }

    function ke(k, z, ue) {
        const ye = n.get(k);
        z !== void 0 && me(ye.__webglFramebuffer, k, k.texture, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, 0), ue !== void 0 && Oe(k)
    }

    function Ee(k) {
        const z = k.texture,
            ue = n.get(k),
            ye = n.get(z);
        k.addEventListener("dispose", R);
        const ge = k.textures,
            Re = k.isWebGLCubeRenderTarget === !0,
            Be = ge.length > 1;
        if (Be || (ye.__webglTexture === void 0 && (ye.__webglTexture = r.createTexture()), ye.__version = z.version, o.memory.textures++), Re) {
            ue.__webglFramebuffer = [];
            for (let Fe = 0; Fe < 6; Fe++)
                if (z.mipmaps && z.mipmaps.length > 0) {
                    ue.__webglFramebuffer[Fe] = [];
                    for (let Ne = 0; Ne < z.mipmaps.length; Ne++) ue.__webglFramebuffer[Fe][Ne] = r.createFramebuffer()
                } else ue.__webglFramebuffer[Fe] = r.createFramebuffer()
        } else {
            if (z.mipmaps && z.mipmaps.length > 0) {
                ue.__webglFramebuffer = [];
                for (let Fe = 0; Fe < z.mipmaps.length; Fe++) ue.__webglFramebuffer[Fe] = r.createFramebuffer()
            } else ue.__webglFramebuffer = r.createFramebuffer();
            if (Be)
                for (let Fe = 0, Ne = ge.length; Fe < Ne; Fe++) {
                    const ot = n.get(ge[Fe]);
                    ot.__webglTexture === void 0 && (ot.__webglTexture = r.createTexture(), o.memory.textures++)
                }
            if (k.samples > 0 && se(k) === !1) {
                ue.__webglMultisampledFramebuffer = r.createFramebuffer(), ue.__webglColorRenderbuffer = [], t.bindFramebuffer(r.FRAMEBUFFER, ue.__webglMultisampledFramebuffer);
                for (let Fe = 0; Fe < ge.length; Fe++) {
                    const Ne = ge[Fe];
                    ue.__webglColorRenderbuffer[Fe] = r.createRenderbuffer(), r.bindRenderbuffer(r.RENDERBUFFER, ue.__webglColorRenderbuffer[Fe]);
                    const ot = s.convert(Ne.format, Ne.colorSpace),
                        je = s.convert(Ne.type),
                        Ze = S(Ne.internalFormat, ot, je, Ne.colorSpace, k.isXRRenderTarget === !0),
                        it = Ce(k);
                    r.renderbufferStorageMultisample(r.RENDERBUFFER, it, Ze, k.width, k.height), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Fe, r.RENDERBUFFER, ue.__webglColorRenderbuffer[Fe])
                }
                r.bindRenderbuffer(r.RENDERBUFFER, null), k.depthBuffer && (ue.__webglDepthRenderbuffer = r.createRenderbuffer(), ce(ue.__webglDepthRenderbuffer, k, !0)), t.bindFramebuffer(r.FRAMEBUFFER, null)
            }
        }
        if (Re) {
            t.bindTexture(r.TEXTURE_CUBE_MAP, ye.__webglTexture), te(r.TEXTURE_CUBE_MAP, z);
            for (let Fe = 0; Fe < 6; Fe++)
                if (z.mipmaps && z.mipmaps.length > 0)
                    for (let Ne = 0; Ne < z.mipmaps.length; Ne++) me(ue.__webglFramebuffer[Fe][Ne], k, z, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, Ne);
                else me(ue.__webglFramebuffer[Fe], k, z, r.COLOR_ATTACHMENT0, r.TEXTURE_CUBE_MAP_POSITIVE_X + Fe, 0);
            v(z) && _(r.TEXTURE_CUBE_MAP), t.unbindTexture()
        } else if (Be) {
            for (let Fe = 0, Ne = ge.length; Fe < Ne; Fe++) {
                const ot = ge[Fe],
                    je = n.get(ot);
                t.bindTexture(r.TEXTURE_2D, je.__webglTexture), te(r.TEXTURE_2D, ot), me(ue.__webglFramebuffer, k, ot, r.COLOR_ATTACHMENT0 + Fe, r.TEXTURE_2D, 0), v(ot) && _(r.TEXTURE_2D)
            }
            t.unbindTexture()
        } else {
            let Fe = r.TEXTURE_2D;
            if ((k.isWebGL3DRenderTarget || k.isWebGLArrayRenderTarget) && (Fe = k.isWebGL3DRenderTarget ? r.TEXTURE_3D : r.TEXTURE_2D_ARRAY), t.bindTexture(Fe, ye.__webglTexture), te(Fe, z), z.mipmaps && z.mipmaps.length > 0)
                for (let Ne = 0; Ne < z.mipmaps.length; Ne++) me(ue.__webglFramebuffer[Ne], k, z, r.COLOR_ATTACHMENT0, Fe, Ne);
            else me(ue.__webglFramebuffer, k, z, r.COLOR_ATTACHMENT0, Fe, 0);
            v(z) && _(Fe), t.unbindTexture()
        }
        k.depthBuffer && Oe(k)
    }

    function pe(k) {
        const z = k.textures;
        for (let ue = 0, ye = z.length; ue < ye; ue++) {
            const ge = z[ue];
            if (v(ge)) {
                const Re = A(k),
                    Be = n.get(ge).__webglTexture;
                t.bindTexture(Re, Be), _(Re), t.unbindTexture()
            }
        }
    }
    const xe = [],
        J = [];

    function De(k) {
        if (k.samples > 0) {
            if (se(k) === !1) {
                const z = k.textures,
                    ue = k.width,
                    ye = k.height;
                let ge = r.COLOR_BUFFER_BIT;
                const Re = k.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT,
                    Be = n.get(k),
                    Fe = z.length > 1;
                if (Fe)
                    for (let Ne = 0; Ne < z.length; Ne++) t.bindFramebuffer(r.FRAMEBUFFER, Be.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Ne, r.RENDERBUFFER, null), t.bindFramebuffer(r.FRAMEBUFFER, Be.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Ne, r.TEXTURE_2D, null, 0);
                t.bindFramebuffer(r.READ_FRAMEBUFFER, Be.__webglMultisampledFramebuffer), t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Be.__webglFramebuffer);
                for (let Ne = 0; Ne < z.length; Ne++) {
                    if (k.resolveDepthBuffer && (k.depthBuffer && (ge |= r.DEPTH_BUFFER_BIT), k.stencilBuffer && k.resolveStencilBuffer && (ge |= r.STENCIL_BUFFER_BIT)), Fe) {
                        r.framebufferRenderbuffer(r.READ_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.RENDERBUFFER, Be.__webglColorRenderbuffer[Ne]);
                        const ot = n.get(z[Ne]).__webglTexture;
                        r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0, r.TEXTURE_2D, ot, 0)
                    }
                    r.blitFramebuffer(0, 0, ue, ye, 0, 0, ue, ye, ge, r.NEAREST), l === !0 && (xe.length = 0, J.length = 0, xe.push(r.COLOR_ATTACHMENT0 + Ne), k.depthBuffer && k.resolveDepthBuffer === !1 && (xe.push(Re), J.push(Re), r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, J)), r.invalidateFramebuffer(r.READ_FRAMEBUFFER, xe))
                }
                if (t.bindFramebuffer(r.READ_FRAMEBUFFER, null), t.bindFramebuffer(r.DRAW_FRAMEBUFFER, null), Fe)
                    for (let Ne = 0; Ne < z.length; Ne++) {
                        t.bindFramebuffer(r.FRAMEBUFFER, Be.__webglMultisampledFramebuffer), r.framebufferRenderbuffer(r.FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Ne, r.RENDERBUFFER, Be.__webglColorRenderbuffer[Ne]);
                        const ot = n.get(z[Ne]).__webglTexture;
                        t.bindFramebuffer(r.FRAMEBUFFER, Be.__webglFramebuffer), r.framebufferTexture2D(r.DRAW_FRAMEBUFFER, r.COLOR_ATTACHMENT0 + Ne, r.TEXTURE_2D, ot, 0)
                    }
                t.bindFramebuffer(r.DRAW_FRAMEBUFFER, Be.__webglMultisampledFramebuffer)
            } else if (k.depthBuffer && k.resolveDepthBuffer === !1 && l) {
                const z = k.stencilBuffer ? r.DEPTH_STENCIL_ATTACHMENT : r.DEPTH_ATTACHMENT;
                r.invalidateFramebuffer(r.DRAW_FRAMEBUFFER, [z])
            }
        }
    }

    function Ce(k) {
        return Math.min(i.maxSamples, k.samples)
    }

    function se(k) {
        const z = n.get(k);
        return k.samples > 0 && e.has("WEBGL_multisampled_render_to_texture") === !0 && z.__useRenderToTexture !== !1
    }

    function Se(k) {
        const z = o.render.frame;
        u.get(k) !== z && (u.set(k, z), k.update())
    }

    function Xe(k, z) {
        const ue = k.colorSpace,
            ye = k.format,
            ge = k.type;
        return k.isCompressedTexture === !0 || k.isVideoTexture === !0 || ue !== Qs && ue !== uo && (xn.getTransfer(ue) === Ln ? (ye !== kn || ge !== Yi) && console.warn("THREE.WebGLTextures: sRGB encoded textures have to use RGBAFormat and UnsignedByteType.") : console.error("THREE.WebGLTextures: Unsupported texture color space:", ue)), z
    }

    function Le(k) {
        return typeof HTMLImageElement < "u" && k instanceof HTMLImageElement ? (c.width = k.naturalWidth || k.width, c.height = k.naturalHeight || k.height) : typeof VideoFrame < "u" && k instanceof VideoFrame ? (c.width = k.displayWidth, c.height = k.displayHeight) : (c.width = k.width, c.height = k.height), c
    }
    this.allocateTextureUnit = V, this.resetTextureUnits = D, this.setTexture2D = q, this.setTexture2DArray = X, this.setTexture3D = oe, this.setTextureCube = Y, this.rebindTextures = ke, this.setupRenderTarget = Ee, this.updateRenderTargetMipmap = pe, this.updateMultisampleRenderTarget = De, this.setupDepthRenderbuffer = Oe, this.setupFrameBufferTexture = me, this.useMultisampledRTT = se
}

function xB(r, e) {
    function t(n, i = uo) {
        let s;
        const o = xn.getTransfer(i);
        if (n === Yi) return r.UNSIGNED_BYTE;
        if (n === ly) return r.UNSIGNED_SHORT_4_4_4_4;
        if (n === cy) return r.UNSIGNED_SHORT_5_5_5_1;
        if (n === BS) return r.UNSIGNED_INT_5_9_9_9_REV;
        if (n === oy) return r.BYTE;
        if (n === ay) return r.SHORT;
        if (n === Kf) return r.UNSIGNED_SHORT;
        if (n === Gp) return r.INT;
        if (n === fo) return r.UNSIGNED_INT;
        if (n === Bn) return r.FLOAT;
        if (n === Ri) return r.HALF_FLOAT;
        if (n === DS) return r.ALPHA;
        if (n === LS) return r.RGB;
        if (n === kn) return r.RGBA;
        if (n === FS) return r.LUMINANCE;
        if (n === US) return r.LUMINANCE_ALPHA;
        if (n === Yc) return r.DEPTH_COMPONENT;
        if (n === wl) return r.DEPTH_STENCIL;
        if (n === Hp) return r.RED;
        if (n === Vp) return r.RED_INTEGER;
        if (n === OS) return r.RG;
        if (n === uy) return r.RG_INTEGER;
        if (n === fy) return r.RGBA_INTEGER;
        if (n === Gd || n === Hd || n === Vd || n === Wd)
            if (o === Ln)
                if (s = e.get("WEBGL_compressed_texture_s3tc_srgb"), s !== null) {
                    if (n === Gd) return s.COMPRESSED_SRGB_S3TC_DXT1_EXT;
                    if (n === Hd) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
                    if (n === Vd) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT;
                    if (n === Wd) return s.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT
                } else return null;
        else if (s = e.get("WEBGL_compressed_texture_s3tc"), s !== null) {
            if (n === Gd) return s.COMPRESSED_RGB_S3TC_DXT1_EXT;
            if (n === Hd) return s.COMPRESSED_RGBA_S3TC_DXT1_EXT;
            if (n === Vd) return s.COMPRESSED_RGBA_S3TC_DXT3_EXT;
            if (n === Wd) return s.COMPRESSED_RGBA_S3TC_DXT5_EXT
        } else return null;
        if (n === sv || n === ov || n === av || n === lv)
            if (s = e.get("WEBGL_compressed_texture_pvrtc"), s !== null) {
                if (n === sv) return s.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
                if (n === ov) return s.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
                if (n === av) return s.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
                if (n === lv) return s.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG
            } else return null;
        if (n === cv || n === uv || n === fv)
            if (s = e.get("WEBGL_compressed_texture_etc"), s !== null) {
                if (n === cv || n === uv) return o === Ln ? s.COMPRESSED_SRGB8_ETC2 : s.COMPRESSED_RGB8_ETC2;
                if (n === fv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC : s.COMPRESSED_RGBA8_ETC2_EAC
            } else return null;
        if (n === hv || n === dv || n === pv || n === mv || n === gv || n === vv || n === yv || n === _v || n === xv || n === Av || n === Sv || n === Mv || n === wv || n === bv)
            if (s = e.get("WEBGL_compressed_texture_astc"), s !== null) {
                if (n === hv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR : s.COMPRESSED_RGBA_ASTC_4x4_KHR;
                if (n === dv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x4_KHR : s.COMPRESSED_RGBA_ASTC_5x4_KHR;
                if (n === pv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_5x5_KHR : s.COMPRESSED_RGBA_ASTC_5x5_KHR;
                if (n === mv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x5_KHR : s.COMPRESSED_RGBA_ASTC_6x5_KHR;
                if (n === gv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_6x6_KHR : s.COMPRESSED_RGBA_ASTC_6x6_KHR;
                if (n === vv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x5_KHR : s.COMPRESSED_RGBA_ASTC_8x5_KHR;
                if (n === yv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x6_KHR : s.COMPRESSED_RGBA_ASTC_8x6_KHR;
                if (n === _v) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_8x8_KHR : s.COMPRESSED_RGBA_ASTC_8x8_KHR;
                if (n === xv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x5_KHR : s.COMPRESSED_RGBA_ASTC_10x5_KHR;
                if (n === Av) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x6_KHR : s.COMPRESSED_RGBA_ASTC_10x6_KHR;
                if (n === Sv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x8_KHR : s.COMPRESSED_RGBA_ASTC_10x8_KHR;
                if (n === Mv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_10x10_KHR : s.COMPRESSED_RGBA_ASTC_10x10_KHR;
                if (n === wv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x10_KHR : s.COMPRESSED_RGBA_ASTC_12x10_KHR;
                if (n === bv) return o === Ln ? s.COMPRESSED_SRGB8_ALPHA8_ASTC_12x12_KHR : s.COMPRESSED_RGBA_ASTC_12x12_KHR
            } else return null;
        if (n === jd || n === Tv || n === Ev)
            if (s = e.get("EXT_texture_compression_bptc"), s !== null) {
                if (n === jd) return o === Ln ? s.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT : s.COMPRESSED_RGBA_BPTC_UNORM_EXT;
                if (n === Tv) return s.COMPRESSED_RGB_BPTC_SIGNED_FLOAT_EXT;
                if (n === Ev) return s.COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT_EXT
            } else return null;
        if (n === NS || n === Cv || n === Rv || n === Pv)
            if (s = e.get("EXT_texture_compression_rgtc"), s !== null) {
                if (n === jd) return s.COMPRESSED_RED_RGTC1_EXT;
                if (n === Cv) return s.COMPRESSED_SIGNED_RED_RGTC1_EXT;
                if (n === Rv) return s.COMPRESSED_RED_GREEN_RGTC2_EXT;
                if (n === Pv) return s.COMPRESSED_SIGNED_RED_GREEN_RGTC2_EXT
            } else return null;
        return n === Ml ? r.UNSIGNED_INT_24_8 : r[n] !== void 0 ? r[n] : null
    }
    return {
        convert: t
    }
}
class AB extends ri {
    constructor(e = []) {
        super(), this.isArrayCamera = !0, this.cameras = e
    }
}
class da extends vn {
    constructor() {
        super(), this.isGroup = !0, this.type = "Group"
    }
}
const u5 = {
    type: "move"
};
class Ix {
    constructor() {
        this._targetRay = null, this._grip = null, this._hand = null
    }
    getHandSpace() {
        return this._hand === null && (this._hand = new da, this._hand.matrixAutoUpdate = !1, this._hand.visible = !1, this._hand.joints = {}, this._hand.inputState = {
            pinching: !1
        }), this._hand
    }
    getTargetRaySpace() {
        return this._targetRay === null && (this._targetRay = new da, this._targetRay.matrixAutoUpdate = !1, this._targetRay.visible = !1, this._targetRay.hasLinearVelocity = !1, this._targetRay.linearVelocity = new K, this._targetRay.hasAngularVelocity = !1, this._targetRay.angularVelocity = new K), this._targetRay
    }
    getGripSpace() {
        return this._grip === null && (this._grip = new da, this._grip.matrixAutoUpdate = !1, this._grip.visible = !1, this._grip.hasLinearVelocity = !1, this._grip.linearVelocity = new K, this._grip.hasAngularVelocity = !1, this._grip.angularVelocity = new K), this._grip
    }
    dispatchEvent(e) {
        return this._targetRay !== null && this._targetRay.dispatchEvent(e), this._grip !== null && this._grip.dispatchEvent(e), this._hand !== null && this._hand.dispatchEvent(e), this
    }
    connect(e) {
        if (e && e.hand) {
            const t = this._hand;
            if (t)
                for (const n of e.hand.values()) this._getHandJoint(t, n)
        }
        return this.dispatchEvent({
            type: "connected",
            data: e
        }), this
    }
    disconnect(e) {
        return this.dispatchEvent({
            type: "disconnected",
            data: e
        }), this._targetRay !== null && (this._targetRay.visible = !1), this._grip !== null && (this._grip.visible = !1), this._hand !== null && (this._hand.visible = !1), this
    }
    update(e, t, n) {
        let i = null,
            s = null,
            o = null;
        const a = this._targetRay,
            l = this._grip,
            c = this._hand;
        if (e && t.session.visibilityState !== "visible-blurred") {
            if (c && e.hand) {
                o = !0;
                for (const y of e.hand.values()) {
                    const v = t.getJointPose(y, n),
                        _ = this._getHandJoint(c, y);
                    v !== null && (_.matrix.fromArray(v.transform.matrix), _.matrix.decompose(_.position, _.rotation, _.scale), _.matrixWorldNeedsUpdate = !0, _.jointRadius = v.radius), _.visible = v !== null
                }
                const u = c.joints["index-finger-tip"],
                    f = c.joints["thumb-tip"],
                    d = u.position.distanceTo(f.position),
                    m = .02,
                    g = .005;
                c.inputState.pinching && d > m + g ? (c.inputState.pinching = !1, this.dispatchEvent({
                    type: "pinchend",
                    handedness: e.handedness,
                    target: this
                })) : !c.inputState.pinching && d <= m - g && (c.inputState.pinching = !0, this.dispatchEvent({
                    type: "pinchstart",
                    handedness: e.handedness,
                    target: this
                }))
            } else l !== null && e.gripSpace && (s = t.getPose(e.gripSpace, n), s !== null && (l.matrix.fromArray(s.transform.matrix), l.matrix.decompose(l.position, l.rotation, l.scale), l.matrixWorldNeedsUpdate = !0, s.linearVelocity ? (l.hasLinearVelocity = !0, l.linearVelocity.copy(s.linearVelocity)) : l.hasLinearVelocity = !1, s.angularVelocity ? (l.hasAngularVelocity = !0, l.angularVelocity.copy(s.angularVelocity)) : l.hasAngularVelocity = !1));
            a !== null && (i = t.getPose(e.targetRaySpace, n), i === null && s !== null && (i = s), i !== null && (a.matrix.fromArray(i.transform.matrix), a.matrix.decompose(a.position, a.rotation, a.scale), a.matrixWorldNeedsUpdate = !0, i.linearVelocity ? (a.hasLinearVelocity = !0, a.linearVelocity.copy(i.linearVelocity)) : a.hasLinearVelocity = !1, i.angularVelocity ? (a.hasAngularVelocity = !0, a.angularVelocity.copy(i.angularVelocity)) : a.hasAngularVelocity = !1, this.dispatchEvent(u5)))
        }
        return a !== null && (a.visible = i !== null), l !== null && (l.visible = s !== null), c !== null && (c.visible = o !== null), this
    }
    _getHandJoint(e, t) {
        if (e.joints[t.jointName] === void 0) {
            const n = new da;
            n.matrixAutoUpdate = !1, n.visible = !1, e.joints[t.jointName] = n, e.add(n)
        }
        return e.joints[t.jointName]
    }
}
const f5 = `
void main() {

	gl_Position = vec4( position, 1.0 );

}`,
    h5 = `
uniform sampler2DArray depthColor;
uniform float depthWidth;
uniform float depthHeight;

void main() {

	vec2 coord = vec2( gl_FragCoord.x / depthWidth, gl_FragCoord.y / depthHeight );

	if ( coord.x >= 1.0 ) {

		gl_FragDepth = texture( depthColor, vec3( coord.x - 1.0, coord.y, 1 ) ).r;

	} else {

		gl_FragDepth = texture( depthColor, vec3( coord.x, coord.y, 0 ) ).r;

	}

}`;
class d5 {
    constructor() {
        this.texture = null, this.mesh = null, this.depthNear = 0, this.depthFar = 0
    }
    init(e, t, n) {
        if (this.texture === null) {
            const i = new gn,
                s = e.properties.get(i);
            s.__webglTexture = t.texture, (t.depthNear != n.depthNear || t.depthFar != n.depthFar) && (this.depthNear = t.depthNear, this.depthFar = t.depthFar), this.texture = i
        }
    }
    getMesh(e) {
        if (this.texture !== null && this.mesh === null) {
            const t = e.cameras[0].viewport,
                n = new Fn({
                    vertexShader: f5,
                    fragmentShader: h5,
                    uniforms: {
                        depthColor: {
                            value: this.texture
                        },
                        depthWidth: {
                            value: t.z
                        },
                        depthHeight: {
                            value: t.w
                        }
                    }
                });
            this.mesh = new Tn(new bs(20, 20), n)
        }
        return this.mesh
    }
    reset() {
        this.texture = null, this.mesh = null
    }
    getDepthTexture() {
        return this.texture
    }
}
class p5 extends ws {
    constructor(e, t) {
        super();
        const n = this;
        let i = null,
            s = 1,
            o = null,
            a = "local-floor",
            l = 1,
            c = null,
            u = null,
            f = null,
            d = null,
            m = null,
            g = null;
        const y = new d5,
            v = t.getContextAttributes();
        let _ = null,
            A = null;
        const S = [],
            M = [],
            C = new Ue;
        let E = null;
        const R = new ri;
        R.viewport = new An;
        const P = new ri;
        P.viewport = new An;
        const b = [R, P],
            T = new AB;
        let L = null,
            D = null;
        this.cameraAutoUpdate = !0, this.enabled = !1, this.isPresenting = !1, this.getController = function($) {
            let ne = S[$];
            return ne === void 0 && (ne = new Ix, S[$] = ne), ne.getTargetRaySpace()
        }, this.getControllerGrip = function($) {
            let ne = S[$];
            return ne === void 0 && (ne = new Ix, S[$] = ne), ne.getGripSpace()
        }, this.getHand = function($) {
            let ne = S[$];
            return ne === void 0 && (ne = new Ix, S[$] = ne), ne.getHandSpace()
        };

        function V($) {
            const ne = M.indexOf($.inputSource);
            if (ne === -1) return;
            const me = S[ne];
            me !== void 0 && (me.update($.inputSource, $.frame, c || o), me.dispatchEvent({
                type: $.type,
                data: $.inputSource
            }))
        }

        function H() {
            i.removeEventListener("select", V), i.removeEventListener("selectstart", V), i.removeEventListener("selectend", V), i.removeEventListener("squeeze", V), i.removeEventListener("squeezestart", V), i.removeEventListener("squeezeend", V), i.removeEventListener("end", H), i.removeEventListener("inputsourceschange", q);
            for (let $ = 0; $ < S.length; $++) {
                const ne = M[$];
                ne !== null && (M[$] = null, S[$].disconnect(ne))
            }
            L = null, D = null, y.reset(), e.setRenderTarget(_), m = null, d = null, f = null, i = null, A = null, he.stop(), n.isPresenting = !1, e.setPixelRatio(E), e.setSize(C.width, C.height, !1), n.dispatchEvent({
                type: "sessionend"
            })
        }
        this.setFramebufferScaleFactor = function($) {
            s = $, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change framebuffer scale while presenting.")
        }, this.setReferenceSpaceType = function($) {
            a = $, n.isPresenting === !0 && console.warn("THREE.WebXRManager: Cannot change reference space type while presenting.")
        }, this.getReferenceSpace = function() {
            return c || o
        }, this.setReferenceSpace = function($) {
            c = $
        }, this.getBaseLayer = function() {
            return d !== null ? d : m
        }, this.getBinding = function() {
            return f
        }, this.getFrame = function() {
            return g
        }, this.getSession = function() {
            return i
        }, this.setSession = async function($) {
            if (i = $, i !== null) {
                if (_ = e.getRenderTarget(), i.addEventListener("select", V), i.addEventListener("selectstart", V), i.addEventListener("selectend", V), i.addEventListener("squeeze", V), i.addEventListener("squeezestart", V), i.addEventListener("squeezeend", V), i.addEventListener("end", H), i.addEventListener("inputsourceschange", q), v.xrCompatible !== !0 && await t.makeXRCompatible(), E = e.getPixelRatio(), e.getSize(C), i.renderState.layers === void 0) {
                    const ne = {
                        antialias: v.antialias,
                        alpha: !0,
                        depth: v.depth,
                        stencil: v.stencil,
                        framebufferScaleFactor: s
                    };
                    m = new XRWebGLLayer(i, t, ne), i.updateRenderState({
                        baseLayer: m
                    }), e.setPixelRatio(1), e.setSize(m.framebufferWidth, m.framebufferHeight, !1), A = new Zn(m.framebufferWidth, m.framebufferHeight, {
                        format: kn,
                        type: Yi,
                        colorSpace: e.outputColorSpace,
                        stencilBuffer: v.stencil
                    })
                } else {
                    let ne = null,
                        me = null,
                        ce = null;
                    v.depth && (ce = v.stencil ? t.DEPTH24_STENCIL8 : t.DEPTH_COMPONENT24, ne = v.stencil ? wl : Yc, me = v.stencil ? Ml : fo);
                    const _e = {
                        colorFormat: t.RGBA8,
                        depthFormat: ce,
                        scaleFactor: s
                    };
                    f = new XRWebGLBinding(i, t), d = f.createProjectionLayer(_e), i.updateRenderState({
                        layers: [d]
                    }), e.setPixelRatio(1), e.setSize(d.textureWidth, d.textureHeight, !1), A = new Zn(d.textureWidth, d.textureHeight, {
                        format: kn,
                        type: Yi,
                        depthTexture: new Yp(d.textureWidth, d.textureHeight, me, void 0, void 0, void 0, void 0, void 0, void 0, ne),
                        stencilBuffer: v.stencil,
                        colorSpace: e.outputColorSpace,
                        samples: v.antialias ? 4 : 0,
                        resolveDepthBuffer: d.ignoreDepthValues === !1
                    })
                }
                A.isXRRenderTarget = !0, this.setFoveation(l), c = null, o = await i.requestReferenceSpace(a), he.setContext(i), he.start(), n.isPresenting = !0, n.dispatchEvent({
                    type: "sessionstart"
                })
            }
        }, this.getEnvironmentBlendMode = function() {
            if (i !== null) return i.environmentBlendMode
        }, this.getDepthTexture = function() {
            return y.getDepthTexture()
        };

        function q($) {
            for (let ne = 0; ne < $.removed.length; ne++) {
                const me = $.removed[ne],
                    ce = M.indexOf(me);
                ce >= 0 && (M[ce] = null, S[ce].disconnect(me))
            }
            for (let ne = 0; ne < $.added.length; ne++) {
                const me = $.added[ne];
                let ce = M.indexOf(me);
                if (ce === -1) {
                    for (let Oe = 0; Oe < S.length; Oe++)
                        if (Oe >= M.length) {
                            M.push(me), ce = Oe;
                            break
                        } else if (M[Oe] === null) {
                        M[Oe] = me, ce = Oe;
                        break
                    }
                    if (ce === -1) break
                }
                const _e = S[ce];
                _e && _e.connect(me)
            }
        }
        const X = new K,
            oe = new K;

        function Y($, ne, me) {
            X.setFromMatrixPosition(ne.matrixWorld), oe.setFromMatrixPosition(me.matrixWorld);
            const ce = X.distanceTo(oe),
                _e = ne.projectionMatrix.elements,
                Oe = me.projectionMatrix.elements,
                ke = _e[14] / (_e[10] - 1),
                Ee = _e[14] / (_e[10] + 1),
                pe = (_e[9] + 1) / _e[5],
                xe = (_e[9] - 1) / _e[5],
                J = (_e[8] - 1) / _e[0],
                De = (Oe[8] + 1) / Oe[0],
                Ce = ke * J,
                se = ke * De,
                Se = ce / (-J + De),
                Xe = Se * -J;
            if (ne.matrixWorld.decompose($.position, $.quaternion, $.scale), $.translateX(Xe), $.translateZ(Se), $.matrixWorld.compose($.position, $.quaternion, $.scale), $.matrixWorldInverse.copy($.matrixWorld).invert(), _e[10] === -1) $.projectionMatrix.copy(ne.projectionMatrix), $.projectionMatrixInverse.copy(ne.projectionMatrixInverse);
            else {
                const Le = ke + Se,
                    k = Ee + Se,
                    z = Ce - Xe,
                    ue = se + (ce - Xe),
                    ye = pe * Ee / k * Le,
                    ge = xe * Ee / k * Le;
                $.projectionMatrix.makePerspective(z, ue, ye, ge, Le, k), $.projectionMatrixInverse.copy($.projectionMatrix).invert()
            }
        }

        function Z($, ne) {
            ne === null ? $.matrixWorld.copy($.matrix) : $.matrixWorld.multiplyMatrices(ne.matrixWorld, $.matrix), $.matrixWorldInverse.copy($.matrixWorld).invert()
        }
        this.updateCamera = function($) {
            if (i === null) return;
            let ne = $.near,
                me = $.far;
            y.texture !== null && (y.depthNear > 0 && (ne = y.depthNear), y.depthFar > 0 && (me = y.depthFar)), T.near = P.near = R.near = ne, T.far = P.far = R.far = me, (L !== T.near || D !== T.far) && (i.updateRenderState({
                depthNear: T.near,
                depthFar: T.far
            }), L = T.near, D = T.far), R.layers.mask = $.layers.mask | 2, P.layers.mask = $.layers.mask | 4, T.layers.mask = R.layers.mask | P.layers.mask;
            const ce = $.parent,
                _e = T.cameras;
            Z(T, ce);
            for (let Oe = 0; Oe < _e.length; Oe++) Z(_e[Oe], ce);
            _e.length === 2 ? Y(T, R, P) : T.projectionMatrix.copy(R.projectionMatrix), U($, T, ce)
        };

        function U($, ne, me) {
            me === null ? $.matrix.copy(ne.matrixWorld) : ($.matrix.copy(me.matrixWorld), $.matrix.invert(), $.matrix.multiply(ne.matrixWorld)), $.matrix.decompose($.position, $.quaternion, $.scale), $.updateMatrixWorld(!0), $.projectionMatrix.copy(ne.projectionMatrix), $.projectionMatrixInverse.copy(ne.projectionMatrixInverse), $.isPerspectiveCamera && ($.fov = Qf * 2 * Math.atan(1 / $.projectionMatrix.elements[5]), $.zoom = 1)
        }
        this.getCamera = function() {
            return T
        }, this.getFoveation = function() {
            if (!(d === null && m === null)) return l
        }, this.setFoveation = function($) {
            l = $, d !== null && (d.fixedFoveation = $), m !== null && m.fixedFoveation !== void 0 && (m.fixedFoveation = $)
        }, this.hasDepthSensing = function() {
            return y.texture !== null
        }, this.getDepthSensingMesh = function() {
            return y.getMesh(T)
        };
        let j = null;

        function te($, ne) {
            if (u = ne.getViewerPose(c || o), g = ne, u !== null) {
                const me = u.views;
                m !== null && (e.setRenderTargetFramebuffer(A, m.framebuffer), e.setRenderTarget(A));
                let ce = !1;
                me.length !== T.cameras.length && (T.cameras.length = 0, ce = !0);
                for (let Oe = 0; Oe < me.length; Oe++) {
                    const ke = me[Oe];
                    let Ee = null;
                    if (m !== null) Ee = m.getViewport(ke);
                    else {
                        const xe = f.getViewSubImage(d, ke);
                        Ee = xe.viewport, Oe === 0 && (e.setRenderTargetTextures(A, xe.colorTexture, d.ignoreDepthValues ? void 0 : xe.depthStencilTexture), e.setRenderTarget(A))
                    }
                    let pe = b[Oe];
                    pe === void 0 && (pe = new ri, pe.layers.enable(Oe), pe.viewport = new An, b[Oe] = pe), pe.matrix.fromArray(ke.transform.matrix), pe.matrix.decompose(pe.position, pe.quaternion, pe.scale), pe.projectionMatrix.fromArray(ke.projectionMatrix), pe.projectionMatrixInverse.copy(pe.projectionMatrix).invert(), pe.viewport.set(Ee.x, Ee.y, Ee.width, Ee.height), Oe === 0 && (T.matrix.copy(pe.matrix), T.matrix.decompose(T.position, T.quaternion, T.scale)), ce === !0 && T.cameras.push(pe)
                }
                const _e = i.enabledFeatures;
                if (_e && _e.includes("depth-sensing")) {
                    const Oe = f.getDepthInformation(me[0]);
                    Oe && Oe.isValid && Oe.texture && y.init(e, Oe, i.renderState)
                }
            }
            for (let me = 0; me < S.length; me++) {
                const ce = M[me],
                    _e = S[me];
                ce !== null && _e !== void 0 && _e.update(ce, ne, c || o)
            }
            j && j($, ne), ne.detectedPlanes && n.dispatchEvent({
                type: "planesdetected",
                data: ne
            }), g = null
        }
        const he = new mB;
        he.setAnimationLoop(te), this.setAnimationLoop = function($) {
            j = $
        }, this.dispose = function() {}
    }
}
const lc = new As,
    m5 = new Ot;

function g5(r, e) {
    function t(v, _) {
        v.matrixAutoUpdate === !0 && v.updateMatrix(), _.value.copy(v.matrix)
    }

    function n(v, _) {
        _.color.getRGB(v.fogColor.value, pB(r)), _.isFog ? (v.fogNear.value = _.near, v.fogFar.value = _.far) : _.isFogExp2 && (v.fogDensity.value = _.density)
    }

    function i(v, _, A, S, M) {
        _.isMeshBasicMaterial || _.isMeshLambertMaterial ? s(v, _) : _.isMeshToonMaterial ? (s(v, _), f(v, _)) : _.isMeshPhongMaterial ? (s(v, _), u(v, _)) : _.isMeshStandardMaterial ? (s(v, _), d(v, _), _.isMeshPhysicalMaterial && m(v, _, M)) : _.isMeshMatcapMaterial ? (s(v, _), g(v, _)) : _.isMeshDepthMaterial ? s(v, _) : _.isMeshDistanceMaterial ? (s(v, _), y(v, _)) : _.isMeshNormalMaterial ? s(v, _) : _.isLineBasicMaterial ? (o(v, _), _.isLineDashedMaterial && a(v, _)) : _.isPointsMaterial ? l(v, _, A, S) : _.isSpriteMaterial ? c(v, _) : _.isShadowMaterial ? (v.color.value.copy(_.color), v.opacity.value = _.opacity) : _.isShaderMaterial && (_.uniformsNeedUpdate = !1)
    }

    function s(v, _) {
        v.opacity.value = _.opacity, _.color && v.diffuse.value.copy(_.color), _.emissive && v.emissive.value.copy(_.emissive).multiplyScalar(_.emissiveIntensity), _.map && (v.map.value = _.map, t(_.map, v.mapTransform)), _.alphaMap && (v.alphaMap.value = _.alphaMap, t(_.alphaMap, v.alphaMapTransform)), _.bumpMap && (v.bumpMap.value = _.bumpMap, t(_.bumpMap, v.bumpMapTransform), v.bumpScale.value = _.bumpScale, _.side === di && (v.bumpScale.value *= -1)), _.normalMap && (v.normalMap.value = _.normalMap, t(_.normalMap, v.normalMapTransform), v.normalScale.value.copy(_.normalScale), _.side === di && v.normalScale.value.negate()), _.displacementMap && (v.displacementMap.value = _.displacementMap, t(_.displacementMap, v.displacementMapTransform), v.displacementScale.value = _.displacementScale, v.displacementBias.value = _.displacementBias), _.emissiveMap && (v.emissiveMap.value = _.emissiveMap, t(_.emissiveMap, v.emissiveMapTransform)), _.specularMap && (v.specularMap.value = _.specularMap, t(_.specularMap, v.specularMapTransform)), _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest);
        const A = e.get(_),
            S = A.envMap,
            M = A.envMapRotation;
        S && (v.envMap.value = S, lc.copy(M), lc.x *= -1, lc.y *= -1, lc.z *= -1, S.isCubeTexture && S.isRenderTargetTexture === !1 && (lc.y *= -1, lc.z *= -1), v.envMapRotation.value.setFromMatrix4(m5.makeRotationFromEuler(lc)), v.flipEnvMap.value = S.isCubeTexture && S.isRenderTargetTexture === !1 ? -1 : 1, v.reflectivity.value = _.reflectivity, v.ior.value = _.ior, v.refractionRatio.value = _.refractionRatio), _.lightMap && (v.lightMap.value = _.lightMap, v.lightMapIntensity.value = _.lightMapIntensity, t(_.lightMap, v.lightMapTransform)), _.aoMap && (v.aoMap.value = _.aoMap, v.aoMapIntensity.value = _.aoMapIntensity, t(_.aoMap, v.aoMapTransform))
    }

    function o(v, _) {
        v.diffuse.value.copy(_.color), v.opacity.value = _.opacity, _.map && (v.map.value = _.map, t(_.map, v.mapTransform))
    }

    function a(v, _) {
        v.dashSize.value = _.dashSize, v.totalSize.value = _.dashSize + _.gapSize, v.scale.value = _.scale
    }

    function l(v, _, A, S) {
        v.diffuse.value.copy(_.color), v.opacity.value = _.opacity, v.size.value = _.size * A, v.scale.value = S * .5, _.map && (v.map.value = _.map, t(_.map, v.uvTransform)), _.alphaMap && (v.alphaMap.value = _.alphaMap, t(_.alphaMap, v.alphaMapTransform)), _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest)
    }

    function c(v, _) {
        v.diffuse.value.copy(_.color), v.opacity.value = _.opacity, v.rotation.value = _.rotation, _.map && (v.map.value = _.map, t(_.map, v.mapTransform)), _.alphaMap && (v.alphaMap.value = _.alphaMap, t(_.alphaMap, v.alphaMapTransform)), _.alphaTest > 0 && (v.alphaTest.value = _.alphaTest)
    }

    function u(v, _) {
        v.specular.value.copy(_.specular), v.shininess.value = Math.max(_.shininess, 1e-4)
    }

    function f(v, _) {
        _.gradientMap && (v.gradientMap.value = _.gradientMap)
    }

    function d(v, _) {
        v.metalness.value = _.metalness, _.metalnessMap && (v.metalnessMap.value = _.metalnessMap, t(_.metalnessMap, v.metalnessMapTransform)), v.roughness.value = _.roughness, _.roughnessMap && (v.roughnessMap.value = _.roughnessMap, t(_.roughnessMap, v.roughnessMapTransform)), _.envMap && (v.envMapIntensity.value = _.envMapIntensity)
    }

    function m(v, _, A) {
        v.ior.value = _.ior, _.sheen > 0 && (v.sheenColor.value.copy(_.sheenColor).multiplyScalar(_.sheen), v.sheenRoughness.value = _.sheenRoughness, _.sheenColorMap && (v.sheenColorMap.value = _.sheenColorMap, t(_.sheenColorMap, v.sheenColorMapTransform)), _.sheenRoughnessMap && (v.sheenRoughnessMap.value = _.sheenRoughnessMap, t(_.sheenRoughnessMap, v.sheenRoughnessMapTransform))), _.clearcoat > 0 && (v.clearcoat.value = _.clearcoat, v.clearcoatRoughness.value = _.clearcoatRoughness, _.clearcoatMap && (v.clearcoatMap.value = _.clearcoatMap, t(_.clearcoatMap, v.clearcoatMapTransform)), _.clearcoatRoughnessMap && (v.clearcoatRoughnessMap.value = _.clearcoatRoughnessMap, t(_.clearcoatRoughnessMap, v.clearcoatRoughnessMapTransform)), _.clearcoatNormalMap && (v.clearcoatNormalMap.value = _.clearcoatNormalMap, t(_.clearcoatNormalMap, v.clearcoatNormalMapTransform), v.clearcoatNormalScale.value.copy(_.clearcoatNormalScale), _.side === di && v.clearcoatNormalScale.value.negate())), _.dispersion > 0 && (v.dispersion.value = _.dispersion), _.iridescence > 0 && (v.iridescence.value = _.iridescence, v.iridescenceIOR.value = _.iridescenceIOR, v.iridescenceThicknessMinimum.value = _.iridescenceThicknessRange[0], v.iridescenceThicknessMaximum.value = _.iridescenceThicknessRange[1], _.iridescenceMap && (v.iridescenceMap.value = _.iridescenceMap, t(_.iridescenceMap, v.iridescenceMapTransform)), _.iridescenceThicknessMap && (v.iridescenceThicknessMap.value = _.iridescenceThicknessMap, t(_.iridescenceThicknessMap, v.iridescenceThicknessMapTransform))), _.transmission > 0 && (v.transmission.value = _.transmission, v.transmissionSamplerMap.value = A.texture, v.transmissionSamplerSize.value.set(A.width, A.height), _.transmissionMap && (v.transmissionMap.value = _.transmissionMap, t(_.transmissionMap, v.transmissionMapTransform)), v.thickness.value = _.thickness, _.thicknessMap && (v.thicknessMap.value = _.thicknessMap, t(_.thicknessMap, v.thicknessMapTransform)), v.attenuationDistance.value = _.attenuationDistance, v.attenuationColor.value.copy(_.attenuationColor)), _.anisotropy > 0 && (v.anisotropyVector.value.set(_.anisotropy * Math.cos(_.anisotropyRotation), _.anisotropy * Math.sin(_.anisotropyRotation)), _.anisotropyMap && (v.anisotropyMap.value = _.anisotropyMap, t(_.anisotropyMap, v.anisotropyMapTransform))), v.specularIntensity.value = _.specularIntensity, v.specularColor.value.copy(_.specularColor), _.specularColorMap && (v.specularColorMap.value = _.specularColorMap, t(_.specularColorMap, v.specularColorMapTransform)), _.specularIntensityMap && (v.specularIntensityMap.value = _.specularIntensityMap, t(_.specularIntensityMap, v.specularIntensityMapTransform))
    }

    function g(v, _) {
        _.matcap && (v.matcap.value = _.matcap)
    }

    function y(v, _) {
        const A = e.get(_).light;
        v.referencePosition.value.setFromMatrixPosition(A.matrixWorld), v.nearDistance.value = A.shadow.camera.near, v.farDistance.value = A.shadow.camera.far
    }
    return {
        refreshFogUniforms: n,
        refreshMaterialUniforms: i
    }
}

function v5(r, e, t, n) {
    let i = {},
        s = {},
        o = [];
    const a = r.getParameter(r.MAX_UNIFORM_BUFFER_BINDINGS);

    function l(A, S) {
        const M = S.program;
        n.uniformBlockBinding(A, M)
    }

    function c(A, S) {
        let M = i[A.id];
        M === void 0 && (g(A), M = u(A), i[A.id] = M, A.addEventListener("dispose", v));
        const C = S.program;
        n.updateUBOMapping(A, C);
        const E = e.render.frame;
        s[A.id] !== E && (d(A), s[A.id] = E)
    }

    function u(A) {
        const S = f();
        A.__bindingPointIndex = S;
        const M = r.createBuffer(),
            C = A.__size,
            E = A.usage;
        return r.bindBuffer(r.UNIFORM_BUFFER, M), r.bufferData(r.UNIFORM_BUFFER, C, E), r.bindBuffer(r.UNIFORM_BUFFER, null), r.bindBufferBase(r.UNIFORM_BUFFER, S, M), M
    }

    function f() {
        for (let A = 0; A < a; A++)
            if (o.indexOf(A) === -1) return o.push(A), A;
        return console.error("THREE.WebGLRenderer: Maximum number of simultaneously usable uniforms groups reached."), 0
    }

    function d(A) {
        const S = i[A.id],
            M = A.uniforms,
            C = A.__cache;
        r.bindBuffer(r.UNIFORM_BUFFER, S);
        for (let E = 0, R = M.length; E < R; E++) {
            const P = Array.isArray(M[E]) ? M[E] : [M[E]];
            for (let b = 0, T = P.length; b < T; b++) {
                const L = P[b];
                if (m(L, E, b, C) === !0) {
                    const D = L.__offset,
                        V = Array.isArray(L.value) ? L.value : [L.value];
                    let H = 0;
                    for (let q = 0; q < V.length; q++) {
                        const X = V[q],
                            oe = y(X);
                        typeof X == "number" || typeof X == "boolean" ? (L.__data[0] = X, r.bufferSubData(r.UNIFORM_BUFFER, D + H, L.__data)) : X.isMatrix3 ? (L.__data[0] = X.elements[0], L.__data[1] = X.elements[1], L.__data[2] = X.elements[2], L.__data[3] = 0, L.__data[4] = X.elements[3], L.__data[5] = X.elements[4], L.__data[6] = X.elements[5], L.__data[7] = 0, L.__data[8] = X.elements[6], L.__data[9] = X.elements[7], L.__data[10] = X.elements[8], L.__data[11] = 0) : (X.toArray(L.__data, H), H += oe.storage / Float32Array.BYTES_PER_ELEMENT)
                    }
                    r.bufferSubData(r.UNIFORM_BUFFER, D, L.__data)
                }
            }
        }
        r.bindBuffer(r.UNIFORM_BUFFER, null)
    }

    function m(A, S, M, C) {
        const E = A.value,
            R = S + "_" + M;
        if (C[R] === void 0) return typeof E == "number" || typeof E == "boolean" ? C[R] = E : C[R] = E.clone(), !0; {
            const P = C[R];
            if (typeof E == "number" || typeof E == "boolean") {
                if (P !== E) return C[R] = E, !0
            } else if (P.equals(E) === !1) return P.copy(E), !0
        }
        return !1
    }

    function g(A) {
        const S = A.uniforms;
        let M = 0;
        const C = 16;
        for (let R = 0, P = S.length; R < P; R++) {
            const b = Array.isArray(S[R]) ? S[R] : [S[R]];
            for (let T = 0, L = b.length; T < L; T++) {
                const D = b[T],
                    V = Array.isArray(D.value) ? D.value : [D.value];
                for (let H = 0, q = V.length; H < q; H++) {
                    const X = V[H],
                        oe = y(X),
                        Y = M % C,
                        Z = Y % oe.boundary,
                        U = Y + Z;
                    M += Z, U !== 0 && C - U < oe.storage && (M += C - U), D.__data = new Float32Array(oe.storage / Float32Array.BYTES_PER_ELEMENT), D.__offset = M, M += oe.storage
                }
            }
        }
        const E = M % C;
        return E > 0 && (M += C - E), A.__size = M, A.__cache = {}, this
    }

    function y(A) {
        const S = {
            boundary: 0,
            storage: 0
        };
        return typeof A == "number" || typeof A == "boolean" ? (S.boundary = 4, S.storage = 4) : A.isVector2 ? (S.boundary = 8, S.storage = 8) : A.isVector3 || A.isColor ? (S.boundary = 16, S.storage = 12) : A.isVector4 ? (S.boundary = 16, S.storage = 16) : A.isMatrix3 ? (S.boundary = 48, S.storage = 48) : A.isMatrix4 ? (S.boundary = 64, S.storage = 64) : A.isTexture ? console.warn("THREE.WebGLRenderer: Texture samplers can not be part of an uniforms group.") : console.warn("THREE.WebGLRenderer: Unsupported uniform value type.", A), S
    }

    function v(A) {
        const S = A.target;
        S.removeEventListener("dispose", v);
        const M = o.indexOf(S.__bindingPointIndex);
        o.splice(M, 1), r.deleteBuffer(i[S.id]), delete i[S.id], delete s[S.id]
    }

    function _() {
        for (const A in i) r.deleteBuffer(i[A]);
        o = [], i = {}, s = {}
    }
    return {
        bind: l,
        update: c,
        dispose: _
    }
}
class KS {
    constructor(e = {}) {
        const {
            canvas: t = uB(),
            context: n = null,
            depth: i = !0,
            stencil: s = !1,
            alpha: o = !1,
            antialias: a = !1,
            premultipliedAlpha: l = !0,
            preserveDrawingBuffer: c = !1,
            powerPreference: u = "default",
            failIfMajorPerformanceCaveat: f = !1,
            reverseDepthBuffer: d = !1
        } = e;
        this.isWebGLRenderer = !0;
        let m;
        if (n !== null) {
            if (typeof WebGLRenderingContext < "u" && n instanceof WebGLRenderingContext) throw new Error("THREE.WebGLRenderer: WebGL 1 is not supported since r163.");
            m = n.getContextAttributes().alpha
        } else m = o;
        const g = new Uint32Array(4),
            y = new Int32Array(4);
        let v = null,
            _ = null;
        const A = [],
            S = [];
        this.domElement = t, this.debug = {
            checkShaderErrors: !0,
            onShaderError: null
        }, this.autoClear = !0, this.autoClearColor = !0, this.autoClearDepth = !0, this.autoClearStencil = !0, this.sortObjects = !0, this.clippingPlanes = [], this.localClippingEnabled = !1, this._outputColorSpace = Jn, this.toneMapping = Js, this.toneMappingExposure = 1;
        const M = this;
        let C = !1,
            E = 0,
            R = 0,
            P = null,
            b = -1,
            T = null;
        const L = new An,
            D = new An;
        let V = null;
        const H = new rt(0);
        let q = 0,
            X = t.width,
            oe = t.height,
            Y = 1,
            Z = null,
            U = null;
        const j = new An(0, 0, X, oe),
            te = new An(0, 0, X, oe);
        let he = !1;
        const $ = new Xp;
        let ne = !1,
            me = !1;
        const ce = new Ot,
            _e = new Ot,
            Oe = new K,
            ke = new An,
            Ee = {
                background: null,
                fog: null,
                environment: null,
                overrideMaterial: null,
                isScene: !0
            };
        let pe = !1;

        function xe() {
            return P === null ? Y : 1
        }
        let J = n;

        function De(F, Q) {
            return t.getContext(F, Q)
        }
        try {
            const F = {
                alpha: !0,
                depth: i,
                stencil: s,
                antialias: a,
                premultipliedAlpha: l,
                preserveDrawingBuffer: c,
                powerPreference: u,
                failIfMajorPerformanceCaveat: f
            };
            if ("setAttribute" in t && t.setAttribute("data-engine", `three.js r${du}`), t.addEventListener("webglcontextlost", He, !1), t.addEventListener("webglcontextrestored", Je, !1), t.addEventListener("webglcontextcreationerror", Ye, !1), J === null) {
                const Q = "webgl2";
                if (J = De(Q, F), J === null) throw De(Q) ? new Error("Error creating WebGL context with your selected attributes.") : new Error("Error creating WebGL context.")
            }
        } catch (F) {
            throw console.error("THREE.WebGLRenderer: " + F.message), F
        }
        let Ce, se, Se, Xe, Le, k, z, ue, ye, ge, Re, Be, Fe, Ne, ot, je, Ze, it, $e, We, yt, at, Mt, ae;

        function ve() {
            Ce = new MG(J), Ce.init(), at = new xB(J, Ce), se = new vG(J, Ce, e, at), Se = new i5(J, Ce), se.reverseDepthBuffer && d && Se.buffers.depth.setReversed(!0), Xe = new TG(J), Le = new WH, k = new c5(J, Ce, Se, Le, se, at, Xe), z = new _G(M), ue = new SG(M), ye = new Dk(J), Mt = new mG(J, ye), ge = new wG(J, ye, Xe, Mt), Re = new CG(J, ge, ye, Xe), $e = new EG(J, se, k), je = new yG(Le), Be = new VH(M, z, ue, Ce, se, Mt, je), Fe = new g5(M, Le), Ne = new XH, ot = new QH(Ce), it = new pG(M, z, ue, Se, Re, m, l), Ze = new t5(M, Re, se), ae = new v5(J, Xe, se, Se), We = new gG(J, Ce, Xe), yt = new bG(J, Ce, Xe), Xe.programs = Be.programs, M.capabilities = se, M.extensions = Ce, M.properties = Le, M.renderLists = Ne, M.shadowMap = Ze, M.state = Se, M.info = Xe
        }
        ve();
        const we = new p5(M, J);
        this.xr = we, this.getContext = function() {
            return J
        }, this.getContextAttributes = function() {
            return J.getContextAttributes()
        }, this.forceContextLoss = function() {
            const F = Ce.get("WEBGL_lose_context");
            F && F.loseContext()
        }, this.forceContextRestore = function() {
            const F = Ce.get("WEBGL_lose_context");
            F && F.restoreContext()
        }, this.getPixelRatio = function() {
            return Y
        }, this.setPixelRatio = function(F) {
            F !== void 0 && (Y = F, this.setSize(X, oe, !1))
        }, this.getSize = function(F) {
            return F.set(X, oe)
        }, this.setSize = function(F, Q, re = !0) {
            if (we.isPresenting) {
                console.warn("THREE.WebGLRenderer: Can't change size while VR device is presenting.");
                return
            }
            X = F, oe = Q, t.width = Math.floor(F * Y), t.height = Math.floor(Q * Y), re === !0 && (t.style.width = F + "px", t.style.height = Q + "px"), this.setViewport(0, 0, F, Q)
        }, this.getDrawingBufferSize = function(F) {
            return F.set(X * Y, oe * Y).floor()
        }, this.setDrawingBufferSize = function(F, Q, re) {
            X = F, oe = Q, Y = re, t.width = Math.floor(F * re), t.height = Math.floor(Q * re), this.setViewport(0, 0, F, Q)
        }, this.getCurrentViewport = function(F) {
            return F.copy(L)
        }, this.getViewport = function(F) {
            return F.copy(j)
        }, this.setViewport = function(F, Q, re, le) {
            F.isVector4 ? j.set(F.x, F.y, F.z, F.w) : j.set(F, Q, re, le), Se.viewport(L.copy(j).multiplyScalar(Y).round())
        }, this.getScissor = function(F) {
            return F.copy(te)
        }, this.setScissor = function(F, Q, re, le) {
            F.isVector4 ? te.set(F.x, F.y, F.z, F.w) : te.set(F, Q, re, le), Se.scissor(D.copy(te).multiplyScalar(Y).round())
        }, this.getScissorTest = function() {
            return he
        }, this.setScissorTest = function(F) {
            Se.setScissorTest(he = F)
        }, this.setOpaqueSort = function(F) {
            Z = F
        }, this.setTransparentSort = function(F) {
            U = F
        }, this.getClearColor = function(F) {
            return F.copy(it.getClearColor())
        }, this.setClearColor = function() {
            it.setClearColor.apply(it, arguments)
        }, this.getClearAlpha = function() {
            return it.getClearAlpha()
        }, this.setClearAlpha = function() {
            it.setClearAlpha.apply(it, arguments)
        }, this.clear = function(F = !0, Q = !0, re = !0) {
            let le = 0;
            if (F) {
                let ee = !1;
                if (P !== null) {
                    const Te = P.texture.format;
                    ee = Te === fy || Te === uy || Te === Vp
                }
                if (ee) {
                    const Te = P.texture.type,
                        fe = Te === Yi || Te === fo || Te === Kf || Te === Ml || Te === ly || Te === cy,
                        Ke = it.getClearColor(),
                        Ge = it.getClearAlpha(),
                        qe = Ke.r,
                        st = Ke.g,
                        Qe = Ke.b;
                    fe ? (g[0] = qe, g[1] = st, g[2] = Qe, g[3] = Ge, J.clearBufferuiv(J.COLOR, 0, g)) : (y[0] = qe, y[1] = st, y[2] = Qe, y[3] = Ge, J.clearBufferiv(J.COLOR, 0, y))
                } else le |= J.COLOR_BUFFER_BIT
            }
            Q && (le |= J.DEPTH_BUFFER_BIT), re && (le |= J.STENCIL_BUFFER_BIT, this.state.buffers.stencil.setMask(4294967295)), J.clear(le)
        }, this.clearColor = function() {
            this.clear(!0, !1, !1)
        }, this.clearDepth = function() {
            this.clear(!1, !0, !1)
        }, this.clearStencil = function() {
            this.clear(!1, !1, !0)
        }, this.dispose = function() {
            t.removeEventListener("webglcontextlost", He, !1), t.removeEventListener("webglcontextrestored", Je, !1), t.removeEventListener("webglcontextcreationerror", Ye, !1), Ne.dispose(), ot.dispose(), Le.dispose(), z.dispose(), ue.dispose(), Re.dispose(), Mt.dispose(), ae.dispose(), Be.dispose(), we.dispose(), we.removeEventListener("sessionstart", nt), we.removeEventListener("sessionend", It), pt.stop()
        };

        function He(F) {
            F.preventDefault(), console.log("THREE.WebGLRenderer: Context Lost."), C = !0
        }

        function Je() {
            console.log("THREE.WebGLRenderer: Context Restored."), C = !1;
            const F = Xe.autoReset,
                Q = Ze.enabled,
                re = Ze.autoUpdate,
                le = Ze.needsUpdate,
                ee = Ze.type;
            ve(), Xe.autoReset = F, Ze.enabled = Q, Ze.autoUpdate = re, Ze.needsUpdate = le, Ze.type = ee
        }

        function Ye(F) {
            console.error("THREE.WebGLRenderer: A WebGL context could not be created. Reason: ", F.statusMessage)
        }

        function mt(F) {
            const Q = F.target;
            Q.removeEventListener("dispose", mt), Pt(Q)
        }

        function Pt(F) {
            St(F), Le.remove(F)
        }

        function St(F) {
            const Q = Le.get(F).programs;
            Q !== void 0 && (Q.forEach(function(re) {
                Be.releaseProgram(re)
            }), F.isShaderMaterial && Be.releaseShaderCache(F))
        }
        this.renderBufferDirect = function(F, Q, re, le, ee, Te) {
            Q === null && (Q = Ee);
            const fe = ee.isMesh && ee.matrixWorld.determinant() < 0,
                Ke = de(F, Q, re, le, ee);
            Se.setMaterial(le, fe);
            let Ge = re.index,
                qe = 1;
            if (le.wireframe === !0) {
                if (Ge = ge.getWireframeAttribute(re), Ge === void 0) return;
                qe = 2
            }
            const st = re.drawRange,
                Qe = re.attributes.position;
            let ft = st.start * qe,
                _t = (st.start + st.count) * qe;
            Te !== null && (ft = Math.max(ft, Te.start * qe), _t = Math.min(_t, (Te.start + Te.count) * qe)), Ge !== null ? (ft = Math.max(ft, 0), _t = Math.min(_t, Ge.count)) : Qe != null && (ft = Math.max(ft, 0), _t = Math.min(_t, Qe.count));
            const ht = _t - ft;
            if (ht < 0 || ht === 1 / 0) return;
            Mt.setup(ee, le, Ke, re, Ge);
            let wt, At = We;
            if (Ge !== null && (wt = ye.get(Ge), At = yt, At.setIndex(wt)), ee.isMesh) le.wireframe === !0 ? (Se.setLineWidth(le.wireframeLinewidth * xe()), At.setMode(J.LINES)) : At.setMode(J.TRIANGLES);
            else if (ee.isLine) {
                let ct = le.linewidth;
                ct === void 0 && (ct = 1), Se.setLineWidth(ct * xe()), ee.isLineSegments ? At.setMode(J.LINES) : ee.isLineLoop ? At.setMode(J.LINE_LOOP) : At.setMode(J.LINE_STRIP)
            } else ee.isPoints ? At.setMode(J.POINTS) : ee.isSprite && At.setMode(J.TRIANGLES);
            if (ee.isBatchedMesh)
                if (ee._multiDrawInstances !== null) At.renderMultiDrawInstances(ee._multiDrawStarts, ee._multiDrawCounts, ee._multiDrawCount, ee._multiDrawInstances);
                else if (Ce.get("WEBGL_multi_draw")) At.renderMultiDraw(ee._multiDrawStarts, ee._multiDrawCounts, ee._multiDrawCount);
            else {
                const ct = ee._multiDrawStarts,
                    Ut = ee._multiDrawCounts,
                    Bt = ee._multiDrawCount,
                    Mn = Ge ? ye.get(Ge).bytesPerElement : 1,
                    In = Le.get(le).currentProgram.getUniforms();
                for (let cn = 0; cn < Bt; cn++) In.setValue(J, "_gl_DrawID", cn), At.render(ct[cn] / Mn, Ut[cn])
            } else if (ee.isInstancedMesh) At.renderInstances(ft, ht, ee.count);
            else if (re.isInstancedBufferGeometry) {
                const ct = re._maxInstanceCount !== void 0 ? re._maxInstanceCount : 1 / 0,
                    Ut = Math.min(re.instanceCount, ct);
                At.renderInstances(ft, ht, Ut)
            } else At.render(ft, ht)
        };

        function tt(F, Q, re) {
            F.transparent === !0 && F.side === hn && F.forceSinglePass === !1 ? (F.side = di, F.needsUpdate = !0, rn(F, Q, re), F.side = Zs, F.needsUpdate = !0, rn(F, Q, re), F.side = hn) : rn(F, Q, re)
        }
        this.compile = function(F, Q, re = null) {
            re === null && (re = F), _ = ot.get(re), _.init(Q), S.push(_), re.traverseVisible(function(ee) {
                ee.isLight && ee.layers.test(Q.layers) && (_.pushLight(ee), ee.castShadow && _.pushShadow(ee))
            }), F !== re && F.traverseVisible(function(ee) {
                ee.isLight && ee.layers.test(Q.layers) && (_.pushLight(ee), ee.castShadow && _.pushShadow(ee))
            }), _.setupLights();
            const le = new Set;
            return F.traverse(function(ee) {
                if (!(ee.isMesh || ee.isPoints || ee.isLine || ee.isSprite)) return;
                const Te = ee.material;
                if (Te)
                    if (Array.isArray(Te))
                        for (let fe = 0; fe < Te.length; fe++) {
                            const Ke = Te[fe];
                            tt(Ke, re, ee), le.add(Ke)
                        } else tt(Te, re, ee), le.add(Te)
            }), S.pop(), _ = null, le
        }, this.compileAsync = function(F, Q, re = null) {
            const le = this.compile(F, Q, re);
            return new Promise(ee => {
                function Te() {
                    if (le.forEach(function(fe) {
                            Le.get(fe).currentProgram.isReady() && le.delete(fe)
                        }), le.size === 0) {
                        ee(F);
                        return
                    }
                    setTimeout(Te, 10)
                }
                Ce.get("KHR_parallel_shader_compile") !== null ? Te() : setTimeout(Te, 10)
            })
        };
        let ut = null;

        function Rt(F) {
            ut && ut(F)
        }

        function nt() {
            pt.stop()
        }

        function It() {
            pt.start()
        }
        const pt = new mB;
        pt.setAnimationLoop(Rt), typeof self < "u" && pt.setContext(self), this.setAnimationLoop = function(F) {
            ut = F, we.setAnimationLoop(F), F === null ? pt.stop() : pt.start()
        }, we.addEventListener("sessionstart", nt), we.addEventListener("sessionend", It), this.render = function(F, Q) {
            if (Q !== void 0 && Q.isCamera !== !0) {
                console.error("THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.");
                return
            }
            if (C === !0) return;
            if (F.matrixWorldAutoUpdate === !0 && F.updateMatrixWorld(), Q.parent === null && Q.matrixWorldAutoUpdate === !0 && Q.updateMatrixWorld(), we.enabled === !0 && we.isPresenting === !0 && (we.cameraAutoUpdate === !0 && we.updateCamera(Q), Q = we.getCamera()), F.isScene === !0 && F.onBeforeRender(M, F, Q, P), _ = ot.get(F, S.length), _.init(Q), S.push(_), _e.multiplyMatrices(Q.projectionMatrix, Q.matrixWorldInverse), $.setFromProjectionMatrix(_e), me = this.localClippingEnabled, ne = je.init(this.clippingPlanes, me), v = Ne.get(F, A.length), v.init(), A.push(v), we.enabled === !0 && we.isPresenting === !0) {
                const Te = M.xr.getDepthSensingMesh();
                Te !== null && Ct(Te, Q, -1 / 0, M.sortObjects)
            }
            Ct(F, Q, 0, M.sortObjects), v.finish(), M.sortObjects === !0 && v.sort(Z, U), pe = we.enabled === !1 || we.isPresenting === !1 || we.hasDepthSensing() === !1, pe && it.addToRenderList(v, F), this.info.render.frame++, ne === !0 && je.beginShadows();
            const re = _.state.shadowsArray;
            Ze.render(re, F, Q), ne === !0 && je.endShadows(), this.info.autoReset === !0 && this.info.reset();
            const le = v.opaque,
                ee = v.transmissive;
            if (_.setupLights(), Q.isArrayCamera) {
                const Te = Q.cameras;
                if (ee.length > 0)
                    for (let fe = 0, Ke = Te.length; fe < Ke; fe++) {
                        const Ge = Te[fe];
                        Dt(le, ee, F, Ge)
                    }
                pe && it.render(F);
                for (let fe = 0, Ke = Te.length; fe < Ke; fe++) {
                    const Ge = Te[fe];
                    ln(v, F, Ge, Ge.viewport)
                }
            } else ee.length > 0 && Dt(le, ee, F, Q), pe && it.render(F), ln(v, F, Q);
            P !== null && (k.updateMultisampleRenderTarget(P), k.updateRenderTargetMipmap(P)), F.isScene === !0 && F.onAfterRender(M, F, Q), Mt.resetDefaultState(), b = -1, T = null, S.pop(), S.length > 0 ? (_ = S[S.length - 1], ne === !0 && je.setGlobalState(M.clippingPlanes, _.state.camera)) : _ = null, A.pop(), A.length > 0 ? v = A[A.length - 1] : v = null
        };

        function Ct(F, Q, re, le) {
            if (F.visible === !1) return;
            if (F.layers.test(Q.layers)) {
                if (F.isGroup) re = F.renderOrder;
                else if (F.isLOD) F.autoUpdate === !0 && F.update(Q);
                else if (F.isLight) _.pushLight(F), F.castShadow && _.pushShadow(F);
                else if (F.isSprite) {
                    if (!F.frustumCulled || $.intersectsSprite(F)) {
                        le && ke.setFromMatrixPosition(F.matrixWorld).applyMatrix4(_e);
                        const fe = Re.update(F),
                            Ke = F.material;
                        Ke.visible && v.push(F, fe, Ke, re, ke.z, null)
                    }
                } else if ((F.isMesh || F.isLine || F.isPoints) && (!F.frustumCulled || $.intersectsObject(F))) {
                    const fe = Re.update(F),
                        Ke = F.material;
                    if (le && (F.boundingSphere !== void 0 ? (F.boundingSphere === null && F.computeBoundingSphere(), ke.copy(F.boundingSphere.center)) : (fe.boundingSphere === null && fe.computeBoundingSphere(), ke.copy(fe.boundingSphere.center)), ke.applyMatrix4(F.matrixWorld).applyMatrix4(_e)), Array.isArray(Ke)) {
                        const Ge = fe.groups;
                        for (let qe = 0, st = Ge.length; qe < st; qe++) {
                            const Qe = Ge[qe],
                                ft = Ke[Qe.materialIndex];
                            ft && ft.visible && v.push(F, fe, ft, re, ke.z, Qe)
                        }
                    } else Ke.visible && v.push(F, fe, Ke, re, ke.z, null)
                }
            }
            const Te = F.children;
            for (let fe = 0, Ke = Te.length; fe < Ke; fe++) Ct(Te[fe], Q, re, le)
        }

        function ln(F, Q, re, le) {
            const ee = F.opaque,
                Te = F.transmissive,
                fe = F.transparent;
            _.setupLightsView(re), ne === !0 && je.setGlobalState(M.clippingPlanes, re), le && Se.viewport(L.copy(le)), ee.length > 0 && gt(ee, Q, re), Te.length > 0 && gt(Te, Q, re), fe.length > 0 && gt(fe, Q, re), Se.buffers.depth.setTest(!0), Se.buffers.depth.setMask(!0), Se.buffers.color.setMask(!0), Se.setPolygonOffset(!1)
        }

        function Dt(F, Q, re, le) {
            if ((re.isScene === !0 ? re.overrideMaterial : null) !== null) return;
            _.state.transmissionRenderTarget[le.id] === void 0 && (_.state.transmissionRenderTarget[le.id] = new Zn(1, 1, {
                generateMipmaps: !0,
                type: Ce.has("EXT_color_buffer_half_float") || Ce.has("EXT_color_buffer_float") ? Ri : Yi,
                minFilter: gs,
                samples: 4,
                stencilBuffer: s,
                resolveDepthBuffer: !1,
                resolveStencilBuffer: !1,
                colorSpace: xn.workingColorSpace
            }));
            const Te = _.state.transmissionRenderTarget[le.id],
                fe = le.viewport || L;
            Te.setSize(fe.z, fe.w);
            const Ke = M.getRenderTarget();
            M.setRenderTarget(Te), M.getClearColor(H), q = M.getClearAlpha(), q < 1 && M.setClearColor(16777215, .5), M.clear(), pe && it.render(re);
            const Ge = M.toneMapping;
            M.toneMapping = Js;
            const qe = le.viewport;
            if (le.viewport !== void 0 && (le.viewport = void 0), _.setupLightsView(le), ne === !0 && je.setGlobalState(M.clippingPlanes, le), gt(F, re, le), k.updateMultisampleRenderTarget(Te), k.updateRenderTargetMipmap(Te), Ce.has("WEBGL_multisampled_render_to_texture") === !1) {
                let st = !1;
                for (let Qe = 0, ft = Q.length; Qe < ft; Qe++) {
                    const _t = Q[Qe],
                        ht = _t.object,
                        wt = _t.geometry,
                        At = _t.material,
                        ct = _t.group;
                    if (At.side === hn && ht.layers.test(le.layers)) {
                        const Ut = At.side;
                        At.side = di, At.needsUpdate = !0, $t(ht, re, le, wt, At, ct), At.side = Ut, At.needsUpdate = !0, st = !0
                    }
                }
                st === !0 && (k.updateMultisampleRenderTarget(Te), k.updateRenderTargetMipmap(Te))
            }
            M.setRenderTarget(Ke), M.setClearColor(H, q), qe !== void 0 && (le.viewport = qe), M.toneMapping = Ge
        }

        function gt(F, Q, re) {
            const le = Q.isScene === !0 ? Q.overrideMaterial : null;
            for (let ee = 0, Te = F.length; ee < Te; ee++) {
                const fe = F[ee],
                    Ke = fe.object,
                    Ge = fe.geometry,
                    qe = le === null ? fe.material : le,
                    st = fe.group;
                Ke.layers.test(re.layers) && $t(Ke, Q, re, Ge, qe, st)
            }
        }

        function $t(F, Q, re, le, ee, Te) {
            F.onBeforeRender(M, Q, re, le, ee, Te), F.modelViewMatrix.multiplyMatrices(re.matrixWorldInverse, F.matrixWorld), F.normalMatrix.getNormalMatrix(F.modelViewMatrix), ee.onBeforeRender(M, Q, re, le, F, Te), ee.transparent === !0 && ee.side === hn && ee.forceSinglePass === !1 ? (ee.side = di, ee.needsUpdate = !0, M.renderBufferDirect(re, Q, le, ee, F, Te), ee.side = Zs, ee.needsUpdate = !0, M.renderBufferDirect(re, Q, le, ee, F, Te), ee.side = hn) : M.renderBufferDirect(re, Q, le, ee, F, Te), F.onAfterRender(M, Q, re, le, ee, Te)
        }

        function rn(F, Q, re) {
            Q.isScene !== !0 && (Q = Ee);
            const le = Le.get(F),
                ee = _.state.lights,
                Te = _.state.shadowsArray,
                fe = ee.state.version,
                Ke = Be.getParameters(F, ee.state, Te, Q, re),
                Ge = Be.getProgramCacheKey(Ke);
            let qe = le.programs;
            le.environment = F.isMeshStandardMaterial ? Q.environment : null, le.fog = Q.fog, le.envMap = (F.isMeshStandardMaterial ? ue : z).get(F.envMap || le.environment), le.envMapRotation = le.environment !== null && F.envMap === null ? Q.environmentRotation : F.envMapRotation, qe === void 0 && (F.addEventListener("dispose", mt), qe = new Map, le.programs = qe);
            let st = qe.get(Ge);
            if (st !== void 0) {
                if (le.currentProgram === st && le.lightsStateVersion === fe) return W(F, Ke), st
            } else Ke.uniforms = Be.getUniforms(F), F.onBeforeCompile(Ke, M), st = Be.acquireProgram(Ke, Ge), qe.set(Ge, st), le.uniforms = Ke.uniforms;
            const Qe = le.uniforms;
            return (!F.isShaderMaterial && !F.isRawShaderMaterial || F.clipping === !0) && (Qe.clippingPlanes = je.uniform), W(F, Ke), le.needsLights = Pe(F), le.lightsStateVersion = fe, le.needsLights && (Qe.ambientLightColor.value = ee.state.ambient, Qe.lightProbe.value = ee.state.probe, Qe.directionalLights.value = ee.state.directional, Qe.directionalLightShadows.value = ee.state.directionalShadow, Qe.spotLights.value = ee.state.spot, Qe.spotLightShadows.value = ee.state.spotShadow, Qe.rectAreaLights.value = ee.state.rectArea, Qe.ltc_1.value = ee.state.rectAreaLTC1, Qe.ltc_2.value = ee.state.rectAreaLTC2, Qe.pointLights.value = ee.state.point, Qe.pointLightShadows.value = ee.state.pointShadow, Qe.hemisphereLights.value = ee.state.hemi, Qe.directionalShadowMap.value = ee.state.directionalShadowMap, Qe.directionalShadowMatrix.value = ee.state.directionalShadowMatrix, Qe.spotShadowMap.value = ee.state.spotShadowMap, Qe.spotLightMatrix.value = ee.state.spotLightMatrix, Qe.spotLightMap.value = ee.state.spotLightMap, Qe.pointShadowMap.value = ee.state.pointShadowMap, Qe.pointShadowMatrix.value = ee.state.pointShadowMatrix), le.currentProgram = st, le.uniformsList = null, st
        }

        function O(F) {
            if (F.uniformsList === null) {
                const Q = F.currentProgram.getUniforms();
                F.uniformsList = I0.seqWithValue(Q.seq, F.uniforms)
            }
            return F.uniformsList
        }

        function W(F, Q) {
            const re = Le.get(F);
            re.outputColorSpace = Q.outputColorSpace, re.batching = Q.batching, re.batchingColor = Q.batchingColor, re.instancing = Q.instancing, re.instancingColor = Q.instancingColor, re.instancingMorph = Q.instancingMorph, re.skinning = Q.skinning, re.morphTargets = Q.morphTargets, re.morphNormals = Q.morphNormals, re.morphColors = Q.morphColors, re.morphTargetsCount = Q.morphTargetsCount, re.numClippingPlanes = Q.numClippingPlanes, re.numIntersection = Q.numClipIntersection, re.vertexAlphas = Q.vertexAlphas, re.vertexTangents = Q.vertexTangents, re.toneMapping = Q.toneMapping
        }

        function de(F, Q, re, le, ee) {
            Q.isScene !== !0 && (Q = Ee), k.resetTextureUnits();
            const Te = Q.fog,
                fe = le.isMeshStandardMaterial ? Q.environment : null,
                Ke = P === null ? M.outputColorSpace : P.isXRRenderTarget === !0 ? P.texture.colorSpace : Qs,
                Ge = (le.isMeshStandardMaterial ? ue : z).get(le.envMap || fe),
                qe = le.vertexColors === !0 && !!re.attributes.color && re.attributes.color.itemSize === 4,
                st = !!re.attributes.tangent && (!!le.normalMap || le.anisotropy > 0),
                Qe = !!re.morphAttributes.position,
                ft = !!re.morphAttributes.normal,
                _t = !!re.morphAttributes.color;
            let ht = Js;
            le.toneMapped && (P === null || P.isXRRenderTarget === !0) && (ht = M.toneMapping);
            const wt = re.morphAttributes.position || re.morphAttributes.normal || re.morphAttributes.color,
                At = wt !== void 0 ? wt.length : 0,
                ct = Le.get(le),
                Ut = _.state.lights;
            if (ne === !0 && (me === !0 || F !== T)) {
                const sn = F === T && le.id === b;
                je.setState(le, F, sn)
            }
            let Bt = !1;
            le.version === ct.__version ? (ct.needsLights && ct.lightsStateVersion !== Ut.state.version || ct.outputColorSpace !== Ke || ee.isBatchedMesh && ct.batching === !1 || !ee.isBatchedMesh && ct.batching === !0 || ee.isBatchedMesh && ct.batchingColor === !0 && ee.colorTexture === null || ee.isBatchedMesh && ct.batchingColor === !1 && ee.colorTexture !== null || ee.isInstancedMesh && ct.instancing === !1 || !ee.isInstancedMesh && ct.instancing === !0 || ee.isSkinnedMesh && ct.skinning === !1 || !ee.isSkinnedMesh && ct.skinning === !0 || ee.isInstancedMesh && ct.instancingColor === !0 && ee.instanceColor === null || ee.isInstancedMesh && ct.instancingColor === !1 && ee.instanceColor !== null || ee.isInstancedMesh && ct.instancingMorph === !0 && ee.morphTexture === null || ee.isInstancedMesh && ct.instancingMorph === !1 && ee.morphTexture !== null || ct.envMap !== Ge || le.fog === !0 && ct.fog !== Te || ct.numClippingPlanes !== void 0 && (ct.numClippingPlanes !== je.numPlanes || ct.numIntersection !== je.numIntersection) || ct.vertexAlphas !== qe || ct.vertexTangents !== st || ct.morphTargets !== Qe || ct.morphNormals !== ft || ct.morphColors !== _t || ct.toneMapping !== ht || ct.morphTargetsCount !== At) && (Bt = !0) : (Bt = !0, ct.__version = le.version);
            let Mn = ct.currentProgram;
            Bt === !0 && (Mn = rn(le, Q, ee));
            let In = !1,
                cn = !1,
                en = !1;
            const Gt = Mn.getUniforms(),
                Wt = ct.uniforms;
            if (Se.useProgram(Mn.program) && (In = !0, cn = !0, en = !0), le.id !== b && (b = le.id, cn = !0), In || T !== F) {
                Se.buffers.depth.getReversed() ? (ce.copy(F.projectionMatrix), sk(ce), ok(ce), Gt.setValue(J, "projectionMatrix", ce)) : Gt.setValue(J, "projectionMatrix", F.projectionMatrix), Gt.setValue(J, "viewMatrix", F.matrixWorldInverse);
                const Qn = Gt.map.cameraPosition;
                Qn !== void 0 && Qn.setValue(J, Oe.setFromMatrixPosition(F.matrixWorld)), se.logarithmicDepthBuffer && Gt.setValue(J, "logDepthBufFC", 2 / (Math.log(F.far + 1) / Math.LN2)), (le.isMeshPhongMaterial || le.isMeshToonMaterial || le.isMeshLambertMaterial || le.isMeshBasicMaterial || le.isMeshStandardMaterial || le.isShaderMaterial) && Gt.setValue(J, "isOrthographic", F.isOrthographicCamera === !0), T !== F && (T = F, cn = !0, en = !0)
            }
            if (ee.isSkinnedMesh) {
                Gt.setOptional(J, ee, "bindMatrix"), Gt.setOptional(J, ee, "bindMatrixInverse");
                const sn = ee.skeleton;
                sn && (sn.boneTexture === null && sn.computeBoneTexture(), Gt.setValue(J, "boneTexture", sn.boneTexture, k))
            }
            ee.isBatchedMesh && (Gt.setOptional(J, ee, "batchingTexture"), Gt.setValue(J, "batchingTexture", ee._matricesTexture, k), Gt.setOptional(J, ee, "batchingIdTexture"), Gt.setValue(J, "batchingIdTexture", ee._indirectTexture, k), Gt.setOptional(J, ee, "batchingColorTexture"), ee._colorsTexture !== null && Gt.setValue(J, "batchingColorTexture", ee._colorsTexture, k));
            const Ht = re.morphAttributes;
            if ((Ht.position !== void 0 || Ht.normal !== void 0 || Ht.color !== void 0) && $e.update(ee, re, Mn), (cn || ct.receiveShadow !== ee.receiveShadow) && (ct.receiveShadow = ee.receiveShadow, Gt.setValue(J, "receiveShadow", ee.receiveShadow)), le.isMeshGouraudMaterial && le.envMap !== null && (Wt.envMap.value = Ge, Wt.flipEnvMap.value = Ge.isCubeTexture && Ge.isRenderTargetTexture === !1 ? -1 : 1), le.isMeshStandardMaterial && le.envMap === null && Q.environment !== null && (Wt.envMapIntensity.value = Q.environmentIntensity), cn && (Gt.setValue(J, "toneMappingExposure", M.toneMappingExposure), ct.needsLights && be(Wt, en), Te && le.fog === !0 && Fe.refreshFogUniforms(Wt, Te), Fe.refreshMaterialUniforms(Wt, le, Y, oe, _.state.transmissionRenderTarget[F.id]), I0.upload(J, O(ct), Wt, k)), le.isShaderMaterial && le.uniformsNeedUpdate === !0 && (I0.upload(J, O(ct), Wt, k), le.uniformsNeedUpdate = !1), le.isSpriteMaterial && Gt.setValue(J, "center", ee.center), Gt.setValue(J, "modelViewMatrix", ee.modelViewMatrix), Gt.setValue(J, "normalMatrix", ee.normalMatrix), Gt.setValue(J, "modelMatrix", ee.matrixWorld), le.isShaderMaterial || le.isRawShaderMaterial) {
                const sn = le.uniformsGroups;
                for (let Qn = 0, Dn = sn.length; Qn < Dn; Qn++) {
                    const tr = sn[Qn];
                    ae.update(tr, Mn), ae.bind(tr, Mn)
                }
            }
            return Mn
        }

        function be(F, Q) {
            F.ambientLightColor.needsUpdate = Q, F.lightProbe.needsUpdate = Q, F.directionalLights.needsUpdate = Q, F.directionalLightShadows.needsUpdate = Q, F.pointLights.needsUpdate = Q, F.pointLightShadows.needsUpdate = Q, F.spotLights.needsUpdate = Q, F.spotLightShadows.needsUpdate = Q, F.rectAreaLights.needsUpdate = Q, F.hemisphereLights.needsUpdate = Q
        }

        function Pe(F) {
            return F.isMeshLambertMaterial || F.isMeshToonMaterial || F.isMeshPhongMaterial || F.isMeshStandardMaterial || F.isShadowMaterial || F.isShaderMaterial && F.lights === !0
        }
        this.getActiveCubeFace = function() {
            return E
        }, this.getActiveMipmapLevel = function() {
            return R
        }, this.getRenderTarget = function() {
            return P
        }, this.setRenderTargetTextures = function(F, Q, re) {
            Le.get(F.texture).__webglTexture = Q, Le.get(F.depthTexture).__webglTexture = re;
            const le = Le.get(F);
            le.__hasExternalTextures = !0, le.__autoAllocateDepthBuffer = re === void 0, le.__autoAllocateDepthBuffer || Ce.has("WEBGL_multisampled_render_to_texture") === !0 && (console.warn("THREE.WebGLRenderer: Render-to-texture extension was disabled because an external texture was provided"), le.__useRenderToTexture = !1)
        }, this.setRenderTargetFramebuffer = function(F, Q) {
            const re = Le.get(F);
            re.__webglFramebuffer = Q, re.__useDefaultFramebuffer = Q === void 0
        }, this.setRenderTarget = function(F, Q = 0, re = 0) {
            P = F, E = Q, R = re;
            let le = !0,
                ee = null,
                Te = !1,
                fe = !1;
            if (F) {
                const Ge = Le.get(F);
                if (Ge.__useDefaultFramebuffer !== void 0) Se.bindFramebuffer(J.FRAMEBUFFER, null), le = !1;
                else if (Ge.__webglFramebuffer === void 0) k.setupRenderTarget(F);
                else if (Ge.__hasExternalTextures) k.rebindTextures(F, Le.get(F.texture).__webglTexture, Le.get(F.depthTexture).__webglTexture);
                else if (F.depthBuffer) {
                    const Qe = F.depthTexture;
                    if (Ge.__boundDepthTexture !== Qe) {
                        if (Qe !== null && Le.has(Qe) && (F.width !== Qe.image.width || F.height !== Qe.image.height)) throw new Error("WebGLRenderTarget: Attached DepthTexture is initialized to the incorrect size.");
                        k.setupDepthRenderbuffer(F)
                    }
                }
                const qe = F.texture;
                (qe.isData3DTexture || qe.isDataArrayTexture || qe.isCompressedArrayTexture) && (fe = !0);
                const st = Le.get(F).__webglFramebuffer;
                F.isWebGLCubeRenderTarget ? (Array.isArray(st[Q]) ? ee = st[Q][re] : ee = st[Q], Te = !0) : F.samples > 0 && k.useMultisampledRTT(F) === !1 ? ee = Le.get(F).__webglMultisampledFramebuffer : Array.isArray(st) ? ee = st[re] : ee = st, L.copy(F.viewport), D.copy(F.scissor), V = F.scissorTest
            } else L.copy(j).multiplyScalar(Y).floor(), D.copy(te).multiplyScalar(Y).floor(), V = he;
            if (Se.bindFramebuffer(J.FRAMEBUFFER, ee) && le && Se.drawBuffers(F, ee), Se.viewport(L), Se.scissor(D), Se.setScissorTest(V), Te) {
                const Ge = Le.get(F.texture);
                J.framebufferTexture2D(J.FRAMEBUFFER, J.COLOR_ATTACHMENT0, J.TEXTURE_CUBE_MAP_POSITIVE_X + Q, Ge.__webglTexture, re)
            } else if (fe) {
                const Ge = Le.get(F.texture),
                    qe = Q || 0;
                J.framebufferTextureLayer(J.FRAMEBUFFER, J.COLOR_ATTACHMENT0, Ge.__webglTexture, re || 0, qe)
            }
            b = -1
        }, this.readRenderTargetPixels = function(F, Q, re, le, ee, Te, fe) {
            if (!(F && F.isWebGLRenderTarget)) {
                console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
                return
            }
            let Ke = Le.get(F).__webglFramebuffer;
            if (F.isWebGLCubeRenderTarget && fe !== void 0 && (Ke = Ke[fe]), Ke) {
                Se.bindFramebuffer(J.FRAMEBUFFER, Ke);
                try {
                    const Ge = F.texture,
                        qe = Ge.format,
                        st = Ge.type;
                    if (!se.textureFormatReadable(qe)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.");
                        return
                    }
                    if (!se.textureTypeReadable(st)) {
                        console.error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.");
                        return
                    }
                    Q >= 0 && Q <= F.width - le && re >= 0 && re <= F.height - ee && J.readPixels(Q, re, le, ee, at.convert(qe), at.convert(st), Te)
                } finally {
                    const Ge = P !== null ? Le.get(P).__webglFramebuffer : null;
                    Se.bindFramebuffer(J.FRAMEBUFFER, Ge)
                }
            }
        }, this.readRenderTargetPixelsAsync = async function(F, Q, re, le, ee, Te, fe) {
            if (!(F && F.isWebGLRenderTarget)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.");
            let Ke = Le.get(F).__webglFramebuffer;
            if (F.isWebGLCubeRenderTarget && fe !== void 0 && (Ke = Ke[fe]), Ke) {
                const Ge = F.texture,
                    qe = Ge.format,
                    st = Ge.type;
                if (!se.textureFormatReadable(qe)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in RGBA or implementation defined format.");
                if (!se.textureTypeReadable(st)) throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: renderTarget is not in UnsignedByteType or implementation defined type.");
                if (Q >= 0 && Q <= F.width - le && re >= 0 && re <= F.height - ee) {
                    Se.bindFramebuffer(J.FRAMEBUFFER, Ke);
                    const Qe = J.createBuffer();
                    J.bindBuffer(J.PIXEL_PACK_BUFFER, Qe), J.bufferData(J.PIXEL_PACK_BUFFER, Te.byteLength, J.STREAM_READ), J.readPixels(Q, re, le, ee, at.convert(qe), at.convert(st), 0);
                    const ft = P !== null ? Le.get(P).__webglFramebuffer : null;
                    Se.bindFramebuffer(J.FRAMEBUFFER, ft);
                    const _t = J.fenceSync(J.SYNC_GPU_COMMANDS_COMPLETE, 0);
                    return J.flush(), await rk(J, _t, 4), J.bindBuffer(J.PIXEL_PACK_BUFFER, Qe), J.getBufferSubData(J.PIXEL_PACK_BUFFER, 0, Te), J.deleteBuffer(Qe), J.deleteSync(_t), Te
                } else throw new Error("THREE.WebGLRenderer.readRenderTargetPixelsAsync: requested read bounds are out of range.")
            }
        }, this.copyFramebufferToTexture = function(F, Q = null, re = 0) {
            F.isTexture !== !0 && (Ad("WebGLRenderer: copyFramebufferToTexture function signature has changed."), Q = arguments[0] || null, F = arguments[1]);
            const le = Math.pow(2, -re),
                ee = Math.floor(F.image.width * le),
                Te = Math.floor(F.image.height * le),
                fe = Q !== null ? Q.x : 0,
                Ke = Q !== null ? Q.y : 0;
            k.setTexture2D(F, 0), J.copyTexSubImage2D(J.TEXTURE_2D, re, 0, 0, fe, Ke, ee, Te), Se.unbindTexture()
        }, this.copyTextureToTexture = function(F, Q, re = null, le = null, ee = 0) {
            F.isTexture !== !0 && (Ad("WebGLRenderer: copyTextureToTexture function signature has changed."), le = arguments[0] || null, F = arguments[1], Q = arguments[2], ee = arguments[3] || 0, re = null);
            let Te, fe, Ke, Ge, qe, st, Qe, ft, _t;
            const ht = F.isCompressedTexture ? F.mipmaps[ee] : F.image;
            re !== null ? (Te = re.max.x - re.min.x, fe = re.max.y - re.min.y, Ke = re.isBox3 ? re.max.z - re.min.z : 1, Ge = re.min.x, qe = re.min.y, st = re.isBox3 ? re.min.z : 0) : (Te = ht.width, fe = ht.height, Ke = ht.depth || 1, Ge = 0, qe = 0, st = 0), le !== null ? (Qe = le.x, ft = le.y, _t = le.z) : (Qe = 0, ft = 0, _t = 0);
            const wt = at.convert(Q.format),
                At = at.convert(Q.type);
            let ct;
            Q.isData3DTexture ? (k.setTexture3D(Q, 0), ct = J.TEXTURE_3D) : Q.isDataArrayTexture || Q.isCompressedArrayTexture ? (k.setTexture2DArray(Q, 0), ct = J.TEXTURE_2D_ARRAY) : (k.setTexture2D(Q, 0), ct = J.TEXTURE_2D), J.pixelStorei(J.UNPACK_FLIP_Y_WEBGL, Q.flipY), J.pixelStorei(J.UNPACK_PREMULTIPLY_ALPHA_WEBGL, Q.premultiplyAlpha), J.pixelStorei(J.UNPACK_ALIGNMENT, Q.unpackAlignment);
            const Ut = J.getParameter(J.UNPACK_ROW_LENGTH),
                Bt = J.getParameter(J.UNPACK_IMAGE_HEIGHT),
                Mn = J.getParameter(J.UNPACK_SKIP_PIXELS),
                In = J.getParameter(J.UNPACK_SKIP_ROWS),
                cn = J.getParameter(J.UNPACK_SKIP_IMAGES);
            J.pixelStorei(J.UNPACK_ROW_LENGTH, ht.width), J.pixelStorei(J.UNPACK_IMAGE_HEIGHT, ht.height), J.pixelStorei(J.UNPACK_SKIP_PIXELS, Ge), J.pixelStorei(J.UNPACK_SKIP_ROWS, qe), J.pixelStorei(J.UNPACK_SKIP_IMAGES, st);
            const en = F.isDataArrayTexture || F.isData3DTexture,
                Gt = Q.isDataArrayTexture || Q.isData3DTexture;
            if (F.isRenderTargetTexture || F.isDepthTexture) {
                const Wt = Le.get(F),
                    Ht = Le.get(Q),
                    sn = Le.get(Wt.__renderTarget),
                    Qn = Le.get(Ht.__renderTarget);
                Se.bindFramebuffer(J.READ_FRAMEBUFFER, sn.__webglFramebuffer), Se.bindFramebuffer(J.DRAW_FRAMEBUFFER, Qn.__webglFramebuffer);
                for (let Dn = 0; Dn < Ke; Dn++) en && J.framebufferTextureLayer(J.READ_FRAMEBUFFER, J.COLOR_ATTACHMENT0, Le.get(F).__webglTexture, ee, st + Dn), F.isDepthTexture ? (Gt && J.framebufferTextureLayer(J.DRAW_FRAMEBUFFER, J.COLOR_ATTACHMENT0, Le.get(Q).__webglTexture, ee, _t + Dn), J.blitFramebuffer(Ge, qe, Te, fe, Qe, ft, Te, fe, J.DEPTH_BUFFER_BIT, J.NEAREST)) : Gt ? J.copyTexSubImage3D(ct, ee, Qe, ft, _t + Dn, Ge, qe, Te, fe) : J.copyTexSubImage2D(ct, ee, Qe, ft, _t + Dn, Ge, qe, Te, fe);
                Se.bindFramebuffer(J.READ_FRAMEBUFFER, null), Se.bindFramebuffer(J.DRAW_FRAMEBUFFER, null)
            } else Gt ? F.isDataTexture || F.isData3DTexture ? J.texSubImage3D(ct, ee, Qe, ft, _t, Te, fe, Ke, wt, At, ht.data) : Q.isCompressedArrayTexture ? J.compressedTexSubImage3D(ct, ee, Qe, ft, _t, Te, fe, Ke, wt, ht.data) : J.texSubImage3D(ct, ee, Qe, ft, _t, Te, fe, Ke, wt, At, ht) : F.isDataTexture ? J.texSubImage2D(J.TEXTURE_2D, ee, Qe, ft, Te, fe, wt, At, ht.data) : F.isCompressedTexture ? J.compressedTexSubImage2D(J.TEXTURE_2D, ee, Qe, ft, ht.width, ht.height, wt, ht.data) : J.texSubImage2D(J.TEXTURE_2D, ee, Qe, ft, Te, fe, wt, At, ht);
            J.pixelStorei(J.UNPACK_ROW_LENGTH, Ut), J.pixelStorei(J.UNPACK_IMAGE_HEIGHT, Bt), J.pixelStorei(J.UNPACK_SKIP_PIXELS, Mn), J.pixelStorei(J.UNPACK_SKIP_ROWS, In), J.pixelStorei(J.UNPACK_SKIP_IMAGES, cn), ee === 0 && Q.generateMipmaps && J.generateMipmap(ct), Se.unbindTexture()
        }, this.copyTextureToTexture3D = function(F, Q, re = null, le = null, ee = 0) {
            return F.isTexture !== !0 && (Ad("WebGLRenderer: copyTextureToTexture3D function signature has changed."), re = arguments[0] || null, le = arguments[1] || null, F = arguments[2], Q = arguments[3], ee = arguments[4] || 0), Ad('WebGLRenderer: copyTextureToTexture3D function has been deprecated. Use "copyTextureToTexture" instead.'), this.copyTextureToTexture(F, Q, re, le, ee)
        }, this.initRenderTarget = function(F) {
            Le.get(F).__webglFramebuffer === void 0 && k.setupRenderTarget(F)
        }, this.initTexture = function(F) {
            F.isCubeTexture ? k.setTextureCube(F, 0) : F.isData3DTexture ? k.setTexture3D(F, 0) : F.isDataArrayTexture || F.isCompressedArrayTexture ? k.setTexture2DArray(F, 0) : k.setTexture2D(F, 0), Se.unbindTexture()
        }, this.resetState = function() {
            E = 0, R = 0, P = null, Se.reset(), Mt.reset()
        }, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    get coordinateSystem() {
        return Io
    }
    get outputColorSpace() {
        return this._outputColorSpace
    }
    set outputColorSpace(e) {
        this._outputColorSpace = e;
        const t = this.getContext();
        t.drawingBufferColorspace = xn._getDrawingBufferColorSpace(e), t.unpackColorSpace = xn._getUnpackColorSpace()
    }
}
class yy {
    constructor(e, t = 25e-5) {
        this.isFogExp2 = !0, this.name = "", this.color = new rt(e), this.density = t
    }
    clone() {
        return new yy(this.color, this.density)
    }
    toJSON() {
        return {
            type: "FogExp2",
            name: this.name,
            color: this.color.getHex(),
            density: this.density
        }
    }
}
class _y {
    constructor(e, t = 1, n = 1e3) {
        this.isFog = !0, this.name = "", this.color = new rt(e), this.near = t, this.far = n
    }
    clone() {
        return new _y(this.color, this.near, this.far)
    }
    toJSON() {
        return {
            type: "Fog",
            name: this.name,
            color: this.color.getHex(),
            near: this.near,
            far: this.far
        }
    }
}
class ho extends vn {
    constructor() {
        super(), this.isScene = !0, this.type = "Scene", this.background = null, this.environment = null, this.fog = null, this.backgroundBlurriness = 0, this.backgroundIntensity = 1, this.backgroundRotation = new As, this.environmentIntensity = 1, this.environmentRotation = new As, this.overrideMaterial = null, typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("observe", {
            detail: this
        }))
    }
    copy(e, t) {
        return super.copy(e, t), e.background !== null && (this.background = e.background.clone()), e.environment !== null && (this.environment = e.environment.clone()), e.fog !== null && (this.fog = e.fog.clone()), this.backgroundBlurriness = e.backgroundBlurriness, this.backgroundIntensity = e.backgroundIntensity, this.backgroundRotation.copy(e.backgroundRotation), this.environmentIntensity = e.environmentIntensity, this.environmentRotation.copy(e.environmentRotation), e.overrideMaterial !== null && (this.overrideMaterial = e.overrideMaterial.clone()), this.matrixAutoUpdate = e.matrixAutoUpdate, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return this.fog !== null && (t.object.fog = this.fog.toJSON()), this.backgroundBlurriness > 0 && (t.object.backgroundBlurriness = this.backgroundBlurriness), this.backgroundIntensity !== 1 && (t.object.backgroundIntensity = this.backgroundIntensity), t.object.backgroundRotation = this.backgroundRotation.toArray(), this.environmentIntensity !== 1 && (t.object.environmentIntensity = this.environmentIntensity), t.object.environmentRotation = this.environmentRotation.toArray(), t
    }
}
class Jp {
    constructor(e, t) {
        this.isInterleavedBuffer = !0, this.array = e, this.stride = t, this.count = e !== void 0 ? e.length / t : 0, this.usage = mp, this.updateRanges = [], this.version = 0, this.uuid = ys()
    }
    onUploadCallback() {}
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setUsage(e) {
        return this.usage = e, this
    }
    addUpdateRange(e, t) {
        this.updateRanges.push({
            start: e,
            count: t
        })
    }
    clearUpdateRanges() {
        this.updateRanges.length = 0
    }
    copy(e) {
        return this.array = new e.array.constructor(e.array), this.count = e.count, this.stride = e.stride, this.usage = e.usage, this
    }
    copyAt(e, t, n) {
        e *= this.stride, n *= t.stride;
        for (let i = 0, s = this.stride; i < s; i++) this.array[e + i] = t.array[n + i];
        return this
    }
    set(e, t = 0) {
        return this.array.set(e, t), this
    }
    clone(e) {
        e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ys()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = this.array.slice(0).buffer);
        const t = new this.array.constructor(e.arrayBuffers[this.array.buffer._uuid]),
            n = new this.constructor(t, this.stride);
        return n.setUsage(this.usage), n
    }
    onUpload(e) {
        return this.onUploadCallback = e, this
    }
    toJSON(e) {
        return e.arrayBuffers === void 0 && (e.arrayBuffers = {}), this.array.buffer._uuid === void 0 && (this.array.buffer._uuid = ys()), e.arrayBuffers[this.array.buffer._uuid] === void 0 && (e.arrayBuffers[this.array.buffer._uuid] = Array.from(new Uint32Array(this.array.buffer))), {
            uuid: this.uuid,
            buffer: this.array.buffer._uuid,
            type: this.array.constructor.name,
            stride: this.stride
        }
    }
}
const Tr = new K;
class Tl {
    constructor(e, t, n, i = !1) {
        this.isInterleavedBufferAttribute = !0, this.name = "", this.data = e, this.itemSize = t, this.offset = n, this.normalized = i
    }
    get count() {
        return this.data.count
    }
    get array() {
        return this.data.array
    }
    set needsUpdate(e) {
        this.data.needsUpdate = e
    }
    applyMatrix4(e) {
        for (let t = 0, n = this.data.count; t < n; t++) Tr.fromBufferAttribute(this, t), Tr.applyMatrix4(e), this.setXYZ(t, Tr.x, Tr.y, Tr.z);
        return this
    }
    applyNormalMatrix(e) {
        for (let t = 0, n = this.count; t < n; t++) Tr.fromBufferAttribute(this, t), Tr.applyNormalMatrix(e), this.setXYZ(t, Tr.x, Tr.y, Tr.z);
        return this
    }
    transformDirection(e) {
        for (let t = 0, n = this.count; t < n; t++) Tr.fromBufferAttribute(this, t), Tr.transformDirection(e), this.setXYZ(t, Tr.x, Tr.y, Tr.z);
        return this
    }
    getComponent(e, t) {
        let n = this.array[e * this.data.stride + this.offset + t];
        return this.normalized && (n = Ur(n, this.array)), n
    }
    setComponent(e, t, n) {
        return this.normalized && (n = Kt(n, this.array)), this.data.array[e * this.data.stride + this.offset + t] = n, this
    }
    setX(e, t) {
        return this.normalized && (t = Kt(t, this.array)), this.data.array[e * this.data.stride + this.offset] = t, this
    }
    setY(e, t) {
        return this.normalized && (t = Kt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 1] = t, this
    }
    setZ(e, t) {
        return this.normalized && (t = Kt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 2] = t, this
    }
    setW(e, t) {
        return this.normalized && (t = Kt(t, this.array)), this.data.array[e * this.data.stride + this.offset + 3] = t, this
    }
    getX(e) {
        let t = this.data.array[e * this.data.stride + this.offset];
        return this.normalized && (t = Ur(t, this.array)), t
    }
    getY(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 1];
        return this.normalized && (t = Ur(t, this.array)), t
    }
    getZ(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 2];
        return this.normalized && (t = Ur(t, this.array)), t
    }
    getW(e) {
        let t = this.data.array[e * this.data.stride + this.offset + 3];
        return this.normalized && (t = Ur(t, this.array)), t
    }
    setXY(e, t, n) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = Kt(t, this.array), n = Kt(n, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this
    }
    setXYZ(e, t, n, i) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = Kt(t, this.array), n = Kt(n, this.array), i = Kt(i, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this
    }
    setXYZW(e, t, n, i, s) {
        return e = e * this.data.stride + this.offset, this.normalized && (t = Kt(t, this.array), n = Kt(n, this.array), i = Kt(i, this.array), s = Kt(s, this.array)), this.data.array[e + 0] = t, this.data.array[e + 1] = n, this.data.array[e + 2] = i, this.data.array[e + 3] = s, this
    }
    clone(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.clone(): Cloning an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s])
            }
            return new an(new this.array.constructor(t), this.itemSize, this.normalized)
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.clone(e)), new Tl(e.interleavedBuffers[this.data.uuid], this.itemSize, this.offset, this.normalized)
    }
    toJSON(e) {
        if (e === void 0) {
            console.log("THREE.InterleavedBufferAttribute.toJSON(): Serializing an interleaved buffer attribute will de-interleave buffer data.");
            const t = [];
            for (let n = 0; n < this.count; n++) {
                const i = n * this.data.stride + this.offset;
                for (let s = 0; s < this.itemSize; s++) t.push(this.data.array[i + s])
            }
            return {
                itemSize: this.itemSize,
                type: this.array.constructor.name,
                array: t,
                normalized: this.normalized
            }
        } else return e.interleavedBuffers === void 0 && (e.interleavedBuffers = {}), e.interleavedBuffers[this.data.uuid] === void 0 && (e.interleavedBuffers[this.data.uuid] = this.data.toJSON(e)), {
            isInterleavedBufferAttribute: !0,
            itemSize: this.itemSize,
            data: this.data.uuid,
            offset: this.offset,
            normalized: this.normalized
        }
    }
}
class qS extends mi {
    static get type() {
        return "SpriteMaterial"
    }
    constructor(e) {
        super(), this.isSpriteMaterial = !0, this.color = new rt(16777215), this.map = null, this.alphaMap = null, this.rotation = 0, this.sizeAttenuation = !0, this.transparent = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.rotation = e.rotation, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
    }
}
let Zu;
const Kh = new K,
    Qu = new K,
    $u = new K,
    ef = new Ue,
    qh = new Ue,
    SB = new Ot,
    Fg = new K,
    Zh = new K,
    Ug = new K,
    IE = new Ue,
    Bx = new Ue,
    BE = new Ue;
class MB extends vn {
    constructor(e = new qS) {
        if (super(), this.isSprite = !0, this.type = "Sprite", Zu === void 0) {
            Zu = new zt;
            const t = new Float32Array([-.5, -.5, 0, 0, 0, .5, -.5, 0, 1, 0, .5, .5, 0, 1, 1, -.5, .5, 0, 0, 1]),
                n = new Jp(t, 5);
            Zu.setIndex([0, 1, 2, 0, 2, 3]), Zu.setAttribute("position", new Tl(n, 3, 0, !1)), Zu.setAttribute("uv", new Tl(n, 2, 3, !1))
        }
        this.geometry = Zu, this.material = e, this.center = new Ue(.5, .5)
    }
    raycast(e, t) {
        e.camera === null && console.error('THREE.Sprite: "Raycaster.camera" needs to be set in order to raycast against sprites.'), Qu.setFromMatrixScale(this.matrixWorld), SB.copy(e.camera.matrixWorld), this.modelViewMatrix.multiplyMatrices(e.camera.matrixWorldInverse, this.matrixWorld), $u.setFromMatrixPosition(this.modelViewMatrix), e.camera.isPerspectiveCamera && this.material.sizeAttenuation === !1 && Qu.multiplyScalar(-$u.z);
        const n = this.material.rotation;
        let i, s;
        n !== 0 && (s = Math.cos(n), i = Math.sin(n));
        const o = this.center;
        Og(Fg.set(-.5, -.5, 0), $u, o, Qu, i, s), Og(Zh.set(.5, -.5, 0), $u, o, Qu, i, s), Og(Ug.set(.5, .5, 0), $u, o, Qu, i, s), IE.set(0, 0), Bx.set(1, 0), BE.set(1, 1);
        let a = e.ray.intersectTriangle(Fg, Zh, Ug, !1, Kh);
        if (a === null && (Og(Zh.set(-.5, .5, 0), $u, o, Qu, i, s), Bx.set(0, 1), a = e.ray.intersectTriangle(Fg, Ug, Zh, !1, Kh), a === null)) return;
        const l = e.ray.origin.distanceTo(Kh);
        l < e.near || l > e.far || t.push({
            distance: l,
            point: Kh.clone(),
            uv: Or.getInterpolation(Kh, Fg, Zh, Ug, IE, Bx, BE, new Ue),
            face: null,
            object: this
        })
    }
    copy(e, t) {
        return super.copy(e, t), e.center !== void 0 && this.center.copy(e.center), this.material = e.material, this
    }
}

function Og(r, e, t, n, i, s) {
    ef.subVectors(r, t).addScalar(.5).multiply(n), i !== void 0 ? (qh.x = s * ef.x - i * ef.y, qh.y = i * ef.x + s * ef.y) : qh.copy(ef), r.copy(e), r.x += qh.x, r.y += qh.y, r.applyMatrix4(SB)
}
const Ng = new K,
    DE = new K;
class wB extends vn {
    constructor() {
        super(), this._currentLevel = 0, this.type = "LOD", Object.defineProperties(this, {
            levels: {
                enumerable: !0,
                value: []
            },
            isLOD: {
                value: !0
            }
        }), this.autoUpdate = !0
    }
    copy(e) {
        super.copy(e, !1);
        const t = e.levels;
        for (let n = 0, i = t.length; n < i; n++) {
            const s = t[n];
            this.addLevel(s.object.clone(), s.distance, s.hysteresis)
        }
        return this.autoUpdate = e.autoUpdate, this
    }
    addLevel(e, t = 0, n = 0) {
        t = Math.abs(t);
        const i = this.levels;
        let s;
        for (s = 0; s < i.length && !(t < i[s].distance); s++);
        return i.splice(s, 0, {
            distance: t,
            hysteresis: n,
            object: e
        }), this.add(e), this
    }
    removeLevel(e) {
        const t = this.levels;
        for (let n = 0; n < t.length; n++)
            if (t[n].distance === e) {
                const i = t.splice(n, 1);
                return this.remove(i[0].object), !0
            }
        return !1
    }
    getCurrentLevel() {
        return this._currentLevel
    }
    getObjectForDistance(e) {
        const t = this.levels;
        if (t.length > 0) {
            let n, i;
            for (n = 1, i = t.length; n < i; n++) {
                let s = t[n].distance;
                if (t[n].object.visible && (s -= s * t[n].hysteresis), e < s) break
            }
            return t[n - 1].object
        }
        return null
    }
    raycast(e, t) {
        if (this.levels.length > 0) {
            Ng.setFromMatrixPosition(this.matrixWorld);
            const i = e.ray.origin.distanceTo(Ng);
            this.getObjectForDistance(i).raycast(e, t)
        }
    }
    update(e) {
        const t = this.levels;
        if (t.length > 1) {
            Ng.setFromMatrixPosition(e.matrixWorld), DE.setFromMatrixPosition(this.matrixWorld);
            const n = Ng.distanceTo(DE) / e.zoom;
            t[0].object.visible = !0;
            let i, s;
            for (i = 1, s = t.length; i < s; i++) {
                let o = t[i].distance;
                if (t[i].object.visible && (o -= o * t[i].hysteresis), n >= o) t[i - 1].object.visible = !1, t[i].object.visible = !0;
                else break
            }
            for (this._currentLevel = i - 1; i < s; i++) t[i].object.visible = !1
        }
    }
    toJSON(e) {
        const t = super.toJSON(e);
        this.autoUpdate === !1 && (t.object.autoUpdate = !1), t.object.levels = [];
        const n = this.levels;
        for (let i = 0, s = n.length; i < s; i++) {
            const o = n[i];
            t.object.levels.push({
                object: o.object.uuid,
                distance: o.distance,
                hysteresis: o.hysteresis
            })
        }
        return t
    }
}
const LE = new K,
    FE = new An,
    UE = new An,
    y5 = new K,
    OE = new Ot,
    kg = new K,
    Dx = new ji,
    NE = new Ot,
    Lx = new Ll;
class ZS extends Tn {
    constructor(e, t) {
        super(e, t), this.isSkinnedMesh = !0, this.type = "SkinnedMesh", this.bindMode = uA, this.bindMatrix = new Ot, this.bindMatrixInverse = new Ot, this.boundingBox = null, this.boundingSphere = null
    }
    computeBoundingBox() {
        const e = this.geometry;
        this.boundingBox === null && (this.boundingBox = new Wi), this.boundingBox.makeEmpty();
        const t = e.getAttribute("position");
        for (let n = 0; n < t.count; n++) this.getVertexPosition(n, kg), this.boundingBox.expandByPoint(kg)
    }
    computeBoundingSphere() {
        const e = this.geometry;
        this.boundingSphere === null && (this.boundingSphere = new ji), this.boundingSphere.makeEmpty();
        const t = e.getAttribute("position");
        for (let n = 0; n < t.count; n++) this.getVertexPosition(n, kg), this.boundingSphere.expandByPoint(kg)
    }
    copy(e, t) {
        return super.copy(e, t), this.bindMode = e.bindMode, this.bindMatrix.copy(e.bindMatrix), this.bindMatrixInverse.copy(e.bindMatrixInverse), this.skeleton = e.skeleton, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
    }
    raycast(e, t) {
        const n = this.material,
            i = this.matrixWorld;
        n !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), Dx.copy(this.boundingSphere), Dx.applyMatrix4(i), e.ray.intersectsSphere(Dx) !== !1 && (NE.copy(i).invert(), Lx.copy(e.ray).applyMatrix4(NE), !(this.boundingBox !== null && Lx.intersectsBox(this.boundingBox) === !1) && this._computeIntersections(e, t, Lx)))
    }
    getVertexPosition(e, t) {
        return super.getVertexPosition(e, t), this.applyBoneTransform(e, t), t
    }
    bind(e, t) {
        this.skeleton = e, t === void 0 && (this.updateMatrixWorld(!0), this.skeleton.calculateInverses(), t = this.matrixWorld), this.bindMatrix.copy(t), this.bindMatrixInverse.copy(t).invert()
    }
    pose() {
        this.skeleton.pose()
    }
    normalizeSkinWeights() {
        const e = new An,
            t = this.geometry.attributes.skinWeight;
        for (let n = 0, i = t.count; n < i; n++) {
            e.fromBufferAttribute(t, n);
            const s = 1 / e.manhattanLength();
            s !== 1 / 0 ? e.multiplyScalar(s) : e.set(1, 0, 0, 0), t.setXYZW(n, e.x, e.y, e.z, e.w)
        }
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e), this.bindMode === uA ? this.bindMatrixInverse.copy(this.matrixWorld).invert() : this.bindMode === qI ? this.bindMatrixInverse.copy(this.bindMatrix).invert() : console.warn("THREE.SkinnedMesh: Unrecognized bindMode: " + this.bindMode)
    }
    applyBoneTransform(e, t) {
        const n = this.skeleton,
            i = this.geometry;
        FE.fromBufferAttribute(i.attributes.skinIndex, e), UE.fromBufferAttribute(i.attributes.skinWeight, e), LE.copy(t).applyMatrix4(this.bindMatrix), t.set(0, 0, 0);
        for (let s = 0; s < 4; s++) {
            const o = UE.getComponent(s);
            if (o !== 0) {
                const a = FE.getComponent(s);
                OE.multiplyMatrices(n.bones[a].matrixWorld, n.boneInverses[a]), t.addScaledVector(y5.copy(LE).applyMatrix4(OE), o)
            }
        }
        return t.applyMatrix4(this.bindMatrixInverse)
    }
}
class xy extends vn {
    constructor() {
        super(), this.isBone = !0, this.type = "Bone"
    }
}
class qr extends gn {
    constructor(e = null, t = 1, n = 1, i, s, o, a, l, c = bn, u = bn, f, d) {
        super(null, o, a, l, c, u, i, s, f, d), this.isDataTexture = !0, this.image = {
            data: e,
            width: t,
            height: n
        }, this.generateMipmaps = !1, this.flipY = !1, this.unpackAlignment = 1
    }
}
const kE = new Ot,
    _5 = new Ot;
class Kp {
    constructor(e = [], t = []) {
        this.uuid = ys(), this.bones = e.slice(0), this.boneInverses = t, this.boneMatrices = null, this.boneTexture = null, this.init()
    }
    init() {
        const e = this.bones,
            t = this.boneInverses;
        if (this.boneMatrices = new Float32Array(e.length * 16), t.length === 0) this.calculateInverses();
        else if (e.length !== t.length) {
            console.warn("THREE.Skeleton: Number of inverse bone matrices does not match amount of bones."), this.boneInverses = [];
            for (let n = 0, i = this.bones.length; n < i; n++) this.boneInverses.push(new Ot)
        }
    }
    calculateInverses() {
        this.boneInverses.length = 0;
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = new Ot;
            this.bones[e] && n.copy(this.bones[e].matrixWorld).invert(), this.boneInverses.push(n)
        }
    }
    pose() {
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && n.matrixWorld.copy(this.boneInverses[e]).invert()
        }
        for (let e = 0, t = this.bones.length; e < t; e++) {
            const n = this.bones[e];
            n && (n.parent && n.parent.isBone ? (n.matrix.copy(n.parent.matrixWorld).invert(), n.matrix.multiply(n.matrixWorld)) : n.matrix.copy(n.matrixWorld), n.matrix.decompose(n.position, n.quaternion, n.scale))
        }
    }
    update() {
        const e = this.bones,
            t = this.boneInverses,
            n = this.boneMatrices,
            i = this.boneTexture;
        for (let s = 0, o = e.length; s < o; s++) {
            const a = e[s] ? e[s].matrixWorld : _5;
            kE.multiplyMatrices(a, t[s]), kE.toArray(n, s * 16)
        }
        i !== null && (i.needsUpdate = !0)
    }
    clone() {
        return new Kp(this.bones, this.boneInverses)
    }
    computeBoneTexture() {
        let e = Math.sqrt(this.bones.length * 4);
        e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4);
        t.set(this.boneMatrices);
        const n = new qr(t, e, e, kn, Bn);
        return n.needsUpdate = !0, this.boneMatrices = t, this.boneTexture = n, this
    }
    getBoneByName(e) {
        for (let t = 0, n = this.bones.length; t < n; t++) {
            const i = this.bones[t];
            if (i.name === e) return i
        }
    }
    dispose() {
        this.boneTexture !== null && (this.boneTexture.dispose(), this.boneTexture = null)
    }
    fromJSON(e, t) {
        this.uuid = e.uuid;
        for (let n = 0, i = e.bones.length; n < i; n++) {
            const s = e.bones[n];
            let o = t[s];
            o === void 0 && (console.warn("THREE.Skeleton: No bone found with UUID:", s), o = new xy), this.bones.push(o), this.boneInverses.push(new Ot().fromArray(e.boneInverses[n]))
        }
        return this.init(), this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Skeleton",
                generator: "Skeleton.toJSON"
            },
            bones: [],
            boneInverses: []
        };
        e.uuid = this.uuid;
        const t = this.bones,
            n = this.boneInverses;
        for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i];
            e.bones.push(o.uuid);
            const a = n[i];
            e.boneInverses.push(a.toArray())
        }
        return e
    }
}
class El extends an {
    constructor(e, t, n, i = 1) {
        super(e, t, n), this.isInstancedBufferAttribute = !0, this.meshPerAttribute = i
    }
    copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.meshPerAttribute = this.meshPerAttribute, e.isInstancedBufferAttribute = !0, e
    }
}
const tf = new Ot,
    zE = new Ot,
    zg = [],
    GE = new Wi,
    x5 = new Ot,
    Qh = new Tn,
    $h = new ji;
class QS extends Tn {
    constructor(e, t, n) {
        super(e, t), this.isInstancedMesh = !0, this.instanceMatrix = new El(new Float32Array(n * 16), 16), this.instanceColor = null, this.morphTexture = null, this.count = n, this.boundingBox = null, this.boundingSphere = null;
        for (let i = 0; i < n; i++) this.setMatrixAt(i, x5)
    }
    computeBoundingBox() {
        const e = this.geometry,
            t = this.count;
        this.boundingBox === null && (this.boundingBox = new Wi), e.boundingBox === null && e.computeBoundingBox(), this.boundingBox.makeEmpty();
        for (let n = 0; n < t; n++) this.getMatrixAt(n, tf), GE.copy(e.boundingBox).applyMatrix4(tf), this.boundingBox.union(GE)
    }
    computeBoundingSphere() {
        const e = this.geometry,
            t = this.count;
        this.boundingSphere === null && (this.boundingSphere = new ji), e.boundingSphere === null && e.computeBoundingSphere(), this.boundingSphere.makeEmpty();
        for (let n = 0; n < t; n++) this.getMatrixAt(n, tf), $h.copy(e.boundingSphere).applyMatrix4(tf), this.boundingSphere.union($h)
    }
    copy(e, t) {
        return super.copy(e, t), this.instanceMatrix.copy(e.instanceMatrix), e.morphTexture !== null && (this.morphTexture = e.morphTexture.clone()), e.instanceColor !== null && (this.instanceColor = e.instanceColor.clone()), this.count = e.count, e.boundingBox !== null && (this.boundingBox = e.boundingBox.clone()), e.boundingSphere !== null && (this.boundingSphere = e.boundingSphere.clone()), this
    }
    getColorAt(e, t) {
        t.fromArray(this.instanceColor.array, e * 3)
    }
    getMatrixAt(e, t) {
        t.fromArray(this.instanceMatrix.array, e * 16)
    }
    getMorphAt(e, t) {
        const n = t.morphTargetInfluences,
            i = this.morphTexture.source.data.data,
            s = n.length + 1,
            o = e * s + 1;
        for (let a = 0; a < n.length; a++) n[a] = i[o + a]
    }
    raycast(e, t) {
        const n = this.matrixWorld,
            i = this.count;
        if (Qh.geometry = this.geometry, Qh.material = this.material, Qh.material !== void 0 && (this.boundingSphere === null && this.computeBoundingSphere(), $h.copy(this.boundingSphere), $h.applyMatrix4(n), e.ray.intersectsSphere($h) !== !1))
            for (let s = 0; s < i; s++) {
                this.getMatrixAt(s, tf), zE.multiplyMatrices(n, tf), Qh.matrixWorld = zE, Qh.raycast(e, zg);
                for (let o = 0, a = zg.length; o < a; o++) {
                    const l = zg[o];
                    l.instanceId = s, l.object = this, t.push(l)
                }
                zg.length = 0
            }
    }
    setColorAt(e, t) {
        this.instanceColor === null && (this.instanceColor = new El(new Float32Array(this.instanceMatrix.count * 3).fill(1), 3)), t.toArray(this.instanceColor.array, e * 3)
    }
    setMatrixAt(e, t) {
        t.toArray(this.instanceMatrix.array, e * 16)
    }
    setMorphAt(e, t) {
        const n = t.morphTargetInfluences,
            i = n.length + 1;
        this.morphTexture === null && (this.morphTexture = new qr(new Float32Array(i * this.count), i, this.count, Hp, Bn));
        const s = this.morphTexture.source.data.data;
        let o = 0;
        for (let c = 0; c < n.length; c++) o += n[c];
        const a = this.geometry.morphTargetsRelative ? 1 : 1 - o,
            l = i * e;
        s[l] = a, s.set(n, l + 1)
    }
    updateMorphTargets() {}
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }), this.morphTexture !== null && (this.morphTexture.dispose(), this.morphTexture = null), this
    }
}

function Fx(r, e) {
    return r - e
}

function A5(r, e) {
    return r.z - e.z
}

function S5(r, e) {
    return e.z - r.z
}
class M5 {
    constructor() {
        this.index = 0, this.pool = [], this.list = []
    }
    push(e, t, n, i) {
        const s = this.pool,
            o = this.list;
        this.index >= s.length && s.push({
            start: -1,
            count: -1,
            z: -1,
            index: -1
        });
        const a = s[this.index];
        o.push(a), this.index++, a.start = e, a.count = t, a.z = n, a.index = i
    }
    reset() {
        this.list.length = 0, this.index = 0
    }
}
const Vr = new Ot,
    w5 = new rt(1, 1, 1),
    Ux = new Xp,
    Gg = new Wi,
    cc = new ji,
    ed = new K,
    HE = new K,
    b5 = new K,
    Ox = new M5,
    lr = new Tn,
    Hg = [];

function T5(r, e, t = 0) {
    const n = e.itemSize;
    if (r.isInterleavedBufferAttribute || r.array.constructor !== e.array.constructor) {
        const i = r.count;
        for (let s = 0; s < i; s++)
            for (let o = 0; o < n; o++) e.setComponent(s + t, o, r.getComponent(s, o))
    } else e.array.set(r.array, t * n);
    e.needsUpdate = !0
}

function uc(r, e) {
    if (r.constructor !== e.constructor) {
        const t = Math.min(r.length, e.length);
        for (let n = 0; n < t; n++) e[n] = r[n]
    } else {
        const t = Math.min(r.length, e.length);
        e.set(new r.constructor(r.buffer, 0, t))
    }
}
class bB extends Tn {
    get maxInstanceCount() {
        return this._maxInstanceCount
    }
    get instanceCount() {
        return this._instanceInfo.length - this._availableInstanceIds.length
    }
    get unusedVertexCount() {
        return this._maxVertexCount - this._nextVertexStart
    }
    get unusedIndexCount() {
        return this._maxIndexCount - this._nextIndexStart
    }
    constructor(e, t, n = t * 2, i) {
        super(new zt, i), this.isBatchedMesh = !0, this.perObjectFrustumCulled = !0, this.sortObjects = !0, this.boundingBox = null, this.boundingSphere = null, this.customSort = null, this._instanceInfo = [], this._geometryInfo = [], this._availableInstanceIds = [], this._availableGeometryIds = [], this._nextIndexStart = 0, this._nextVertexStart = 0, this._geometryCount = 0, this._visibilityChanged = !0, this._geometryInitialized = !1, this._maxInstanceCount = e, this._maxVertexCount = t, this._maxIndexCount = n, this._multiDrawCounts = new Int32Array(e), this._multiDrawStarts = new Int32Array(e), this._multiDrawCount = 0, this._multiDrawInstances = null, this._matricesTexture = null, this._indirectTexture = null, this._colorsTexture = null, this._initMatricesTexture(), this._initIndirectTexture()
    }
    _initMatricesTexture() {
        let e = Math.sqrt(this._maxInstanceCount * 4);
        e = Math.ceil(e / 4) * 4, e = Math.max(e, 4);
        const t = new Float32Array(e * e * 4),
            n = new qr(t, e, e, kn, Bn);
        this._matricesTexture = n
    }
    _initIndirectTexture() {
        let e = Math.sqrt(this._maxInstanceCount);
        e = Math.ceil(e);
        const t = new Uint32Array(e * e),
            n = new qr(t, e, e, Vp, fo);
        this._indirectTexture = n
    }
    _initColorsTexture() {
        let e = Math.sqrt(this._maxInstanceCount);
        e = Math.ceil(e);
        const t = new Float32Array(e * e * 4).fill(1),
            n = new qr(t, e, e, kn, Bn);
        n.colorSpace = xn.workingColorSpace, this._colorsTexture = n
    }
    _initializeGeometry(e) {
        const t = this.geometry,
            n = this._maxVertexCount,
            i = this._maxIndexCount;
        if (this._geometryInitialized === !1) {
            for (const s in e.attributes) {
                const o = e.getAttribute(s),
                    {
                        array: a,
                        itemSize: l,
                        normalized: c
                    } = o,
                    u = new a.constructor(n * l),
                    f = new an(u, l, c);
                t.setAttribute(s, f)
            }
            if (e.getIndex() !== null) {
                const s = n > 65535 ? new Uint32Array(i) : new Uint16Array(i);
                t.setIndex(new an(s, 1))
            }
            this._geometryInitialized = !0
        }
    }
    _validateGeometry(e) {
        const t = this.geometry;
        if (!!e.getIndex() != !!t.getIndex()) throw new Error('BatchedMesh: All geometries must consistently have "index".');
        for (const n in t.attributes) {
            if (!e.hasAttribute(n)) throw new Error(`BatchedMesh: Added geometry missing "${n}". All geometries must have consistent attributes.`);
            const i = e.getAttribute(n),
                s = t.getAttribute(n);
            if (i.itemSize !== s.itemSize || i.normalized !== s.normalized) throw new Error("BatchedMesh: All attributes must have a consistent itemSize and normalized value.")
        }
    }
    setCustomSort(e) {
        return this.customSort = e, this
    }
    computeBoundingBox() {
        this.boundingBox === null && (this.boundingBox = new Wi);
        const e = this.boundingBox,
            t = this._instanceInfo;
        e.makeEmpty();
        for (let n = 0, i = t.length; n < i; n++) {
            if (t[n].active === !1) continue;
            const s = t[n].geometryIndex;
            this.getMatrixAt(n, Vr), this.getBoundingBoxAt(s, Gg).applyMatrix4(Vr), e.union(Gg)
        }
    }
    computeBoundingSphere() {
        this.boundingSphere === null && (this.boundingSphere = new ji);
        const e = this.boundingSphere,
            t = this._instanceInfo;
        e.makeEmpty();
        for (let n = 0, i = t.length; n < i; n++) {
            if (t[n].active === !1) continue;
            const s = t[n].geometryIndex;
            this.getMatrixAt(n, Vr), this.getBoundingSphereAt(s, cc).applyMatrix4(Vr), e.union(cc)
        }
    }
    addInstance(e) {
        if (this._instanceInfo.length >= this.maxInstanceCount && this._availableInstanceIds.length === 0) throw new Error("BatchedMesh: Maximum item count reached.");
        const n = {
            visible: !0,
            active: !0,
            geometryIndex: e
        };
        let i = null;
        this._availableInstanceIds.length > 0 ? (this._availableInstanceIds.sort(Fx), i = this._availableInstanceIds.shift(), this._instanceInfo[i] = n) : (i = this._instanceInfo.length, this._instanceInfo.push(n));
        const s = this._matricesTexture;
        Vr.identity().toArray(s.image.data, i * 16), s.needsUpdate = !0;
        const o = this._colorsTexture;
        return o && (w5.toArray(o.image.data, i * 4), o.needsUpdate = !0), this._visibilityChanged = !0, i
    }
    addGeometry(e, t = -1, n = -1) {
        this._initializeGeometry(e), this._validateGeometry(e);
        const i = {
                vertexStart: -1,
                vertexCount: -1,
                reservedVertexCount: -1,
                indexStart: -1,
                indexCount: -1,
                reservedIndexCount: -1,
                start: -1,
                count: -1,
                boundingBox: null,
                boundingSphere: null,
                active: !0
            },
            s = this._geometryInfo;
        i.vertexStart = this._nextVertexStart, i.reservedVertexCount = t === -1 ? e.getAttribute("position").count : t;
        const o = e.getIndex();
        if (o !== null && (i.indexStart = this._nextIndexStart, i.reservedIndexCount = n === -1 ? o.count : n), i.indexStart !== -1 && i.indexStart + i.reservedIndexCount > this._maxIndexCount || i.vertexStart + i.reservedVertexCount > this._maxVertexCount) throw new Error("BatchedMesh: Reserved space request exceeds the maximum buffer size.");
        let l;
        return this._availableGeometryIds.length > 0 ? (this._availableGeometryIds.sort(Fx), l = this._availableGeometryIds.shift(), s[l] = i) : (l = this._geometryCount, this._geometryCount++, s.push(i)), this.setGeometryAt(l, e), this._nextIndexStart = i.indexStart + i.reservedIndexCount, this._nextVertexStart = i.vertexStart + i.reservedVertexCount, l
    }
    setGeometryAt(e, t) {
        if (e >= this._geometryCount) throw new Error("BatchedMesh: Maximum geometry count reached.");
        this._validateGeometry(t);
        const n = this.geometry,
            i = n.getIndex() !== null,
            s = n.getIndex(),
            o = t.getIndex(),
            a = this._geometryInfo[e];
        if (i && o.count > a.reservedIndexCount || t.attributes.position.count > a.reservedVertexCount) throw new Error("BatchedMesh: Reserved space not large enough for provided geometry.");
        const l = a.vertexStart,
            c = a.reservedVertexCount;
        a.vertexCount = t.getAttribute("position").count;
        for (const u in n.attributes) {
            const f = t.getAttribute(u),
                d = n.getAttribute(u);
            T5(f, d, l);
            const m = f.itemSize;
            for (let g = f.count, y = c; g < y; g++) {
                const v = l + g;
                for (let _ = 0; _ < m; _++) d.setComponent(v, _, 0)
            }
            d.needsUpdate = !0, d.addUpdateRange(l * m, c * m)
        }
        if (i) {
            const u = a.indexStart,
                f = a.reservedIndexCount;
            a.indexCount = t.getIndex().count;
            for (let d = 0; d < o.count; d++) s.setX(u + d, l + o.getX(d));
            for (let d = o.count, m = f; d < m; d++) s.setX(u + d, l);
            s.needsUpdate = !0, s.addUpdateRange(u, a.reservedIndexCount)
        }
        return a.start = i ? a.indexStart : a.vertexStart, a.count = i ? a.indexCount : a.vertexCount, a.boundingBox = null, t.boundingBox !== null && (a.boundingBox = t.boundingBox.clone()), a.boundingSphere = null, t.boundingSphere !== null && (a.boundingSphere = t.boundingSphere.clone()), this._visibilityChanged = !0, e
    }
    deleteGeometry(e) {
        const t = this._geometryInfo;
        if (e >= t.length || t[e].active === !1) return this;
        const n = this._instanceInfo;
        for (let i = 0, s = n.length; i < s; i++) n[i].geometryIndex === e && this.deleteInstance(i);
        return t[e].active = !1, this._availableGeometryIds.push(e), this._visibilityChanged = !0, this
    }
    deleteInstance(e) {
        const t = this._instanceInfo;
        return e >= t.length || t[e].active === !1 ? this : (t[e].active = !1, this._availableInstanceIds.push(e), this._visibilityChanged = !0, this)
    }
    optimize() {
        let e = 0,
            t = 0;
        const n = this._geometryInfo,
            i = n.map((o, a) => a).sort((o, a) => n[o].vertexStart - n[a].vertexStart),
            s = this.geometry;
        for (let o = 0, a = n.length; o < a; o++) {
            const l = i[o],
                c = n[l];
            if (c.active !== !1) {
                if (s.index !== null) {
                    if (c.indexStart !== t) {
                        const {
                            indexStart: u,
                            vertexStart: f,
                            reservedIndexCount: d
                        } = c, m = s.index, g = m.array, y = e - f;
                        for (let v = u; v < u + d; v++) g[v] = g[v] + y;
                        m.array.copyWithin(t, u, u + d), m.addUpdateRange(t, d), c.indexStart = t
                    }
                    t += c.reservedIndexCount
                }
                if (c.vertexStart !== e) {
                    const {
                        vertexStart: u,
                        reservedVertexCount: f
                    } = c, d = s.attributes;
                    for (const m in d) {
                        const g = d[m],
                            {
                                array: y,
                                itemSize: v
                            } = g;
                        y.copyWithin(e * v, u * v, (u + f) * v), g.addUpdateRange(e * v, f * v)
                    }
                    c.vertexStart = e
                }
                e += c.reservedVertexCount, c.start = s.index ? c.indexStart : c.vertexStart, this._nextIndexStart = s.index ? c.indexStart + c.reservedIndexCount : 0, this._nextVertexStart = c.vertexStart + c.reservedVertexCount
            }
        }
        return this
    }
    getBoundingBoxAt(e, t) {
        if (e >= this._geometryCount) return null;
        const n = this.geometry,
            i = this._geometryInfo[e];
        if (i.boundingBox === null) {
            const s = new Wi,
                o = n.index,
                a = n.attributes.position;
            for (let l = i.start, c = i.start + i.count; l < c; l++) {
                let u = l;
                o && (u = o.getX(u)), s.expandByPoint(ed.fromBufferAttribute(a, u))
            }
            i.boundingBox = s
        }
        return t.copy(i.boundingBox), t
    }
    getBoundingSphereAt(e, t) {
        if (e >= this._geometryCount) return null;
        const n = this.geometry,
            i = this._geometryInfo[e];
        if (i.boundingSphere === null) {
            const s = new ji;
            this.getBoundingBoxAt(e, Gg), Gg.getCenter(s.center);
            const o = n.index,
                a = n.attributes.position;
            let l = 0;
            for (let c = i.start, u = i.start + i.count; c < u; c++) {
                let f = c;
                o && (f = o.getX(f)), ed.fromBufferAttribute(a, f), l = Math.max(l, s.center.distanceToSquared(ed))
            }
            s.radius = Math.sqrt(l), i.boundingSphere = s
        }
        return t.copy(i.boundingSphere), t
    }
    setMatrixAt(e, t) {
        const n = this._instanceInfo,
            i = this._matricesTexture,
            s = this._matricesTexture.image.data;
        return e >= n.length || n[e].active === !1 ? this : (t.toArray(s, e * 16), i.needsUpdate = !0, this)
    }
    getMatrixAt(e, t) {
        const n = this._instanceInfo,
            i = this._matricesTexture.image.data;
        return e >= n.length || n[e].active === !1 ? null : t.fromArray(i, e * 16)
    }
    setColorAt(e, t) {
        this._colorsTexture === null && this._initColorsTexture();
        const n = this._colorsTexture,
            i = this._colorsTexture.image.data,
            s = this._instanceInfo;
        return e >= s.length || s[e].active === !1 ? this : (t.toArray(i, e * 4), n.needsUpdate = !0, this)
    }
    getColorAt(e, t) {
        const n = this._colorsTexture.image.data,
            i = this._instanceInfo;
        return e >= i.length || i[e].active === !1 ? null : t.fromArray(n, e * 4)
    }
    setVisibleAt(e, t) {
        const n = this._instanceInfo;
        return e >= n.length || n[e].active === !1 || n[e].visible === t ? this : (n[e].visible = t, this._visibilityChanged = !0, this)
    }
    getVisibleAt(e) {
        const t = this._instanceInfo;
        return e >= t.length || t[e].active === !1 ? !1 : t[e].visible
    }
    setGeometryIdAt(e, t) {
        const n = this._instanceInfo,
            i = this._geometryInfo;
        return e >= n.length || n[e].active === !1 || t >= i.length || i[t].active === !1 ? null : (n[e].geometryIndex = t, this)
    }
    getGeometryIdAt(e) {
        const t = this._instanceInfo;
        return e >= t.length || t[e].active === !1 ? -1 : t[e].geometryIndex
    }
    getGeometryRangeAt(e, t = {}) {
        if (e < 0 || e >= this._geometryCount) return null;
        const n = this._geometryInfo[e];
        return t.vertexStart = n.vertexStart, t.vertexCount = n.vertexCount, t.reservedVertexCount = n.reservedVertexCount, t.indexStart = n.indexStart, t.indexCount = n.indexCount, t.reservedIndexCount = n.reservedIndexCount, t.start = n.start, t.count = n.count, t
    }
    setInstanceCount(e) {
        const t = this._availableInstanceIds,
            n = this._instanceInfo;
        for (t.sort(Fx); t[t.length - 1] === n.length;) n.pop(), t.pop();
        if (e < n.length) throw new Error(`BatchedMesh: Instance ids outside the range ${e} are being used. Cannot shrink instance count.`);
        const i = new Int32Array(e),
            s = new Int32Array(e);
        uc(this._multiDrawCounts, i), uc(this._multiDrawStarts, s), this._multiDrawCounts = i, this._multiDrawStarts = s, this._maxInstanceCount = e;
        const o = this._indirectTexture,
            a = this._matricesTexture,
            l = this._colorsTexture;
        o.dispose(), this._initIndirectTexture(), uc(o.image.data, this._indirectTexture.image.data), a.dispose(), this._initMatricesTexture(), uc(a.image.data, this._matricesTexture.image.data), l && (l.dispose(), this._initColorsTexture(), uc(l.image.data, this._colorsTexture.image.data))
    }
    setGeometrySize(e, t) {
        const n = [...this._geometryInfo].filter(a => a.active);
        if (Math.max(...n.map(a => a.vertexStart + a.reservedVertexCount)) > e) throw new Error(`BatchedMesh: Geometry vertex values are being used outside the range ${t}. Cannot shrink further.`);
        if (this.geometry.index && Math.max(...n.map(l => l.indexStart + l.reservedIndexCount)) > t) throw new Error(`BatchedMesh: Geometry index values are being used outside the range ${t}. Cannot shrink further.`);
        const s = this.geometry;
        s.dispose(), this._maxVertexCount = e, this._maxIndexCount = t, this._geometryInitialized && (this._geometryInitialized = !1, this.geometry = new zt, this._initializeGeometry(s));
        const o = this.geometry;
        s.index && uc(s.index.array, o.index.array);
        for (const a in s.attributes) uc(s.attributes[a].array, o.attributes[a].array)
    }
    raycast(e, t) {
        const n = this._instanceInfo,
            i = this._geometryInfo,
            s = this.matrixWorld,
            o = this.geometry;
        lr.material = this.material, lr.geometry.index = o.index, lr.geometry.attributes = o.attributes, lr.geometry.boundingBox === null && (lr.geometry.boundingBox = new Wi), lr.geometry.boundingSphere === null && (lr.geometry.boundingSphere = new ji);
        for (let a = 0, l = n.length; a < l; a++) {
            if (!n[a].visible || !n[a].active) continue;
            const c = n[a].geometryIndex,
                u = i[c];
            lr.geometry.setDrawRange(u.start, u.count), this.getMatrixAt(a, lr.matrixWorld).premultiply(s), this.getBoundingBoxAt(c, lr.geometry.boundingBox), this.getBoundingSphereAt(c, lr.geometry.boundingSphere), lr.raycast(e, Hg);
            for (let f = 0, d = Hg.length; f < d; f++) {
                const m = Hg[f];
                m.object = this, m.batchId = a, t.push(m)
            }
            Hg.length = 0
        }
        lr.material = null, lr.geometry.index = null, lr.geometry.attributes = {}, lr.geometry.setDrawRange(0, 1 / 0)
    }
    copy(e) {
        return super.copy(e), this.geometry = e.geometry.clone(), this.perObjectFrustumCulled = e.perObjectFrustumCulled, this.sortObjects = e.sortObjects, this.boundingBox = e.boundingBox !== null ? e.boundingBox.clone() : null, this.boundingSphere = e.boundingSphere !== null ? e.boundingSphere.clone() : null, this._geometryInfo = e._geometryInfo.map(t => ({ ...t,
            boundingBox: t.boundingBox !== null ? t.boundingBox.clone() : null,
            boundingSphere: t.boundingSphere !== null ? t.boundingSphere.clone() : null
        })), this._instanceInfo = e._instanceInfo.map(t => ({ ...t
        })), this._maxInstanceCount = e._maxInstanceCount, this._maxVertexCount = e._maxVertexCount, this._maxIndexCount = e._maxIndexCount, this._geometryInitialized = e._geometryInitialized, this._geometryCount = e._geometryCount, this._multiDrawCounts = e._multiDrawCounts.slice(), this._multiDrawStarts = e._multiDrawStarts.slice(), this._matricesTexture = e._matricesTexture.clone(), this._matricesTexture.image.data = this._matricesTexture.image.data.slice(), this._colorsTexture !== null && (this._colorsTexture = e._colorsTexture.clone(), this._colorsTexture.image.data = this._colorsTexture.image.data.slice()), this
    }
    dispose() {
        return this.geometry.dispose(), this._matricesTexture.dispose(), this._matricesTexture = null, this._indirectTexture.dispose(), this._indirectTexture = null, this._colorsTexture !== null && (this._colorsTexture.dispose(), this._colorsTexture = null), this
    }
    onBeforeRender(e, t, n, i, s) {
        if (!this._visibilityChanged && !this.perObjectFrustumCulled && !this.sortObjects) return;
        const o = i.getIndex(),
            a = o === null ? 1 : o.array.BYTES_PER_ELEMENT,
            l = this._instanceInfo,
            c = this._multiDrawStarts,
            u = this._multiDrawCounts,
            f = this._geometryInfo,
            d = this.perObjectFrustumCulled,
            m = this._indirectTexture,
            g = m.image.data;
        d && (Vr.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse).multiply(this.matrixWorld), Ux.setFromProjectionMatrix(Vr, e.coordinateSystem));
        let y = 0;
        if (this.sortObjects) {
            Vr.copy(this.matrixWorld).invert(), ed.setFromMatrixPosition(n.matrixWorld).applyMatrix4(Vr), HE.set(0, 0, -1).transformDirection(n.matrixWorld).transformDirection(Vr);
            for (let A = 0, S = l.length; A < S; A++)
                if (l[A].visible && l[A].active) {
                    const M = l[A].geometryIndex;
                    this.getMatrixAt(A, Vr), this.getBoundingSphereAt(M, cc).applyMatrix4(Vr);
                    let C = !1;
                    if (d && (C = !Ux.intersectsSphere(cc)), !C) {
                        const E = f[M],
                            R = b5.subVectors(cc.center, ed).dot(HE);
                        Ox.push(E.start, E.count, R, A)
                    }
                }
            const v = Ox.list,
                _ = this.customSort;
            _ === null ? v.sort(s.transparent ? S5 : A5) : _.call(this, v, n);
            for (let A = 0, S = v.length; A < S; A++) {
                const M = v[A];
                c[y] = M.start * a, u[y] = M.count, g[y] = M.index, y++
            }
            Ox.reset()
        } else
            for (let v = 0, _ = l.length; v < _; v++)
                if (l[v].visible && l[v].active) {
                    const A = l[v].geometryIndex;
                    let S = !1;
                    if (d && (this.getMatrixAt(v, Vr), this.getBoundingSphereAt(A, cc).applyMatrix4(Vr), S = !Ux.intersectsSphere(cc)), !S) {
                        const M = f[A];
                        c[y] = M.start * a, u[y] = M.count, g[y] = v, y++
                    }
                }
        m.needsUpdate = !0, this._multiDrawCount = y, this._visibilityChanged = !1
    }
    onBeforeShadow(e, t, n, i, s, o) {
        this.onBeforeRender(e, null, i, s, o)
    }
}
class yr extends mi {
    static get type() {
        return "LineBasicMaterial"
    }
    constructor(e) {
        super(), this.isLineBasicMaterial = !0, this.color = new rt(16777215), this.map = null, this.linewidth = 1, this.linecap = "round", this.linejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.linewidth = e.linewidth, this.linecap = e.linecap, this.linejoin = e.linejoin, this.fog = e.fog, this
    }
}
const Bv = new K,
    Dv = new K,
    VE = new Ot,
    td = new Ll,
    Vg = new ji,
    Nx = new K,
    WE = new K;
class Ta extends vn {
    constructor(e = new zt, t = new yr) {
        super(), this.isLine = !0, this.type = "Line", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position,
                n = [0];
            for (let i = 1, s = t.count; i < s; i++) Bv.fromBufferAttribute(t, i - 1), Dv.fromBufferAttribute(t, i), n[i] = n[i - 1], n[i] += Bv.distanceTo(Dv);
            e.setAttribute("lineDistance", new Et(n, 1))
        } else console.warn("THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
    raycast(e, t) {
        const n = this.geometry,
            i = this.matrixWorld,
            s = e.params.Line.threshold,
            o = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(), Vg.copy(n.boundingSphere), Vg.applyMatrix4(i), Vg.radius += s, e.ray.intersectsSphere(Vg) === !1) return;
        VE.copy(i).invert(), td.copy(e.ray).applyMatrix4(VE);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = this.isLineSegments ? 2 : 1,
            u = n.index,
            d = n.attributes.position;
        if (u !== null) {
            const m = Math.max(0, o.start),
                g = Math.min(u.count, o.start + o.count);
            for (let y = m, v = g - 1; y < v; y += c) {
                const _ = u.getX(y),
                    A = u.getX(y + 1),
                    S = Wg(this, e, td, l, _, A);
                S && t.push(S)
            }
            if (this.isLineLoop) {
                const y = u.getX(g - 1),
                    v = u.getX(m),
                    _ = Wg(this, e, td, l, y, v);
                _ && t.push(_)
            }
        } else {
            const m = Math.max(0, o.start),
                g = Math.min(d.count, o.start + o.count);
            for (let y = m, v = g - 1; y < v; y += c) {
                const _ = Wg(this, e, td, l, y, y + 1);
                _ && t.push(_)
            }
            if (this.isLineLoop) {
                const y = Wg(this, e, td, l, g - 1, m);
                y && t.push(y)
            }
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}

function Wg(r, e, t, n, i, s) {
    const o = r.geometry.attributes.position;
    if (Bv.fromBufferAttribute(o, i), Dv.fromBufferAttribute(o, s), t.distanceSqToSegment(Bv, Dv, Nx, WE) > n) return;
    Nx.applyMatrix4(r.matrixWorld);
    const l = e.ray.origin.distanceTo(Nx);
    if (!(l < e.near || l > e.far)) return {
        distance: l,
        point: WE.clone().applyMatrix4(r.matrixWorld),
        index: i,
        face: null,
        faceIndex: null,
        barycoord: null,
        object: r
    }
}
const jE = new K,
    XE = new K;
class po extends Ta {
    constructor(e, t) {
        super(e, t), this.isLineSegments = !0, this.type = "LineSegments"
    }
    computeLineDistances() {
        const e = this.geometry;
        if (e.index === null) {
            const t = e.attributes.position,
                n = [];
            for (let i = 0, s = t.count; i < s; i += 2) jE.fromBufferAttribute(t, i), XE.fromBufferAttribute(t, i + 1), n[i] = i === 0 ? 0 : n[i - 1], n[i + 1] = n[i] + jE.distanceTo(XE);
            e.setAttribute("lineDistance", new Et(n, 1))
        } else console.warn("THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.");
        return this
    }
}
class $S extends Ta {
    constructor(e, t) {
        super(e, t), this.isLineLoop = !0, this.type = "LineLoop"
    }
}
class qp extends mi {
    static get type() {
        return "PointsMaterial"
    }
    constructor(e) {
        super(), this.isPointsMaterial = !0, this.color = new rt(16777215), this.map = null, this.alphaMap = null, this.size = 1, this.sizeAttenuation = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.alphaMap = e.alphaMap, this.size = e.size, this.sizeAttenuation = e.sizeAttenuation, this.fog = e.fog, this
    }
}
const YE = new Ot,
    vA = new Ll,
    jg = new ji,
    Xg = new K;
class Ay extends vn {
    constructor(e = new zt, t = new qp) {
        super(), this.isPoints = !0, this.type = "Points", this.geometry = e, this.material = t, this.updateMorphTargets()
    }
    copy(e, t) {
        return super.copy(e, t), this.material = Array.isArray(e.material) ? e.material.slice() : e.material, this.geometry = e.geometry, this
    }
    raycast(e, t) {
        const n = this.geometry,
            i = this.matrixWorld,
            s = e.params.Points.threshold,
            o = n.drawRange;
        if (n.boundingSphere === null && n.computeBoundingSphere(), jg.copy(n.boundingSphere), jg.applyMatrix4(i), jg.radius += s, e.ray.intersectsSphere(jg) === !1) return;
        YE.copy(i).invert(), vA.copy(e.ray).applyMatrix4(YE);
        const a = s / ((this.scale.x + this.scale.y + this.scale.z) / 3),
            l = a * a,
            c = n.index,
            f = n.attributes.position;
        if (c !== null) {
            const d = Math.max(0, o.start),
                m = Math.min(c.count, o.start + o.count);
            for (let g = d, y = m; g < y; g++) {
                const v = c.getX(g);
                Xg.fromBufferAttribute(f, v), JE(Xg, v, l, i, e, t, this)
            }
        } else {
            const d = Math.max(0, o.start),
                m = Math.min(f.count, o.start + o.count);
            for (let g = d, y = m; g < y; g++) Xg.fromBufferAttribute(f, g), JE(Xg, g, l, i, e, t, this)
        }
    }
    updateMorphTargets() {
        const t = this.geometry.morphAttributes,
            n = Object.keys(t);
        if (n.length > 0) {
            const i = t[n[0]];
            if (i !== void 0) {
                this.morphTargetInfluences = [], this.morphTargetDictionary = {};
                for (let s = 0, o = i.length; s < o; s++) {
                    const a = i[s].name || String(s);
                    this.morphTargetInfluences.push(0), this.morphTargetDictionary[a] = s
                }
            }
        }
    }
}

function JE(r, e, t, n, i, s, o) {
    const a = vA.distanceSqToPoint(r);
    if (a < t) {
        const l = new K;
        vA.closestPointToPoint(r, l), l.applyMatrix4(n);
        const c = i.ray.origin.distanceTo(l);
        if (c < i.near || c > i.far) return;
        s.push({
            distance: c,
            distanceToRay: Math.sqrt(a),
            point: l,
            index: e,
            face: null,
            faceIndex: null,
            barycoord: null,
            object: o
        })
    }
}
class E5 extends gn {
    constructor(e, t, n, i, s, o, a, l, c) {
        super(e, t, n, i, s, o, a, l, c), this.isVideoTexture = !0, this.minFilter = o !== void 0 ? o : nn, this.magFilter = s !== void 0 ? s : nn, this.generateMipmaps = !1;
        const u = this;

        function f() {
            u.needsUpdate = !0, e.requestVideoFrameCallback(f)
        }
        "requestVideoFrameCallback" in e && e.requestVideoFrameCallback(f)
    }
    clone() {
        return new this.constructor(this.image).copy(this)
    }
    update() {
        const e = this.image;
        "requestVideoFrameCallback" in e === !1 && e.readyState >= e.HAVE_CURRENT_DATA && (this.needsUpdate = !0)
    }
}
class C5 extends gn {
    constructor(e, t) {
        super({
            width: e,
            height: t
        }), this.isFramebufferTexture = !0, this.magFilter = bn, this.minFilter = bn, this.generateMipmaps = !1, this.needsUpdate = !0
    }
}
class Sy extends gn {
    constructor(e, t, n, i, s, o, a, l, c, u, f, d) {
        super(null, o, a, l, c, u, i, s, f, d), this.isCompressedTexture = !0, this.image = {
            width: t,
            height: n
        }, this.mipmaps = e, this.flipY = !1, this.generateMipmaps = !1
    }
}
class R5 extends Sy {
    constructor(e, t, n, i, s, o) {
        super(e, t, n, s, o), this.isCompressedArrayTexture = !0, this.image.depth = i, this.wrapR = Nn, this.layerUpdates = new Set
    }
    addLayerUpdate(e) {
        this.layerUpdates.add(e)
    }
    clearLayerUpdates() {
        this.layerUpdates.clear()
    }
}
class P5 extends Sy {
    constructor(e, t, n) {
        super(void 0, e[0].width, e[0].height, t, n, ko), this.isCompressedCubeTexture = !0, this.isCubeTexture = !0, this.image = e
    }
}
class I5 extends gn {
    constructor(e, t, n, i, s, o, a, l, c) {
        super(e, t, n, i, s, o, a, l, c), this.isCanvasTexture = !0, this.needsUpdate = !0
    }
}
class mo {
    constructor() {
        this.type = "Curve", this.arcLengthDivisions = 200
    }
    getPoint() {
        return console.warn("THREE.Curve: .getPoint() not implemented."), null
    }
    getPointAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getPoint(n, t)
    }
    getPoints(e = 5) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
        return t
    }
    getSpacedPoints(e = 5) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPointAt(n / e));
        return t
    }
    getLength() {
        const e = this.getLengths();
        return e[e.length - 1]
    }
    getLengths(e = this.arcLengthDivisions) {
        if (this.cacheArcLengths && this.cacheArcLengths.length === e + 1 && !this.needsUpdate) return this.cacheArcLengths;
        this.needsUpdate = !1;
        const t = [];
        let n, i = this.getPoint(0),
            s = 0;
        t.push(0);
        for (let o = 1; o <= e; o++) n = this.getPoint(o / e), s += n.distanceTo(i), t.push(s), i = n;
        return this.cacheArcLengths = t, t
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.getLengths()
    }
    getUtoTmapping(e, t) {
        const n = this.getLengths();
        let i = 0;
        const s = n.length;
        let o;
        t ? o = t : o = e * n[s - 1];
        let a = 0,
            l = s - 1,
            c;
        for (; a <= l;)
            if (i = Math.floor(a + (l - a) / 2), c = n[i] - o, c < 0) a = i + 1;
            else if (c > 0) l = i - 1;
        else {
            l = i;
            break
        }
        if (i = l, n[i] === o) return i / (s - 1);
        const u = n[i],
            d = n[i + 1] - u,
            m = (o - u) / d;
        return (i + m) / (s - 1)
    }
    getTangent(e, t) {
        let i = e - 1e-4,
            s = e + 1e-4;
        i < 0 && (i = 0), s > 1 && (s = 1);
        const o = this.getPoint(i),
            a = this.getPoint(s),
            l = t || (o.isVector2 ? new Ue : new K);
        return l.copy(a).sub(o).normalize(), l
    }
    getTangentAt(e, t) {
        const n = this.getUtoTmapping(e);
        return this.getTangent(n, t)
    }
    computeFrenetFrames(e, t) {
        const n = new K,
            i = [],
            s = [],
            o = [],
            a = new K,
            l = new Ot;
        for (let m = 0; m <= e; m++) {
            const g = m / e;
            i[m] = this.getTangentAt(g, new K)
        }
        s[0] = new K, o[0] = new K;
        let c = Number.MAX_VALUE;
        const u = Math.abs(i[0].x),
            f = Math.abs(i[0].y),
            d = Math.abs(i[0].z);
        u <= c && (c = u, n.set(1, 0, 0)), f <= c && (c = f, n.set(0, 1, 0)), d <= c && n.set(0, 0, 1), a.crossVectors(i[0], n).normalize(), s[0].crossVectors(i[0], a), o[0].crossVectors(i[0], s[0]);
        for (let m = 1; m <= e; m++) {
            if (s[m] = s[m - 1].clone(), o[m] = o[m - 1].clone(), a.crossVectors(i[m - 1], i[m]), a.length() > Number.EPSILON) {
                a.normalize();
                const g = Math.acos(fi(i[m - 1].dot(i[m]), -1, 1));
                s[m].applyMatrix4(l.makeRotationAxis(a, g))
            }
            o[m].crossVectors(i[m], s[m])
        }
        if (t === !0) {
            let m = Math.acos(fi(s[0].dot(s[e]), -1, 1));
            m /= e, i[0].dot(a.crossVectors(s[0], s[e])) > 0 && (m = -m);
            for (let g = 1; g <= e; g++) s[g].applyMatrix4(l.makeRotationAxis(i[g], m * g)), o[g].crossVectors(i[g], s[g])
        }
        return {
            tangents: i,
            normals: s,
            binormals: o
        }
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this
    }
    toJSON() {
        const e = {
            metadata: {
                version: 4.6,
                type: "Curve",
                generator: "Curve.toJSON"
            }
        };
        return e.arcLengthDivisions = this.arcLengthDivisions, e.type = this.type, e
    }
    fromJSON(e) {
        return this.arcLengthDivisions = e.arcLengthDivisions, this
    }
}
class My extends mo {
    constructor(e = 0, t = 0, n = 1, i = 1, s = 0, o = Math.PI * 2, a = !1, l = 0) {
        super(), this.isEllipseCurve = !0, this.type = "EllipseCurve", this.aX = e, this.aY = t, this.xRadius = n, this.yRadius = i, this.aStartAngle = s, this.aEndAngle = o, this.aClockwise = a, this.aRotation = l
    }
    getPoint(e, t = new Ue) {
        const n = t,
            i = Math.PI * 2;
        let s = this.aEndAngle - this.aStartAngle;
        const o = Math.abs(s) < Number.EPSILON;
        for (; s < 0;) s += i;
        for (; s > i;) s -= i;
        s < Number.EPSILON && (o ? s = 0 : s = i), this.aClockwise === !0 && !o && (s === i ? s = -i : s = s - i);
        const a = this.aStartAngle + e * s;
        let l = this.aX + this.xRadius * Math.cos(a),
            c = this.aY + this.yRadius * Math.sin(a);
        if (this.aRotation !== 0) {
            const u = Math.cos(this.aRotation),
                f = Math.sin(this.aRotation),
                d = l - this.aX,
                m = c - this.aY;
            l = d * u - m * f + this.aX, c = d * f + m * u + this.aY
        }
        return n.set(l, c)
    }
    copy(e) {
        return super.copy(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.aX = this.aX, e.aY = this.aY, e.xRadius = this.xRadius, e.yRadius = this.yRadius, e.aStartAngle = this.aStartAngle, e.aEndAngle = this.aEndAngle, e.aClockwise = this.aClockwise, e.aRotation = this.aRotation, e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.aX = e.aX, this.aY = e.aY, this.xRadius = e.xRadius, this.yRadius = e.yRadius, this.aStartAngle = e.aStartAngle, this.aEndAngle = e.aEndAngle, this.aClockwise = e.aClockwise, this.aRotation = e.aRotation, this
    }
}
class TB extends My {
    constructor(e, t, n, i, s, o) {
        super(e, t, n, n, i, s, o), this.isArcCurve = !0, this.type = "ArcCurve"
    }
}

function eM() {
    let r = 0,
        e = 0,
        t = 0,
        n = 0;

    function i(s, o, a, l) {
        r = s, e = a, t = -3 * s + 3 * o - 2 * a - l, n = 2 * s - 2 * o + a + l
    }
    return {
        initCatmullRom: function(s, o, a, l, c) {
            i(o, a, c * (a - s), c * (l - o))
        },
        initNonuniformCatmullRom: function(s, o, a, l, c, u, f) {
            let d = (o - s) / c - (a - s) / (c + u) + (a - o) / u,
                m = (a - o) / u - (l - o) / (u + f) + (l - a) / f;
            d *= u, m *= u, i(o, a, d, m)
        },
        calc: function(s) {
            const o = s * s,
                a = o * s;
            return r + e * s + t * o + n * a
        }
    }
}
const Yg = new K,
    kx = new eM,
    zx = new eM,
    Gx = new eM;
class EB extends mo {
    constructor(e = [], t = !1, n = "centripetal", i = .5) {
        super(), this.isCatmullRomCurve3 = !0, this.type = "CatmullRomCurve3", this.points = e, this.closed = t, this.curveType = n, this.tension = i
    }
    getPoint(e, t = new K) {
        const n = t,
            i = this.points,
            s = i.length,
            o = (s - (this.closed ? 0 : 1)) * e;
        let a = Math.floor(o),
            l = o - a;
        this.closed ? a += a > 0 ? 0 : (Math.floor(Math.abs(a) / s) + 1) * s : l === 0 && a === s - 1 && (a = s - 2, l = 1);
        let c, u;
        this.closed || a > 0 ? c = i[(a - 1) % s] : (Yg.subVectors(i[0], i[1]).add(i[0]), c = Yg);
        const f = i[a % s],
            d = i[(a + 1) % s];
        if (this.closed || a + 2 < s ? u = i[(a + 2) % s] : (Yg.subVectors(i[s - 1], i[s - 2]).add(i[s - 1]), u = Yg), this.curveType === "centripetal" || this.curveType === "chordal") {
            const m = this.curveType === "chordal" ? .5 : .25;
            let g = Math.pow(c.distanceToSquared(f), m),
                y = Math.pow(f.distanceToSquared(d), m),
                v = Math.pow(d.distanceToSquared(u), m);
            y < 1e-4 && (y = 1), g < 1e-4 && (g = y), v < 1e-4 && (v = y), kx.initNonuniformCatmullRom(c.x, f.x, d.x, u.x, g, y, v), zx.initNonuniformCatmullRom(c.y, f.y, d.y, u.y, g, y, v), Gx.initNonuniformCatmullRom(c.z, f.z, d.z, u.z, g, y, v)
        } else this.curveType === "catmullrom" && (kx.initCatmullRom(c.x, f.x, d.x, u.x, this.tension), zx.initCatmullRom(c.y, f.y, d.y, u.y, this.tension), Gx.initCatmullRom(c.z, f.z, d.z, u.z, this.tension));
        return n.set(kx.calc(l), zx.calc(l), Gx.calc(l)), n
    }
    copy(e) {
        super.copy(e), this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone())
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray())
        }
        return e.closed = this.closed, e.curveType = this.curveType, e.tension = this.tension, e
    }
    fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new K().fromArray(i))
        }
        return this.closed = e.closed, this.curveType = e.curveType, this.tension = e.tension, this
    }
}

function KE(r, e, t, n, i) {
    const s = (n - e) * .5,
        o = (i - t) * .5,
        a = r * r,
        l = r * a;
    return (2 * t - 2 * n + s + o) * l + (-3 * t + 3 * n - 2 * s - o) * a + s * r + t
}

function B5(r, e) {
    const t = 1 - r;
    return t * t * e
}

function D5(r, e) {
    return 2 * (1 - r) * r * e
}

function L5(r, e) {
    return r * r * e
}

function Yd(r, e, t, n) {
    return B5(r, e) + D5(r, t) + L5(r, n)
}

function F5(r, e) {
    const t = 1 - r;
    return t * t * t * e
}

function U5(r, e) {
    const t = 1 - r;
    return 3 * t * t * r * e
}

function O5(r, e) {
    return 3 * (1 - r) * r * r * e
}

function N5(r, e) {
    return r * r * r * e
}

function Jd(r, e, t, n, i) {
    return F5(r, e) + U5(r, t) + O5(r, n) + N5(r, i)
}
class tM extends mo {
    constructor(e = new Ue, t = new Ue, n = new Ue, i = new Ue) {
        super(), this.isCubicBezierCurve = !0, this.type = "CubicBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
    }
    getPoint(e, t = new Ue) {
        const n = t,
            i = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
        return n.set(Jd(e, i.x, s.x, o.x, a.x), Jd(e, i.y, s.y, o.y, a.y)), n
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }
}
class CB extends mo {
    constructor(e = new K, t = new K, n = new K, i = new K) {
        super(), this.isCubicBezierCurve3 = !0, this.type = "CubicBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n, this.v3 = i
    }
    getPoint(e, t = new K) {
        const n = t,
            i = this.v0,
            s = this.v1,
            o = this.v2,
            a = this.v3;
        return n.set(Jd(e, i.x, s.x, o.x, a.x), Jd(e, i.y, s.y, o.y, a.y), Jd(e, i.z, s.z, o.z, a.z)), n
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this.v3.copy(e.v3), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e.v3 = this.v3.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this.v3.fromArray(e.v3), this
    }
}
class nM extends mo {
    constructor(e = new Ue, t = new Ue) {
        super(), this.isLineCurve = !0, this.type = "LineCurve", this.v1 = e, this.v2 = t
    }
    getPoint(e, t = new Ue) {
        const n = t;
        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t = new Ue) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class RB extends mo {
    constructor(e = new K, t = new K) {
        super(), this.isLineCurve3 = !0, this.type = "LineCurve3", this.v1 = e, this.v2 = t
    }
    getPoint(e, t = new K) {
        const n = t;
        return e === 1 ? n.copy(this.v2) : (n.copy(this.v2).sub(this.v1), n.multiplyScalar(e).add(this.v1)), n
    }
    getPointAt(e, t) {
        return this.getPoint(e, t)
    }
    getTangent(e, t = new K) {
        return t.subVectors(this.v2, this.v1).normalize()
    }
    getTangentAt(e, t) {
        return this.getTangent(e, t)
    }
    copy(e) {
        return super.copy(e), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class iM extends mo {
    constructor(e = new Ue, t = new Ue, n = new Ue) {
        super(), this.isQuadraticBezierCurve = !0, this.type = "QuadraticBezierCurve", this.v0 = e, this.v1 = t, this.v2 = n
    }
    getPoint(e, t = new Ue) {
        const n = t,
            i = this.v0,
            s = this.v1,
            o = this.v2;
        return n.set(Yd(e, i.x, s.x, o.x), Yd(e, i.y, s.y, o.y)), n
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class rM extends mo {
    constructor(e = new K, t = new K, n = new K) {
        super(), this.isQuadraticBezierCurve3 = !0, this.type = "QuadraticBezierCurve3", this.v0 = e, this.v1 = t, this.v2 = n
    }
    getPoint(e, t = new K) {
        const n = t,
            i = this.v0,
            s = this.v1,
            o = this.v2;
        return n.set(Yd(e, i.x, s.x, o.x), Yd(e, i.y, s.y, o.y), Yd(e, i.z, s.z, o.z)), n
    }
    copy(e) {
        return super.copy(e), this.v0.copy(e.v0), this.v1.copy(e.v1), this.v2.copy(e.v2), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.v0 = this.v0.toArray(), e.v1 = this.v1.toArray(), e.v2 = this.v2.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.v0.fromArray(e.v0), this.v1.fromArray(e.v1), this.v2.fromArray(e.v2), this
    }
}
class sM extends mo {
    constructor(e = []) {
        super(), this.isSplineCurve = !0, this.type = "SplineCurve", this.points = e
    }
    getPoint(e, t = new Ue) {
        const n = t,
            i = this.points,
            s = (i.length - 1) * e,
            o = Math.floor(s),
            a = s - o,
            l = i[o === 0 ? o : o - 1],
            c = i[o],
            u = i[o > i.length - 2 ? i.length - 1 : o + 1],
            f = i[o > i.length - 3 ? i.length - 1 : o + 2];
        return n.set(KE(a, l.x, c.x, u.x, f.x), KE(a, l.y, c.y, u.y, f.y)), n
    }
    copy(e) {
        super.copy(e), this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(i.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.points = [];
        for (let t = 0, n = this.points.length; t < n; t++) {
            const i = this.points[t];
            e.points.push(i.toArray())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.points = [];
        for (let t = 0, n = e.points.length; t < n; t++) {
            const i = e.points[t];
            this.points.push(new Ue().fromArray(i))
        }
        return this
    }
}
var Lv = Object.freeze({
    __proto__: null,
    ArcCurve: TB,
    CatmullRomCurve3: EB,
    CubicBezierCurve: tM,
    CubicBezierCurve3: CB,
    EllipseCurve: My,
    LineCurve: nM,
    LineCurve3: RB,
    QuadraticBezierCurve: iM,
    QuadraticBezierCurve3: rM,
    SplineCurve: sM
});
class PB extends mo {
    constructor() {
        super(), this.type = "CurvePath", this.curves = [], this.autoClose = !1
    }
    add(e) {
        this.curves.push(e)
    }
    closePath() {
        const e = this.curves[0].getPoint(0),
            t = this.curves[this.curves.length - 1].getPoint(1);
        if (!e.equals(t)) {
            const n = e.isVector2 === !0 ? "LineCurve" : "LineCurve3";
            this.curves.push(new Lv[n](t, e))
        }
        return this
    }
    getPoint(e, t) {
        const n = e * this.getLength(),
            i = this.getCurveLengths();
        let s = 0;
        for (; s < i.length;) {
            if (i[s] >= n) {
                const o = i[s] - n,
                    a = this.curves[s],
                    l = a.getLength(),
                    c = l === 0 ? 0 : 1 - o / l;
                return a.getPointAt(c, t)
            }
            s++
        }
        return null
    }
    getLength() {
        const e = this.getCurveLengths();
        return e[e.length - 1]
    }
    updateArcLengths() {
        this.needsUpdate = !0, this.cacheLengths = null, this.getCurveLengths()
    }
    getCurveLengths() {
        if (this.cacheLengths && this.cacheLengths.length === this.curves.length) return this.cacheLengths;
        const e = [];
        let t = 0;
        for (let n = 0, i = this.curves.length; n < i; n++) t += this.curves[n].getLength(), e.push(t);
        return this.cacheLengths = e, e
    }
    getSpacedPoints(e = 40) {
        const t = [];
        for (let n = 0; n <= e; n++) t.push(this.getPoint(n / e));
        return this.autoClose && t.push(t[0]), t
    }
    getPoints(e = 12) {
        const t = [];
        let n;
        for (let i = 0, s = this.curves; i < s.length; i++) {
            const o = s[i],
                a = o.isEllipseCurve ? e * 2 : o.isLineCurve || o.isLineCurve3 ? 1 : o.isSplineCurve ? e * o.points.length : e,
                l = o.getPoints(a);
            for (let c = 0; c < l.length; c++) {
                const u = l[c];
                n && n.equals(u) || (t.push(u), n = u)
            }
        }
        return this.autoClose && t.length > 1 && !t[t.length - 1].equals(t[0]) && t.push(t[0]), t
    }
    copy(e) {
        super.copy(e), this.curves = [];
        for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(i.clone())
        }
        return this.autoClose = e.autoClose, this
    }
    toJSON() {
        const e = super.toJSON();
        e.autoClose = this.autoClose, e.curves = [];
        for (let t = 0, n = this.curves.length; t < n; t++) {
            const i = this.curves[t];
            e.curves.push(i.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.autoClose = e.autoClose, this.curves = [];
        for (let t = 0, n = e.curves.length; t < n; t++) {
            const i = e.curves[t];
            this.curves.push(new Lv[i.type]().fromJSON(i))
        }
        return this
    }
}
class yp extends PB {
    constructor(e) {
        super(), this.type = "Path", this.currentPoint = new Ue, e && this.setFromPoints(e)
    }
    setFromPoints(e) {
        this.moveTo(e[0].x, e[0].y);
        for (let t = 1, n = e.length; t < n; t++) this.lineTo(e[t].x, e[t].y);
        return this
    }
    moveTo(e, t) {
        return this.currentPoint.set(e, t), this
    }
    lineTo(e, t) {
        const n = new nM(this.currentPoint.clone(), new Ue(e, t));
        return this.curves.push(n), this.currentPoint.set(e, t), this
    }
    quadraticCurveTo(e, t, n, i) {
        const s = new iM(this.currentPoint.clone(), new Ue(e, t), new Ue(n, i));
        return this.curves.push(s), this.currentPoint.set(n, i), this
    }
    bezierCurveTo(e, t, n, i, s, o) {
        const a = new tM(this.currentPoint.clone(), new Ue(e, t), new Ue(n, i), new Ue(s, o));
        return this.curves.push(a), this.currentPoint.set(s, o), this
    }
    splineThru(e) {
        const t = [this.currentPoint.clone()].concat(e),
            n = new sM(t);
        return this.curves.push(n), this.currentPoint.copy(e[e.length - 1]), this
    }
    arc(e, t, n, i, s, o) {
        const a = this.currentPoint.x,
            l = this.currentPoint.y;
        return this.absarc(e + a, t + l, n, i, s, o), this
    }
    absarc(e, t, n, i, s, o) {
        return this.absellipse(e, t, n, n, i, s, o), this
    }
    ellipse(e, t, n, i, s, o, a, l) {
        const c = this.currentPoint.x,
            u = this.currentPoint.y;
        return this.absellipse(e + c, t + u, n, i, s, o, a, l), this
    }
    absellipse(e, t, n, i, s, o, a, l) {
        const c = new My(e, t, n, i, s, o, a, l);
        if (this.curves.length > 0) {
            const f = c.getPoint(0);
            f.equals(this.currentPoint) || this.lineTo(f.x, f.y)
        }
        this.curves.push(c);
        const u = c.getPoint(1);
        return this.currentPoint.copy(u), this
    }
    copy(e) {
        return super.copy(e), this.currentPoint.copy(e.currentPoint), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.currentPoint = this.currentPoint.toArray(), e
    }
    fromJSON(e) {
        return super.fromJSON(e), this.currentPoint.fromArray(e.currentPoint), this
    }
}
class Zp extends zt {
    constructor(e = [new Ue(0, -.5), new Ue(.5, 0), new Ue(0, .5)], t = 12, n = 0, i = Math.PI * 2) {
        super(), this.type = "LatheGeometry", this.parameters = {
            points: e,
            segments: t,
            phiStart: n,
            phiLength: i
        }, t = Math.floor(t), i = fi(i, 0, Math.PI * 2);
        const s = [],
            o = [],
            a = [],
            l = [],
            c = [],
            u = 1 / t,
            f = new K,
            d = new Ue,
            m = new K,
            g = new K,
            y = new K;
        let v = 0,
            _ = 0;
        for (let A = 0; A <= e.length - 1; A++) switch (A) {
            case 0:
                v = e[A + 1].x - e[A].x, _ = e[A + 1].y - e[A].y, m.x = _ * 1, m.y = -v, m.z = _ * 0, y.copy(m), m.normalize(), l.push(m.x, m.y, m.z);
                break;
            case e.length - 1:
                l.push(y.x, y.y, y.z);
                break;
            default:
                v = e[A + 1].x - e[A].x, _ = e[A + 1].y - e[A].y, m.x = _ * 1, m.y = -v, m.z = _ * 0, g.copy(m), m.x += y.x, m.y += y.y, m.z += y.z, m.normalize(), l.push(m.x, m.y, m.z), y.copy(g)
        }
        for (let A = 0; A <= t; A++) {
            const S = n + A * u * i,
                M = Math.sin(S),
                C = Math.cos(S);
            for (let E = 0; E <= e.length - 1; E++) {
                f.x = e[E].x * M, f.y = e[E].y, f.z = e[E].x * C, o.push(f.x, f.y, f.z), d.x = A / t, d.y = E / (e.length - 1), a.push(d.x, d.y);
                const R = l[3 * E + 0] * M,
                    P = l[3 * E + 1],
                    b = l[3 * E + 0] * C;
                c.push(R, P, b)
            }
        }
        for (let A = 0; A < t; A++)
            for (let S = 0; S < e.length - 1; S++) {
                const M = S + A * e.length,
                    C = M,
                    E = M + e.length,
                    R = M + e.length + 1,
                    P = M + 1;
                s.push(C, E, P), s.push(R, P, E)
            }
        this.setIndex(s), this.setAttribute("position", new Et(o, 3)), this.setAttribute("uv", new Et(a, 2)), this.setAttribute("normal", new Et(c, 3))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new Zp(e.points, e.segments, e.phiStart, e.phiLength)
    }
}
class wy extends Zp {
    constructor(e = 1, t = 1, n = 4, i = 8) {
        const s = new yp;
        s.absarc(0, -t / 2, e, Math.PI * 1.5, 0), s.absarc(0, t / 2, e, 0, Math.PI * .5), super(s.getPoints(n), i), this.type = "CapsuleGeometry", this.parameters = {
            radius: e,
            length: t,
            capSegments: n,
            radialSegments: i
        }
    }
    static fromJSON(e) {
        return new wy(e.radius, e.length, e.capSegments, e.radialSegments)
    }
}
class by extends zt {
    constructor(e = 1, t = 32, n = 0, i = Math.PI * 2) {
        super(), this.type = "CircleGeometry", this.parameters = {
            radius: e,
            segments: t,
            thetaStart: n,
            thetaLength: i
        }, t = Math.max(3, t);
        const s = [],
            o = [],
            a = [],
            l = [],
            c = new K,
            u = new Ue;
        o.push(0, 0, 0), a.push(0, 0, 1), l.push(.5, .5);
        for (let f = 0, d = 3; f <= t; f++, d += 3) {
            const m = n + f / t * i;
            c.x = e * Math.cos(m), c.y = e * Math.sin(m), o.push(c.x, c.y, c.z), a.push(0, 0, 1), u.x = (o[d] / e + 1) / 2, u.y = (o[d + 1] / e + 1) / 2, l.push(u.x, u.y)
        }
        for (let f = 1; f <= t; f++) s.push(f, f + 1, 0);
        this.setIndex(s), this.setAttribute("position", new Et(o, 3)), this.setAttribute("normal", new Et(a, 3)), this.setAttribute("uv", new Et(l, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new by(e.radius, e.segments, e.thetaStart, e.thetaLength)
    }
}
class ch extends zt {
    constructor(e = 1, t = 1, n = 1, i = 32, s = 1, o = !1, a = 0, l = Math.PI * 2) {
        super(), this.type = "CylinderGeometry", this.parameters = {
            radiusTop: e,
            radiusBottom: t,
            height: n,
            radialSegments: i,
            heightSegments: s,
            openEnded: o,
            thetaStart: a,
            thetaLength: l
        };
        const c = this;
        i = Math.floor(i), s = Math.floor(s);
        const u = [],
            f = [],
            d = [],
            m = [];
        let g = 0;
        const y = [],
            v = n / 2;
        let _ = 0;
        A(), o === !1 && (e > 0 && S(!0), t > 0 && S(!1)), this.setIndex(u), this.setAttribute("position", new Et(f, 3)), this.setAttribute("normal", new Et(d, 3)), this.setAttribute("uv", new Et(m, 2));

        function A() {
            const M = new K,
                C = new K;
            let E = 0;
            const R = (t - e) / n;
            for (let P = 0; P <= s; P++) {
                const b = [],
                    T = P / s,
                    L = T * (t - e) + e;
                for (let D = 0; D <= i; D++) {
                    const V = D / i,
                        H = V * l + a,
                        q = Math.sin(H),
                        X = Math.cos(H);
                    C.x = L * q, C.y = -T * n + v, C.z = L * X, f.push(C.x, C.y, C.z), M.set(q, R, X).normalize(), d.push(M.x, M.y, M.z), m.push(V, 1 - T), b.push(g++)
                }
                y.push(b)
            }
            for (let P = 0; P < i; P++)
                for (let b = 0; b < s; b++) {
                    const T = y[b][P],
                        L = y[b + 1][P],
                        D = y[b + 1][P + 1],
                        V = y[b][P + 1];
                    (e > 0 || b !== 0) && (u.push(T, L, V), E += 3), (t > 0 || b !== s - 1) && (u.push(L, D, V), E += 3)
                }
            c.addGroup(_, E, 0), _ += E
        }

        function S(M) {
            const C = g,
                E = new Ue,
                R = new K;
            let P = 0;
            const b = M === !0 ? e : t,
                T = M === !0 ? 1 : -1;
            for (let D = 1; D <= i; D++) f.push(0, v * T, 0), d.push(0, T, 0), m.push(.5, .5), g++;
            const L = g;
            for (let D = 0; D <= i; D++) {
                const H = D / i * l + a,
                    q = Math.cos(H),
                    X = Math.sin(H);
                R.x = b * X, R.y = v * T, R.z = b * q, f.push(R.x, R.y, R.z), d.push(0, T, 0), E.x = q * .5 + .5, E.y = X * .5 * T + .5, m.push(E.x, E.y), g++
            }
            for (let D = 0; D < i; D++) {
                const V = C + D,
                    H = L + D;
                M === !0 ? u.push(H, H + 1, V) : u.push(H + 1, H, V), P += 3
            }
            c.addGroup(_, P, M === !0 ? 1 : 2), _ += P
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new ch(e.radiusTop, e.radiusBottom, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
    }
}
class Ty extends ch {
    constructor(e = 1, t = 1, n = 32, i = 1, s = !1, o = 0, a = Math.PI * 2) {
        super(0, e, t, n, i, s, o, a), this.type = "ConeGeometry", this.parameters = {
            radius: e,
            height: t,
            radialSegments: n,
            heightSegments: i,
            openEnded: s,
            thetaStart: o,
            thetaLength: a
        }
    }
    static fromJSON(e) {
        return new Ty(e.radius, e.height, e.radialSegments, e.heightSegments, e.openEnded, e.thetaStart, e.thetaLength)
    }
}
class Ul extends zt {
    constructor(e = [], t = [], n = 1, i = 0) {
        super(), this.type = "PolyhedronGeometry", this.parameters = {
            vertices: e,
            indices: t,
            radius: n,
            detail: i
        };
        const s = [],
            o = [];
        a(i), c(n), u(), this.setAttribute("position", new Et(s, 3)), this.setAttribute("normal", new Et(s.slice(), 3)), this.setAttribute("uv", new Et(o, 2)), i === 0 ? this.computeVertexNormals() : this.normalizeNormals();

        function a(A) {
            const S = new K,
                M = new K,
                C = new K;
            for (let E = 0; E < t.length; E += 3) m(t[E + 0], S), m(t[E + 1], M), m(t[E + 2], C), l(S, M, C, A)
        }

        function l(A, S, M, C) {
            const E = C + 1,
                R = [];
            for (let P = 0; P <= E; P++) {
                R[P] = [];
                const b = A.clone().lerp(M, P / E),
                    T = S.clone().lerp(M, P / E),
                    L = E - P;
                for (let D = 0; D <= L; D++) D === 0 && P === E ? R[P][D] = b : R[P][D] = b.clone().lerp(T, D / L)
            }
            for (let P = 0; P < E; P++)
                for (let b = 0; b < 2 * (E - P) - 1; b++) {
                    const T = Math.floor(b / 2);
                    b % 2 === 0 ? (d(R[P][T + 1]), d(R[P + 1][T]), d(R[P][T])) : (d(R[P][T + 1]), d(R[P + 1][T + 1]), d(R[P + 1][T]))
                }
        }

        function c(A) {
            const S = new K;
            for (let M = 0; M < s.length; M += 3) S.x = s[M + 0], S.y = s[M + 1], S.z = s[M + 2], S.normalize().multiplyScalar(A), s[M + 0] = S.x, s[M + 1] = S.y, s[M + 2] = S.z
        }

        function u() {
            const A = new K;
            for (let S = 0; S < s.length; S += 3) {
                A.x = s[S + 0], A.y = s[S + 1], A.z = s[S + 2];
                const M = v(A) / 2 / Math.PI + .5,
                    C = _(A) / Math.PI + .5;
                o.push(M, 1 - C)
            }
            g(), f()
        }

        function f() {
            for (let A = 0; A < o.length; A += 6) {
                const S = o[A + 0],
                    M = o[A + 2],
                    C = o[A + 4],
                    E = Math.max(S, M, C),
                    R = Math.min(S, M, C);
                E > .9 && R < .1 && (S < .2 && (o[A + 0] += 1), M < .2 && (o[A + 2] += 1), C < .2 && (o[A + 4] += 1))
            }
        }

        function d(A) {
            s.push(A.x, A.y, A.z)
        }

        function m(A, S) {
            const M = A * 3;
            S.x = e[M + 0], S.y = e[M + 1], S.z = e[M + 2]
        }

        function g() {
            const A = new K,
                S = new K,
                M = new K,
                C = new K,
                E = new Ue,
                R = new Ue,
                P = new Ue;
            for (let b = 0, T = 0; b < s.length; b += 9, T += 6) {
                A.set(s[b + 0], s[b + 1], s[b + 2]), S.set(s[b + 3], s[b + 4], s[b + 5]), M.set(s[b + 6], s[b + 7], s[b + 8]), E.set(o[T + 0], o[T + 1]), R.set(o[T + 2], o[T + 3]), P.set(o[T + 4], o[T + 5]), C.copy(A).add(S).add(M).divideScalar(3);
                const L = v(C);
                y(E, T + 0, A, L), y(R, T + 2, S, L), y(P, T + 4, M, L)
            }
        }

        function y(A, S, M, C) {
            C < 0 && A.x === 1 && (o[S] = A.x - 1), M.x === 0 && M.z === 0 && (o[S] = C / 2 / Math.PI + .5)
        }

        function v(A) {
            return Math.atan2(A.z, -A.x)
        }

        function _(A) {
            return Math.atan2(-A.y, Math.sqrt(A.x * A.x + A.z * A.z))
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new Ul(e.vertices, e.indices, e.radius, e.details)
    }
}
class Ey extends Ul {
    constructor(e = 1, t = 0) {
        const n = (1 + Math.sqrt(5)) / 2,
            i = 1 / n,
            s = [-1, -1, -1, -1, -1, 1, -1, 1, -1, -1, 1, 1, 1, -1, -1, 1, -1, 1, 1, 1, -1, 1, 1, 1, 0, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, -i, -n, 0, -i, n, 0, i, -n, 0, i, n, 0, -n, 0, -i, n, 0, -i, -n, 0, i, n, 0, i],
            o = [3, 11, 7, 3, 7, 15, 3, 15, 13, 7, 19, 17, 7, 17, 6, 7, 6, 15, 17, 4, 8, 17, 8, 10, 17, 10, 6, 8, 0, 16, 8, 16, 2, 8, 2, 10, 0, 12, 1, 0, 1, 18, 0, 18, 16, 6, 10, 2, 6, 2, 13, 6, 13, 15, 2, 16, 18, 2, 18, 3, 2, 3, 13, 18, 1, 9, 18, 9, 11, 18, 11, 3, 4, 14, 12, 4, 12, 0, 4, 0, 8, 11, 9, 5, 11, 5, 19, 11, 19, 7, 19, 5, 14, 19, 14, 4, 19, 4, 17, 1, 12, 14, 1, 14, 5, 1, 5, 9];
        super(s, o, e, t), this.type = "DodecahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Ey(e.radius, e.detail)
    }
}
const Jg = new K,
    Kg = new K,
    Hx = new K,
    qg = new Or;
class IB extends zt {
    constructor(e = null, t = 1) {
        if (super(), this.type = "EdgesGeometry", this.parameters = {
                geometry: e,
                thresholdAngle: t
            }, e !== null) {
            const i = Math.pow(10, 4),
                s = Math.cos(Jc * t),
                o = e.getIndex(),
                a = e.getAttribute("position"),
                l = o ? o.count : a.count,
                c = [0, 0, 0],
                u = ["a", "b", "c"],
                f = new Array(3),
                d = {},
                m = [];
            for (let g = 0; g < l; g += 3) {
                o ? (c[0] = o.getX(g), c[1] = o.getX(g + 1), c[2] = o.getX(g + 2)) : (c[0] = g, c[1] = g + 1, c[2] = g + 2);
                const {
                    a: y,
                    b: v,
                    c: _
                } = qg;
                if (y.fromBufferAttribute(a, c[0]), v.fromBufferAttribute(a, c[1]), _.fromBufferAttribute(a, c[2]), qg.getNormal(Hx), f[0] = `${Math.round(y.x*i)},${Math.round(y.y*i)},${Math.round(y.z*i)}`, f[1] = `${Math.round(v.x*i)},${Math.round(v.y*i)},${Math.round(v.z*i)}`, f[2] = `${Math.round(_.x*i)},${Math.round(_.y*i)},${Math.round(_.z*i)}`, !(f[0] === f[1] || f[1] === f[2] || f[2] === f[0]))
                    for (let A = 0; A < 3; A++) {
                        const S = (A + 1) % 3,
                            M = f[A],
                            C = f[S],
                            E = qg[u[A]],
                            R = qg[u[S]],
                            P = `${M}_${C}`,
                            b = `${C}_${M}`;
                        b in d && d[b] ? (Hx.dot(d[b].normal) <= s && (m.push(E.x, E.y, E.z), m.push(R.x, R.y, R.z)), d[b] = null) : P in d || (d[P] = {
                            index0: c[A],
                            index1: c[S],
                            normal: Hx.clone()
                        })
                    }
            }
            for (const g in d)
                if (d[g]) {
                    const {
                        index0: y,
                        index1: v
                    } = d[g];
                    Jg.fromBufferAttribute(a, y), Kg.fromBufferAttribute(a, v), m.push(Jg.x, Jg.y, Jg.z), m.push(Kg.x, Kg.y, Kg.z)
                }
            this.setAttribute("position", new Et(m, 3))
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
}
class dl extends yp {
    constructor(e) {
        super(e), this.uuid = ys(), this.type = "Shape", this.holes = []
    }
    getPointsHoles(e) {
        const t = [];
        for (let n = 0, i = this.holes.length; n < i; n++) t[n] = this.holes[n].getPoints(e);
        return t
    }
    extractPoints(e) {
        return {
            shape: this.getPoints(e),
            holes: this.getPointsHoles(e)
        }
    }
    copy(e) {
        super.copy(e), this.holes = [];
        for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(i.clone())
        }
        return this
    }
    toJSON() {
        const e = super.toJSON();
        e.uuid = this.uuid, e.holes = [];
        for (let t = 0, n = this.holes.length; t < n; t++) {
            const i = this.holes[t];
            e.holes.push(i.toJSON())
        }
        return e
    }
    fromJSON(e) {
        super.fromJSON(e), this.uuid = e.uuid, this.holes = [];
        for (let t = 0, n = e.holes.length; t < n; t++) {
            const i = e.holes[t];
            this.holes.push(new yp().fromJSON(i))
        }
        return this
    }
}
const k5 = {
    triangulate: function(r, e, t = 2) {
        const n = e && e.length,
            i = n ? e[0] * t : r.length;
        let s = BB(r, 0, i, t, !0);
        const o = [];
        if (!s || s.next === s.prev) return o;
        let a, l, c, u, f, d, m;
        if (n && (s = W5(r, e, s, t)), r.length > 80 * t) {
            a = c = r[0], l = u = r[1];
            for (let g = t; g < i; g += t) f = r[g], d = r[g + 1], f < a && (a = f), d < l && (l = d), f > c && (c = f), d > u && (u = d);
            m = Math.max(c - a, u - l), m = m !== 0 ? 32767 / m : 0
        }
        return _p(s, o, t, a, l, m, 0), o
    }
};

function BB(r, e, t, n, i) {
    let s, o;
    if (i === tV(r, e, t, n) > 0)
        for (s = e; s < t; s += n) o = qE(s, r[s], r[s + 1], o);
    else
        for (s = t - n; s >= e; s -= n) o = qE(s, r[s], r[s + 1], o);
    return o && Cy(o, o.next) && (Ap(o), o = o.next), o
}

function lu(r, e) {
    if (!r) return r;
    e || (e = r);
    let t = r,
        n;
    do
        if (n = !1, !t.steiner && (Cy(t, t.next) || oi(t.prev, t, t.next) === 0)) {
            if (Ap(t), t = e = t.prev, t === t.next) break;
            n = !0
        } else t = t.next; while (n || t !== e);
    return e
}

function _p(r, e, t, n, i, s, o) {
    if (!r) return;
    !o && s && K5(r, n, i, s);
    let a = r,
        l, c;
    for (; r.prev !== r.next;) {
        if (l = r.prev, c = r.next, s ? G5(r, n, i, s) : z5(r)) {
            e.push(l.i / t | 0), e.push(r.i / t | 0), e.push(c.i / t | 0), Ap(r), r = c.next, a = c.next;
            continue
        }
        if (r = c, r === a) {
            o ? o === 1 ? (r = H5(lu(r), e, t), _p(r, e, t, n, i, s, 2)) : o === 2 && V5(r, e, t, n, i, s) : _p(lu(r), e, t, n, i, s, 1);
            break
        }
    }
}

function z5(r) {
    const e = r.prev,
        t = r,
        n = r.next;
    if (oi(e, t, n) >= 0) return !1;
    const i = e.x,
        s = t.x,
        o = n.x,
        a = e.y,
        l = t.y,
        c = n.y,
        u = i < s ? i < o ? i : o : s < o ? s : o,
        f = a < l ? a < c ? a : c : l < c ? l : c,
        d = i > s ? i > o ? i : o : s > o ? s : o,
        m = a > l ? a > c ? a : c : l > c ? l : c;
    let g = n.next;
    for (; g !== e;) {
        if (g.x >= u && g.x <= d && g.y >= f && g.y <= m && vf(i, a, s, l, o, c, g.x, g.y) && oi(g.prev, g, g.next) >= 0) return !1;
        g = g.next
    }
    return !0
}

function G5(r, e, t, n) {
    const i = r.prev,
        s = r,
        o = r.next;
    if (oi(i, s, o) >= 0) return !1;
    const a = i.x,
        l = s.x,
        c = o.x,
        u = i.y,
        f = s.y,
        d = o.y,
        m = a < l ? a < c ? a : c : l < c ? l : c,
        g = u < f ? u < d ? u : d : f < d ? f : d,
        y = a > l ? a > c ? a : c : l > c ? l : c,
        v = u > f ? u > d ? u : d : f > d ? f : d,
        _ = yA(m, g, e, t, n),
        A = yA(y, v, e, t, n);
    let S = r.prevZ,
        M = r.nextZ;
    for (; S && S.z >= _ && M && M.z <= A;) {
        if (S.x >= m && S.x <= y && S.y >= g && S.y <= v && S !== i && S !== o && vf(a, u, l, f, c, d, S.x, S.y) && oi(S.prev, S, S.next) >= 0 || (S = S.prevZ, M.x >= m && M.x <= y && M.y >= g && M.y <= v && M !== i && M !== o && vf(a, u, l, f, c, d, M.x, M.y) && oi(M.prev, M, M.next) >= 0)) return !1;
        M = M.nextZ
    }
    for (; S && S.z >= _;) {
        if (S.x >= m && S.x <= y && S.y >= g && S.y <= v && S !== i && S !== o && vf(a, u, l, f, c, d, S.x, S.y) && oi(S.prev, S, S.next) >= 0) return !1;
        S = S.prevZ
    }
    for (; M && M.z <= A;) {
        if (M.x >= m && M.x <= y && M.y >= g && M.y <= v && M !== i && M !== o && vf(a, u, l, f, c, d, M.x, M.y) && oi(M.prev, M, M.next) >= 0) return !1;
        M = M.nextZ
    }
    return !0
}

function H5(r, e, t) {
    let n = r;
    do {
        const i = n.prev,
            s = n.next.next;
        !Cy(i, s) && DB(i, n, n.next, s) && xp(i, s) && xp(s, i) && (e.push(i.i / t | 0), e.push(n.i / t | 0), e.push(s.i / t | 0), Ap(n), Ap(n.next), n = r = s), n = n.next
    } while (n !== r);
    return lu(n)
}

function V5(r, e, t, n, i, s) {
    let o = r;
    do {
        let a = o.next.next;
        for (; a !== o.prev;) {
            if (o.i !== a.i && Q5(o, a)) {
                let l = LB(o, a);
                o = lu(o, o.next), l = lu(l, l.next), _p(o, e, t, n, i, s, 0), _p(l, e, t, n, i, s, 0);
                return
            }
            a = a.next
        }
        o = o.next
    } while (o !== r)
}

function W5(r, e, t, n) {
    const i = [];
    let s, o, a, l, c;
    for (s = 0, o = e.length; s < o; s++) a = e[s] * n, l = s < o - 1 ? e[s + 1] * n : r.length, c = BB(r, a, l, n, !1), c === c.next && (c.steiner = !0), i.push(Z5(c));
    for (i.sort(j5), s = 0; s < i.length; s++) t = X5(i[s], t);
    return t
}

function j5(r, e) {
    return r.x - e.x
}

function X5(r, e) {
    const t = Y5(r, e);
    if (!t) return e;
    const n = LB(t, r);
    return lu(n, n.next), lu(t, t.next)
}

function Y5(r, e) {
    let t = e,
        n = -1 / 0,
        i;
    const s = r.x,
        o = r.y;
    do {
        if (o <= t.y && o >= t.next.y && t.next.y !== t.y) {
            const d = t.x + (o - t.y) * (t.next.x - t.x) / (t.next.y - t.y);
            if (d <= s && d > n && (n = d, i = t.x < t.next.x ? t : t.next, d === s)) return i
        }
        t = t.next
    } while (t !== e);
    if (!i) return null;
    const a = i,
        l = i.x,
        c = i.y;
    let u = 1 / 0,
        f;
    t = i;
    do s >= t.x && t.x >= l && s !== t.x && vf(o < c ? s : n, o, l, c, o < c ? n : s, o, t.x, t.y) && (f = Math.abs(o - t.y) / (s - t.x), xp(t, r) && (f < u || f === u && (t.x > i.x || t.x === i.x && J5(i, t))) && (i = t, u = f)), t = t.next; while (t !== a);
    return i
}

function J5(r, e) {
    return oi(r.prev, r, e.prev) < 0 && oi(e.next, r, r.next) < 0
}

function K5(r, e, t, n) {
    let i = r;
    do i.z === 0 && (i.z = yA(i.x, i.y, e, t, n)), i.prevZ = i.prev, i.nextZ = i.next, i = i.next; while (i !== r);
    i.prevZ.nextZ = null, i.prevZ = null, q5(i)
}

function q5(r) {
    let e, t, n, i, s, o, a, l, c = 1;
    do {
        for (t = r, r = null, s = null, o = 0; t;) {
            for (o++, n = t, a = 0, e = 0; e < c && (a++, n = n.nextZ, !!n); e++);
            for (l = c; a > 0 || l > 0 && n;) a !== 0 && (l === 0 || !n || t.z <= n.z) ? (i = t, t = t.nextZ, a--) : (i = n, n = n.nextZ, l--), s ? s.nextZ = i : r = i, i.prevZ = s, s = i;
            t = n
        }
        s.nextZ = null, c *= 2
    } while (o > 1);
    return r
}

function yA(r, e, t, n, i) {
    return r = (r - t) * i | 0, e = (e - n) * i | 0, r = (r | r << 8) & 16711935, r = (r | r << 4) & 252645135, r = (r | r << 2) & 858993459, r = (r | r << 1) & 1431655765, e = (e | e << 8) & 16711935, e = (e | e << 4) & 252645135, e = (e | e << 2) & 858993459, e = (e | e << 1) & 1431655765, r | e << 1
}

function Z5(r) {
    let e = r,
        t = r;
    do(e.x < t.x || e.x === t.x && e.y < t.y) && (t = e), e = e.next; while (e !== r);
    return t
}

function vf(r, e, t, n, i, s, o, a) {
    return (i - o) * (e - a) >= (r - o) * (s - a) && (r - o) * (n - a) >= (t - o) * (e - a) && (t - o) * (s - a) >= (i - o) * (n - a)
}

function Q5(r, e) {
    return r.next.i !== e.i && r.prev.i !== e.i && !$5(r, e) && (xp(r, e) && xp(e, r) && eV(r, e) && (oi(r.prev, r, e.prev) || oi(r, e.prev, e)) || Cy(r, e) && oi(r.prev, r, r.next) > 0 && oi(e.prev, e, e.next) > 0)
}

function oi(r, e, t) {
    return (e.y - r.y) * (t.x - e.x) - (e.x - r.x) * (t.y - e.y)
}

function Cy(r, e) {
    return r.x === e.x && r.y === e.y
}

function DB(r, e, t, n) {
    const i = Qg(oi(r, e, t)),
        s = Qg(oi(r, e, n)),
        o = Qg(oi(t, n, r)),
        a = Qg(oi(t, n, e));
    return !!(i !== s && o !== a || i === 0 && Zg(r, t, e) || s === 0 && Zg(r, n, e) || o === 0 && Zg(t, r, n) || a === 0 && Zg(t, e, n))
}

function Zg(r, e, t) {
    return e.x <= Math.max(r.x, t.x) && e.x >= Math.min(r.x, t.x) && e.y <= Math.max(r.y, t.y) && e.y >= Math.min(r.y, t.y)
}

function Qg(r) {
    return r > 0 ? 1 : r < 0 ? -1 : 0
}

function $5(r, e) {
    let t = r;
    do {
        if (t.i !== r.i && t.next.i !== r.i && t.i !== e.i && t.next.i !== e.i && DB(t, t.next, r, e)) return !0;
        t = t.next
    } while (t !== r);
    return !1
}

function xp(r, e) {
    return oi(r.prev, r, r.next) < 0 ? oi(r, e, r.next) >= 0 && oi(r, r.prev, e) >= 0 : oi(r, e, r.prev) < 0 || oi(r, r.next, e) < 0
}

function eV(r, e) {
    let t = r,
        n = !1;
    const i = (r.x + e.x) / 2,
        s = (r.y + e.y) / 2;
    do t.y > s != t.next.y > s && t.next.y !== t.y && i < (t.next.x - t.x) * (s - t.y) / (t.next.y - t.y) + t.x && (n = !n), t = t.next; while (t !== r);
    return n
}

function LB(r, e) {
    const t = new _A(r.i, r.x, r.y),
        n = new _A(e.i, e.x, e.y),
        i = r.next,
        s = e.prev;
    return r.next = e, e.prev = r, t.next = i, i.prev = t, n.next = t, t.prev = n, s.next = n, n.prev = s, n
}

function qE(r, e, t, n) {
    const i = new _A(r, e, t);
    return n ? (i.next = n.next, i.prev = n, n.next.prev = i, n.next = i) : (i.prev = i, i.next = i), i
}

function Ap(r) {
    r.next.prev = r.prev, r.prev.next = r.next, r.prevZ && (r.prevZ.nextZ = r.nextZ), r.nextZ && (r.nextZ.prevZ = r.prevZ)
}

function _A(r, e, t) {
    this.i = r, this.x = e, this.y = t, this.prev = null, this.next = null, this.z = 0, this.prevZ = null, this.nextZ = null, this.steiner = !1
}

function tV(r, e, t, n) {
    let i = 0;
    for (let s = e, o = t - n; s < t; s += n) i += (r[o] - r[s]) * (r[s + 1] + r[o + 1]), o = s;
    return i
}
class Fo {
    static area(e) {
        const t = e.length;
        let n = 0;
        for (let i = t - 1, s = 0; s < t; i = s++) n += e[i].x * e[s].y - e[s].x * e[i].y;
        return n * .5
    }
    static isClockWise(e) {
        return Fo.area(e) < 0
    }
    static triangulateShape(e, t) {
        const n = [],
            i = [],
            s = [];
        ZE(e), QE(n, e);
        let o = e.length;
        t.forEach(ZE);
        for (let l = 0; l < t.length; l++) i.push(o), o += t[l].length, QE(n, t[l]);
        const a = k5.triangulate(n, i);
        for (let l = 0; l < a.length; l += 3) s.push(a.slice(l, l + 3));
        return s
    }
}

function ZE(r) {
    const e = r.length;
    e > 2 && r[e - 1].equals(r[0]) && r.pop()
}

function QE(r, e) {
    for (let t = 0; t < e.length; t++) r.push(e[t].x), r.push(e[t].y)
}
class Ry extends zt {
    constructor(e = new dl([new Ue(.5, .5), new Ue(-.5, .5), new Ue(-.5, -.5), new Ue(.5, -.5)]), t = {}) {
        super(), this.type = "ExtrudeGeometry", this.parameters = {
            shapes: e,
            options: t
        }, e = Array.isArray(e) ? e : [e];
        const n = this,
            i = [],
            s = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a];
            o(c)
        }
        this.setAttribute("position", new Et(i, 3)), this.setAttribute("uv", new Et(s, 2)), this.computeVertexNormals();

        function o(a) {
            const l = [],
                c = t.curveSegments !== void 0 ? t.curveSegments : 12,
                u = t.steps !== void 0 ? t.steps : 1,
                f = t.depth !== void 0 ? t.depth : 1;
            let d = t.bevelEnabled !== void 0 ? t.bevelEnabled : !0,
                m = t.bevelThickness !== void 0 ? t.bevelThickness : .2,
                g = t.bevelSize !== void 0 ? t.bevelSize : m - .1,
                y = t.bevelOffset !== void 0 ? t.bevelOffset : 0,
                v = t.bevelSegments !== void 0 ? t.bevelSegments : 3;
            const _ = t.extrudePath,
                A = t.UVGenerator !== void 0 ? t.UVGenerator : nV;
            let S, M = !1,
                C, E, R, P;
            _ && (S = _.getSpacedPoints(u), M = !0, d = !1, C = _.computeFrenetFrames(u, !1), E = new K, R = new K, P = new K), d || (v = 0, m = 0, g = 0, y = 0);
            const b = a.extractPoints(c);
            let T = b.shape;
            const L = b.holes;
            if (!Fo.isClockWise(T)) {
                T = T.reverse();
                for (let pe = 0, xe = L.length; pe < xe; pe++) {
                    const J = L[pe];
                    Fo.isClockWise(J) && (L[pe] = J.reverse())
                }
            }
            const V = Fo.triangulateShape(T, L),
                H = T;
            for (let pe = 0, xe = L.length; pe < xe; pe++) {
                const J = L[pe];
                T = T.concat(J)
            }

            function q(pe, xe, J) {
                return xe || console.error("THREE.ExtrudeGeometry: vec does not exist"), pe.clone().addScaledVector(xe, J)
            }
            const X = T.length,
                oe = V.length;

            function Y(pe, xe, J) {
                let De, Ce, se;
                const Se = pe.x - xe.x,
                    Xe = pe.y - xe.y,
                    Le = J.x - pe.x,
                    k = J.y - pe.y,
                    z = Se * Se + Xe * Xe,
                    ue = Se * k - Xe * Le;
                if (Math.abs(ue) > Number.EPSILON) {
                    const ye = Math.sqrt(z),
                        ge = Math.sqrt(Le * Le + k * k),
                        Re = xe.x - Xe / ye,
                        Be = xe.y + Se / ye,
                        Fe = J.x - k / ge,
                        Ne = J.y + Le / ge,
                        ot = ((Fe - Re) * k - (Ne - Be) * Le) / (Se * k - Xe * Le);
                    De = Re + Se * ot - pe.x, Ce = Be + Xe * ot - pe.y;
                    const je = De * De + Ce * Ce;
                    if (je <= 2) return new Ue(De, Ce);
                    se = Math.sqrt(je / 2)
                } else {
                    let ye = !1;
                    Se > Number.EPSILON ? Le > Number.EPSILON && (ye = !0) : Se < -Number.EPSILON ? Le < -Number.EPSILON && (ye = !0) : Math.sign(Xe) === Math.sign(k) && (ye = !0), ye ? (De = -Xe, Ce = Se, se = Math.sqrt(z)) : (De = Se, Ce = Xe, se = Math.sqrt(z / 2))
                }
                return new Ue(De / se, Ce / se)
            }
            const Z = [];
            for (let pe = 0, xe = H.length, J = xe - 1, De = pe + 1; pe < xe; pe++, J++, De++) J === xe && (J = 0), De === xe && (De = 0), Z[pe] = Y(H[pe], H[J], H[De]);
            const U = [];
            let j, te = Z.concat();
            for (let pe = 0, xe = L.length; pe < xe; pe++) {
                const J = L[pe];
                j = [];
                for (let De = 0, Ce = J.length, se = Ce - 1, Se = De + 1; De < Ce; De++, se++, Se++) se === Ce && (se = 0), Se === Ce && (Se = 0), j[De] = Y(J[De], J[se], J[Se]);
                U.push(j), te = te.concat(j)
            }
            for (let pe = 0; pe < v; pe++) {
                const xe = pe / v,
                    J = m * Math.cos(xe * Math.PI / 2),
                    De = g * Math.sin(xe * Math.PI / 2) + y;
                for (let Ce = 0, se = H.length; Ce < se; Ce++) {
                    const Se = q(H[Ce], Z[Ce], De);
                    ce(Se.x, Se.y, -J)
                }
                for (let Ce = 0, se = L.length; Ce < se; Ce++) {
                    const Se = L[Ce];
                    j = U[Ce];
                    for (let Xe = 0, Le = Se.length; Xe < Le; Xe++) {
                        const k = q(Se[Xe], j[Xe], De);
                        ce(k.x, k.y, -J)
                    }
                }
            }
            const he = g + y;
            for (let pe = 0; pe < X; pe++) {
                const xe = d ? q(T[pe], te[pe], he) : T[pe];
                M ? (R.copy(C.normals[0]).multiplyScalar(xe.x), E.copy(C.binormals[0]).multiplyScalar(xe.y), P.copy(S[0]).add(R).add(E), ce(P.x, P.y, P.z)) : ce(xe.x, xe.y, 0)
            }
            for (let pe = 1; pe <= u; pe++)
                for (let xe = 0; xe < X; xe++) {
                    const J = d ? q(T[xe], te[xe], he) : T[xe];
                    M ? (R.copy(C.normals[pe]).multiplyScalar(J.x), E.copy(C.binormals[pe]).multiplyScalar(J.y), P.copy(S[pe]).add(R).add(E), ce(P.x, P.y, P.z)) : ce(J.x, J.y, f / u * pe)
                }
            for (let pe = v - 1; pe >= 0; pe--) {
                const xe = pe / v,
                    J = m * Math.cos(xe * Math.PI / 2),
                    De = g * Math.sin(xe * Math.PI / 2) + y;
                for (let Ce = 0, se = H.length; Ce < se; Ce++) {
                    const Se = q(H[Ce], Z[Ce], De);
                    ce(Se.x, Se.y, f + J)
                }
                for (let Ce = 0, se = L.length; Ce < se; Ce++) {
                    const Se = L[Ce];
                    j = U[Ce];
                    for (let Xe = 0, Le = Se.length; Xe < Le; Xe++) {
                        const k = q(Se[Xe], j[Xe], De);
                        M ? ce(k.x, k.y + S[u - 1].y, S[u - 1].x + J) : ce(k.x, k.y, f + J)
                    }
                }
            }
            $(), ne();

            function $() {
                const pe = i.length / 3;
                if (d) {
                    let xe = 0,
                        J = X * xe;
                    for (let De = 0; De < oe; De++) {
                        const Ce = V[De];
                        _e(Ce[2] + J, Ce[1] + J, Ce[0] + J)
                    }
                    xe = u + v * 2, J = X * xe;
                    for (let De = 0; De < oe; De++) {
                        const Ce = V[De];
                        _e(Ce[0] + J, Ce[1] + J, Ce[2] + J)
                    }
                } else {
                    for (let xe = 0; xe < oe; xe++) {
                        const J = V[xe];
                        _e(J[2], J[1], J[0])
                    }
                    for (let xe = 0; xe < oe; xe++) {
                        const J = V[xe];
                        _e(J[0] + X * u, J[1] + X * u, J[2] + X * u)
                    }
                }
                n.addGroup(pe, i.length / 3 - pe, 0)
            }

            function ne() {
                const pe = i.length / 3;
                let xe = 0;
                me(H, xe), xe += H.length;
                for (let J = 0, De = L.length; J < De; J++) {
                    const Ce = L[J];
                    me(Ce, xe), xe += Ce.length
                }
                n.addGroup(pe, i.length / 3 - pe, 1)
            }

            function me(pe, xe) {
                let J = pe.length;
                for (; --J >= 0;) {
                    const De = J;
                    let Ce = J - 1;
                    Ce < 0 && (Ce = pe.length - 1);
                    for (let se = 0, Se = u + v * 2; se < Se; se++) {
                        const Xe = X * se,
                            Le = X * (se + 1),
                            k = xe + De + Xe,
                            z = xe + Ce + Xe,
                            ue = xe + Ce + Le,
                            ye = xe + De + Le;
                        Oe(k, z, ue, ye)
                    }
                }
            }

            function ce(pe, xe, J) {
                l.push(pe), l.push(xe), l.push(J)
            }

            function _e(pe, xe, J) {
                ke(pe), ke(xe), ke(J);
                const De = i.length / 3,
                    Ce = A.generateTopUV(n, i, De - 3, De - 2, De - 1);
                Ee(Ce[0]), Ee(Ce[1]), Ee(Ce[2])
            }

            function Oe(pe, xe, J, De) {
                ke(pe), ke(xe), ke(De), ke(xe), ke(J), ke(De);
                const Ce = i.length / 3,
                    se = A.generateSideWallUV(n, i, Ce - 6, Ce - 3, Ce - 2, Ce - 1);
                Ee(se[0]), Ee(se[1]), Ee(se[3]), Ee(se[1]), Ee(se[2]), Ee(se[3])
            }

            function ke(pe) {
                i.push(l[pe * 3 + 0]), i.push(l[pe * 3 + 1]), i.push(l[pe * 3 + 2])
            }

            function Ee(pe) {
                s.push(pe.x), s.push(pe.y)
            }
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    toJSON() {
        const e = super.toJSON(),
            t = this.parameters.shapes,
            n = this.parameters.options;
        return iV(t, n, e)
    }
    static fromJSON(e, t) {
        const n = [];
        for (let s = 0, o = e.shapes.length; s < o; s++) {
            const a = t[e.shapes[s]];
            n.push(a)
        }
        const i = e.options.extrudePath;
        return i !== void 0 && (e.options.extrudePath = new Lv[i.type]().fromJSON(i)), new Ry(n, e.options)
    }
}
const nV = {
    generateTopUV: function(r, e, t, n, i) {
        const s = e[t * 3],
            o = e[t * 3 + 1],
            a = e[n * 3],
            l = e[n * 3 + 1],
            c = e[i * 3],
            u = e[i * 3 + 1];
        return [new Ue(s, o), new Ue(a, l), new Ue(c, u)]
    },
    generateSideWallUV: function(r, e, t, n, i, s) {
        const o = e[t * 3],
            a = e[t * 3 + 1],
            l = e[t * 3 + 2],
            c = e[n * 3],
            u = e[n * 3 + 1],
            f = e[n * 3 + 2],
            d = e[i * 3],
            m = e[i * 3 + 1],
            g = e[i * 3 + 2],
            y = e[s * 3],
            v = e[s * 3 + 1],
            _ = e[s * 3 + 2];
        return Math.abs(a - u) < Math.abs(o - c) ? [new Ue(o, 1 - l), new Ue(c, 1 - f), new Ue(d, 1 - g), new Ue(y, 1 - _)] : [new Ue(a, 1 - l), new Ue(u, 1 - f), new Ue(m, 1 - g), new Ue(v, 1 - _)]
    }
};

function iV(r, e, t) {
    if (t.shapes = [], Array.isArray(r))
        for (let n = 0, i = r.length; n < i; n++) {
            const s = r[n];
            t.shapes.push(s.uuid)
        } else t.shapes.push(r.uuid);
    return t.options = Object.assign({}, e), e.extrudePath !== void 0 && (t.options.extrudePath = e.extrudePath.toJSON()), t
}
class Qp extends Ul {
    constructor(e = 1, t = 0) {
        const n = (1 + Math.sqrt(5)) / 2,
            i = [-1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, 0, 0, -1, n, 0, 1, n, 0, -1, -n, 0, 1, -n, n, 0, -1, n, 0, 1, -n, 0, -1, -n, 0, 1],
            s = [0, 11, 5, 0, 5, 1, 0, 1, 7, 0, 7, 10, 0, 10, 11, 1, 5, 9, 5, 11, 4, 11, 10, 2, 10, 7, 6, 7, 1, 8, 3, 9, 4, 3, 4, 2, 3, 2, 6, 3, 6, 8, 3, 8, 9, 4, 9, 5, 2, 4, 11, 6, 2, 10, 8, 6, 7, 9, 8, 1];
        super(i, s, e, t), this.type = "IcosahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Qp(e.radius, e.detail)
    }
}
class $p extends Ul {
    constructor(e = 1, t = 0) {
        const n = [1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1, 0, 0, 0, 1, 0, 0, -1],
            i = [0, 2, 4, 0, 4, 3, 0, 3, 5, 0, 5, 2, 1, 2, 5, 1, 5, 3, 1, 3, 4, 1, 4, 2];
        super(n, i, e, t), this.type = "OctahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new $p(e.radius, e.detail)
    }
}
class Py extends zt {
    constructor(e = .5, t = 1, n = 32, i = 1, s = 0, o = Math.PI * 2) {
        super(), this.type = "RingGeometry", this.parameters = {
            innerRadius: e,
            outerRadius: t,
            thetaSegments: n,
            phiSegments: i,
            thetaStart: s,
            thetaLength: o
        }, n = Math.max(3, n), i = Math.max(1, i);
        const a = [],
            l = [],
            c = [],
            u = [];
        let f = e;
        const d = (t - e) / i,
            m = new K,
            g = new Ue;
        for (let y = 0; y <= i; y++) {
            for (let v = 0; v <= n; v++) {
                const _ = s + v / n * o;
                m.x = f * Math.cos(_), m.y = f * Math.sin(_), l.push(m.x, m.y, m.z), c.push(0, 0, 1), g.x = (m.x / t + 1) / 2, g.y = (m.y / t + 1) / 2, u.push(g.x, g.y)
            }
            f += d
        }
        for (let y = 0; y < i; y++) {
            const v = y * (n + 1);
            for (let _ = 0; _ < n; _++) {
                const A = _ + v,
                    S = A,
                    M = A + n + 1,
                    C = A + n + 2,
                    E = A + 1;
                a.push(S, M, E), a.push(M, C, E)
            }
        }
        this.setIndex(a), this.setAttribute("position", new Et(l, 3)), this.setAttribute("normal", new Et(c, 3)), this.setAttribute("uv", new Et(u, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new Py(e.innerRadius, e.outerRadius, e.thetaSegments, e.phiSegments, e.thetaStart, e.thetaLength)
    }
}
class em extends zt {
    constructor(e = new dl([new Ue(0, .5), new Ue(-.5, -.5), new Ue(.5, -.5)]), t = 12) {
        super(), this.type = "ShapeGeometry", this.parameters = {
            shapes: e,
            curveSegments: t
        };
        const n = [],
            i = [],
            s = [],
            o = [];
        let a = 0,
            l = 0;
        if (Array.isArray(e) === !1) c(e);
        else
            for (let u = 0; u < e.length; u++) c(e[u]), this.addGroup(a, l, u), a += l, l = 0;
        this.setIndex(n), this.setAttribute("position", new Et(i, 3)), this.setAttribute("normal", new Et(s, 3)), this.setAttribute("uv", new Et(o, 2));

        function c(u) {
            const f = i.length / 3,
                d = u.extractPoints(t);
            let m = d.shape;
            const g = d.holes;
            Fo.isClockWise(m) === !1 && (m = m.reverse());
            for (let v = 0, _ = g.length; v < _; v++) {
                const A = g[v];
                Fo.isClockWise(A) === !0 && (g[v] = A.reverse())
            }
            const y = Fo.triangulateShape(m, g);
            for (let v = 0, _ = g.length; v < _; v++) {
                const A = g[v];
                m = m.concat(A)
            }
            for (let v = 0, _ = m.length; v < _; v++) {
                const A = m[v];
                i.push(A.x, A.y, 0), s.push(0, 0, 1), o.push(A.x, A.y)
            }
            for (let v = 0, _ = y.length; v < _; v++) {
                const A = y[v],
                    S = A[0] + f,
                    M = A[1] + f,
                    C = A[2] + f;
                n.push(S, M, C), l += 3
            }
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    toJSON() {
        const e = super.toJSON(),
            t = this.parameters.shapes;
        return rV(t, e)
    }
    static fromJSON(e, t) {
        const n = [];
        for (let i = 0, s = e.shapes.length; i < s; i++) {
            const o = t[e.shapes[i]];
            n.push(o)
        }
        return new em(n, e.curveSegments)
    }
}

function rV(r, e) {
    if (e.shapes = [], Array.isArray(r))
        for (let t = 0, n = r.length; t < n; t++) {
            const i = r[t];
            e.shapes.push(i.uuid)
        } else e.shapes.push(r.uuid);
    return e
}
class tm extends zt {
    constructor(e = 1, t = 32, n = 16, i = 0, s = Math.PI * 2, o = 0, a = Math.PI) {
        super(), this.type = "SphereGeometry", this.parameters = {
            radius: e,
            widthSegments: t,
            heightSegments: n,
            phiStart: i,
            phiLength: s,
            thetaStart: o,
            thetaLength: a
        }, t = Math.max(3, Math.floor(t)), n = Math.max(2, Math.floor(n));
        const l = Math.min(o + a, Math.PI);
        let c = 0;
        const u = [],
            f = new K,
            d = new K,
            m = [],
            g = [],
            y = [],
            v = [];
        for (let _ = 0; _ <= n; _++) {
            const A = [],
                S = _ / n;
            let M = 0;
            _ === 0 && o === 0 ? M = .5 / t : _ === n && l === Math.PI && (M = -.5 / t);
            for (let C = 0; C <= t; C++) {
                const E = C / t;
                f.x = -e * Math.cos(i + E * s) * Math.sin(o + S * a), f.y = e * Math.cos(o + S * a), f.z = e * Math.sin(i + E * s) * Math.sin(o + S * a), g.push(f.x, f.y, f.z), d.copy(f).normalize(), y.push(d.x, d.y, d.z), v.push(E + M, 1 - S), A.push(c++)
            }
            u.push(A)
        }
        for (let _ = 0; _ < n; _++)
            for (let A = 0; A < t; A++) {
                const S = u[_][A + 1],
                    M = u[_][A],
                    C = u[_ + 1][A],
                    E = u[_ + 1][A + 1];
                (_ !== 0 || o > 0) && m.push(S, M, E), (_ !== n - 1 || l < Math.PI) && m.push(M, C, E)
            }
        this.setIndex(m), this.setAttribute("position", new Et(g, 3)), this.setAttribute("normal", new Et(y, 3)), this.setAttribute("uv", new Et(v, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new tm(e.radius, e.widthSegments, e.heightSegments, e.phiStart, e.phiLength, e.thetaStart, e.thetaLength)
    }
}
class Iy extends Ul {
    constructor(e = 1, t = 0) {
        const n = [1, 1, 1, -1, -1, 1, -1, 1, -1, 1, -1, -1],
            i = [2, 1, 0, 0, 3, 2, 1, 3, 0, 2, 3, 1];
        super(n, i, e, t), this.type = "TetrahedronGeometry", this.parameters = {
            radius: e,
            detail: t
        }
    }
    static fromJSON(e) {
        return new Iy(e.radius, e.detail)
    }
}
class By extends zt {
    constructor(e = 1, t = .4, n = 12, i = 48, s = Math.PI * 2) {
        super(), this.type = "TorusGeometry", this.parameters = {
            radius: e,
            tube: t,
            radialSegments: n,
            tubularSegments: i,
            arc: s
        }, n = Math.floor(n), i = Math.floor(i);
        const o = [],
            a = [],
            l = [],
            c = [],
            u = new K,
            f = new K,
            d = new K;
        for (let m = 0; m <= n; m++)
            for (let g = 0; g <= i; g++) {
                const y = g / i * s,
                    v = m / n * Math.PI * 2;
                f.x = (e + t * Math.cos(v)) * Math.cos(y), f.y = (e + t * Math.cos(v)) * Math.sin(y), f.z = t * Math.sin(v), a.push(f.x, f.y, f.z), u.x = e * Math.cos(y), u.y = e * Math.sin(y), d.subVectors(f, u).normalize(), l.push(d.x, d.y, d.z), c.push(g / i), c.push(m / n)
            }
        for (let m = 1; m <= n; m++)
            for (let g = 1; g <= i; g++) {
                const y = (i + 1) * m + g - 1,
                    v = (i + 1) * (m - 1) + g - 1,
                    _ = (i + 1) * (m - 1) + g,
                    A = (i + 1) * m + g;
                o.push(y, v, A), o.push(v, _, A)
            }
        this.setIndex(o), this.setAttribute("position", new Et(a, 3)), this.setAttribute("normal", new Et(l, 3)), this.setAttribute("uv", new Et(c, 2))
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new By(e.radius, e.tube, e.radialSegments, e.tubularSegments, e.arc)
    }
}
class Dy extends zt {
    constructor(e = 1, t = .4, n = 64, i = 8, s = 2, o = 3) {
        super(), this.type = "TorusKnotGeometry", this.parameters = {
            radius: e,
            tube: t,
            tubularSegments: n,
            radialSegments: i,
            p: s,
            q: o
        }, n = Math.floor(n), i = Math.floor(i);
        const a = [],
            l = [],
            c = [],
            u = [],
            f = new K,
            d = new K,
            m = new K,
            g = new K,
            y = new K,
            v = new K,
            _ = new K;
        for (let S = 0; S <= n; ++S) {
            const M = S / n * s * Math.PI * 2;
            A(M, s, o, e, m), A(M + .01, s, o, e, g), v.subVectors(g, m), _.addVectors(g, m), y.crossVectors(v, _), _.crossVectors(y, v), y.normalize(), _.normalize();
            for (let C = 0; C <= i; ++C) {
                const E = C / i * Math.PI * 2,
                    R = -t * Math.cos(E),
                    P = t * Math.sin(E);
                f.x = m.x + (R * _.x + P * y.x), f.y = m.y + (R * _.y + P * y.y), f.z = m.z + (R * _.z + P * y.z), l.push(f.x, f.y, f.z), d.subVectors(f, m).normalize(), c.push(d.x, d.y, d.z), u.push(S / n), u.push(C / i)
            }
        }
        for (let S = 1; S <= n; S++)
            for (let M = 1; M <= i; M++) {
                const C = (i + 1) * (S - 1) + (M - 1),
                    E = (i + 1) * S + (M - 1),
                    R = (i + 1) * S + M,
                    P = (i + 1) * (S - 1) + M;
                a.push(C, E, P), a.push(E, R, P)
            }
        this.setIndex(a), this.setAttribute("position", new Et(l, 3)), this.setAttribute("normal", new Et(c, 3)), this.setAttribute("uv", new Et(u, 2));

        function A(S, M, C, E, R) {
            const P = Math.cos(S),
                b = Math.sin(S),
                T = C / M * S,
                L = Math.cos(T);
            R.x = E * (2 + L) * .5 * P, R.y = E * (2 + L) * b * .5, R.z = E * Math.sin(T) * .5
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    static fromJSON(e) {
        return new Dy(e.radius, e.tube, e.tubularSegments, e.radialSegments, e.p, e.q)
    }
}
class Ly extends zt {
    constructor(e = new rM(new K(-1, -1, 0), new K(-1, 1, 0), new K(1, 1, 0)), t = 64, n = 1, i = 8, s = !1) {
        super(), this.type = "TubeGeometry", this.parameters = {
            path: e,
            tubularSegments: t,
            radius: n,
            radialSegments: i,
            closed: s
        };
        const o = e.computeFrenetFrames(t, s);
        this.tangents = o.tangents, this.normals = o.normals, this.binormals = o.binormals;
        const a = new K,
            l = new K,
            c = new Ue;
        let u = new K;
        const f = [],
            d = [],
            m = [],
            g = [];
        y(), this.setIndex(g), this.setAttribute("position", new Et(f, 3)), this.setAttribute("normal", new Et(d, 3)), this.setAttribute("uv", new Et(m, 2));

        function y() {
            for (let S = 0; S < t; S++) v(S);
            v(s === !1 ? t : 0), A(), _()
        }

        function v(S) {
            u = e.getPointAt(S / t, u);
            const M = o.normals[S],
                C = o.binormals[S];
            for (let E = 0; E <= i; E++) {
                const R = E / i * Math.PI * 2,
                    P = Math.sin(R),
                    b = -Math.cos(R);
                l.x = b * M.x + P * C.x, l.y = b * M.y + P * C.y, l.z = b * M.z + P * C.z, l.normalize(), d.push(l.x, l.y, l.z), a.x = u.x + n * l.x, a.y = u.y + n * l.y, a.z = u.z + n * l.z, f.push(a.x, a.y, a.z)
            }
        }

        function _() {
            for (let S = 1; S <= t; S++)
                for (let M = 1; M <= i; M++) {
                    const C = (i + 1) * (S - 1) + (M - 1),
                        E = (i + 1) * S + (M - 1),
                        R = (i + 1) * S + M,
                        P = (i + 1) * (S - 1) + M;
                    g.push(C, E, P), g.push(E, R, P)
                }
        }

        function A() {
            for (let S = 0; S <= t; S++)
                for (let M = 0; M <= i; M++) c.x = S / t, c.y = M / i, m.push(c.x, c.y)
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
    toJSON() {
        const e = super.toJSON();
        return e.path = this.parameters.path.toJSON(), e
    }
    static fromJSON(e) {
        return new Ly(new Lv[e.path.type]().fromJSON(e.path), e.tubularSegments, e.radius, e.radialSegments, e.closed)
    }
}
class FB extends zt {
    constructor(e = null) {
        if (super(), this.type = "WireframeGeometry", this.parameters = {
                geometry: e
            }, e !== null) {
            const t = [],
                n = new Set,
                i = new K,
                s = new K;
            if (e.index !== null) {
                const o = e.attributes.position,
                    a = e.index;
                let l = e.groups;
                l.length === 0 && (l = [{
                    start: 0,
                    count: a.count,
                    materialIndex: 0
                }]);
                for (let c = 0, u = l.length; c < u; ++c) {
                    const f = l[c],
                        d = f.start,
                        m = f.count;
                    for (let g = d, y = d + m; g < y; g += 3)
                        for (let v = 0; v < 3; v++) {
                            const _ = a.getX(g + v),
                                A = a.getX(g + (v + 1) % 3);
                            i.fromBufferAttribute(o, _), s.fromBufferAttribute(o, A), $E(i, s, n) === !0 && (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z))
                        }
                }
            } else {
                const o = e.attributes.position;
                for (let a = 0, l = o.count / 3; a < l; a++)
                    for (let c = 0; c < 3; c++) {
                        const u = 3 * a + c,
                            f = 3 * a + (c + 1) % 3;
                        i.fromBufferAttribute(o, u), s.fromBufferAttribute(o, f), $E(i, s, n) === !0 && (t.push(i.x, i.y, i.z), t.push(s.x, s.y, s.z))
                    }
            }
            this.setAttribute("position", new Et(t, 3))
        }
    }
    copy(e) {
        return super.copy(e), this.parameters = Object.assign({}, e.parameters), this
    }
}

function $E(r, e, t) {
    const n = `${r.x},${r.y},${r.z}-${e.x},${e.y},${e.z}`,
        i = `${e.x},${e.y},${e.z}-${r.x},${r.y},${r.z}`;
    return t.has(n) === !0 || t.has(i) === !0 ? !1 : (t.add(n), t.add(i), !0)
}
var eC = Object.freeze({
    __proto__: null,
    BoxGeometry: pu,
    CapsuleGeometry: wy,
    CircleGeometry: by,
    ConeGeometry: Ty,
    CylinderGeometry: ch,
    DodecahedronGeometry: Ey,
    EdgesGeometry: IB,
    ExtrudeGeometry: Ry,
    IcosahedronGeometry: Qp,
    LatheGeometry: Zp,
    OctahedronGeometry: $p,
    PlaneGeometry: bs,
    PolyhedronGeometry: Ul,
    RingGeometry: Py,
    ShapeGeometry: em,
    SphereGeometry: tm,
    TetrahedronGeometry: Iy,
    TorusGeometry: By,
    TorusKnotGeometry: Dy,
    TubeGeometry: Ly,
    WireframeGeometry: FB
});
class UB extends mi {
    static get type() {
        return "ShadowMaterial"
    }
    constructor(e) {
        super(), this.isShadowMaterial = !0, this.color = new rt(0), this.transparent = !0, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.fog = e.fog, this
    }
}
class Fv extends Fn {
    static get type() {
        return "RawShaderMaterial"
    }
    constructor(e) {
        super(e), this.isRawShaderMaterial = !0
    }
}
class mu extends mi {
    static get type() {
        return "MeshStandardMaterial"
    }
    constructor(e) {
        super(), this.isMeshStandardMaterial = !0, this.defines = {
            STANDARD: ""
        }, this.color = new rt(16777215), this.roughness = 1, this.metalness = 0, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Dl, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.roughnessMap = null, this.metalnessMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new As, this.envMapIntensity = 1, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.defines = {
            STANDARD: ""
        }, this.color.copy(e.color), this.roughness = e.roughness, this.metalness = e.metalness, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.roughnessMap = e.roughnessMap, this.metalnessMap = e.metalnessMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.envMapIntensity = e.envMapIntensity, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class Ts extends mu {
    static get type() {
        return "MeshPhysicalMaterial"
    }
    constructor(e) {
        super(), this.isMeshPhysicalMaterial = !0, this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.anisotropyRotation = 0, this.anisotropyMap = null, this.clearcoatMap = null, this.clearcoatRoughness = 0, this.clearcoatRoughnessMap = null, this.clearcoatNormalScale = new Ue(1, 1), this.clearcoatNormalMap = null, this.ior = 1.5, Object.defineProperty(this, "reflectivity", {
            get: function() {
                return fi(2.5 * (this.ior - 1) / (this.ior + 1), 0, 1)
            },
            set: function(t) {
                this.ior = (1 + .4 * t) / (1 - .4 * t)
            }
        }), this.iridescenceMap = null, this.iridescenceIOR = 1.3, this.iridescenceThicknessRange = [100, 400], this.iridescenceThicknessMap = null, this.sheenColor = new rt(0), this.sheenColorMap = null, this.sheenRoughness = 1, this.sheenRoughnessMap = null, this.transmissionMap = null, this.thickness = 0, this.thicknessMap = null, this.attenuationDistance = 1 / 0, this.attenuationColor = new rt(1, 1, 1), this.specularIntensity = 1, this.specularIntensityMap = null, this.specularColor = new rt(1, 1, 1), this.specularColorMap = null, this._anisotropy = 0, this._clearcoat = 0, this._dispersion = 0, this._iridescence = 0, this._sheen = 0, this._transmission = 0, this.setValues(e)
    }
    get anisotropy() {
        return this._anisotropy
    }
    set anisotropy(e) {
        this._anisotropy > 0 != e > 0 && this.version++, this._anisotropy = e
    }
    get clearcoat() {
        return this._clearcoat
    }
    set clearcoat(e) {
        this._clearcoat > 0 != e > 0 && this.version++, this._clearcoat = e
    }
    get iridescence() {
        return this._iridescence
    }
    set iridescence(e) {
        this._iridescence > 0 != e > 0 && this.version++, this._iridescence = e
    }
    get dispersion() {
        return this._dispersion
    }
    set dispersion(e) {
        this._dispersion > 0 != e > 0 && this.version++, this._dispersion = e
    }
    get sheen() {
        return this._sheen
    }
    set sheen(e) {
        this._sheen > 0 != e > 0 && this.version++, this._sheen = e
    }
    get transmission() {
        return this._transmission
    }
    set transmission(e) {
        this._transmission > 0 != e > 0 && this.version++, this._transmission = e
    }
    copy(e) {
        return super.copy(e), this.defines = {
            STANDARD: "",
            PHYSICAL: ""
        }, this.anisotropy = e.anisotropy, this.anisotropyRotation = e.anisotropyRotation, this.anisotropyMap = e.anisotropyMap, this.clearcoat = e.clearcoat, this.clearcoatMap = e.clearcoatMap, this.clearcoatRoughness = e.clearcoatRoughness, this.clearcoatRoughnessMap = e.clearcoatRoughnessMap, this.clearcoatNormalMap = e.clearcoatNormalMap, this.clearcoatNormalScale.copy(e.clearcoatNormalScale), this.dispersion = e.dispersion, this.ior = e.ior, this.iridescence = e.iridescence, this.iridescenceMap = e.iridescenceMap, this.iridescenceIOR = e.iridescenceIOR, this.iridescenceThicknessRange = [...e.iridescenceThicknessRange], this.iridescenceThicknessMap = e.iridescenceThicknessMap, this.sheen = e.sheen, this.sheenColor.copy(e.sheenColor), this.sheenColorMap = e.sheenColorMap, this.sheenRoughness = e.sheenRoughness, this.sheenRoughnessMap = e.sheenRoughnessMap, this.transmission = e.transmission, this.transmissionMap = e.transmissionMap, this.thickness = e.thickness, this.thicknessMap = e.thicknessMap, this.attenuationDistance = e.attenuationDistance, this.attenuationColor.copy(e.attenuationColor), this.specularIntensity = e.specularIntensity, this.specularIntensityMap = e.specularIntensityMap, this.specularColor.copy(e.specularColor), this.specularColorMap = e.specularColorMap, this
    }
}
class OB extends mi {
    static get type() {
        return "MeshPhongMaterial"
    }
    constructor(e) {
        super(), this.isMeshPhongMaterial = !0, this.color = new rt(16777215), this.specular = new rt(1118481), this.shininess = 30, this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Dl, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new As, this.combine = zp, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.specular.copy(e.specular), this.shininess = e.shininess, this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class NB extends mi {
    static get type() {
        return "MeshToonMaterial"
    }
    constructor(e) {
        super(), this.isMeshToonMaterial = !0, this.defines = {
            TOON: ""
        }, this.color = new rt(16777215), this.map = null, this.gradientMap = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Dl, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.gradientMap = e.gradientMap, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.fog = e.fog, this
    }
}
class oM extends mi {
    static get type() {
        return "MeshNormalMaterial"
    }
    constructor(e) {
        super(), this.isMeshNormalMaterial = !0, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Dl, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.wireframe = !1, this.wireframeLinewidth = 1, this.flatShading = !1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.flatShading = e.flatShading, this
    }
}
class kB extends mi {
    static get type() {
        return "MeshLambertMaterial"
    }
    constructor(e) {
        super(), this.isMeshLambertMaterial = !0, this.color = new rt(16777215), this.map = null, this.lightMap = null, this.lightMapIntensity = 1, this.aoMap = null, this.aoMapIntensity = 1, this.emissive = new rt(0), this.emissiveIntensity = 1, this.emissiveMap = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Dl, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.specularMap = null, this.alphaMap = null, this.envMap = null, this.envMapRotation = new As, this.combine = zp, this.reflectivity = 1, this.refractionRatio = .98, this.wireframe = !1, this.wireframeLinewidth = 1, this.wireframeLinecap = "round", this.wireframeLinejoin = "round", this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.color.copy(e.color), this.map = e.map, this.lightMap = e.lightMap, this.lightMapIntensity = e.lightMapIntensity, this.aoMap = e.aoMap, this.aoMapIntensity = e.aoMapIntensity, this.emissive.copy(e.emissive), this.emissiveMap = e.emissiveMap, this.emissiveIntensity = e.emissiveIntensity, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.specularMap = e.specularMap, this.alphaMap = e.alphaMap, this.envMap = e.envMap, this.envMapRotation.copy(e.envMapRotation), this.combine = e.combine, this.reflectivity = e.reflectivity, this.refractionRatio = e.refractionRatio, this.wireframe = e.wireframe, this.wireframeLinewidth = e.wireframeLinewidth, this.wireframeLinecap = e.wireframeLinecap, this.wireframeLinejoin = e.wireframeLinejoin, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class zB extends mi {
    static get type() {
        return "MeshMatcapMaterial"
    }
    constructor(e) {
        super(), this.isMeshMatcapMaterial = !0, this.defines = {
            MATCAP: ""
        }, this.color = new rt(16777215), this.matcap = null, this.map = null, this.bumpMap = null, this.bumpScale = 1, this.normalMap = null, this.normalMapType = Dl, this.normalScale = new Ue(1, 1), this.displacementMap = null, this.displacementScale = 1, this.displacementBias = 0, this.alphaMap = null, this.flatShading = !1, this.fog = !0, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.defines = {
            MATCAP: ""
        }, this.color.copy(e.color), this.matcap = e.matcap, this.map = e.map, this.bumpMap = e.bumpMap, this.bumpScale = e.bumpScale, this.normalMap = e.normalMap, this.normalMapType = e.normalMapType, this.normalScale.copy(e.normalScale), this.displacementMap = e.displacementMap, this.displacementScale = e.displacementScale, this.displacementBias = e.displacementBias, this.alphaMap = e.alphaMap, this.flatShading = e.flatShading, this.fog = e.fog, this
    }
}
class GB extends yr {
    static get type() {
        return "LineDashedMaterial"
    }
    constructor(e) {
        super(), this.isLineDashedMaterial = !0, this.scale = 1, this.dashSize = 3, this.gapSize = 1, this.setValues(e)
    }
    copy(e) {
        return super.copy(e), this.scale = e.scale, this.dashSize = e.dashSize, this.gapSize = e.gapSize, this
    }
}

function Fc(r, e, t) {
    return !r || !t && r.constructor === e ? r : typeof e.BYTES_PER_ELEMENT == "number" ? new e(r) : Array.prototype.slice.call(r)
}

function HB(r) {
    return ArrayBuffer.isView(r) && !(r instanceof DataView)
}

function VB(r) {
    function e(i, s) {
        return r[i] - r[s]
    }
    const t = r.length,
        n = new Array(t);
    for (let i = 0; i !== t; ++i) n[i] = i;
    return n.sort(e), n
}

function xA(r, e, t) {
    const n = r.length,
        i = new r.constructor(n);
    for (let s = 0, o = 0; o !== n; ++s) {
        const a = t[s] * e;
        for (let l = 0; l !== e; ++l) i[o++] = r[a + l]
    }
    return i
}

function aM(r, e, t, n) {
    let i = 1,
        s = r[0];
    for (; s !== void 0 && s[n] === void 0;) s = r[i++];
    if (s === void 0) return;
    let o = s[n];
    if (o !== void 0)
        if (Array.isArray(o))
            do o = s[n], o !== void 0 && (e.push(s.time), t.push.apply(t, o)), s = r[i++]; while (s !== void 0);
        else if (o.toArray !== void 0)
        do o = s[n], o !== void 0 && (e.push(s.time), o.toArray(t, t.length)), s = r[i++]; while (s !== void 0);
    else
        do o = s[n], o !== void 0 && (e.push(s.time), t.push(o)), s = r[i++]; while (s !== void 0)
}

function sV(r, e, t, n, i = 30) {
    const s = r.clone();
    s.name = e;
    const o = [];
    for (let l = 0; l < s.tracks.length; ++l) {
        const c = s.tracks[l],
            u = c.getValueSize(),
            f = [],
            d = [];
        for (let m = 0; m < c.times.length; ++m) {
            const g = c.times[m] * i;
            if (!(g < t || g >= n)) {
                f.push(c.times[m]);
                for (let y = 0; y < u; ++y) d.push(c.values[m * u + y])
            }
        }
        f.length !== 0 && (c.times = Fc(f, c.times.constructor), c.values = Fc(d, c.values.constructor), o.push(c))
    }
    s.tracks = o;
    let a = 1 / 0;
    for (let l = 0; l < s.tracks.length; ++l) a > s.tracks[l].times[0] && (a = s.tracks[l].times[0]);
    for (let l = 0; l < s.tracks.length; ++l) s.tracks[l].shift(-1 * a);
    return s.resetDuration(), s
}

function oV(r, e = 0, t = r, n = 30) {
    n <= 0 && (n = 30);
    const i = t.tracks.length,
        s = e / n;
    for (let o = 0; o < i; ++o) {
        const a = t.tracks[o],
            l = a.ValueTypeName;
        if (l === "bool" || l === "string") continue;
        const c = r.tracks.find(function(_) {
            return _.name === a.name && _.ValueTypeName === l
        });
        if (c === void 0) continue;
        let u = 0;
        const f = a.getValueSize();
        a.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (u = f / 3);
        let d = 0;
        const m = c.getValueSize();
        c.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline && (d = m / 3);
        const g = a.times.length - 1;
        let y;
        if (s <= a.times[0]) {
            const _ = u,
                A = f - u;
            y = a.values.slice(_, A)
        } else if (s >= a.times[g]) {
            const _ = g * f + u,
                A = _ + f - u;
            y = a.values.slice(_, A)
        } else {
            const _ = a.createInterpolant(),
                A = u,
                S = f - u;
            _.evaluate(s), y = _.resultBuffer.slice(A, S)
        }
        l === "quaternion" && new gr().fromArray(y).normalize().conjugate().toArray(y);
        const v = c.times.length;
        for (let _ = 0; _ < v; ++_) {
            const A = _ * m + d;
            if (l === "quaternion") gr.multiplyQuaternionsFlat(c.values, A, y, 0, c.values, A);
            else {
                const S = m - d * 2;
                for (let M = 0; M < S; ++M) c.values[A + M] -= y[M]
            }
        }
    }
    return r.blendMode = kS, r
}
const aV = {
    convertArray: Fc,
    isTypedArray: HB,
    getKeyframeOrder: VB,
    sortedArray: xA,
    flattenJSON: aM,
    subclip: sV,
    makeClipAdditive: oV
};
class uh {
    constructor(e, t, n, i) {
        this.parameterPositions = e, this._cachedIndex = 0, this.resultBuffer = i !== void 0 ? i : new t.constructor(n), this.sampleValues = t, this.valueSize = n, this.settings = null, this.DefaultSettings_ = {}
    }
    evaluate(e) {
        const t = this.parameterPositions;
        let n = this._cachedIndex,
            i = t[n],
            s = t[n - 1];
        e: {
            t: {
                let o;n: {
                    i: if (!(e < i)) {
                        for (let a = n + 2;;) {
                            if (i === void 0) {
                                if (e < s) break i;
                                return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
                            }
                            if (n === a) break;
                            if (s = i, i = t[++n], e < i) break t
                        }
                        o = t.length;
                        break n
                    }if (!(e >= s)) {
                        const a = t[1];
                        e < a && (n = 2, s = a);
                        for (let l = n - 2;;) {
                            if (s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                            if (n === l) break;
                            if (i = s, s = t[--n - 1], e >= s) break t
                        }
                        o = n, n = 0;
                        break n
                    }
                    break e
                }
                for (; n < o;) {
                    const a = n + o >>> 1;
                    e < t[a] ? o = a : n = a + 1
                }
                if (i = t[n], s = t[n - 1], s === void 0) return this._cachedIndex = 0, this.copySampleValue_(0);
                if (i === void 0) return n = t.length, this._cachedIndex = n, this.copySampleValue_(n - 1)
            }
            this._cachedIndex = n,
            this.intervalChanged_(n, s, i)
        }
        return this.interpolate_(n, s, e, i)
    }
    getSettings_() {
        return this.settings || this.DefaultSettings_
    }
    copySampleValue_(e) {
        const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            s = e * i;
        for (let o = 0; o !== i; ++o) t[o] = n[s + o];
        return t
    }
    interpolate_() {
        throw new Error("call to abstract method")
    }
    intervalChanged_() {}
}
class WB extends uh {
    constructor(e, t, n, i) {
        super(e, t, n, i), this._weightPrev = -0, this._offsetPrev = -0, this._weightNext = -0, this._offsetNext = -0, this.DefaultSettings_ = {
            endingStart: Ic,
            endingEnd: Ic
        }
    }
    intervalChanged_(e, t, n) {
        const i = this.parameterPositions;
        let s = e - 2,
            o = e + 1,
            a = i[s],
            l = i[o];
        if (a === void 0) switch (this.getSettings_().endingStart) {
            case Bc:
                s = e, a = 2 * t - n;
                break;
            case pp:
                s = i.length - 2, a = t + i[s] - i[s + 1];
                break;
            default:
                s = e, a = n
        }
        if (l === void 0) switch (this.getSettings_().endingEnd) {
            case Bc:
                o = e, l = 2 * n - t;
                break;
            case pp:
                o = 1, l = n + i[1] - i[0];
                break;
            default:
                o = e - 1, l = t
        }
        const c = (n - t) * .5,
            u = this.valueSize;
        this._weightPrev = c / (t - a), this._weightNext = c / (l - n), this._offsetPrev = s * u, this._offsetNext = o * u
    }
    interpolate_(e, t, n, i) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            u = this._offsetPrev,
            f = this._offsetNext,
            d = this._weightPrev,
            m = this._weightNext,
            g = (n - t) / (i - t),
            y = g * g,
            v = y * g,
            _ = -d * v + 2 * d * y - d * g,
            A = (1 + d) * v + (-1.5 - 2 * d) * y + (-.5 + d) * g + 1,
            S = (-1 - m) * v + (1.5 + m) * y + .5 * g,
            M = m * v - m * y;
        for (let C = 0; C !== a; ++C) s[C] = _ * o[u + C] + A * o[c + C] + S * o[l + C] + M * o[f + C];
        return s
    }
}
class lM extends uh {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = e * a,
            c = l - a,
            u = (n - t) / (i - t),
            f = 1 - u;
        for (let d = 0; d !== a; ++d) s[d] = o[c + d] * f + o[l + d] * u;
        return s
    }
}
class jB extends uh {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e) {
        return this.copySampleValue_(e - 1)
    }
}
class go {
    constructor(e, t, n, i) {
        if (e === void 0) throw new Error("THREE.KeyframeTrack: track name is undefined");
        if (t === void 0 || t.length === 0) throw new Error("THREE.KeyframeTrack: no keyframes in track named " + e);
        this.name = e, this.times = Fc(t, this.TimeBufferType), this.values = Fc(n, this.ValueBufferType), this.setInterpolation(i || this.DefaultInterpolation)
    }
    static toJSON(e) {
        const t = e.constructor;
        let n;
        if (t.toJSON !== this.toJSON) n = t.toJSON(e);
        else {
            n = {
                name: e.name,
                times: Fc(e.times, Array),
                values: Fc(e.values, Array)
            };
            const i = e.getInterpolation();
            i !== e.DefaultInterpolation && (n.interpolation = i)
        }
        return n.type = e.ValueTypeName, n
    }
    InterpolantFactoryMethodDiscrete(e) {
        return new jB(this.times, this.values, this.getValueSize(), e)
    }
    InterpolantFactoryMethodLinear(e) {
        return new lM(this.times, this.values, this.getValueSize(), e)
    }
    InterpolantFactoryMethodSmooth(e) {
        return new WB(this.times, this.values, this.getValueSize(), e)
    }
    setInterpolation(e) {
        let t;
        switch (e) {
            case qf:
                t = this.InterpolantFactoryMethodDiscrete;
                break;
            case Zf:
                t = this.InterpolantFactoryMethodLinear;
                break;
            case P0:
                t = this.InterpolantFactoryMethodSmooth;
                break
        }
        if (t === void 0) {
            const n = "unsupported interpolation for " + this.ValueTypeName + " keyframe track named " + this.name;
            if (this.createInterpolant === void 0)
                if (e !== this.DefaultInterpolation) this.setInterpolation(this.DefaultInterpolation);
                else throw new Error(n);
            return console.warn("THREE.KeyframeTrack:", n), this
        }
        return this.createInterpolant = t, this
    }
    getInterpolation() {
        switch (this.createInterpolant) {
            case this.InterpolantFactoryMethodDiscrete:
                return qf;
            case this.InterpolantFactoryMethodLinear:
                return Zf;
            case this.InterpolantFactoryMethodSmooth:
                return P0
        }
    }
    getValueSize() {
        return this.values.length / this.times.length
    }
    shift(e) {
        if (e !== 0) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] += e
        }
        return this
    }
    scale(e) {
        if (e !== 1) {
            const t = this.times;
            for (let n = 0, i = t.length; n !== i; ++n) t[n] *= e
        }
        return this
    }
    trim(e, t) {
        const n = this.times,
            i = n.length;
        let s = 0,
            o = i - 1;
        for (; s !== i && n[s] < e;) ++s;
        for (; o !== -1 && n[o] > t;) --o;
        if (++o, s !== 0 || o !== i) {
            s >= o && (o = Math.max(o, 1), s = o - 1);
            const a = this.getValueSize();
            this.times = n.slice(s, o), this.values = this.values.slice(s * a, o * a)
        }
        return this
    }
    validate() {
        let e = !0;
        const t = this.getValueSize();
        t - Math.floor(t) !== 0 && (console.error("THREE.KeyframeTrack: Invalid value size in track.", this), e = !1);
        const n = this.times,
            i = this.values,
            s = n.length;
        s === 0 && (console.error("THREE.KeyframeTrack: Track is empty.", this), e = !1);
        let o = null;
        for (let a = 0; a !== s; a++) {
            const l = n[a];
            if (typeof l == "number" && isNaN(l)) {
                console.error("THREE.KeyframeTrack: Time is not a valid number.", this, a, l), e = !1;
                break
            }
            if (o !== null && o > l) {
                console.error("THREE.KeyframeTrack: Out of order keys.", this, a, l, o), e = !1;
                break
            }
            o = l
        }
        if (i !== void 0 && HB(i))
            for (let a = 0, l = i.length; a !== l; ++a) {
                const c = i[a];
                if (isNaN(c)) {
                    console.error("THREE.KeyframeTrack: Value is not a valid number.", this, a, c), e = !1;
                    break
                }
            }
        return e
    }
    optimize() {
        const e = this.times.slice(),
            t = this.values.slice(),
            n = this.getValueSize(),
            i = this.getInterpolation() === P0,
            s = e.length - 1;
        let o = 1;
        for (let a = 1; a < s; ++a) {
            let l = !1;
            const c = e[a],
                u = e[a + 1];
            if (c !== u && (a !== 1 || c !== e[0]))
                if (i) l = !0;
                else {
                    const f = a * n,
                        d = f - n,
                        m = f + n;
                    for (let g = 0; g !== n; ++g) {
                        const y = t[f + g];
                        if (y !== t[d + g] || y !== t[m + g]) {
                            l = !0;
                            break
                        }
                    }
                }
            if (l) {
                if (a !== o) {
                    e[o] = e[a];
                    const f = a * n,
                        d = o * n;
                    for (let m = 0; m !== n; ++m) t[d + m] = t[f + m]
                }++o
            }
        }
        if (s > 0) {
            e[o] = e[s];
            for (let a = s * n, l = o * n, c = 0; c !== n; ++c) t[l + c] = t[a + c];
            ++o
        }
        return o !== e.length ? (this.times = e.slice(0, o), this.values = t.slice(0, o * n)) : (this.times = e, this.values = t), this
    }
    clone() {
        const e = this.times.slice(),
            t = this.values.slice(),
            n = this.constructor,
            i = new n(this.name, e, t);
        return i.createInterpolant = this.createInterpolant, i
    }
}
go.prototype.TimeBufferType = Float32Array;
go.prototype.ValueBufferType = Float32Array;
go.prototype.DefaultInterpolation = Zf;
class gu extends go {
    constructor(e, t, n) {
        super(e, t, n)
    }
}
gu.prototype.ValueTypeName = "bool";
gu.prototype.ValueBufferType = Array;
gu.prototype.DefaultInterpolation = qf;
gu.prototype.InterpolantFactoryMethodLinear = void 0;
gu.prototype.InterpolantFactoryMethodSmooth = void 0;
class cM extends go {}
cM.prototype.ValueTypeName = "color";
class cu extends go {}
cu.prototype.ValueTypeName = "number";
class XB extends uh {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    interpolate_(e, t, n, i) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = (n - t) / (i - t);
        let c = e * a;
        for (let u = c + a; c !== u; c += 4) gr.slerpFlat(s, 0, o, c - a, o, c, l);
        return s
    }
}
class uu extends go {
    InterpolantFactoryMethodLinear(e) {
        return new XB(this.times, this.values, this.getValueSize(), e)
    }
}
uu.prototype.ValueTypeName = "quaternion";
uu.prototype.InterpolantFactoryMethodSmooth = void 0;
class vu extends go {
    constructor(e, t, n) {
        super(e, t, n)
    }
}
vu.prototype.ValueTypeName = "string";
vu.prototype.ValueBufferType = Array;
vu.prototype.DefaultInterpolation = qf;
vu.prototype.InterpolantFactoryMethodLinear = void 0;
vu.prototype.InterpolantFactoryMethodSmooth = void 0;
class fu extends go {}
fu.prototype.ValueTypeName = "vector";
class eh {
    constructor(e = "", t = -1, n = [], i = hy) {
        this.name = e, this.tracks = n, this.duration = t, this.blendMode = i, this.uuid = ys(), this.duration < 0 && this.resetDuration()
    }
    static parse(e) {
        const t = [],
            n = e.tracks,
            i = 1 / (e.fps || 1);
        for (let o = 0, a = n.length; o !== a; ++o) t.push(cV(n[o]).scale(i));
        const s = new this(e.name, e.duration, t, e.blendMode);
        return s.uuid = e.uuid, s
    }
    static toJSON(e) {
        const t = [],
            n = e.tracks,
            i = {
                name: e.name,
                duration: e.duration,
                tracks: t,
                uuid: e.uuid,
                blendMode: e.blendMode
            };
        for (let s = 0, o = n.length; s !== o; ++s) t.push(go.toJSON(n[s]));
        return i
    }
    static CreateFromMorphTargetSequence(e, t, n, i) {
        const s = t.length,
            o = [];
        for (let a = 0; a < s; a++) {
            let l = [],
                c = [];
            l.push((a + s - 1) % s, a, (a + 1) % s), c.push(0, 1, 0);
            const u = VB(l);
            l = xA(l, 1, u), c = xA(c, 1, u), !i && l[0] === 0 && (l.push(s), c.push(c[0])), o.push(new cu(".morphTargetInfluences[" + t[a].name + "]", l, c).scale(1 / n))
        }
        return new this(e, -1, o)
    }
    static findByName(e, t) {
        let n = e;
        if (!Array.isArray(e)) {
            const i = e;
            n = i.geometry && i.geometry.animations || i.animations
        }
        for (let i = 0; i < n.length; i++)
            if (n[i].name === t) return n[i];
        return null
    }
    static CreateClipsFromMorphTargetSequences(e, t, n) {
        const i = {},
            s = /^([\w-]*?)([\d]+)$/;
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
                u = c.name.match(s);
            if (u && u.length > 1) {
                const f = u[1];
                let d = i[f];
                d || (i[f] = d = []), d.push(c)
            }
        }
        const o = [];
        for (const a in i) o.push(this.CreateFromMorphTargetSequence(a, i[a], t, n));
        return o
    }
    static parseAnimation(e, t) {
        if (!e) return console.error("THREE.AnimationClip: No animation in JSONLoader data."), null;
        const n = function(f, d, m, g, y) {
                if (m.length !== 0) {
                    const v = [],
                        _ = [];
                    aM(m, v, _, g), v.length !== 0 && y.push(new f(d, v, _))
                }
            },
            i = [],
            s = e.name || "default",
            o = e.fps || 30,
            a = e.blendMode;
        let l = e.length || -1;
        const c = e.hierarchy || [];
        for (let f = 0; f < c.length; f++) {
            const d = c[f].keys;
            if (!(!d || d.length === 0))
                if (d[0].morphTargets) {
                    const m = {};
                    let g;
                    for (g = 0; g < d.length; g++)
                        if (d[g].morphTargets)
                            for (let y = 0; y < d[g].morphTargets.length; y++) m[d[g].morphTargets[y]] = -1;
                    for (const y in m) {
                        const v = [],
                            _ = [];
                        for (let A = 0; A !== d[g].morphTargets.length; ++A) {
                            const S = d[g];
                            v.push(S.time), _.push(S.morphTarget === y ? 1 : 0)
                        }
                        i.push(new cu(".morphTargetInfluence[" + y + "]", v, _))
                    }
                    l = m.length * o
                } else {
                    const m = ".bones[" + t[f].name + "]";
                    n(fu, m + ".position", d, "pos", i), n(uu, m + ".quaternion", d, "rot", i), n(fu, m + ".scale", d, "scl", i)
                }
        }
        return i.length === 0 ? null : new this(s, l, i, a)
    }
    resetDuration() {
        const e = this.tracks;
        let t = 0;
        for (let n = 0, i = e.length; n !== i; ++n) {
            const s = this.tracks[n];
            t = Math.max(t, s.times[s.times.length - 1])
        }
        return this.duration = t, this
    }
    trim() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].trim(0, this.duration);
        return this
    }
    validate() {
        let e = !0;
        for (let t = 0; t < this.tracks.length; t++) e = e && this.tracks[t].validate();
        return e
    }
    optimize() {
        for (let e = 0; e < this.tracks.length; e++) this.tracks[e].optimize();
        return this
    }
    clone() {
        const e = [];
        for (let t = 0; t < this.tracks.length; t++) e.push(this.tracks[t].clone());
        return new this.constructor(this.name, this.duration, e, this.blendMode)
    }
    toJSON() {
        return this.constructor.toJSON(this)
    }
}

function lV(r) {
    switch (r.toLowerCase()) {
        case "scalar":
        case "double":
        case "float":
        case "number":
        case "integer":
            return cu;
        case "vector":
        case "vector2":
        case "vector3":
        case "vector4":
            return fu;
        case "color":
            return cM;
        case "quaternion":
            return uu;
        case "bool":
        case "boolean":
            return gu;
        case "string":
            return vu
    }
    throw new Error("THREE.KeyframeTrack: Unsupported typeName: " + r)
}

function cV(r) {
    if (r.type === void 0) throw new Error("THREE.KeyframeTrack: track type undefined, can not parse");
    const e = lV(r.type);
    if (r.times === void 0) {
        const t = [],
            n = [];
        aM(r.keys, t, n, "value"), r.times = t, r.values = n
    }
    return e.parse !== void 0 ? e.parse(r) : new e(r.name, r.times, r.values, r.interpolation)
}
const pa = {
    enabled: !1,
    files: {},
    add: function(r, e) {
        this.enabled !== !1 && (this.files[r] = e)
    },
    get: function(r) {
        if (this.enabled !== !1) return this.files[r]
    },
    remove: function(r) {
        delete this.files[r]
    },
    clear: function() {
        this.files = {}
    }
};
class Fy {
    constructor(e, t, n) {
        const i = this;
        let s = !1,
            o = 0,
            a = 0,
            l;
        const c = [];
        this.onStart = void 0, this.onLoad = e, this.onProgress = t, this.onError = n, this.itemStart = function(u) {
            a++, s === !1 && i.onStart !== void 0 && i.onStart(u, o, a), s = !0
        }, this.itemEnd = function(u) {
            o++, i.onProgress !== void 0 && i.onProgress(u, o, a), o === a && (s = !1, i.onLoad !== void 0 && i.onLoad())
        }, this.itemError = function(u) {
            i.onError !== void 0 && i.onError(u)
        }, this.resolveURL = function(u) {
            return l ? l(u) : u
        }, this.setURLModifier = function(u) {
            return l = u, this
        }, this.addHandler = function(u, f) {
            return c.push(u, f), this
        }, this.removeHandler = function(u) {
            const f = c.indexOf(u);
            return f !== -1 && c.splice(f, 2), this
        }, this.getHandler = function(u) {
            for (let f = 0, d = c.length; f < d; f += 2) {
                const m = c[f],
                    g = c[f + 1];
                if (m.global && (m.lastIndex = 0), m.test(u)) return g
            }
            return null
        }
    }
}
const YB = new Fy;
let er = class {
    constructor(e) {
        this.manager = e !== void 0 ? e : YB, this.crossOrigin = "anonymous", this.withCredentials = !1, this.path = "", this.resourcePath = "", this.requestHeader = {}
    }
    load() {}
    loadAsync(e, t) {
        const n = this;
        return new Promise(function(i, s) {
            n.load(e, i, t, s)
        })
    }
    parse() {}
    setCrossOrigin(e) {
        return this.crossOrigin = e, this
    }
    setWithCredentials(e) {
        return this.withCredentials = e, this
    }
    setPath(e) {
        return this.path = e, this
    }
    setResourcePath(e) {
        return this.resourcePath = e, this
    }
    setRequestHeader(e) {
        return this.requestHeader = e, this
    }
};
er.DEFAULT_MATERIAL_NAME = "__DEFAULT";
const na = {};
class uV extends Error {
    constructor(e, t) {
        super(e), this.response = t
    }
}
class $i extends er {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = pa.get(e);
        if (s !== void 0) return this.manager.itemStart(e), setTimeout(() => {
            t && t(s), this.manager.itemEnd(e)
        }, 0), s;
        if (na[e] !== void 0) {
            na[e].push({
                onLoad: t,
                onProgress: n,
                onError: i
            });
            return
        }
        na[e] = [], na[e].push({
            onLoad: t,
            onProgress: n,
            onError: i
        });
        const o = new Request(e, {
                headers: new Headers(this.requestHeader),
                credentials: this.withCredentials ? "include" : "same-origin"
            }),
            a = this.mimeType,
            l = this.responseType;
        fetch(o).then(c => {
            if (c.status === 200 || c.status === 0) {
                if (c.status === 0 && console.warn("THREE.FileLoader: HTTP Status 0 received."), typeof ReadableStream > "u" || c.body === void 0 || c.body.getReader === void 0) return c;
                const u = na[e],
                    f = c.body.getReader(),
                    d = c.headers.get("X-File-Size") || c.headers.get("Content-Length"),
                    m = d ? parseInt(d) : 0,
                    g = m !== 0;
                let y = 0;
                const v = new ReadableStream({
                    start(_) {
                        A();

                        function A() {
                            f.read().then(({
                                done: S,
                                value: M
                            }) => {
                                if (S) _.close();
                                else {
                                    y += M.byteLength;
                                    const C = new ProgressEvent("progress", {
                                        lengthComputable: g,
                                        loaded: y,
                                        total: m
                                    });
                                    for (let E = 0, R = u.length; E < R; E++) {
                                        const P = u[E];
                                        P.onProgress && P.onProgress(C)
                                    }
                                    _.enqueue(M), A()
                                }
                            }, S => {
                                _.error(S)
                            })
                        }
                    }
                });
                return new Response(v)
            } else throw new uV(`fetch for "${c.url}" responded with ${c.status}: ${c.statusText}`, c)
        }).then(c => {
            switch (l) {
                case "arraybuffer":
                    return c.arrayBuffer();
                case "blob":
                    return c.blob();
                case "document":
                    return c.text().then(u => new DOMParser().parseFromString(u, a));
                case "json":
                    return c.json();
                default:
                    if (a === void 0) return c.text(); {
                        const f = /charset="?([^;"\s]*)"?/i.exec(a),
                            d = f && f[1] ? f[1].toLowerCase() : void 0,
                            m = new TextDecoder(d);
                        return c.arrayBuffer().then(g => m.decode(g))
                    }
            }
        }).then(c => {
            pa.add(e, c);
            const u = na[e];
            delete na[e];
            for (let f = 0, d = u.length; f < d; f++) {
                const m = u[f];
                m.onLoad && m.onLoad(c)
            }
        }).catch(c => {
            const u = na[e];
            if (u === void 0) throw this.manager.itemError(e), c;
            delete na[e];
            for (let f = 0, d = u.length; f < d; f++) {
                const m = u[f];
                m.onError && m.onError(c)
            }
            this.manager.itemError(e)
        }).finally(() => {
            this.manager.itemEnd(e)
        }), this.manager.itemStart(e)
    }
    setResponseType(e) {
        return this.responseType = e, this
    }
    setMimeType(e) {
        return this.mimeType = e, this
    }
}
class fV extends er {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const s = this,
            o = new $i(this.manager);
        o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                i ? i(l) : console.error(l), s.manager.itemError(e)
            }
        }, n, i)
    }
    parse(e) {
        const t = [];
        for (let n = 0; n < e.length; n++) {
            const i = eh.parse(e[n]);
            t.push(i)
        }
        return t
    }
}
class hV extends er {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const s = this,
            o = [],
            a = new Sy,
            l = new $i(this.manager);
        l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(s.withCredentials);
        let c = 0;

        function u(f) {
            l.load(e[f], function(d) {
                const m = s.parse(d, !0);
                o[f] = {
                    width: m.width,
                    height: m.height,
                    format: m.format,
                    mipmaps: m.mipmaps
                }, c += 1, c === 6 && (m.mipmapCount === 1 && (a.minFilter = nn), a.image = o, a.format = m.format, a.needsUpdate = !0, t && t(a))
            }, n, i)
        }
        if (Array.isArray(e))
            for (let f = 0, d = e.length; f < d; ++f) u(f);
        else l.load(e, function(f) {
            const d = s.parse(f, !0);
            if (d.isCubemap) {
                const m = d.mipmaps.length / d.mipmapCount;
                for (let g = 0; g < m; g++) {
                    o[g] = {
                        mipmaps: []
                    };
                    for (let y = 0; y < d.mipmapCount; y++) o[g].mipmaps.push(d.mipmaps[g * d.mipmapCount + y]), o[g].format = d.format, o[g].width = d.width, o[g].height = d.height
                }
                a.image = o
            } else a.image.width = d.width, a.image.height = d.height, a.mipmaps = d.mipmaps;
            d.mipmapCount === 1 && (a.minFilter = nn), a.format = d.format, a.needsUpdate = !0, t && t(a)
        }, n, i);
        return a
    }
}
class Sp extends er {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = this,
            o = pa.get(e);
        if (o !== void 0) return s.manager.itemStart(e), setTimeout(function() {
            t && t(o), s.manager.itemEnd(e)
        }, 0), o;
        const a = vp("img");

        function l() {
            u(), pa.add(e, this), t && t(this), s.manager.itemEnd(e)
        }

        function c(f) {
            u(), i && i(f), s.manager.itemError(e), s.manager.itemEnd(e)
        }

        function u() {
            a.removeEventListener("load", l, !1), a.removeEventListener("error", c, !1)
        }
        return a.addEventListener("load", l, !1), a.addEventListener("error", c, !1), e.slice(0, 5) !== "data:" && this.crossOrigin !== void 0 && (a.crossOrigin = this.crossOrigin), s.manager.itemStart(e), a.src = e, a
    }
}
class JB extends er {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const s = new jp;
        s.colorSpace = Jn;
        const o = new Sp(this.manager);
        o.setCrossOrigin(this.crossOrigin), o.setPath(this.path);
        let a = 0;

        function l(c) {
            o.load(e[c], function(u) {
                s.images[c] = u, a++, a === 6 && (s.needsUpdate = !0, t && t(s))
            }, void 0, i)
        }
        for (let c = 0; c < e.length; ++c) l(c);
        return s
    }
}
class uM extends er {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const s = this,
            o = new qr,
            a = new $i(this.manager);
        return a.setResponseType("arraybuffer"), a.setRequestHeader(this.requestHeader), a.setPath(this.path), a.setWithCredentials(s.withCredentials), a.load(e, function(l) {
            let c;
            try {
                c = s.parse(l)
            } catch (u) {
                if (i !== void 0) i(u);
                else {
                    console.error(u);
                    return
                }
            }
            c.image !== void 0 ? o.image = c.image : c.data !== void 0 && (o.image.width = c.width, o.image.height = c.height, o.image.data = c.data), o.wrapS = c.wrapS !== void 0 ? c.wrapS : Nn, o.wrapT = c.wrapT !== void 0 ? c.wrapT : Nn, o.magFilter = c.magFilter !== void 0 ? c.magFilter : nn, o.minFilter = c.minFilter !== void 0 ? c.minFilter : nn, o.anisotropy = c.anisotropy !== void 0 ? c.anisotropy : 1, c.colorSpace !== void 0 && (o.colorSpace = c.colorSpace), c.flipY !== void 0 && (o.flipY = c.flipY), c.format !== void 0 && (o.format = c.format), c.type !== void 0 && (o.type = c.type), c.mipmaps !== void 0 && (o.mipmaps = c.mipmaps, o.minFilter = gs), c.mipmapCount === 1 && (o.minFilter = nn), c.generateMipmaps !== void 0 && (o.generateMipmaps = c.generateMipmaps), o.needsUpdate = !0, t && t(o, c)
        }, n, i), o
    }
}
class zo extends er {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const s = new gn,
            o = new Sp(this.manager);
        return o.setCrossOrigin(this.crossOrigin), o.setPath(this.path), o.load(e, function(a) {
            s.image = a, s.needsUpdate = !0, t !== void 0 && t(s)
        }, n, i), s
    }
}
class Ol extends vn {
    constructor(e, t = 1) {
        super(), this.isLight = !0, this.type = "Light", this.color = new rt(e), this.intensity = t
    }
    dispose() {}
    copy(e, t) {
        return super.copy(e, t), this.color.copy(e.color), this.intensity = e.intensity, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.color = this.color.getHex(), t.object.intensity = this.intensity, this.groundColor !== void 0 && (t.object.groundColor = this.groundColor.getHex()), this.distance !== void 0 && (t.object.distance = this.distance), this.angle !== void 0 && (t.object.angle = this.angle), this.decay !== void 0 && (t.object.decay = this.decay), this.penumbra !== void 0 && (t.object.penumbra = this.penumbra), this.shadow !== void 0 && (t.object.shadow = this.shadow.toJSON()), this.target !== void 0 && (t.object.target = this.target.uuid), t
    }
}
class KB extends Ol {
    constructor(e, t, n) {
        super(e, n), this.isHemisphereLight = !0, this.type = "HemisphereLight", this.position.copy(vn.DEFAULT_UP), this.updateMatrix(), this.groundColor = new rt(t)
    }
    copy(e, t) {
        return super.copy(e, t), this.groundColor.copy(e.groundColor), this
    }
}
const Vx = new Ot,
    tC = new K,
    nC = new K;
class fM {
    constructor(e) {
        this.camera = e, this.intensity = 1, this.bias = 0, this.normalBias = 0, this.radius = 1, this.blurSamples = 8, this.mapSize = new Ue(512, 512), this.map = null, this.mapPass = null, this.matrix = new Ot, this.autoUpdate = !0, this.needsUpdate = !1, this._frustum = new Xp, this._frameExtents = new Ue(1, 1), this._viewportCount = 1, this._viewports = [new An(0, 0, 1, 1)]
    }
    getViewportCount() {
        return this._viewportCount
    }
    getFrustum() {
        return this._frustum
    }
    updateMatrices(e) {
        const t = this.camera,
            n = this.matrix;
        tC.setFromMatrixPosition(e.matrixWorld), t.position.copy(tC), nC.setFromMatrixPosition(e.target.matrixWorld), t.lookAt(nC), t.updateMatrixWorld(), Vx.multiplyMatrices(t.projectionMatrix, t.matrixWorldInverse), this._frustum.setFromProjectionMatrix(Vx), n.set(.5, 0, 0, .5, 0, .5, 0, .5, 0, 0, .5, .5, 0, 0, 0, 1), n.multiply(Vx)
    }
    getViewport(e) {
        return this._viewports[e]
    }
    getFrameExtents() {
        return this._frameExtents
    }
    dispose() {
        this.map && this.map.dispose(), this.mapPass && this.mapPass.dispose()
    }
    copy(e) {
        return this.camera = e.camera.clone(), this.intensity = e.intensity, this.bias = e.bias, this.radius = e.radius, this.mapSize.copy(e.mapSize), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    toJSON() {
        const e = {};
        return this.intensity !== 1 && (e.intensity = this.intensity), this.bias !== 0 && (e.bias = this.bias), this.normalBias !== 0 && (e.normalBias = this.normalBias), this.radius !== 1 && (e.radius = this.radius), (this.mapSize.x !== 512 || this.mapSize.y !== 512) && (e.mapSize = this.mapSize.toArray()), e.camera = this.camera.toJSON(!1).object, delete e.camera.matrix, e
    }
}
class dV extends fM {
    constructor() {
        super(new ri(50, 1, .5, 500)), this.isSpotLightShadow = !0, this.focus = 1
    }
    updateMatrices(e) {
        const t = this.camera,
            n = Qf * 2 * e.angle * this.focus,
            i = this.mapSize.width / this.mapSize.height,
            s = e.distance || t.far;
        (n !== t.fov || i !== t.aspect || s !== t.far) && (t.fov = n, t.aspect = i, t.far = s, t.updateProjectionMatrix()), super.updateMatrices(e)
    }
    copy(e) {
        return super.copy(e), this.focus = e.focus, this
    }
}
class hM extends Ol {
    constructor(e, t, n = 0, i = Math.PI / 3, s = 0, o = 2) {
        super(e, t), this.isSpotLight = !0, this.type = "SpotLight", this.position.copy(vn.DEFAULT_UP), this.updateMatrix(), this.target = new vn, this.distance = n, this.angle = i, this.penumbra = s, this.decay = o, this.map = null, this.shadow = new dV
    }
    get power() {
        return this.intensity * Math.PI
    }
    set power(e) {
        this.intensity = e / Math.PI
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t), this.distance = e.distance, this.angle = e.angle, this.penumbra = e.penumbra, this.decay = e.decay, this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
    }
}
const iC = new Ot,
    nd = new K,
    Wx = new K;
class pV extends fM {
    constructor() {
        super(new ri(90, 1, .5, 500)), this.isPointLightShadow = !0, this._frameExtents = new Ue(4, 2), this._viewportCount = 6, this._viewports = [new An(2, 1, 1, 1), new An(0, 1, 1, 1), new An(3, 1, 1, 1), new An(1, 1, 1, 1), new An(3, 0, 1, 1), new An(1, 0, 1, 1)], this._cubeDirections = [new K(1, 0, 0), new K(-1, 0, 0), new K(0, 0, 1), new K(0, 0, -1), new K(0, 1, 0), new K(0, -1, 0)], this._cubeUps = [new K(0, 1, 0), new K(0, 1, 0), new K(0, 1, 0), new K(0, 1, 0), new K(0, 0, 1), new K(0, 0, -1)]
    }
    updateMatrices(e, t = 0) {
        const n = this.camera,
            i = this.matrix,
            s = e.distance || n.far;
        s !== n.far && (n.far = s, n.updateProjectionMatrix()), nd.setFromMatrixPosition(e.matrixWorld), n.position.copy(nd), Wx.copy(n.position), Wx.add(this._cubeDirections[t]), n.up.copy(this._cubeUps[t]), n.lookAt(Wx), n.updateMatrixWorld(), i.makeTranslation(-nd.x, -nd.y, -nd.z), iC.multiplyMatrices(n.projectionMatrix, n.matrixWorldInverse), this._frustum.setFromProjectionMatrix(iC)
    }
}
class Uy extends Ol {
    constructor(e, t, n = 0, i = 2) {
        super(e, t), this.isPointLight = !0, this.type = "PointLight", this.distance = n, this.decay = i, this.shadow = new pV
    }
    get power() {
        return this.intensity * 4 * Math.PI
    }
    set power(e) {
        this.intensity = e / (4 * Math.PI)
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e, t) {
        return super.copy(e, t), this.distance = e.distance, this.decay = e.decay, this.shadow = e.shadow.clone(), this
    }
}
class mV extends fM {
    constructor() {
        super(new Ca(-5, 5, 5, -5, .5, 500)), this.isDirectionalLightShadow = !0
    }
}
class Mp extends Ol {
    constructor(e, t) {
        super(e, t), this.isDirectionalLight = !0, this.type = "DirectionalLight", this.position.copy(vn.DEFAULT_UP), this.updateMatrix(), this.target = new vn, this.shadow = new mV
    }
    dispose() {
        this.shadow.dispose()
    }
    copy(e) {
        return super.copy(e), this.target = e.target.clone(), this.shadow = e.shadow.clone(), this
    }
}
class dM extends Ol {
    constructor(e, t) {
        super(e, t), this.isAmbientLight = !0, this.type = "AmbientLight"
    }
}
class qB extends Ol {
    constructor(e, t, n = 10, i = 10) {
        super(e, t), this.isRectAreaLight = !0, this.type = "RectAreaLight", this.width = n, this.height = i
    }
    get power() {
        return this.intensity * this.width * this.height * Math.PI
    }
    set power(e) {
        this.intensity = e / (this.width * this.height * Math.PI)
    }
    copy(e) {
        return super.copy(e), this.width = e.width, this.height = e.height, this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.width = this.width, t.object.height = this.height, t
    }
}
class ZB {
    constructor() {
        this.isSphericalHarmonics3 = !0, this.coefficients = [];
        for (let e = 0; e < 9; e++) this.coefficients.push(new K)
    }
    set(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].copy(e[t]);
        return this
    }
    zero() {
        for (let e = 0; e < 9; e++) this.coefficients[e].set(0, 0, 0);
        return this
    }
    getAt(e, t) {
        const n = e.x,
            i = e.y,
            s = e.z,
            o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.282095), t.addScaledVector(o[1], .488603 * i), t.addScaledVector(o[2], .488603 * s), t.addScaledVector(o[3], .488603 * n), t.addScaledVector(o[4], 1.092548 * (n * i)), t.addScaledVector(o[5], 1.092548 * (i * s)), t.addScaledVector(o[6], .315392 * (3 * s * s - 1)), t.addScaledVector(o[7], 1.092548 * (n * s)), t.addScaledVector(o[8], .546274 * (n * n - i * i)), t
    }
    getIrradianceAt(e, t) {
        const n = e.x,
            i = e.y,
            s = e.z,
            o = this.coefficients;
        return t.copy(o[0]).multiplyScalar(.886227), t.addScaledVector(o[1], 2 * .511664 * i), t.addScaledVector(o[2], 2 * .511664 * s), t.addScaledVector(o[3], 2 * .511664 * n), t.addScaledVector(o[4], 2 * .429043 * n * i), t.addScaledVector(o[5], 2 * .429043 * i * s), t.addScaledVector(o[6], .743125 * s * s - .247708), t.addScaledVector(o[7], 2 * .429043 * n * s), t.addScaledVector(o[8], .429043 * (n * n - i * i)), t
    }
    add(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].add(e.coefficients[t]);
        return this
    }
    addScaledSH(e, t) {
        for (let n = 0; n < 9; n++) this.coefficients[n].addScaledVector(e.coefficients[n], t);
        return this
    }
    scale(e) {
        for (let t = 0; t < 9; t++) this.coefficients[t].multiplyScalar(e);
        return this
    }
    lerp(e, t) {
        for (let n = 0; n < 9; n++) this.coefficients[n].lerp(e.coefficients[n], t);
        return this
    }
    equals(e) {
        for (let t = 0; t < 9; t++)
            if (!this.coefficients[t].equals(e.coefficients[t])) return !1;
        return !0
    }
    copy(e) {
        return this.set(e.coefficients)
    }
    clone() {
        return new this.constructor().copy(this)
    }
    fromArray(e, t = 0) {
        const n = this.coefficients;
        for (let i = 0; i < 9; i++) n[i].fromArray(e, t + i * 3);
        return this
    }
    toArray(e = [], t = 0) {
        const n = this.coefficients;
        for (let i = 0; i < 9; i++) n[i].toArray(e, t + i * 3);
        return e
    }
    static getBasisAt(e, t) {
        const n = e.x,
            i = e.y,
            s = e.z;
        t[0] = .282095, t[1] = .488603 * i, t[2] = .488603 * s, t[3] = .488603 * n, t[4] = 1.092548 * n * i, t[5] = 1.092548 * i * s, t[6] = .315392 * (3 * s * s - 1), t[7] = 1.092548 * n * s, t[8] = .546274 * (n * n - i * i)
    }
}
class QB extends Ol {
    constructor(e = new ZB, t = 1) {
        super(void 0, t), this.isLightProbe = !0, this.sh = e
    }
    copy(e) {
        return super.copy(e), this.sh.copy(e.sh), this
    }
    fromJSON(e) {
        return this.intensity = e.intensity, this.sh.fromArray(e.sh), this
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.object.sh = this.sh.toArray(), t
    }
}
class Oy extends er {
    constructor(e) {
        super(e), this.textures = {}
    }
    load(e, t, n, i) {
        const s = this,
            o = new $i(s.manager);
        o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                i ? i(l) : console.error(l), s.manager.itemError(e)
            }
        }, n, i)
    }
    parse(e) {
        const t = this.textures;

        function n(s) {
            return t[s] === void 0 && console.warn("THREE.MaterialLoader: Undefined texture", s), t[s]
        }
        const i = this.createMaterialFromType(e.type);
        if (e.uuid !== void 0 && (i.uuid = e.uuid), e.name !== void 0 && (i.name = e.name), e.color !== void 0 && i.color !== void 0 && i.color.setHex(e.color), e.roughness !== void 0 && (i.roughness = e.roughness), e.metalness !== void 0 && (i.metalness = e.metalness), e.sheen !== void 0 && (i.sheen = e.sheen), e.sheenColor !== void 0 && (i.sheenColor = new rt().setHex(e.sheenColor)), e.sheenRoughness !== void 0 && (i.sheenRoughness = e.sheenRoughness), e.emissive !== void 0 && i.emissive !== void 0 && i.emissive.setHex(e.emissive), e.specular !== void 0 && i.specular !== void 0 && i.specular.setHex(e.specular), e.specularIntensity !== void 0 && (i.specularIntensity = e.specularIntensity), e.specularColor !== void 0 && i.specularColor !== void 0 && i.specularColor.setHex(e.specularColor), e.shininess !== void 0 && (i.shininess = e.shininess), e.clearcoat !== void 0 && (i.clearcoat = e.clearcoat), e.clearcoatRoughness !== void 0 && (i.clearcoatRoughness = e.clearcoatRoughness), e.dispersion !== void 0 && (i.dispersion = e.dispersion), e.iridescence !== void 0 && (i.iridescence = e.iridescence), e.iridescenceIOR !== void 0 && (i.iridescenceIOR = e.iridescenceIOR), e.iridescenceThicknessRange !== void 0 && (i.iridescenceThicknessRange = e.iridescenceThicknessRange), e.transmission !== void 0 && (i.transmission = e.transmission), e.thickness !== void 0 && (i.thickness = e.thickness), e.attenuationDistance !== void 0 && (i.attenuationDistance = e.attenuationDistance), e.attenuationColor !== void 0 && i.attenuationColor !== void 0 && i.attenuationColor.setHex(e.attenuationColor), e.anisotropy !== void 0 && (i.anisotropy = e.anisotropy), e.anisotropyRotation !== void 0 && (i.anisotropyRotation = e.anisotropyRotation), e.fog !== void 0 && (i.fog = e.fog), e.flatShading !== void 0 && (i.flatShading = e.flatShading), e.blending !== void 0 && (i.blending = e.blending), e.combine !== void 0 && (i.combine = e.combine), e.side !== void 0 && (i.side = e.side), e.shadowSide !== void 0 && (i.shadowSide = e.shadowSide), e.opacity !== void 0 && (i.opacity = e.opacity), e.transparent !== void 0 && (i.transparent = e.transparent), e.alphaTest !== void 0 && (i.alphaTest = e.alphaTest), e.alphaHash !== void 0 && (i.alphaHash = e.alphaHash), e.depthFunc !== void 0 && (i.depthFunc = e.depthFunc), e.depthTest !== void 0 && (i.depthTest = e.depthTest), e.depthWrite !== void 0 && (i.depthWrite = e.depthWrite), e.colorWrite !== void 0 && (i.colorWrite = e.colorWrite), e.blendSrc !== void 0 && (i.blendSrc = e.blendSrc), e.blendDst !== void 0 && (i.blendDst = e.blendDst), e.blendEquation !== void 0 && (i.blendEquation = e.blendEquation), e.blendSrcAlpha !== void 0 && (i.blendSrcAlpha = e.blendSrcAlpha), e.blendDstAlpha !== void 0 && (i.blendDstAlpha = e.blendDstAlpha), e.blendEquationAlpha !== void 0 && (i.blendEquationAlpha = e.blendEquationAlpha), e.blendColor !== void 0 && i.blendColor !== void 0 && i.blendColor.setHex(e.blendColor), e.blendAlpha !== void 0 && (i.blendAlpha = e.blendAlpha), e.stencilWriteMask !== void 0 && (i.stencilWriteMask = e.stencilWriteMask), e.stencilFunc !== void 0 && (i.stencilFunc = e.stencilFunc), e.stencilRef !== void 0 && (i.stencilRef = e.stencilRef), e.stencilFuncMask !== void 0 && (i.stencilFuncMask = e.stencilFuncMask), e.stencilFail !== void 0 && (i.stencilFail = e.stencilFail), e.stencilZFail !== void 0 && (i.stencilZFail = e.stencilZFail), e.stencilZPass !== void 0 && (i.stencilZPass = e.stencilZPass), e.stencilWrite !== void 0 && (i.stencilWrite = e.stencilWrite), e.wireframe !== void 0 && (i.wireframe = e.wireframe), e.wireframeLinewidth !== void 0 && (i.wireframeLinewidth = e.wireframeLinewidth), e.wireframeLinecap !== void 0 && (i.wireframeLinecap = e.wireframeLinecap), e.wireframeLinejoin !== void 0 && (i.wireframeLinejoin = e.wireframeLinejoin), e.rotation !== void 0 && (i.rotation = e.rotation), e.linewidth !== void 0 && (i.linewidth = e.linewidth), e.dashSize !== void 0 && (i.dashSize = e.dashSize), e.gapSize !== void 0 && (i.gapSize = e.gapSize), e.scale !== void 0 && (i.scale = e.scale), e.polygonOffset !== void 0 && (i.polygonOffset = e.polygonOffset), e.polygonOffsetFactor !== void 0 && (i.polygonOffsetFactor = e.polygonOffsetFactor), e.polygonOffsetUnits !== void 0 && (i.polygonOffsetUnits = e.polygonOffsetUnits), e.dithering !== void 0 && (i.dithering = e.dithering), e.alphaToCoverage !== void 0 && (i.alphaToCoverage = e.alphaToCoverage), e.premultipliedAlpha !== void 0 && (i.premultipliedAlpha = e.premultipliedAlpha), e.forceSinglePass !== void 0 && (i.forceSinglePass = e.forceSinglePass), e.visible !== void 0 && (i.visible = e.visible), e.toneMapped !== void 0 && (i.toneMapped = e.toneMapped), e.userData !== void 0 && (i.userData = e.userData), e.vertexColors !== void 0 && (typeof e.vertexColors == "number" ? i.vertexColors = e.vertexColors > 0 : i.vertexColors = e.vertexColors), e.uniforms !== void 0)
            for (const s in e.uniforms) {
                const o = e.uniforms[s];
                switch (i.uniforms[s] = {}, o.type) {
                    case "t":
                        i.uniforms[s].value = n(o.value);
                        break;
                    case "c":
                        i.uniforms[s].value = new rt().setHex(o.value);
                        break;
                    case "v2":
                        i.uniforms[s].value = new Ue().fromArray(o.value);
                        break;
                    case "v3":
                        i.uniforms[s].value = new K().fromArray(o.value);
                        break;
                    case "v4":
                        i.uniforms[s].value = new An().fromArray(o.value);
                        break;
                    case "m3":
                        i.uniforms[s].value = new jt().fromArray(o.value);
                        break;
                    case "m4":
                        i.uniforms[s].value = new Ot().fromArray(o.value);
                        break;
                    default:
                        i.uniforms[s].value = o.value
                }
            }
        if (e.defines !== void 0 && (i.defines = e.defines), e.vertexShader !== void 0 && (i.vertexShader = e.vertexShader), e.fragmentShader !== void 0 && (i.fragmentShader = e.fragmentShader), e.glslVersion !== void 0 && (i.glslVersion = e.glslVersion), e.extensions !== void 0)
            for (const s in e.extensions) i.extensions[s] = e.extensions[s];
        if (e.lights !== void 0 && (i.lights = e.lights), e.clipping !== void 0 && (i.clipping = e.clipping), e.size !== void 0 && (i.size = e.size), e.sizeAttenuation !== void 0 && (i.sizeAttenuation = e.sizeAttenuation), e.map !== void 0 && (i.map = n(e.map)), e.matcap !== void 0 && (i.matcap = n(e.matcap)), e.alphaMap !== void 0 && (i.alphaMap = n(e.alphaMap)), e.bumpMap !== void 0 && (i.bumpMap = n(e.bumpMap)), e.bumpScale !== void 0 && (i.bumpScale = e.bumpScale), e.normalMap !== void 0 && (i.normalMap = n(e.normalMap)), e.normalMapType !== void 0 && (i.normalMapType = e.normalMapType), e.normalScale !== void 0) {
            let s = e.normalScale;
            Array.isArray(s) === !1 && (s = [s, s]), i.normalScale = new Ue().fromArray(s)
        }
        return e.displacementMap !== void 0 && (i.displacementMap = n(e.displacementMap)), e.displacementScale !== void 0 && (i.displacementScale = e.displacementScale), e.displacementBias !== void 0 && (i.displacementBias = e.displacementBias), e.roughnessMap !== void 0 && (i.roughnessMap = n(e.roughnessMap)), e.metalnessMap !== void 0 && (i.metalnessMap = n(e.metalnessMap)), e.emissiveMap !== void 0 && (i.emissiveMap = n(e.emissiveMap)), e.emissiveIntensity !== void 0 && (i.emissiveIntensity = e.emissiveIntensity), e.specularMap !== void 0 && (i.specularMap = n(e.specularMap)), e.specularIntensityMap !== void 0 && (i.specularIntensityMap = n(e.specularIntensityMap)), e.specularColorMap !== void 0 && (i.specularColorMap = n(e.specularColorMap)), e.envMap !== void 0 && (i.envMap = n(e.envMap)), e.envMapRotation !== void 0 && i.envMapRotation.fromArray(e.envMapRotation), e.envMapIntensity !== void 0 && (i.envMapIntensity = e.envMapIntensity), e.reflectivity !== void 0 && (i.reflectivity = e.reflectivity), e.refractionRatio !== void 0 && (i.refractionRatio = e.refractionRatio), e.lightMap !== void 0 && (i.lightMap = n(e.lightMap)), e.lightMapIntensity !== void 0 && (i.lightMapIntensity = e.lightMapIntensity), e.aoMap !== void 0 && (i.aoMap = n(e.aoMap)), e.aoMapIntensity !== void 0 && (i.aoMapIntensity = e.aoMapIntensity), e.gradientMap !== void 0 && (i.gradientMap = n(e.gradientMap)), e.clearcoatMap !== void 0 && (i.clearcoatMap = n(e.clearcoatMap)), e.clearcoatRoughnessMap !== void 0 && (i.clearcoatRoughnessMap = n(e.clearcoatRoughnessMap)), e.clearcoatNormalMap !== void 0 && (i.clearcoatNormalMap = n(e.clearcoatNormalMap)), e.clearcoatNormalScale !== void 0 && (i.clearcoatNormalScale = new Ue().fromArray(e.clearcoatNormalScale)), e.iridescenceMap !== void 0 && (i.iridescenceMap = n(e.iridescenceMap)), e.iridescenceThicknessMap !== void 0 && (i.iridescenceThicknessMap = n(e.iridescenceThicknessMap)), e.transmissionMap !== void 0 && (i.transmissionMap = n(e.transmissionMap)), e.thicknessMap !== void 0 && (i.thicknessMap = n(e.thicknessMap)), e.anisotropyMap !== void 0 && (i.anisotropyMap = n(e.anisotropyMap)), e.sheenColorMap !== void 0 && (i.sheenColorMap = n(e.sheenColorMap)), e.sheenRoughnessMap !== void 0 && (i.sheenRoughnessMap = n(e.sheenRoughnessMap)), i
    }
    setTextures(e) {
        return this.textures = e, this
    }
    createMaterialFromType(e) {
        return Oy.createMaterialFromType(e)
    }
    static createMaterialFromType(e) {
        const t = {
            ShadowMaterial: UB,
            SpriteMaterial: qS,
            RawShaderMaterial: Fv,
            ShaderMaterial: Fn,
            PointsMaterial: qp,
            MeshPhysicalMaterial: Ts,
            MeshStandardMaterial: mu,
            MeshPhongMaterial: OB,
            MeshToonMaterial: NB,
            MeshNormalMaterial: oM,
            MeshLambertMaterial: kB,
            MeshDepthMaterial: gy,
            MeshDistanceMaterial: vy,
            MeshBasicMaterial: Mi,
            MeshMatcapMaterial: zB,
            LineDashedMaterial: GB,
            LineBasicMaterial: yr,
            Material: mi
        };
        return new t[e]
    }
}
class pl {
    static decodeText(e) {
        if (console.warn("THREE.LoaderUtils: decodeText() has been deprecated with r165 and will be removed with r175. Use TextDecoder instead."), typeof TextDecoder < "u") return new TextDecoder().decode(e);
        let t = "";
        for (let n = 0, i = e.length; n < i; n++) t += String.fromCharCode(e[n]);
        try {
            return decodeURIComponent(escape(t))
        } catch {
            return t
        }
    }
    static extractUrlBase(e) {
        const t = e.lastIndexOf("/");
        return t === -1 ? "./" : e.slice(0, t + 1)
    }
    static resolveURL(e, t) {
        return typeof e != "string" || e === "" ? "" : (/^https?:\/\//i.test(t) && /^\//.test(e) && (t = t.replace(/(^https?:\/\/[^\/]+).*/i, "$1")), /^(https?:)?\/\//i.test(e) || /^data:.*,.*$/i.test(e) || /^blob:.*$/i.test(e) ? e : t + e)
    }
}
class pM extends zt {
    constructor() {
        super(), this.isInstancedBufferGeometry = !0, this.type = "InstancedBufferGeometry", this.instanceCount = 1 / 0
    }
    copy(e) {
        return super.copy(e), this.instanceCount = e.instanceCount, this
    }
    toJSON() {
        const e = super.toJSON();
        return e.instanceCount = this.instanceCount, e.isInstancedBufferGeometry = !0, e
    }
}
class $B extends er {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const s = this,
            o = new $i(s.manager);
        o.setPath(s.path), o.setRequestHeader(s.requestHeader), o.setWithCredentials(s.withCredentials), o.load(e, function(a) {
            try {
                t(s.parse(JSON.parse(a)))
            } catch (l) {
                i ? i(l) : console.error(l), s.manager.itemError(e)
            }
        }, n, i)
    }
    parse(e) {
        const t = {},
            n = {};

        function i(m, g) {
            if (t[g] !== void 0) return t[g];
            const v = m.interleavedBuffers[g],
                _ = s(m, v.buffer),
                A = mf(v.type, _),
                S = new Jp(A, v.stride);
            return S.uuid = v.uuid, t[g] = S, S
        }

        function s(m, g) {
            if (n[g] !== void 0) return n[g];
            const v = m.arrayBuffers[g],
                _ = new Uint32Array(v).buffer;
            return n[g] = _, _
        }
        const o = e.isInstancedBufferGeometry ? new pM : new zt,
            a = e.data.index;
        if (a !== void 0) {
            const m = mf(a.type, a.array);
            o.setIndex(new an(m, 1))
        }
        const l = e.data.attributes;
        for (const m in l) {
            const g = l[m];
            let y;
            if (g.isInterleavedBufferAttribute) {
                const v = i(e.data, g.data);
                y = new Tl(v, g.itemSize, g.offset, g.normalized)
            } else {
                const v = mf(g.type, g.array),
                    _ = g.isInstancedBufferAttribute ? El : an;
                y = new _(v, g.itemSize, g.normalized)
            }
            g.name !== void 0 && (y.name = g.name), g.usage !== void 0 && y.setUsage(g.usage), o.setAttribute(m, y)
        }
        const c = e.data.morphAttributes;
        if (c)
            for (const m in c) {
                const g = c[m],
                    y = [];
                for (let v = 0, _ = g.length; v < _; v++) {
                    const A = g[v];
                    let S;
                    if (A.isInterleavedBufferAttribute) {
                        const M = i(e.data, A.data);
                        S = new Tl(M, A.itemSize, A.offset, A.normalized)
                    } else {
                        const M = mf(A.type, A.array);
                        S = new an(M, A.itemSize, A.normalized)
                    }
                    A.name !== void 0 && (S.name = A.name), y.push(S)
                }
                o.morphAttributes[m] = y
            }
        e.data.morphTargetsRelative && (o.morphTargetsRelative = !0);
        const f = e.data.groups || e.data.drawcalls || e.data.offsets;
        if (f !== void 0)
            for (let m = 0, g = f.length; m !== g; ++m) {
                const y = f[m];
                o.addGroup(y.start, y.count, y.materialIndex)
            }
        const d = e.data.boundingSphere;
        if (d !== void 0) {
            const m = new K;
            d.center !== void 0 && m.fromArray(d.center), o.boundingSphere = new ji(m, d.radius)
        }
        return e.name && (o.name = e.name), e.userData && (o.userData = e.userData), o
    }
}
class gV extends er {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const s = this,
            o = this.path === "" ? pl.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || o;
        const a = new $i(this.manager);
        a.setPath(this.path), a.setRequestHeader(this.requestHeader), a.setWithCredentials(this.withCredentials), a.load(e, function(l) {
            let c = null;
            try {
                c = JSON.parse(l)
            } catch (f) {
                i !== void 0 && i(f), console.error("THREE:ObjectLoader: Can't parse " + e + ".", f.message);
                return
            }
            const u = c.metadata;
            if (u === void 0 || u.type === void 0 || u.type.toLowerCase() === "geometry") {
                i !== void 0 && i(new Error("THREE.ObjectLoader: Can't load " + e)), console.error("THREE.ObjectLoader: Can't load " + e);
                return
            }
            s.parse(c, t)
        }, n, i)
    }
    async loadAsync(e, t) {
        const n = this,
            i = this.path === "" ? pl.extractUrlBase(e) : this.path;
        this.resourcePath = this.resourcePath || i;
        const s = new $i(this.manager);
        s.setPath(this.path), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials);
        const o = await s.loadAsync(e, t),
            a = JSON.parse(o),
            l = a.metadata;
        if (l === void 0 || l.type === void 0 || l.type.toLowerCase() === "geometry") throw new Error("THREE.ObjectLoader: Can't load " + e);
        return await n.parseAsync(a)
    }
    parse(e, t) {
        const n = this.parseAnimations(e.animations),
            i = this.parseShapes(e.shapes),
            s = this.parseGeometries(e.geometries, i),
            o = this.parseImages(e.images, function() {
                t !== void 0 && t(c)
            }),
            a = this.parseTextures(e.textures, o),
            l = this.parseMaterials(e.materials, a),
            c = this.parseObject(e.object, s, l, a, n),
            u = this.parseSkeletons(e.skeletons, c);
        if (this.bindSkeletons(c, u), this.bindLightTargets(c), t !== void 0) {
            let f = !1;
            for (const d in o)
                if (o[d].data instanceof HTMLImageElement) {
                    f = !0;
                    break
                }
            f === !1 && t(c)
        }
        return c
    }
    async parseAsync(e) {
        const t = this.parseAnimations(e.animations),
            n = this.parseShapes(e.shapes),
            i = this.parseGeometries(e.geometries, n),
            s = await this.parseImagesAsync(e.images),
            o = this.parseTextures(e.textures, s),
            a = this.parseMaterials(e.materials, o),
            l = this.parseObject(e.object, i, a, o, t),
            c = this.parseSkeletons(e.skeletons, l);
        return this.bindSkeletons(l, c), this.bindLightTargets(l), l
    }
    parseShapes(e) {
        const t = {};
        if (e !== void 0)
            for (let n = 0, i = e.length; n < i; n++) {
                const s = new dl().fromJSON(e[n]);
                t[s.uuid] = s
            }
        return t
    }
    parseSkeletons(e, t) {
        const n = {},
            i = {};
        if (t.traverse(function(s) {
                s.isBone && (i[s.uuid] = s)
            }), e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = new Kp().fromJSON(e[s], i);
                n[a.uuid] = a
            }
        return n
    }
    parseGeometries(e, t) {
        const n = {};
        if (e !== void 0) {
            const i = new $B;
            for (let s = 0, o = e.length; s < o; s++) {
                let a;
                const l = e[s];
                switch (l.type) {
                    case "BufferGeometry":
                    case "InstancedBufferGeometry":
                        a = i.parse(l);
                        break;
                    default:
                        l.type in eC ? a = eC[l.type].fromJSON(l, t) : console.warn(`THREE.ObjectLoader: Unsupported geometry type "${l.type}"`)
                }
                a.uuid = l.uuid, l.name !== void 0 && (a.name = l.name), l.userData !== void 0 && (a.userData = l.userData), n[l.uuid] = a
            }
        }
        return n
    }
    parseMaterials(e, t) {
        const n = {},
            i = {};
        if (e !== void 0) {
            const s = new Oy;
            s.setTextures(t);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o];
                n[l.uuid] === void 0 && (n[l.uuid] = s.parse(l)), i[l.uuid] = n[l.uuid]
            }
        }
        return i
    }
    parseAnimations(e) {
        const t = {};
        if (e !== void 0)
            for (let n = 0; n < e.length; n++) {
                const i = e[n],
                    s = eh.parse(i);
                t[s.uuid] = s
            }
        return t
    }
    parseImages(e, t) {
        const n = this,
            i = {};
        let s;

        function o(l) {
            return n.manager.itemStart(l), s.load(l, function() {
                n.manager.itemEnd(l)
            }, void 0, function() {
                n.manager.itemError(l), n.manager.itemEnd(l)
            })
        }

        function a(l) {
            if (typeof l == "string") {
                const c = l,
                    u = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(c) ? c : n.resourcePath + c;
                return o(u)
            } else return l.data ? {
                data: mf(l.type, l.data),
                width: l.width,
                height: l.height
            } : null
        }
        if (e !== void 0 && e.length > 0) {
            const l = new Fy(t);
            s = new Sp(l), s.setCrossOrigin(this.crossOrigin);
            for (let c = 0, u = e.length; c < u; c++) {
                const f = e[c],
                    d = f.url;
                if (Array.isArray(d)) {
                    const m = [];
                    for (let g = 0, y = d.length; g < y; g++) {
                        const v = d[g],
                            _ = a(v);
                        _ !== null && (_ instanceof HTMLImageElement ? m.push(_) : m.push(new qr(_.data, _.width, _.height)))
                    }
                    i[f.uuid] = new Dc(m)
                } else {
                    const m = a(f.url);
                    i[f.uuid] = new Dc(m)
                }
            }
        }
        return i
    }
    async parseImagesAsync(e) {
        const t = this,
            n = {};
        let i;
        async function s(o) {
            if (typeof o == "string") {
                const a = o,
                    l = /^(\/\/)|([a-z]+:(\/\/)?)/i.test(a) ? a : t.resourcePath + a;
                return await i.loadAsync(l)
            } else return o.data ? {
                data: mf(o.type, o.data),
                width: o.width,
                height: o.height
            } : null
        }
        if (e !== void 0 && e.length > 0) {
            i = new Sp(this.manager), i.setCrossOrigin(this.crossOrigin);
            for (let o = 0, a = e.length; o < a; o++) {
                const l = e[o],
                    c = l.url;
                if (Array.isArray(c)) {
                    const u = [];
                    for (let f = 0, d = c.length; f < d; f++) {
                        const m = c[f],
                            g = await s(m);
                        g !== null && (g instanceof HTMLImageElement ? u.push(g) : u.push(new qr(g.data, g.width, g.height)))
                    }
                    n[l.uuid] = new Dc(u)
                } else {
                    const u = await s(l.url);
                    n[l.uuid] = new Dc(u)
                }
            }
        }
        return n
    }
    parseTextures(e, t) {
        function n(s, o) {
            return typeof s == "number" ? s : (console.warn("THREE.ObjectLoader.parseTexture: Constant should be in numeric form.", s), o[s])
        }
        const i = {};
        if (e !== void 0)
            for (let s = 0, o = e.length; s < o; s++) {
                const a = e[s];
                a.image === void 0 && console.warn('THREE.ObjectLoader: No "image" specified for', a.uuid), t[a.image] === void 0 && console.warn("THREE.ObjectLoader: Undefined image", a.image);
                const l = t[a.image],
                    c = l.data;
                let u;
                Array.isArray(c) ? (u = new jp, c.length === 6 && (u.needsUpdate = !0)) : (c && c.data ? u = new qr : u = new gn, c && (u.needsUpdate = !0)), u.source = l, u.uuid = a.uuid, a.name !== void 0 && (u.name = a.name), a.mapping !== void 0 && (u.mapping = n(a.mapping, vV)), a.channel !== void 0 && (u.channel = a.channel), a.offset !== void 0 && u.offset.fromArray(a.offset), a.repeat !== void 0 && u.repeat.fromArray(a.repeat), a.center !== void 0 && u.center.fromArray(a.center), a.rotation !== void 0 && (u.rotation = a.rotation), a.wrap !== void 0 && (u.wrapS = n(a.wrap[0], rC), u.wrapT = n(a.wrap[1], rC)), a.format !== void 0 && (u.format = a.format), a.internalFormat !== void 0 && (u.internalFormat = a.internalFormat), a.type !== void 0 && (u.type = a.type), a.colorSpace !== void 0 && (u.colorSpace = a.colorSpace), a.minFilter !== void 0 && (u.minFilter = n(a.minFilter, sC)), a.magFilter !== void 0 && (u.magFilter = n(a.magFilter, sC)), a.anisotropy !== void 0 && (u.anisotropy = a.anisotropy), a.flipY !== void 0 && (u.flipY = a.flipY), a.generateMipmaps !== void 0 && (u.generateMipmaps = a.generateMipmaps), a.premultiplyAlpha !== void 0 && (u.premultiplyAlpha = a.premultiplyAlpha), a.unpackAlignment !== void 0 && (u.unpackAlignment = a.unpackAlignment), a.compareFunction !== void 0 && (u.compareFunction = a.compareFunction), a.userData !== void 0 && (u.userData = a.userData), i[a.uuid] = u
            }
        return i
    }
    parseObject(e, t, n, i, s) {
        let o;

        function a(d) {
            return t[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined geometry", d), t[d]
        }

        function l(d) {
            if (d !== void 0) {
                if (Array.isArray(d)) {
                    const m = [];
                    for (let g = 0, y = d.length; g < y; g++) {
                        const v = d[g];
                        n[v] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", v), m.push(n[v])
                    }
                    return m
                }
                return n[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined material", d), n[d]
            }
        }

        function c(d) {
            return i[d] === void 0 && console.warn("THREE.ObjectLoader: Undefined texture", d), i[d]
        }
        let u, f;
        switch (e.type) {
            case "Scene":
                o = new ho, e.background !== void 0 && (Number.isInteger(e.background) ? o.background = new rt(e.background) : o.background = c(e.background)), e.environment !== void 0 && (o.environment = c(e.environment)), e.fog !== void 0 && (e.fog.type === "Fog" ? o.fog = new _y(e.fog.color, e.fog.near, e.fog.far) : e.fog.type === "FogExp2" && (o.fog = new yy(e.fog.color, e.fog.density)), e.fog.name !== "" && (o.fog.name = e.fog.name)), e.backgroundBlurriness !== void 0 && (o.backgroundBlurriness = e.backgroundBlurriness), e.backgroundIntensity !== void 0 && (o.backgroundIntensity = e.backgroundIntensity), e.backgroundRotation !== void 0 && o.backgroundRotation.fromArray(e.backgroundRotation), e.environmentIntensity !== void 0 && (o.environmentIntensity = e.environmentIntensity), e.environmentRotation !== void 0 && o.environmentRotation.fromArray(e.environmentRotation);
                break;
            case "PerspectiveCamera":
                o = new ri(e.fov, e.aspect, e.near, e.far), e.focus !== void 0 && (o.focus = e.focus), e.zoom !== void 0 && (o.zoom = e.zoom), e.filmGauge !== void 0 && (o.filmGauge = e.filmGauge), e.filmOffset !== void 0 && (o.filmOffset = e.filmOffset), e.view !== void 0 && (o.view = Object.assign({}, e.view));
                break;
            case "OrthographicCamera":
                o = new Ca(e.left, e.right, e.top, e.bottom, e.near, e.far), e.zoom !== void 0 && (o.zoom = e.zoom), e.view !== void 0 && (o.view = Object.assign({}, e.view));
                break;
            case "AmbientLight":
                o = new dM(e.color, e.intensity);
                break;
            case "DirectionalLight":
                o = new Mp(e.color, e.intensity), o.target = e.target || "";
                break;
            case "PointLight":
                o = new Uy(e.color, e.intensity, e.distance, e.decay);
                break;
            case "RectAreaLight":
                o = new qB(e.color, e.intensity, e.width, e.height);
                break;
            case "SpotLight":
                o = new hM(e.color, e.intensity, e.distance, e.angle, e.penumbra, e.decay), o.target = e.target || "";
                break;
            case "HemisphereLight":
                o = new KB(e.color, e.groundColor, e.intensity);
                break;
            case "LightProbe":
                o = new QB().fromJSON(e);
                break;
            case "SkinnedMesh":
                u = a(e.geometry), f = l(e.material), o = new ZS(u, f), e.bindMode !== void 0 && (o.bindMode = e.bindMode), e.bindMatrix !== void 0 && o.bindMatrix.fromArray(e.bindMatrix), e.skeleton !== void 0 && (o.skeleton = e.skeleton);
                break;
            case "Mesh":
                u = a(e.geometry), f = l(e.material), o = new Tn(u, f);
                break;
            case "InstancedMesh":
                u = a(e.geometry), f = l(e.material);
                const d = e.count,
                    m = e.instanceMatrix,
                    g = e.instanceColor;
                o = new QS(u, f, d), o.instanceMatrix = new El(new Float32Array(m.array), 16), g !== void 0 && (o.instanceColor = new El(new Float32Array(g.array), g.itemSize));
                break;
            case "BatchedMesh":
                u = a(e.geometry), f = l(e.material), o = new bB(e.maxInstanceCount, e.maxVertexCount, e.maxIndexCount, f), o.geometry = u, o.perObjectFrustumCulled = e.perObjectFrustumCulled, o.sortObjects = e.sortObjects, o._drawRanges = e.drawRanges, o._reservedRanges = e.reservedRanges, o._visibility = e.visibility, o._active = e.active, o._bounds = e.bounds.map(y => {
                    const v = new Wi;
                    v.min.fromArray(y.boxMin), v.max.fromArray(y.boxMax);
                    const _ = new ji;
                    return _.radius = y.sphereRadius, _.center.fromArray(y.sphereCenter), {
                        boxInitialized: y.boxInitialized,
                        box: v,
                        sphereInitialized: y.sphereInitialized,
                        sphere: _
                    }
                }), o._maxInstanceCount = e.maxInstanceCount, o._maxVertexCount = e.maxVertexCount, o._maxIndexCount = e.maxIndexCount, o._geometryInitialized = e.geometryInitialized, o._geometryCount = e.geometryCount, o._matricesTexture = c(e.matricesTexture.uuid), e.colorsTexture !== void 0 && (o._colorsTexture = c(e.colorsTexture.uuid));
                break;
            case "LOD":
                o = new wB;
                break;
            case "Line":
                o = new Ta(a(e.geometry), l(e.material));
                break;
            case "LineLoop":
                o = new $S(a(e.geometry), l(e.material));
                break;
            case "LineSegments":
                o = new po(a(e.geometry), l(e.material));
                break;
            case "PointCloud":
            case "Points":
                o = new Ay(a(e.geometry), l(e.material));
                break;
            case "Sprite":
                o = new MB(l(e.material));
                break;
            case "Group":
                o = new da;
                break;
            case "Bone":
                o = new xy;
                break;
            default:
                o = new vn
        }
        if (o.uuid = e.uuid, e.name !== void 0 && (o.name = e.name), e.matrix !== void 0 ? (o.matrix.fromArray(e.matrix), e.matrixAutoUpdate !== void 0 && (o.matrixAutoUpdate = e.matrixAutoUpdate), o.matrixAutoUpdate && o.matrix.decompose(o.position, o.quaternion, o.scale)) : (e.position !== void 0 && o.position.fromArray(e.position), e.rotation !== void 0 && o.rotation.fromArray(e.rotation), e.quaternion !== void 0 && o.quaternion.fromArray(e.quaternion), e.scale !== void 0 && o.scale.fromArray(e.scale)), e.up !== void 0 && o.up.fromArray(e.up), e.castShadow !== void 0 && (o.castShadow = e.castShadow), e.receiveShadow !== void 0 && (o.receiveShadow = e.receiveShadow), e.shadow && (e.shadow.intensity !== void 0 && (o.shadow.intensity = e.shadow.intensity), e.shadow.bias !== void 0 && (o.shadow.bias = e.shadow.bias), e.shadow.normalBias !== void 0 && (o.shadow.normalBias = e.shadow.normalBias), e.shadow.radius !== void 0 && (o.shadow.radius = e.shadow.radius), e.shadow.mapSize !== void 0 && o.shadow.mapSize.fromArray(e.shadow.mapSize), e.shadow.camera !== void 0 && (o.shadow.camera = this.parseObject(e.shadow.camera))), e.visible !== void 0 && (o.visible = e.visible), e.frustumCulled !== void 0 && (o.frustumCulled = e.frustumCulled), e.renderOrder !== void 0 && (o.renderOrder = e.renderOrder), e.userData !== void 0 && (o.userData = e.userData), e.layers !== void 0 && (o.layers.mask = e.layers), e.children !== void 0) {
            const d = e.children;
            for (let m = 0; m < d.length; m++) o.add(this.parseObject(d[m], t, n, i, s))
        }
        if (e.animations !== void 0) {
            const d = e.animations;
            for (let m = 0; m < d.length; m++) {
                const g = d[m];
                o.animations.push(s[g])
            }
        }
        if (e.type === "LOD") {
            e.autoUpdate !== void 0 && (o.autoUpdate = e.autoUpdate);
            const d = e.levels;
            for (let m = 0; m < d.length; m++) {
                const g = d[m],
                    y = o.getObjectByProperty("uuid", g.object);
                y !== void 0 && o.addLevel(y, g.distance, g.hysteresis)
            }
        }
        return o
    }
    bindSkeletons(e, t) {
        Object.keys(t).length !== 0 && e.traverse(function(n) {
            if (n.isSkinnedMesh === !0 && n.skeleton !== void 0) {
                const i = t[n.skeleton];
                i === void 0 ? console.warn("THREE.ObjectLoader: No skeleton found with UUID:", n.skeleton) : n.bind(i, n.bindMatrix)
            }
        })
    }
    bindLightTargets(e) {
        e.traverse(function(t) {
            if (t.isDirectionalLight || t.isSpotLight) {
                const n = t.target,
                    i = e.getObjectByProperty("uuid", n);
                i !== void 0 ? t.target = i : t.target = new vn
            }
        })
    }
}
const vV = {
        UVMapping: xl,
        CubeReflectionMapping: ko,
        CubeRefractionMapping: Al,
        EquirectangularReflectionMapping: ou,
        EquirectangularRefractionMapping: dp,
        CubeUVReflectionMapping: ah
    },
    rC = {
        RepeatWrapping: Sl,
        ClampToEdgeWrapping: Nn,
        MirroredRepeatWrapping: au
    },
    sC = {
        NearestFilter: bn,
        NearestMipmapNearestFilter: sy,
        NearestMipmapLinearFilter: Pc,
        LinearFilter: nn,
        LinearMipmapNearestFilter: If,
        LinearMipmapLinearFilter: gs
    };
class eD extends er {
    constructor(e) {
        super(e), this.isImageBitmapLoader = !0, typeof createImageBitmap > "u" && console.warn("THREE.ImageBitmapLoader: createImageBitmap() not supported."), typeof fetch > "u" && console.warn("THREE.ImageBitmapLoader: fetch() not supported."), this.options = {
            premultiplyAlpha: "none"
        }
    }
    setOptions(e) {
        return this.options = e, this
    }
    load(e, t, n, i) {
        e === void 0 && (e = ""), this.path !== void 0 && (e = this.path + e), e = this.manager.resolveURL(e);
        const s = this,
            o = pa.get(e);
        if (o !== void 0) {
            if (s.manager.itemStart(e), o.then) {
                o.then(c => {
                    t && t(c), s.manager.itemEnd(e)
                }).catch(c => {
                    i && i(c)
                });
                return
            }
            return setTimeout(function() {
                t && t(o), s.manager.itemEnd(e)
            }, 0), o
        }
        const a = {};
        a.credentials = this.crossOrigin === "anonymous" ? "same-origin" : "include", a.headers = this.requestHeader;
        const l = fetch(e, a).then(function(c) {
            return c.blob()
        }).then(function(c) {
            return createImageBitmap(c, Object.assign(s.options, {
                colorSpaceConversion: "none"
            }))
        }).then(function(c) {
            return pa.add(e, c), t && t(c), s.manager.itemEnd(e), c
        }).catch(function(c) {
            i && i(c), pa.remove(e), s.manager.itemError(e), s.manager.itemEnd(e)
        });
        pa.add(e, l), s.manager.itemStart(e)
    }
}
let $g;
class mM {
    static getContext() {
        return $g === void 0 && ($g = new(window.AudioContext || window.webkitAudioContext)), $g
    }
    static setContext(e) {
        $g = e
    }
}
class yV extends er {
    constructor(e) {
        super(e)
    }
    load(e, t, n, i) {
        const s = this,
            o = new $i(this.manager);
        o.setResponseType("arraybuffer"), o.setPath(this.path), o.setRequestHeader(this.requestHeader), o.setWithCredentials(this.withCredentials), o.load(e, function(l) {
            try {
                const c = l.slice(0);
                mM.getContext().decodeAudioData(c, function(f) {
                    t(f)
                }).catch(a)
            } catch (c) {
                a(c)
            }
        }, n, i);

        function a(l) {
            i ? i(l) : console.error(l), s.manager.itemError(e)
        }
    }
}
const oC = new Ot,
    aC = new Ot,
    fc = new Ot;
class _V {
    constructor() {
        this.type = "StereoCamera", this.aspect = 1, this.eyeSep = .064, this.cameraL = new ri, this.cameraL.layers.enable(1), this.cameraL.matrixAutoUpdate = !1, this.cameraR = new ri, this.cameraR.layers.enable(2), this.cameraR.matrixAutoUpdate = !1, this._cache = {
            focus: null,
            fov: null,
            aspect: null,
            near: null,
            far: null,
            zoom: null,
            eyeSep: null
        }
    }
    update(e) {
        const t = this._cache;
        if (t.focus !== e.focus || t.fov !== e.fov || t.aspect !== e.aspect * this.aspect || t.near !== e.near || t.far !== e.far || t.zoom !== e.zoom || t.eyeSep !== this.eyeSep) {
            t.focus = e.focus, t.fov = e.fov, t.aspect = e.aspect * this.aspect, t.near = e.near, t.far = e.far, t.zoom = e.zoom, t.eyeSep = this.eyeSep, fc.copy(e.projectionMatrix);
            const i = t.eyeSep / 2,
                s = i * t.near / t.focus,
                o = t.near * Math.tan(Jc * t.fov * .5) / t.zoom;
            let a, l;
            aC.elements[12] = -i, oC.elements[12] = i, a = -o * t.aspect + s, l = o * t.aspect + s, fc.elements[0] = 2 * t.near / (l - a), fc.elements[8] = (l + a) / (l - a), this.cameraL.projectionMatrix.copy(fc), a = -o * t.aspect - s, l = o * t.aspect - s, fc.elements[0] = 2 * t.near / (l - a), fc.elements[8] = (l + a) / (l - a), this.cameraR.projectionMatrix.copy(fc)
        }
        this.cameraL.matrixWorld.copy(e.matrixWorld).multiply(aC), this.cameraR.matrixWorld.copy(e.matrixWorld).multiply(oC)
    }
}
class gM {
    constructor(e = !0) {
        this.autoStart = e, this.startTime = 0, this.oldTime = 0, this.elapsedTime = 0, this.running = !1
    }
    start() {
        this.startTime = lC(), this.oldTime = this.startTime, this.elapsedTime = 0, this.running = !0
    }
    stop() {
        this.getElapsedTime(), this.running = !1, this.autoStart = !1
    }
    getElapsedTime() {
        return this.getDelta(), this.elapsedTime
    }
    getDelta() {
        let e = 0;
        if (this.autoStart && !this.running) return this.start(), 0;
        if (this.running) {
            const t = lC();
            e = (t - this.oldTime) / 1e3, this.oldTime = t, this.elapsedTime += e
        }
        return e
    }
}

function lC() {
    return performance.now()
}
const hc = new K,
    cC = new gr,
    xV = new K,
    dc = new K;
class AV extends vn {
    constructor() {
        super(), this.type = "AudioListener", this.context = mM.getContext(), this.gain = this.context.createGain(), this.gain.connect(this.context.destination), this.filter = null, this.timeDelta = 0, this._clock = new gM
    }
    getInput() {
        return this.gain
    }
    removeFilter() {
        return this.filter !== null && (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination), this.gain.connect(this.context.destination), this.filter = null), this
    }
    getFilter() {
        return this.filter
    }
    setFilter(e) {
        return this.filter !== null ? (this.gain.disconnect(this.filter), this.filter.disconnect(this.context.destination)) : this.gain.disconnect(this.context.destination), this.filter = e, this.gain.connect(this.filter), this.filter.connect(this.context.destination), this
    }
    getMasterVolume() {
        return this.gain.gain.value
    }
    setMasterVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
    }
    updateMatrixWorld(e) {
        super.updateMatrixWorld(e);
        const t = this.context.listener,
            n = this.up;
        if (this.timeDelta = this._clock.getDelta(), this.matrixWorld.decompose(hc, cC, xV), dc.set(0, 0, -1).applyQuaternion(cC), t.positionX) {
            const i = this.context.currentTime + this.timeDelta;
            t.positionX.linearRampToValueAtTime(hc.x, i), t.positionY.linearRampToValueAtTime(hc.y, i), t.positionZ.linearRampToValueAtTime(hc.z, i), t.forwardX.linearRampToValueAtTime(dc.x, i), t.forwardY.linearRampToValueAtTime(dc.y, i), t.forwardZ.linearRampToValueAtTime(dc.z, i), t.upX.linearRampToValueAtTime(n.x, i), t.upY.linearRampToValueAtTime(n.y, i), t.upZ.linearRampToValueAtTime(n.z, i)
        } else t.setPosition(hc.x, hc.y, hc.z), t.setOrientation(dc.x, dc.y, dc.z, n.x, n.y, n.z)
    }
}
let tD = class extends vn {
    constructor(e) {
        super(), this.type = "Audio", this.listener = e, this.context = e.context, this.gain = this.context.createGain(), this.gain.connect(e.getInput()), this.autoplay = !1, this.buffer = null, this.detune = 0, this.loop = !1, this.loopStart = 0, this.loopEnd = 0, this.offset = 0, this.duration = void 0, this.playbackRate = 1, this.isPlaying = !1, this.hasPlaybackControl = !0, this.source = null, this.sourceType = "empty", this._startedAt = 0, this._progress = 0, this._connected = !1, this.filters = []
    }
    getOutput() {
        return this.gain
    }
    setNodeSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "audioNode", this.source = e, this.connect(), this
    }
    setMediaElementSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaNode", this.source = this.context.createMediaElementSource(e), this.connect(), this
    }
    setMediaStreamSource(e) {
        return this.hasPlaybackControl = !1, this.sourceType = "mediaStreamNode", this.source = this.context.createMediaStreamSource(e), this.connect(), this
    }
    setBuffer(e) {
        return this.buffer = e, this.sourceType = "buffer", this.autoplay && this.play(), this
    }
    play(e = 0) {
        if (this.isPlaying === !0) {
            console.warn("THREE.Audio: Audio is already playing.");
            return
        }
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        this._startedAt = this.context.currentTime + e;
        const t = this.context.createBufferSource();
        return t.buffer = this.buffer, t.loop = this.loop, t.loopStart = this.loopStart, t.loopEnd = this.loopEnd, t.onended = this.onEnded.bind(this), t.start(this._startedAt, this._progress + this.offset, this.duration), this.isPlaying = !0, this.source = t, this.setDetune(this.detune), this.setPlaybackRate(this.playbackRate), this.connect()
    }
    pause() {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.isPlaying === !0 && (this._progress += Math.max(this.context.currentTime - this._startedAt, 0) * this.playbackRate, this.loop === !0 && (this._progress = this._progress % (this.duration || this.buffer.duration)), this.source.stop(), this.source.onended = null, this.isPlaying = !1), this
    }
    stop(e = 0) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this._progress = 0, this.source !== null && (this.source.stop(this.context.currentTime + e), this.source.onended = null), this.isPlaying = !1, this
    }
    connect() {
        if (this.filters.length > 0) {
            this.source.connect(this.filters[0]);
            for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].connect(this.filters[e]);
            this.filters[this.filters.length - 1].connect(this.getOutput())
        } else this.source.connect(this.getOutput());
        return this._connected = !0, this
    }
    disconnect() {
        if (this._connected !== !1) {
            if (this.filters.length > 0) {
                this.source.disconnect(this.filters[0]);
                for (let e = 1, t = this.filters.length; e < t; e++) this.filters[e - 1].disconnect(this.filters[e]);
                this.filters[this.filters.length - 1].disconnect(this.getOutput())
            } else this.source.disconnect(this.getOutput());
            return this._connected = !1, this
        }
    }
    getFilters() {
        return this.filters
    }
    setFilters(e) {
        return e || (e = []), this._connected === !0 ? (this.disconnect(), this.filters = e.slice(), this.connect()) : this.filters = e.slice(), this
    }
    setDetune(e) {
        return this.detune = e, this.isPlaying === !0 && this.source.detune !== void 0 && this.source.detune.setTargetAtTime(this.detune, this.context.currentTime, .01), this
    }
    getDetune() {
        return this.detune
    }
    getFilter() {
        return this.getFilters()[0]
    }
    setFilter(e) {
        return this.setFilters(e ? [e] : [])
    }
    setPlaybackRate(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.playbackRate = e, this.isPlaying === !0 && this.source.playbackRate.setTargetAtTime(this.playbackRate, this.context.currentTime, .01), this
    }
    getPlaybackRate() {
        return this.playbackRate
    }
    onEnded() {
        this.isPlaying = !1
    }
    getLoop() {
        return this.hasPlaybackControl === !1 ? (console.warn("THREE.Audio: this Audio has no playback control."), !1) : this.loop
    }
    setLoop(e) {
        if (this.hasPlaybackControl === !1) {
            console.warn("THREE.Audio: this Audio has no playback control.");
            return
        }
        return this.loop = e, this.isPlaying === !0 && (this.source.loop = this.loop), this
    }
    setLoopStart(e) {
        return this.loopStart = e, this
    }
    setLoopEnd(e) {
        return this.loopEnd = e, this
    }
    getVolume() {
        return this.gain.gain.value
    }
    setVolume(e) {
        return this.gain.gain.setTargetAtTime(e, this.context.currentTime, .01), this
    }
};
const pc = new K,
    uC = new gr,
    SV = new K,
    mc = new K;
class MV extends tD {
    constructor(e) {
        super(e), this.panner = this.context.createPanner(), this.panner.panningModel = "HRTF", this.panner.connect(this.gain)
    }
    connect() {
        super.connect(), this.panner.connect(this.gain)
    }
    disconnect() {
        super.disconnect(), this.panner.disconnect(this.gain)
    }
    getOutput() {
        return this.panner
    }
    getRefDistance() {
        return this.panner.refDistance
    }
    setRefDistance(e) {
        return this.panner.refDistance = e, this
    }
    getRolloffFactor() {
        return this.panner.rolloffFactor
    }
    setRolloffFactor(e) {
        return this.panner.rolloffFactor = e, this
    }
    getDistanceModel() {
        return this.panner.distanceModel
    }
    setDistanceModel(e) {
        return this.panner.distanceModel = e, this
    }
    getMaxDistance() {
        return this.panner.maxDistance
    }
    setMaxDistance(e) {
        return this.panner.maxDistance = e, this
    }
    setDirectionalCone(e, t, n) {
        return this.panner.coneInnerAngle = e, this.panner.coneOuterAngle = t, this.panner.coneOuterGain = n, this
    }
    updateMatrixWorld(e) {
        if (super.updateMatrixWorld(e), this.hasPlaybackControl === !0 && this.isPlaying === !1) return;
        this.matrixWorld.decompose(pc, uC, SV), mc.set(0, 0, 1).applyQuaternion(uC);
        const t = this.panner;
        if (t.positionX) {
            const n = this.context.currentTime + this.listener.timeDelta;
            t.positionX.linearRampToValueAtTime(pc.x, n), t.positionY.linearRampToValueAtTime(pc.y, n), t.positionZ.linearRampToValueAtTime(pc.z, n), t.orientationX.linearRampToValueAtTime(mc.x, n), t.orientationY.linearRampToValueAtTime(mc.y, n), t.orientationZ.linearRampToValueAtTime(mc.z, n)
        } else t.setPosition(pc.x, pc.y, pc.z), t.setOrientation(mc.x, mc.y, mc.z)
    }
}
class wV {
    constructor(e, t = 2048) {
        this.analyser = e.context.createAnalyser(), this.analyser.fftSize = t, this.data = new Uint8Array(this.analyser.frequencyBinCount), e.getOutput().connect(this.analyser)
    }
    getFrequencyData() {
        return this.analyser.getByteFrequencyData(this.data), this.data
    }
    getAverageFrequency() {
        let e = 0;
        const t = this.getFrequencyData();
        for (let n = 0; n < t.length; n++) e += t[n];
        return e / t.length
    }
}
class nD {
    constructor(e, t, n) {
        this.binding = e, this.valueSize = n;
        let i, s, o;
        switch (t) {
            case "quaternion":
                i = this._slerp, s = this._slerpAdditive, o = this._setAdditiveIdentityQuaternion, this.buffer = new Float64Array(n * 6), this._workIndex = 5;
                break;
            case "string":
            case "bool":
                i = this._select, s = this._select, o = this._setAdditiveIdentityOther, this.buffer = new Array(n * 5);
                break;
            default:
                i = this._lerp, s = this._lerpAdditive, o = this._setAdditiveIdentityNumeric, this.buffer = new Float64Array(n * 5)
        }
        this._mixBufferRegion = i, this._mixBufferRegionAdditive = s, this._setIdentity = o, this._origIndex = 3, this._addIndex = 4, this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, this.useCount = 0, this.referenceCount = 0
    }
    accumulate(e, t) {
        const n = this.buffer,
            i = this.valueSize,
            s = e * i + i;
        let o = this.cumulativeWeight;
        if (o === 0) {
            for (let a = 0; a !== i; ++a) n[s + a] = n[a];
            o = t
        } else {
            o += t;
            const a = t / o;
            this._mixBufferRegion(n, s, 0, a, i)
        }
        this.cumulativeWeight = o
    }
    accumulateAdditive(e) {
        const t = this.buffer,
            n = this.valueSize,
            i = n * this._addIndex;
        this.cumulativeWeightAdditive === 0 && this._setIdentity(), this._mixBufferRegionAdditive(t, i, 0, e, n), this.cumulativeWeightAdditive += e
    }
    apply(e) {
        const t = this.valueSize,
            n = this.buffer,
            i = e * t + t,
            s = this.cumulativeWeight,
            o = this.cumulativeWeightAdditive,
            a = this.binding;
        if (this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0, s < 1) {
            const l = t * this._origIndex;
            this._mixBufferRegion(n, i, l, 1 - s, t)
        }
        o > 0 && this._mixBufferRegionAdditive(n, i, this._addIndex * t, 1, t);
        for (let l = t, c = t + t; l !== c; ++l)
            if (n[l] !== n[l + t]) {
                a.setValue(n, i);
                break
            }
    }
    saveOriginalState() {
        const e = this.binding,
            t = this.buffer,
            n = this.valueSize,
            i = n * this._origIndex;
        e.getValue(t, i);
        for (let s = n, o = i; s !== o; ++s) t[s] = t[i + s % n];
        this._setIdentity(), this.cumulativeWeight = 0, this.cumulativeWeightAdditive = 0
    }
    restoreOriginalState() {
        const e = this.valueSize * 3;
        this.binding.setValue(this.buffer, e)
    }
    _setAdditiveIdentityNumeric() {
        const e = this._addIndex * this.valueSize,
            t = e + this.valueSize;
        for (let n = e; n < t; n++) this.buffer[n] = 0
    }
    _setAdditiveIdentityQuaternion() {
        this._setAdditiveIdentityNumeric(), this.buffer[this._addIndex * this.valueSize + 3] = 1
    }
    _setAdditiveIdentityOther() {
        const e = this._origIndex * this.valueSize,
            t = this._addIndex * this.valueSize;
        for (let n = 0; n < this.valueSize; n++) this.buffer[t + n] = this.buffer[e + n]
    }
    _select(e, t, n, i, s) {
        if (i >= .5)
            for (let o = 0; o !== s; ++o) e[t + o] = e[n + o]
    }
    _slerp(e, t, n, i) {
        gr.slerpFlat(e, t, e, t, e, n, i)
    }
    _slerpAdditive(e, t, n, i, s) {
        const o = this._workIndex * s;
        gr.multiplyQuaternionsFlat(e, o, e, t, e, n), gr.slerpFlat(e, t, e, t, e, o, i)
    }
    _lerp(e, t, n, i, s) {
        const o = 1 - i;
        for (let a = 0; a !== s; ++a) {
            const l = t + a;
            e[l] = e[l] * o + e[n + a] * i
        }
    }
    _lerpAdditive(e, t, n, i, s) {
        for (let o = 0; o !== s; ++o) {
            const a = t + o;
            e[a] = e[a] + e[n + o] * i
        }
    }
}
const vM = "\\[\\]\\.:\\/",
    bV = new RegExp("[" + vM + "]", "g"),
    yM = "[^" + vM + "]",
    TV = "[^" + vM.replace("\\.", "") + "]",
    EV = /((?:WC+[\/:])*)/.source.replace("WC", yM),
    CV = /(WCOD+)?/.source.replace("WCOD", TV),
    RV = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace("WC", yM),
    PV = /\.(WC+)(?:\[(.+)\])?/.source.replace("WC", yM),
    IV = new RegExp("^" + EV + CV + RV + PV + "$"),
    BV = ["material", "materials", "bones", "map"];
class DV {
    constructor(e, t, n) {
        const i = n || wn.parseTrackName(t);
        this._targetGroup = e, this._bindings = e.subscribe_(t, i)
    }
    getValue(e, t) {
        this.bind();
        const n = this._targetGroup.nCachedObjects_,
            i = this._bindings[n];
        i !== void 0 && i.getValue(e, t)
    }
    setValue(e, t) {
        const n = this._bindings;
        for (let i = this._targetGroup.nCachedObjects_, s = n.length; i !== s; ++i) n[i].setValue(e, t)
    }
    bind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].bind()
    }
    unbind() {
        const e = this._bindings;
        for (let t = this._targetGroup.nCachedObjects_, n = e.length; t !== n; ++t) e[t].unbind()
    }
}
class wn {
    constructor(e, t, n) {
        this.path = t, this.parsedPath = n || wn.parseTrackName(t), this.node = wn.findNode(e, this.parsedPath.nodeName), this.rootNode = e, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
    static create(e, t, n) {
        return e && e.isAnimationObjectGroup ? new wn.Composite(e, t, n) : new wn(e, t, n)
    }
    static sanitizeNodeName(e) {
        return e.replace(/\s/g, "_").replace(bV, "")
    }
    static parseTrackName(e) {
        const t = IV.exec(e);
        if (t === null) throw new Error("PropertyBinding: Cannot parse trackName: " + e);
        const n = {
                nodeName: t[2],
                objectName: t[3],
                objectIndex: t[4],
                propertyName: t[5],
                propertyIndex: t[6]
            },
            i = n.nodeName && n.nodeName.lastIndexOf(".");
        if (i !== void 0 && i !== -1) {
            const s = n.nodeName.substring(i + 1);
            BV.indexOf(s) !== -1 && (n.nodeName = n.nodeName.substring(0, i), n.objectName = s)
        }
        if (n.propertyName === null || n.propertyName.length === 0) throw new Error("PropertyBinding: can not parse propertyName from trackName: " + e);
        return n
    }
    static findNode(e, t) {
        if (t === void 0 || t === "" || t === "." || t === -1 || t === e.name || t === e.uuid) return e;
        if (e.skeleton) {
            const n = e.skeleton.getBoneByName(t);
            if (n !== void 0) return n
        }
        if (e.children) {
            const n = function(s) {
                    for (let o = 0; o < s.length; o++) {
                        const a = s[o];
                        if (a.name === t || a.uuid === t) return a;
                        const l = n(a.children);
                        if (l) return l
                    }
                    return null
                },
                i = n(e.children);
            if (i) return i
        }
        return null
    }
    _getValue_unavailable() {}
    _setValue_unavailable() {}
    _getValue_direct(e, t) {
        e[t] = this.targetObject[this.propertyName]
    }
    _getValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i) e[t++] = n[i]
    }
    _getValue_arrayElement(e, t) {
        e[t] = this.resolvedProperty[this.propertyIndex]
    }
    _getValue_toArray(e, t) {
        this.resolvedProperty.toArray(e, t)
    }
    _setValue_direct(e, t) {
        this.targetObject[this.propertyName] = e[t]
    }
    _setValue_direct_setNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.needsUpdate = !0
    }
    _setValue_direct_setMatrixWorldNeedsUpdate(e, t) {
        this.targetObject[this.propertyName] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_array(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++]
    }
    _setValue_array_setNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
        this.targetObject.needsUpdate = !0
    }
    _setValue_array_setMatrixWorldNeedsUpdate(e, t) {
        const n = this.resolvedProperty;
        for (let i = 0, s = n.length; i !== s; ++i) n[i] = e[t++];
        this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_arrayElement(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t]
    }
    _setValue_arrayElement_setNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.needsUpdate = !0
    }
    _setValue_arrayElement_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty[this.propertyIndex] = e[t], this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _setValue_fromArray(e, t) {
        this.resolvedProperty.fromArray(e, t)
    }
    _setValue_fromArray_setNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.needsUpdate = !0
    }
    _setValue_fromArray_setMatrixWorldNeedsUpdate(e, t) {
        this.resolvedProperty.fromArray(e, t), this.targetObject.matrixWorldNeedsUpdate = !0
    }
    _getValue_unbound(e, t) {
        this.bind(), this.getValue(e, t)
    }
    _setValue_unbound(e, t) {
        this.bind(), this.setValue(e, t)
    }
    bind() {
        let e = this.node;
        const t = this.parsedPath,
            n = t.objectName,
            i = t.propertyName;
        let s = t.propertyIndex;
        if (e || (e = wn.findNode(this.rootNode, t.nodeName), this.node = e), this.getValue = this._getValue_unavailable, this.setValue = this._setValue_unavailable, !e) {
            console.warn("THREE.PropertyBinding: No target node found for track: " + this.path + ".");
            return
        }
        if (n) {
            let c = t.objectIndex;
            switch (n) {
                case "materials":
                    if (!e.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!e.material.materials) {
                        console.error("THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.", this);
                        return
                    }
                    e = e.material.materials;
                    break;
                case "bones":
                    if (!e.skeleton) {
                        console.error("THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.", this);
                        return
                    }
                    e = e.skeleton.bones;
                    for (let u = 0; u < e.length; u++)
                        if (e[u].name === c) {
                            c = u;
                            break
                        }
                    break;
                case "map":
                    if ("map" in e) {
                        e = e.map;
                        break
                    }
                    if (!e.material) {
                        console.error("THREE.PropertyBinding: Can not bind to material as node does not have a material.", this);
                        return
                    }
                    if (!e.material.map) {
                        console.error("THREE.PropertyBinding: Can not bind to material.map as node.material does not have a map.", this);
                        return
                    }
                    e = e.material.map;
                    break;
                default:
                    if (e[n] === void 0) {
                        console.error("THREE.PropertyBinding: Can not bind to objectName of node undefined.", this);
                        return
                    }
                    e = e[n]
            }
            if (c !== void 0) {
                if (e[c] === void 0) {
                    console.error("THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.", this, e);
                    return
                }
                e = e[c]
            }
        }
        const o = e[i];
        if (o === void 0) {
            const c = t.nodeName;
            console.error("THREE.PropertyBinding: Trying to update property for track: " + c + "." + i + " but it wasn't found.", e);
            return
        }
        let a = this.Versioning.None;
        this.targetObject = e, e.needsUpdate !== void 0 ? a = this.Versioning.NeedsUpdate : e.matrixWorldNeedsUpdate !== void 0 && (a = this.Versioning.MatrixWorldNeedsUpdate);
        let l = this.BindingType.Direct;
        if (s !== void 0) {
            if (i === "morphTargetInfluences") {
                if (!e.geometry) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.", this);
                    return
                }
                if (!e.geometry.morphAttributes) {
                    console.error("THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.", this);
                    return
                }
                e.morphTargetDictionary[s] !== void 0 && (s = e.morphTargetDictionary[s])
            }
            l = this.BindingType.ArrayElement, this.resolvedProperty = o, this.propertyIndex = s
        } else o.fromArray !== void 0 && o.toArray !== void 0 ? (l = this.BindingType.HasFromToArray, this.resolvedProperty = o) : Array.isArray(o) ? (l = this.BindingType.EntireArray, this.resolvedProperty = o) : this.propertyName = i;
        this.getValue = this.GetterByBindingType[l], this.setValue = this.SetterByBindingTypeAndVersioning[l][a]
    }
    unbind() {
        this.node = null, this.getValue = this._getValue_unbound, this.setValue = this._setValue_unbound
    }
}
wn.Composite = DV;
wn.prototype.BindingType = {
    Direct: 0,
    EntireArray: 1,
    ArrayElement: 2,
    HasFromToArray: 3
};
wn.prototype.Versioning = {
    None: 0,
    NeedsUpdate: 1,
    MatrixWorldNeedsUpdate: 2
};
wn.prototype.GetterByBindingType = [wn.prototype._getValue_direct, wn.prototype._getValue_array, wn.prototype._getValue_arrayElement, wn.prototype._getValue_toArray];
wn.prototype.SetterByBindingTypeAndVersioning = [
    [wn.prototype._setValue_direct, wn.prototype._setValue_direct_setNeedsUpdate, wn.prototype._setValue_direct_setMatrixWorldNeedsUpdate],
    [wn.prototype._setValue_array, wn.prototype._setValue_array_setNeedsUpdate, wn.prototype._setValue_array_setMatrixWorldNeedsUpdate],
    [wn.prototype._setValue_arrayElement, wn.prototype._setValue_arrayElement_setNeedsUpdate, wn.prototype._setValue_arrayElement_setMatrixWorldNeedsUpdate],
    [wn.prototype._setValue_fromArray, wn.prototype._setValue_fromArray_setNeedsUpdate, wn.prototype._setValue_fromArray_setMatrixWorldNeedsUpdate]
];
class LV {
    constructor() {
        this.isAnimationObjectGroup = !0, this.uuid = ys(), this._objects = Array.prototype.slice.call(arguments), this.nCachedObjects_ = 0;
        const e = {};
        this._indicesByUUID = e;
        for (let n = 0, i = arguments.length; n !== i; ++n) e[arguments[n].uuid] = n;
        this._paths = [], this._parsedPaths = [], this._bindings = [], this._bindingsIndicesByPath = {};
        const t = this;
        this.stats = {
            objects: {
                get total() {
                    return t._objects.length
                },
                get inUse() {
                    return this.total - t.nCachedObjects_
                }
            },
            get bindingsPerObject() {
                return t._bindings.length
            }
        }
    }
    add() {
        const e = this._objects,
            t = this._indicesByUUID,
            n = this._paths,
            i = this._parsedPaths,
            s = this._bindings,
            o = s.length;
        let a, l = e.length,
            c = this.nCachedObjects_;
        for (let u = 0, f = arguments.length; u !== f; ++u) {
            const d = arguments[u],
                m = d.uuid;
            let g = t[m];
            if (g === void 0) {
                g = l++, t[m] = g, e.push(d);
                for (let y = 0, v = o; y !== v; ++y) s[y].push(new wn(d, n[y], i[y]))
            } else if (g < c) {
                a = e[g];
                const y = --c,
                    v = e[y];
                t[v.uuid] = g, e[g] = v, t[m] = y, e[y] = d;
                for (let _ = 0, A = o; _ !== A; ++_) {
                    const S = s[_],
                        M = S[y];
                    let C = S[g];
                    S[g] = M, C === void 0 && (C = new wn(d, n[_], i[_])), S[y] = C
                }
            } else e[g] !== a && console.error("THREE.AnimationObjectGroup: Different objects with the same UUID detected. Clean the caches or recreate your infrastructure when reloading scenes.")
        }
        this.nCachedObjects_ = c
    }
    remove() {
        const e = this._objects,
            t = this._indicesByUUID,
            n = this._bindings,
            i = n.length;
        let s = this.nCachedObjects_;
        for (let o = 0, a = arguments.length; o !== a; ++o) {
            const l = arguments[o],
                c = l.uuid,
                u = t[c];
            if (u !== void 0 && u >= s) {
                const f = s++,
                    d = e[f];
                t[d.uuid] = u, e[u] = d, t[c] = f, e[f] = l;
                for (let m = 0, g = i; m !== g; ++m) {
                    const y = n[m],
                        v = y[f],
                        _ = y[u];
                    y[u] = v, y[f] = _
                }
            }
        }
        this.nCachedObjects_ = s
    }
    uncache() {
        const e = this._objects,
            t = this._indicesByUUID,
            n = this._bindings,
            i = n.length;
        let s = this.nCachedObjects_,
            o = e.length;
        for (let a = 0, l = arguments.length; a !== l; ++a) {
            const c = arguments[a],
                u = c.uuid,
                f = t[u];
            if (f !== void 0)
                if (delete t[u], f < s) {
                    const d = --s,
                        m = e[d],
                        g = --o,
                        y = e[g];
                    t[m.uuid] = f, e[f] = m, t[y.uuid] = d, e[d] = y, e.pop();
                    for (let v = 0, _ = i; v !== _; ++v) {
                        const A = n[v],
                            S = A[d],
                            M = A[g];
                        A[f] = S, A[d] = M, A.pop()
                    }
                } else {
                    const d = --o,
                        m = e[d];
                    d > 0 && (t[m.uuid] = f), e[f] = m, e.pop();
                    for (let g = 0, y = i; g !== y; ++g) {
                        const v = n[g];
                        v[f] = v[d], v.pop()
                    }
                }
        }
        this.nCachedObjects_ = s
    }
    subscribe_(e, t) {
        const n = this._bindingsIndicesByPath;
        let i = n[e];
        const s = this._bindings;
        if (i !== void 0) return s[i];
        const o = this._paths,
            a = this._parsedPaths,
            l = this._objects,
            c = l.length,
            u = this.nCachedObjects_,
            f = new Array(c);
        i = s.length, n[e] = i, o.push(e), a.push(t), s.push(f);
        for (let d = u, m = l.length; d !== m; ++d) {
            const g = l[d];
            f[d] = new wn(g, e, t)
        }
        return f
    }
    unsubscribe_(e) {
        const t = this._bindingsIndicesByPath,
            n = t[e];
        if (n !== void 0) {
            const i = this._paths,
                s = this._parsedPaths,
                o = this._bindings,
                a = o.length - 1,
                l = o[a],
                c = e[a];
            t[c] = n, o[n] = l, o.pop(), s[n] = s[a], s.pop(), i[n] = i[a], i.pop()
        }
    }
}
class iD {
    constructor(e, t, n = null, i = t.blendMode) {
        this._mixer = e, this._clip = t, this._localRoot = n, this.blendMode = i;
        const s = t.tracks,
            o = s.length,
            a = new Array(o),
            l = {
                endingStart: Ic,
                endingEnd: Ic
            };
        for (let c = 0; c !== o; ++c) {
            const u = s[c].createInterpolant(null);
            a[c] = u, u.settings = l
        }
        this._interpolantSettings = l, this._interpolants = a, this._propertyBindings = new Array(o), this._cacheIndex = null, this._byClipCacheIndex = null, this._timeScaleInterpolant = null, this._weightInterpolant = null, this.loop = QI, this._loopCount = -1, this._startTime = null, this.time = 0, this.timeScale = 1, this._effectiveTimeScale = 1, this.weight = 1, this._effectiveWeight = 1, this.repetitions = 1 / 0, this.paused = !1, this.enabled = !0, this.clampWhenFinished = !1, this.zeroSlopeAtStart = !0, this.zeroSlopeAtEnd = !0
    }
    play() {
        return this._mixer._activateAction(this), this
    }
    stop() {
        return this._mixer._deactivateAction(this), this.reset()
    }
    reset() {
        return this.paused = !1, this.enabled = !0, this.time = 0, this._loopCount = -1, this._startTime = null, this.stopFading().stopWarping()
    }
    isRunning() {
        return this.enabled && !this.paused && this.timeScale !== 0 && this._startTime === null && this._mixer._isActiveAction(this)
    }
    isScheduled() {
        return this._mixer._isActiveAction(this)
    }
    startAt(e) {
        return this._startTime = e, this
    }
    setLoop(e, t) {
        return this.loop = e, this.repetitions = t, this
    }
    setEffectiveWeight(e) {
        return this.weight = e, this._effectiveWeight = this.enabled ? e : 0, this.stopFading()
    }
    getEffectiveWeight() {
        return this._effectiveWeight
    }
    fadeIn(e) {
        return this._scheduleFading(e, 0, 1)
    }
    fadeOut(e) {
        return this._scheduleFading(e, 1, 0)
    }
    crossFadeFrom(e, t, n) {
        if (e.fadeOut(t), this.fadeIn(t), n) {
            const i = this._clip.duration,
                s = e._clip.duration,
                o = s / i,
                a = i / s;
            e.warp(1, o, t), this.warp(a, 1, t)
        }
        return this
    }
    crossFadeTo(e, t, n) {
        return e.crossFadeFrom(this, t, n)
    }
    stopFading() {
        const e = this._weightInterpolant;
        return e !== null && (this._weightInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
    }
    setEffectiveTimeScale(e) {
        return this.timeScale = e, this._effectiveTimeScale = this.paused ? 0 : e, this.stopWarping()
    }
    getEffectiveTimeScale() {
        return this._effectiveTimeScale
    }
    setDuration(e) {
        return this.timeScale = this._clip.duration / e, this.stopWarping()
    }
    syncWith(e) {
        return this.time = e.time, this.timeScale = e.timeScale, this.stopWarping()
    }
    halt(e) {
        return this.warp(this._effectiveTimeScale, 0, e)
    }
    warp(e, t, n) {
        const i = this._mixer,
            s = i.time,
            o = this.timeScale;
        let a = this._timeScaleInterpolant;
        a === null && (a = i._lendControlInterpolant(), this._timeScaleInterpolant = a);
        const l = a.parameterPositions,
            c = a.sampleValues;
        return l[0] = s, l[1] = s + n, c[0] = e / o, c[1] = t / o, this
    }
    stopWarping() {
        const e = this._timeScaleInterpolant;
        return e !== null && (this._timeScaleInterpolant = null, this._mixer._takeBackControlInterpolant(e)), this
    }
    getMixer() {
        return this._mixer
    }
    getClip() {
        return this._clip
    }
    getRoot() {
        return this._localRoot || this._mixer._root
    }
    _update(e, t, n, i) {
        if (!this.enabled) {
            this._updateWeight(e);
            return
        }
        const s = this._startTime;
        if (s !== null) {
            const l = (e - s) * n;
            l < 0 || n === 0 ? t = 0 : (this._startTime = null, t = n * l)
        }
        t *= this._updateTimeScale(e);
        const o = this._updateTime(t),
            a = this._updateWeight(e);
        if (a > 0) {
            const l = this._interpolants,
                c = this._propertyBindings;
            switch (this.blendMode) {
                case kS:
                    for (let u = 0, f = l.length; u !== f; ++u) l[u].evaluate(o), c[u].accumulateAdditive(a);
                    break;
                case hy:
                default:
                    for (let u = 0, f = l.length; u !== f; ++u) l[u].evaluate(o), c[u].accumulate(i, a)
            }
        }
    }
    _updateWeight(e) {
        let t = 0;
        if (this.enabled) {
            t = this.weight;
            const n = this._weightInterpolant;
            if (n !== null) {
                const i = n.evaluate(e)[0];
                t *= i, e > n.parameterPositions[1] && (this.stopFading(), i === 0 && (this.enabled = !1))
            }
        }
        return this._effectiveWeight = t, t
    }
    _updateTimeScale(e) {
        let t = 0;
        if (!this.paused) {
            t = this.timeScale;
            const n = this._timeScaleInterpolant;
            if (n !== null) {
                const i = n.evaluate(e)[0];
                t *= i, e > n.parameterPositions[1] && (this.stopWarping(), t === 0 ? this.paused = !0 : this.timeScale = t)
            }
        }
        return this._effectiveTimeScale = t, t
    }
    _updateTime(e) {
        const t = this._clip.duration,
            n = this.loop;
        let i = this.time + e,
            s = this._loopCount;
        const o = n === $I;
        if (e === 0) return s === -1 ? i : o && (s & 1) === 1 ? t - i : i;
        if (n === ZI) {
            s === -1 && (this._loopCount = 0, this._setEndings(!0, !0, !1));
            e: {
                if (i >= t) i = t;
                else if (i < 0) i = 0;
                else {
                    this.time = i;
                    break e
                }
                this.clampWhenFinished ? this.paused = !0 : this.enabled = !1,
                this.time = i,
                this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e < 0 ? -1 : 1
                })
            }
        } else {
            if (s === -1 && (e >= 0 ? (s = 0, this._setEndings(!0, this.repetitions === 0, o)) : this._setEndings(this.repetitions === 0, !0, o)), i >= t || i < 0) {
                const a = Math.floor(i / t);
                i -= t * a, s += Math.abs(a);
                const l = this.repetitions - s;
                if (l <= 0) this.clampWhenFinished ? this.paused = !0 : this.enabled = !1, i = e > 0 ? t : 0, this.time = i, this._mixer.dispatchEvent({
                    type: "finished",
                    action: this,
                    direction: e > 0 ? 1 : -1
                });
                else {
                    if (l === 1) {
                        const c = e < 0;
                        this._setEndings(c, !c, o)
                    } else this._setEndings(!1, !1, o);
                    this._loopCount = s, this.time = i, this._mixer.dispatchEvent({
                        type: "loop",
                        action: this,
                        loopDelta: a
                    })
                }
            } else this.time = i;
            if (o && (s & 1) === 1) return t - i
        }
        return i
    }
    _setEndings(e, t, n) {
        const i = this._interpolantSettings;
        n ? (i.endingStart = Bc, i.endingEnd = Bc) : (e ? i.endingStart = this.zeroSlopeAtStart ? Bc : Ic : i.endingStart = pp, t ? i.endingEnd = this.zeroSlopeAtEnd ? Bc : Ic : i.endingEnd = pp)
    }
    _scheduleFading(e, t, n) {
        const i = this._mixer,
            s = i.time;
        let o = this._weightInterpolant;
        o === null && (o = i._lendControlInterpolant(), this._weightInterpolant = o);
        const a = o.parameterPositions,
            l = o.sampleValues;
        return a[0] = s, l[0] = t, a[1] = s + e, l[1] = n, this
    }
}
const FV = new Float32Array(1);
class UV extends ws {
    constructor(e) {
        super(), this._root = e, this._initMemoryManager(), this._accuIndex = 0, this.time = 0, this.timeScale = 1
    }
    _bindAction(e, t) {
        const n = e._localRoot || this._root,
            i = e._clip.tracks,
            s = i.length,
            o = e._propertyBindings,
            a = e._interpolants,
            l = n.uuid,
            c = this._bindingsByRootAndName;
        let u = c[l];
        u === void 0 && (u = {}, c[l] = u);
        for (let f = 0; f !== s; ++f) {
            const d = i[f],
                m = d.name;
            let g = u[m];
            if (g !== void 0) ++g.referenceCount, o[f] = g;
            else {
                if (g = o[f], g !== void 0) {
                    g._cacheIndex === null && (++g.referenceCount, this._addInactiveBinding(g, l, m));
                    continue
                }
                const y = t && t._propertyBindings[f].binding.parsedPath;
                g = new nD(wn.create(n, m, y), d.ValueTypeName, d.getValueSize()), ++g.referenceCount, this._addInactiveBinding(g, l, m), o[f] = g
            }
            a[f].resultBuffer = g.buffer
        }
    }
    _activateAction(e) {
        if (!this._isActiveAction(e)) {
            if (e._cacheIndex === null) {
                const n = (e._localRoot || this._root).uuid,
                    i = e._clip.uuid,
                    s = this._actionsByClip[i];
                this._bindAction(e, s && s.knownActions[0]), this._addInactiveAction(e, i, n)
            }
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
                const s = t[n];
                s.useCount++ === 0 && (this._lendBinding(s), s.saveOriginalState())
            }
            this._lendAction(e)
        }
    }
    _deactivateAction(e) {
        if (this._isActiveAction(e)) {
            const t = e._propertyBindings;
            for (let n = 0, i = t.length; n !== i; ++n) {
                const s = t[n];
                --s.useCount === 0 && (s.restoreOriginalState(), this._takeBackBinding(s))
            }
            this._takeBackAction(e)
        }
    }
    _initMemoryManager() {
        this._actions = [], this._nActiveActions = 0, this._actionsByClip = {}, this._bindings = [], this._nActiveBindings = 0, this._bindingsByRootAndName = {}, this._controlInterpolants = [], this._nActiveControlInterpolants = 0;
        const e = this;
        this.stats = {
            actions: {
                get total() {
                    return e._actions.length
                },
                get inUse() {
                    return e._nActiveActions
                }
            },
            bindings: {
                get total() {
                    return e._bindings.length
                },
                get inUse() {
                    return e._nActiveBindings
                }
            },
            controlInterpolants: {
                get total() {
                    return e._controlInterpolants.length
                },
                get inUse() {
                    return e._nActiveControlInterpolants
                }
            }
        }
    }
    _isActiveAction(e) {
        const t = e._cacheIndex;
        return t !== null && t < this._nActiveActions
    }
    _addInactiveAction(e, t, n) {
        const i = this._actions,
            s = this._actionsByClip;
        let o = s[t];
        if (o === void 0) o = {
            knownActions: [e],
            actionByRoot: {}
        }, e._byClipCacheIndex = 0, s[t] = o;
        else {
            const a = o.knownActions;
            e._byClipCacheIndex = a.length, a.push(e)
        }
        e._cacheIndex = i.length, i.push(e), o.actionByRoot[n] = e
    }
    _removeInactiveAction(e) {
        const t = this._actions,
            n = t[t.length - 1],
            i = e._cacheIndex;
        n._cacheIndex = i, t[i] = n, t.pop(), e._cacheIndex = null;
        const s = e._clip.uuid,
            o = this._actionsByClip,
            a = o[s],
            l = a.knownActions,
            c = l[l.length - 1],
            u = e._byClipCacheIndex;
        c._byClipCacheIndex = u, l[u] = c, l.pop(), e._byClipCacheIndex = null;
        const f = a.actionByRoot,
            d = (e._localRoot || this._root).uuid;
        delete f[d], l.length === 0 && delete o[s], this._removeInactiveBindingsForAction(e)
    }
    _removeInactiveBindingsForAction(e) {
        const t = e._propertyBindings;
        for (let n = 0, i = t.length; n !== i; ++n) {
            const s = t[n];
            --s.referenceCount === 0 && this._removeInactiveBinding(s)
        }
    }
    _lendAction(e) {
        const t = this._actions,
            n = e._cacheIndex,
            i = this._nActiveActions++,
            s = t[i];
        e._cacheIndex = i, t[i] = e, s._cacheIndex = n, t[n] = s
    }
    _takeBackAction(e) {
        const t = this._actions,
            n = e._cacheIndex,
            i = --this._nActiveActions,
            s = t[i];
        e._cacheIndex = i, t[i] = e, s._cacheIndex = n, t[n] = s
    }
    _addInactiveBinding(e, t, n) {
        const i = this._bindingsByRootAndName,
            s = this._bindings;
        let o = i[t];
        o === void 0 && (o = {}, i[t] = o), o[n] = e, e._cacheIndex = s.length, s.push(e)
    }
    _removeInactiveBinding(e) {
        const t = this._bindings,
            n = e.binding,
            i = n.rootNode.uuid,
            s = n.path,
            o = this._bindingsByRootAndName,
            a = o[i],
            l = t[t.length - 1],
            c = e._cacheIndex;
        l._cacheIndex = c, t[c] = l, t.pop(), delete a[s], Object.keys(a).length === 0 && delete o[i]
    }
    _lendBinding(e) {
        const t = this._bindings,
            n = e._cacheIndex,
            i = this._nActiveBindings++,
            s = t[i];
        e._cacheIndex = i, t[i] = e, s._cacheIndex = n, t[n] = s
    }
    _takeBackBinding(e) {
        const t = this._bindings,
            n = e._cacheIndex,
            i = --this._nActiveBindings,
            s = t[i];
        e._cacheIndex = i, t[i] = e, s._cacheIndex = n, t[n] = s
    }
    _lendControlInterpolant() {
        const e = this._controlInterpolants,
            t = this._nActiveControlInterpolants++;
        let n = e[t];
        return n === void 0 && (n = new lM(new Float32Array(2), new Float32Array(2), 1, FV), n.__cacheIndex = t, e[t] = n), n
    }
    _takeBackControlInterpolant(e) {
        const t = this._controlInterpolants,
            n = e.__cacheIndex,
            i = --this._nActiveControlInterpolants,
            s = t[i];
        e.__cacheIndex = i, t[i] = e, s.__cacheIndex = n, t[n] = s
    }
    clipAction(e, t, n) {
        const i = t || this._root,
            s = i.uuid;
        let o = typeof e == "string" ? eh.findByName(i, e) : e;
        const a = o !== null ? o.uuid : e,
            l = this._actionsByClip[a];
        let c = null;
        if (n === void 0 && (o !== null ? n = o.blendMode : n = hy), l !== void 0) {
            const f = l.actionByRoot[s];
            if (f !== void 0 && f.blendMode === n) return f;
            c = l.knownActions[0], o === null && (o = c._clip)
        }
        if (o === null) return null;
        const u = new iD(this, o, t, n);
        return this._bindAction(u, c), this._addInactiveAction(u, a, s), u
    }
    existingAction(e, t) {
        const n = t || this._root,
            i = n.uuid,
            s = typeof e == "string" ? eh.findByName(n, e) : e,
            o = s ? s.uuid : e,
            a = this._actionsByClip[o];
        return a !== void 0 && a.actionByRoot[i] || null
    }
    stopAllAction() {
        const e = this._actions,
            t = this._nActiveActions;
        for (let n = t - 1; n >= 0; --n) e[n].stop();
        return this
    }
    update(e) {
        e *= this.timeScale;
        const t = this._actions,
            n = this._nActiveActions,
            i = this.time += e,
            s = Math.sign(e),
            o = this._accuIndex ^= 1;
        for (let c = 0; c !== n; ++c) t[c]._update(i, e, s, o);
        const a = this._bindings,
            l = this._nActiveBindings;
        for (let c = 0; c !== l; ++c) a[c].apply(o);
        return this
    }
    setTime(e) {
        this.time = 0;
        for (let t = 0; t < this._actions.length; t++) this._actions[t].time = 0;
        return this.update(e)
    }
    getRoot() {
        return this._root
    }
    uncacheClip(e) {
        const t = this._actions,
            n = e.uuid,
            i = this._actionsByClip,
            s = i[n];
        if (s !== void 0) {
            const o = s.knownActions;
            for (let a = 0, l = o.length; a !== l; ++a) {
                const c = o[a];
                this._deactivateAction(c);
                const u = c._cacheIndex,
                    f = t[t.length - 1];
                c._cacheIndex = null, c._byClipCacheIndex = null, f._cacheIndex = u, t[u] = f, t.pop(), this._removeInactiveBindingsForAction(c)
            }
            delete i[n]
        }
    }
    uncacheRoot(e) {
        const t = e.uuid,
            n = this._actionsByClip;
        for (const o in n) {
            const a = n[o].actionByRoot,
                l = a[t];
            l !== void 0 && (this._deactivateAction(l), this._removeInactiveAction(l))
        }
        const i = this._bindingsByRootAndName,
            s = i[t];
        if (s !== void 0)
            for (const o in s) {
                const a = s[o];
                a.restoreOriginalState(), this._removeInactiveBinding(a)
            }
    }
    uncacheAction(e, t) {
        const n = this.existingAction(e, t);
        n !== null && (this._deactivateAction(n), this._removeInactiveAction(n))
    }
}
class Wn {
    constructor(e) {
        this.value = e
    }
    clone() {
        return new Wn(this.value.clone === void 0 ? this.value : this.value.clone())
    }
}
let OV = 0;
class NV extends ws {
    constructor() {
        super(), this.isUniformsGroup = !0, Object.defineProperty(this, "id", {
            value: OV++
        }), this.name = "", this.usage = mp, this.uniforms = []
    }
    add(e) {
        return this.uniforms.push(e), this
    }
    remove(e) {
        const t = this.uniforms.indexOf(e);
        return t !== -1 && this.uniforms.splice(t, 1), this
    }
    setName(e) {
        return this.name = e, this
    }
    setUsage(e) {
        return this.usage = e, this
    }
    dispose() {
        return this.dispatchEvent({
            type: "dispose"
        }), this
    }
    copy(e) {
        this.name = e.name, this.usage = e.usage;
        const t = e.uniforms;
        this.uniforms.length = 0;
        for (let n = 0, i = t.length; n < i; n++) {
            const s = Array.isArray(t[n]) ? t[n] : [t[n]];
            for (let o = 0; o < s.length; o++) this.uniforms.push(s[o].clone())
        }
        return this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class kV extends Jp {
    constructor(e, t, n = 1) {
        super(e, t), this.isInstancedInterleavedBuffer = !0, this.meshPerAttribute = n
    }
    copy(e) {
        return super.copy(e), this.meshPerAttribute = e.meshPerAttribute, this
    }
    clone(e) {
        const t = super.clone(e);
        return t.meshPerAttribute = this.meshPerAttribute, t
    }
    toJSON(e) {
        const t = super.toJSON(e);
        return t.isInstancedInterleavedBuffer = !0, t.meshPerAttribute = this.meshPerAttribute, t
    }
}
class zV {
    constructor(e, t, n, i, s) {
        this.isGLBufferAttribute = !0, this.name = "", this.buffer = e, this.type = t, this.itemSize = n, this.elementSize = i, this.count = s, this.version = 0
    }
    set needsUpdate(e) {
        e === !0 && this.version++
    }
    setBuffer(e) {
        return this.buffer = e, this
    }
    setType(e, t) {
        return this.type = e, this.elementSize = t, this
    }
    setItemSize(e) {
        return this.itemSize = e, this
    }
    setCount(e) {
        return this.count = e, this
    }
}
const fC = new Ot;
class _M {
    constructor(e, t, n = 0, i = 1 / 0) {
        this.ray = new Ll(e, t), this.near = n, this.far = i, this.camera = null, this.layers = new Kc, this.params = {
            Mesh: {},
            Line: {
                threshold: 1
            },
            LOD: {},
            Points: {
                threshold: 1
            },
            Sprite: {}
        }
    }
    set(e, t) {
        this.ray.set(e, t)
    }
    setFromCamera(e, t) {
        t.isPerspectiveCamera ? (this.ray.origin.setFromMatrixPosition(t.matrixWorld), this.ray.direction.set(e.x, e.y, .5).unproject(t).sub(this.ray.origin).normalize(), this.camera = t) : t.isOrthographicCamera ? (this.ray.origin.set(e.x, e.y, (t.near + t.far) / (t.near - t.far)).unproject(t), this.ray.direction.set(0, 0, -1).transformDirection(t.matrixWorld), this.camera = t) : console.error("THREE.Raycaster: Unsupported camera type: " + t.type)
    }
    setFromXRController(e) {
        return fC.identity().extractRotation(e.matrixWorld), this.ray.origin.setFromMatrixPosition(e.matrixWorld), this.ray.direction.set(0, 0, -1).applyMatrix4(fC), this
    }
    intersectObject(e, t = !0, n = []) {
        return AA(e, this, n, t), n.sort(hC), n
    }
    intersectObjects(e, t = !0, n = []) {
        for (let i = 0, s = e.length; i < s; i++) AA(e[i], this, n, t);
        return n.sort(hC), n
    }
}

function hC(r, e) {
    return r.distance - e.distance
}

function AA(r, e, t, n) {
    let i = !0;
    if (r.layers.test(e.layers) && r.raycast(e, t) === !1 && (i = !1), i === !0 && n === !0) {
        const s = r.children;
        for (let o = 0, a = s.length; o < a; o++) AA(s[o], e, t, !0)
    }
}
class GV {
    constructor(e = 1, t = 0, n = 0) {
        return this.radius = e, this.phi = t, this.theta = n, this
    }
    set(e, t, n) {
        return this.radius = e, this.phi = t, this.theta = n, this
    }
    copy(e) {
        return this.radius = e.radius, this.phi = e.phi, this.theta = e.theta, this
    }
    makeSafe() {
        return this.phi = Math.max(1e-6, Math.min(Math.PI - 1e-6, this.phi)), this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, n) {
        return this.radius = Math.sqrt(e * e + t * t + n * n), this.radius === 0 ? (this.theta = 0, this.phi = 0) : (this.theta = Math.atan2(e, n), this.phi = Math.acos(fi(t / this.radius, -1, 1))), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class HV {
    constructor(e = 1, t = 0, n = 0) {
        return this.radius = e, this.theta = t, this.y = n, this
    }
    set(e, t, n) {
        return this.radius = e, this.theta = t, this.y = n, this
    }
    copy(e) {
        return this.radius = e.radius, this.theta = e.theta, this.y = e.y, this
    }
    setFromVector3(e) {
        return this.setFromCartesianCoords(e.x, e.y, e.z)
    }
    setFromCartesianCoords(e, t, n) {
        return this.radius = Math.sqrt(e * e + n * n), this.theta = Math.atan2(e, n), this.y = t, this
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
class xM {
    constructor(e, t, n, i) {
        xM.prototype.isMatrix2 = !0, this.elements = [1, 0, 0, 1], e !== void 0 && this.set(e, t, n, i)
    }
    identity() {
        return this.set(1, 0, 0, 1), this
    }
    fromArray(e, t = 0) {
        for (let n = 0; n < 4; n++) this.elements[n] = e[n + t];
        return this
    }
    set(e, t, n, i) {
        const s = this.elements;
        return s[0] = e, s[2] = t, s[1] = n, s[3] = i, this
    }
}
const dC = new Ue;
class VV {
    constructor(e = new Ue(1 / 0, 1 / 0), t = new Ue(-1 / 0, -1 / 0)) {
        this.isBox2 = !0, this.min = e, this.max = t
    }
    set(e, t) {
        return this.min.copy(e), this.max.copy(t), this
    }
    setFromPoints(e) {
        this.makeEmpty();
        for (let t = 0, n = e.length; t < n; t++) this.expandByPoint(e[t]);
        return this
    }
    setFromCenterAndSize(e, t) {
        const n = dC.copy(t).multiplyScalar(.5);
        return this.min.copy(e).sub(n), this.max.copy(e).add(n), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
    copy(e) {
        return this.min.copy(e.min), this.max.copy(e.max), this
    }
    makeEmpty() {
        return this.min.x = this.min.y = 1 / 0, this.max.x = this.max.y = -1 / 0, this
    }
    isEmpty() {
        return this.max.x < this.min.x || this.max.y < this.min.y
    }
    getCenter(e) {
        return this.isEmpty() ? e.set(0, 0) : e.addVectors(this.min, this.max).multiplyScalar(.5)
    }
    getSize(e) {
        return this.isEmpty() ? e.set(0, 0) : e.subVectors(this.max, this.min)
    }
    expandByPoint(e) {
        return this.min.min(e), this.max.max(e), this
    }
    expandByVector(e) {
        return this.min.sub(e), this.max.add(e), this
    }
    expandByScalar(e) {
        return this.min.addScalar(-e), this.max.addScalar(e), this
    }
    containsPoint(e) {
        return e.x >= this.min.x && e.x <= this.max.x && e.y >= this.min.y && e.y <= this.max.y
    }
    containsBox(e) {
        return this.min.x <= e.min.x && e.max.x <= this.max.x && this.min.y <= e.min.y && e.max.y <= this.max.y
    }
    getParameter(e, t) {
        return t.set((e.x - this.min.x) / (this.max.x - this.min.x), (e.y - this.min.y) / (this.max.y - this.min.y))
    }
    intersectsBox(e) {
        return e.max.x >= this.min.x && e.min.x <= this.max.x && e.max.y >= this.min.y && e.min.y <= this.max.y
    }
    clampPoint(e, t) {
        return t.copy(e).clamp(this.min, this.max)
    }
    distanceToPoint(e) {
        return this.clampPoint(e, dC).distanceTo(e)
    }
    intersect(e) {
        return this.min.max(e.min), this.max.min(e.max), this.isEmpty() && this.makeEmpty(), this
    }
    union(e) {
        return this.min.min(e.min), this.max.max(e.max), this
    }
    translate(e) {
        return this.min.add(e), this.max.add(e), this
    }
    equals(e) {
        return e.min.equals(this.min) && e.max.equals(this.max)
    }
}
const pC = new K,
    e0 = new K;
class WV {
    constructor(e = new K, t = new K) {
        this.start = e, this.end = t
    }
    set(e, t) {
        return this.start.copy(e), this.end.copy(t), this
    }
    copy(e) {
        return this.start.copy(e.start), this.end.copy(e.end), this
    }
    getCenter(e) {
        return e.addVectors(this.start, this.end).multiplyScalar(.5)
    }
    delta(e) {
        return e.subVectors(this.end, this.start)
    }
    distanceSq() {
        return this.start.distanceToSquared(this.end)
    }
    distance() {
        return this.start.distanceTo(this.end)
    }
    at(e, t) {
        return this.delta(t).multiplyScalar(e).add(this.start)
    }
    closestPointToPointParameter(e, t) {
        pC.subVectors(e, this.start), e0.subVectors(this.end, this.start);
        const n = e0.dot(e0);
        let s = e0.dot(pC) / n;
        return t && (s = fi(s, 0, 1)), s
    }
    closestPointToPoint(e, t, n) {
        const i = this.closestPointToPointParameter(e, t);
        return this.delta(n).multiplyScalar(i).add(this.start)
    }
    applyMatrix4(e) {
        return this.start.applyMatrix4(e), this.end.applyMatrix4(e), this
    }
    equals(e) {
        return e.start.equals(this.start) && e.end.equals(this.end)
    }
    clone() {
        return new this.constructor().copy(this)
    }
}
const mC = new K;
class jV extends vn {
    constructor(e, t) {
        super(), this.light = e, this.matrixAutoUpdate = !1, this.color = t, this.type = "SpotLightHelper";
        const n = new zt,
            i = [0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, -1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, -1, 1];
        for (let o = 0, a = 1, l = 32; o < l; o++, a++) {
            const c = o / l * Math.PI * 2,
                u = a / l * Math.PI * 2;
            i.push(Math.cos(c), Math.sin(c), 1, Math.cos(u), Math.sin(u), 1)
        }
        n.setAttribute("position", new Et(i, 3));
        const s = new yr({
            fog: !1,
            toneMapped: !1
        });
        this.cone = new po(n, s), this.add(this.cone), this.update()
    }
    dispose() {
        this.cone.geometry.dispose(), this.cone.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), this.parent ? (this.parent.updateWorldMatrix(!0), this.matrix.copy(this.parent.matrixWorld).invert().multiply(this.light.matrixWorld)) : this.matrix.copy(this.light.matrixWorld), this.matrixWorld.copy(this.light.matrixWorld);
        const e = this.light.distance ? this.light.distance : 1e3,
            t = e * Math.tan(this.light.angle);
        this.cone.scale.set(t, t, e), mC.setFromMatrixPosition(this.light.target.matrixWorld), this.cone.lookAt(mC), this.color !== void 0 ? this.cone.material.color.set(this.color) : this.cone.material.color.copy(this.light.color)
    }
}
const ja = new K,
    t0 = new Ot,
    jx = new Ot;
class XV extends po {
    constructor(e) {
        const t = rD(e),
            n = new zt,
            i = [],
            s = [],
            o = new rt(0, 0, 1),
            a = new rt(0, 1, 0);
        for (let c = 0; c < t.length; c++) {
            const u = t[c];
            u.parent && u.parent.isBone && (i.push(0, 0, 0), i.push(0, 0, 0), s.push(o.r, o.g, o.b), s.push(a.r, a.g, a.b))
        }
        n.setAttribute("position", new Et(i, 3)), n.setAttribute("color", new Et(s, 3));
        const l = new yr({
            vertexColors: !0,
            depthTest: !1,
            depthWrite: !1,
            toneMapped: !1,
            transparent: !0
        });
        super(n, l), this.isSkeletonHelper = !0, this.type = "SkeletonHelper", this.root = e, this.bones = t, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1
    }
    updateMatrixWorld(e) {
        const t = this.bones,
            n = this.geometry,
            i = n.getAttribute("position");
        jx.copy(this.root.matrixWorld).invert();
        for (let s = 0, o = 0; s < t.length; s++) {
            const a = t[s];
            a.parent && a.parent.isBone && (t0.multiplyMatrices(jx, a.matrixWorld), ja.setFromMatrixPosition(t0), i.setXYZ(o, ja.x, ja.y, ja.z), t0.multiplyMatrices(jx, a.parent.matrixWorld), ja.setFromMatrixPosition(t0), i.setXYZ(o + 1, ja.x, ja.y, ja.z), o += 2)
        }
        n.getAttribute("position").needsUpdate = !0, super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

function rD(r) {
    const e = [];
    r.isBone === !0 && e.push(r);
    for (let t = 0; t < r.children.length; t++) e.push.apply(e, rD(r.children[t]));
    return e
}
class YV extends Tn {
    constructor(e, t, n) {
        const i = new tm(t, 4, 2),
            s = new Mi({
                wireframe: !0,
                fog: !1,
                toneMapped: !1
            });
        super(i, s), this.light = e, this.color = n, this.type = "PointLightHelper", this.matrix = this.light.matrixWorld, this.matrixAutoUpdate = !1, this.update()
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1), this.color !== void 0 ? this.material.color.set(this.color) : this.material.color.copy(this.light.color)
    }
}
const JV = new K,
    gC = new rt,
    vC = new rt;
class KV extends vn {
    constructor(e, t, n) {
        super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "HemisphereLightHelper";
        const i = new $p(t);
        i.rotateY(Math.PI * .5), this.material = new Mi({
            wireframe: !0,
            fog: !1,
            toneMapped: !1
        }), this.color === void 0 && (this.material.vertexColors = !0);
        const s = i.getAttribute("position"),
            o = new Float32Array(s.count * 3);
        i.setAttribute("color", new an(o, 3)), this.add(new Tn(i, this.material)), this.update()
    }
    dispose() {
        this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }
    update() {
        const e = this.children[0];
        if (this.color !== void 0) this.material.color.set(this.color);
        else {
            const t = e.geometry.getAttribute("color");
            gC.copy(this.light.color), vC.copy(this.light.groundColor);
            for (let n = 0, i = t.count; n < i; n++) {
                const s = n < i / 2 ? gC : vC;
                t.setXYZ(n, s.r, s.g, s.b)
            }
            t.needsUpdate = !0
        }
        this.light.updateWorldMatrix(!0, !1), e.lookAt(JV.setFromMatrixPosition(this.light.matrixWorld).negate())
    }
}
class qV extends po {
    constructor(e = 10, t = 10, n = 4473924, i = 8947848) {
        n = new rt(n), i = new rt(i);
        const s = t / 2,
            o = e / t,
            a = e / 2,
            l = [],
            c = [];
        for (let d = 0, m = 0, g = -a; d <= t; d++, g += o) {
            l.push(-a, 0, g, a, 0, g), l.push(g, 0, -a, g, 0, a);
            const y = d === s ? n : i;
            y.toArray(c, m), m += 3, y.toArray(c, m), m += 3, y.toArray(c, m), m += 3, y.toArray(c, m), m += 3
        }
        const u = new zt;
        u.setAttribute("position", new Et(l, 3)), u.setAttribute("color", new Et(c, 3));
        const f = new yr({
            vertexColors: !0,
            toneMapped: !1
        });
        super(u, f), this.type = "GridHelper"
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class ZV extends po {
    constructor(e = 10, t = 16, n = 8, i = 64, s = 4473924, o = 8947848) {
        s = new rt(s), o = new rt(o);
        const a = [],
            l = [];
        if (t > 1)
            for (let f = 0; f < t; f++) {
                const d = f / t * (Math.PI * 2),
                    m = Math.sin(d) * e,
                    g = Math.cos(d) * e;
                a.push(0, 0, 0), a.push(m, 0, g);
                const y = f & 1 ? s : o;
                l.push(y.r, y.g, y.b), l.push(y.r, y.g, y.b)
            }
        for (let f = 0; f < n; f++) {
            const d = f & 1 ? s : o,
                m = e - e / n * f;
            for (let g = 0; g < i; g++) {
                let y = g / i * (Math.PI * 2),
                    v = Math.sin(y) * m,
                    _ = Math.cos(y) * m;
                a.push(v, 0, _), l.push(d.r, d.g, d.b), y = (g + 1) / i * (Math.PI * 2), v = Math.sin(y) * m, _ = Math.cos(y) * m, a.push(v, 0, _), l.push(d.r, d.g, d.b)
            }
        }
        const c = new zt;
        c.setAttribute("position", new Et(a, 3)), c.setAttribute("color", new Et(l, 3));
        const u = new yr({
            vertexColors: !0,
            toneMapped: !1
        });
        super(c, u), this.type = "PolarGridHelper"
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
const yC = new K,
    n0 = new K,
    _C = new K;
class QV extends vn {
    constructor(e, t, n) {
        super(), this.light = e, this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.color = n, this.type = "DirectionalLightHelper", t === void 0 && (t = 1);
        let i = new zt;
        i.setAttribute("position", new Et([-t, t, 0, t, t, 0, t, -t, 0, -t, -t, 0, -t, t, 0], 3));
        const s = new yr({
            fog: !1,
            toneMapped: !1
        });
        this.lightPlane = new Ta(i, s), this.add(this.lightPlane), i = new zt, i.setAttribute("position", new Et([0, 0, 0, 0, 0, 1], 3)), this.targetLine = new Ta(i, s), this.add(this.targetLine), this.update()
    }
    dispose() {
        this.lightPlane.geometry.dispose(), this.lightPlane.material.dispose(), this.targetLine.geometry.dispose(), this.targetLine.material.dispose()
    }
    update() {
        this.light.updateWorldMatrix(!0, !1), this.light.target.updateWorldMatrix(!0, !1), yC.setFromMatrixPosition(this.light.matrixWorld), n0.setFromMatrixPosition(this.light.target.matrixWorld), _C.subVectors(n0, yC), this.lightPlane.lookAt(n0), this.color !== void 0 ? (this.lightPlane.material.color.set(this.color), this.targetLine.material.color.set(this.color)) : (this.lightPlane.material.color.copy(this.light.color), this.targetLine.material.color.copy(this.light.color)), this.targetLine.lookAt(n0), this.targetLine.scale.z = _C.length()
    }
}
const i0 = new K,
    ci = new Fl;
class $V extends po {
    constructor(e) {
        const t = new zt,
            n = new yr({
                color: 16777215,
                vertexColors: !0,
                toneMapped: !1
            }),
            i = [],
            s = [],
            o = {};
        a("n1", "n2"), a("n2", "n4"), a("n4", "n3"), a("n3", "n1"), a("f1", "f2"), a("f2", "f4"), a("f4", "f3"), a("f3", "f1"), a("n1", "f1"), a("n2", "f2"), a("n3", "f3"), a("n4", "f4"), a("p", "n1"), a("p", "n2"), a("p", "n3"), a("p", "n4"), a("u1", "u2"), a("u2", "u3"), a("u3", "u1"), a("c", "t"), a("p", "c"), a("cn1", "cn2"), a("cn3", "cn4"), a("cf1", "cf2"), a("cf3", "cf4");

        function a(g, y) {
            l(g), l(y)
        }

        function l(g) {
            i.push(0, 0, 0), s.push(0, 0, 0), o[g] === void 0 && (o[g] = []), o[g].push(i.length / 3 - 1)
        }
        t.setAttribute("position", new Et(i, 3)), t.setAttribute("color", new Et(s, 3)), super(t, n), this.type = "CameraHelper", this.camera = e, this.camera.updateProjectionMatrix && this.camera.updateProjectionMatrix(), this.matrix = e.matrixWorld, this.matrixAutoUpdate = !1, this.pointMap = o, this.update();
        const c = new rt(16755200),
            u = new rt(16711680),
            f = new rt(43775),
            d = new rt(16777215),
            m = new rt(3355443);
        this.setColors(c, u, f, d, m)
    }
    setColors(e, t, n, i, s) {
        const a = this.geometry.getAttribute("color");
        a.setXYZ(0, e.r, e.g, e.b), a.setXYZ(1, e.r, e.g, e.b), a.setXYZ(2, e.r, e.g, e.b), a.setXYZ(3, e.r, e.g, e.b), a.setXYZ(4, e.r, e.g, e.b), a.setXYZ(5, e.r, e.g, e.b), a.setXYZ(6, e.r, e.g, e.b), a.setXYZ(7, e.r, e.g, e.b), a.setXYZ(8, e.r, e.g, e.b), a.setXYZ(9, e.r, e.g, e.b), a.setXYZ(10, e.r, e.g, e.b), a.setXYZ(11, e.r, e.g, e.b), a.setXYZ(12, e.r, e.g, e.b), a.setXYZ(13, e.r, e.g, e.b), a.setXYZ(14, e.r, e.g, e.b), a.setXYZ(15, e.r, e.g, e.b), a.setXYZ(16, e.r, e.g, e.b), a.setXYZ(17, e.r, e.g, e.b), a.setXYZ(18, e.r, e.g, e.b), a.setXYZ(19, e.r, e.g, e.b), a.setXYZ(20, e.r, e.g, e.b), a.setXYZ(21, e.r, e.g, e.b), a.setXYZ(22, e.r, e.g, e.b), a.setXYZ(23, e.r, e.g, e.b), a.setXYZ(24, t.r, t.g, t.b), a.setXYZ(25, t.r, t.g, t.b), a.setXYZ(26, t.r, t.g, t.b), a.setXYZ(27, t.r, t.g, t.b), a.setXYZ(28, t.r, t.g, t.b), a.setXYZ(29, t.r, t.g, t.b), a.setXYZ(30, t.r, t.g, t.b), a.setXYZ(31, t.r, t.g, t.b), a.setXYZ(32, n.r, n.g, n.b), a.setXYZ(33, n.r, n.g, n.b), a.setXYZ(34, n.r, n.g, n.b), a.setXYZ(35, n.r, n.g, n.b), a.setXYZ(36, n.r, n.g, n.b), a.setXYZ(37, n.r, n.g, n.b), a.setXYZ(38, i.r, i.g, i.b), a.setXYZ(39, i.r, i.g, i.b), a.setXYZ(40, s.r, s.g, s.b), a.setXYZ(41, s.r, s.g, s.b), a.setXYZ(42, s.r, s.g, s.b), a.setXYZ(43, s.r, s.g, s.b), a.setXYZ(44, s.r, s.g, s.b), a.setXYZ(45, s.r, s.g, s.b), a.setXYZ(46, s.r, s.g, s.b), a.setXYZ(47, s.r, s.g, s.b), a.setXYZ(48, s.r, s.g, s.b), a.setXYZ(49, s.r, s.g, s.b), a.needsUpdate = !0
    }
    update() {
        const e = this.geometry,
            t = this.pointMap,
            n = 1,
            i = 1;
        ci.projectionMatrixInverse.copy(this.camera.projectionMatrixInverse), _i("c", t, e, ci, 0, 0, -1), _i("t", t, e, ci, 0, 0, 1), _i("n1", t, e, ci, -n, -i, -1), _i("n2", t, e, ci, n, -i, -1), _i("n3", t, e, ci, -n, i, -1), _i("n4", t, e, ci, n, i, -1), _i("f1", t, e, ci, -n, -i, 1), _i("f2", t, e, ci, n, -i, 1), _i("f3", t, e, ci, -n, i, 1), _i("f4", t, e, ci, n, i, 1), _i("u1", t, e, ci, n * .7, i * 1.1, -1), _i("u2", t, e, ci, -n * .7, i * 1.1, -1), _i("u3", t, e, ci, 0, i * 2, -1), _i("cf1", t, e, ci, -n, 0, 1), _i("cf2", t, e, ci, n, 0, 1), _i("cf3", t, e, ci, 0, -i, 1), _i("cf4", t, e, ci, 0, i, 1), _i("cn1", t, e, ci, -n, 0, -1), _i("cn2", t, e, ci, n, 0, -1), _i("cn3", t, e, ci, 0, -i, -1), _i("cn4", t, e, ci, 0, i, -1), e.getAttribute("position").needsUpdate = !0
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}

function _i(r, e, t, n, i, s, o) {
    i0.set(i, s, o).unproject(n);
    const a = e[r];
    if (a !== void 0) {
        const l = t.getAttribute("position");
        for (let c = 0, u = a.length; c < u; c++) l.setXYZ(a[c], i0.x, i0.y, i0.z)
    }
}
const r0 = new Wi;
class e8 extends po {
    constructor(e, t = 16776960) {
        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            i = new Float32Array(8 * 3),
            s = new zt;
        s.setIndex(new an(n, 1)), s.setAttribute("position", new an(i, 3)), super(s, new yr({
            color: t,
            toneMapped: !1
        })), this.object = e, this.type = "BoxHelper", this.matrixAutoUpdate = !1, this.update()
    }
    update(e) {
        if (e !== void 0 && console.warn("THREE.BoxHelper: .update() has no longer arguments."), this.object !== void 0 && r0.setFromObject(this.object), r0.isEmpty()) return;
        const t = r0.min,
            n = r0.max,
            i = this.geometry.attributes.position,
            s = i.array;
        s[0] = n.x, s[1] = n.y, s[2] = n.z, s[3] = t.x, s[4] = n.y, s[5] = n.z, s[6] = t.x, s[7] = t.y, s[8] = n.z, s[9] = n.x, s[10] = t.y, s[11] = n.z, s[12] = n.x, s[13] = n.y, s[14] = t.z, s[15] = t.x, s[16] = n.y, s[17] = t.z, s[18] = t.x, s[19] = t.y, s[20] = t.z, s[21] = n.x, s[22] = t.y, s[23] = t.z, i.needsUpdate = !0, this.geometry.computeBoundingSphere()
    }
    setFromObject(e) {
        return this.object = e, this.update(), this
    }
    copy(e, t) {
        return super.copy(e, t), this.object = e.object, this
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class t8 extends po {
    constructor(e, t = 16776960) {
        const n = new Uint16Array([0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7]),
            i = [1, 1, 1, -1, 1, 1, -1, -1, 1, 1, -1, 1, 1, 1, -1, -1, 1, -1, -1, -1, -1, 1, -1, -1],
            s = new zt;
        s.setIndex(new an(n, 1)), s.setAttribute("position", new Et(i, 3)), super(s, new yr({
            color: t,
            toneMapped: !1
        })), this.box = e, this.type = "Box3Helper", this.geometry.computeBoundingSphere()
    }
    updateMatrixWorld(e) {
        const t = this.box;
        t.isEmpty() || (t.getCenter(this.position), t.getSize(this.scale), this.scale.multiplyScalar(.5), super.updateMatrixWorld(e))
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class n8 extends Ta {
    constructor(e, t = 1, n = 16776960) {
        const i = n,
            s = [1, -1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, 1, 0, -1, -1, 0, 1, -1, 0, 1, 1, 0],
            o = new zt;
        o.setAttribute("position", new Et(s, 3)), o.computeBoundingSphere(), super(o, new yr({
            color: i,
            toneMapped: !1
        })), this.type = "PlaneHelper", this.plane = e, this.size = t;
        const a = [1, 1, 0, -1, 1, 0, -1, -1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],
            l = new zt;
        l.setAttribute("position", new Et(a, 3)), l.computeBoundingSphere(), this.add(new Tn(l, new Mi({
            color: i,
            opacity: .2,
            transparent: !0,
            depthWrite: !1,
            toneMapped: !1
        })))
    }
    updateMatrixWorld(e) {
        this.position.set(0, 0, 0), this.scale.set(.5 * this.size, .5 * this.size, 1), this.lookAt(this.plane.normal), this.translateZ(-this.plane.constant), super.updateMatrixWorld(e)
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose(), this.children[0].geometry.dispose(), this.children[0].material.dispose()
    }
}
const xC = new K;
let s0, Xx;
class i8 extends vn {
    constructor(e = new K(0, 0, 1), t = new K(0, 0, 0), n = 1, i = 16776960, s = n * .2, o = s * .2) {
        super(), this.type = "ArrowHelper", s0 === void 0 && (s0 = new zt, s0.setAttribute("position", new Et([0, 0, 0, 0, 1, 0], 3)), Xx = new ch(0, .5, 1, 5, 1), Xx.translate(0, -.5, 0)), this.position.copy(t), this.line = new Ta(s0, new yr({
            color: i,
            toneMapped: !1
        })), this.line.matrixAutoUpdate = !1, this.add(this.line), this.cone = new Tn(Xx, new Mi({
            color: i,
            toneMapped: !1
        })), this.cone.matrixAutoUpdate = !1, this.add(this.cone), this.setDirection(e), this.setLength(n, s, o)
    }
    setDirection(e) {
        if (e.y > .99999) this.quaternion.set(0, 0, 0, 1);
        else if (e.y < -.99999) this.quaternion.set(1, 0, 0, 0);
        else {
            xC.set(e.z, 0, -e.x).normalize();
            const t = Math.acos(e.y);
            this.quaternion.setFromAxisAngle(xC, t)
        }
    }
    setLength(e, t = e * .2, n = t * .2) {
        this.line.scale.set(1, Math.max(1e-4, e - t), 1), this.line.updateMatrix(), this.cone.scale.set(n, t, n), this.cone.position.y = e, this.cone.updateMatrix()
    }
    setColor(e) {
        this.line.material.color.set(e), this.cone.material.color.set(e)
    }
    copy(e) {
        return super.copy(e, !1), this.line.copy(e.line), this.cone.copy(e.cone), this
    }
    dispose() {
        this.line.geometry.dispose(), this.line.material.dispose(), this.cone.geometry.dispose(), this.cone.material.dispose()
    }
}
class r8 extends po {
    constructor(e = 1) {
        const t = [0, 0, 0, e, 0, 0, 0, 0, 0, 0, e, 0, 0, 0, 0, 0, 0, e],
            n = [1, 0, 0, 1, .6, 0, 0, 1, 0, .6, 1, 0, 0, 0, 1, 0, .6, 1],
            i = new zt;
        i.setAttribute("position", new Et(t, 3)), i.setAttribute("color", new Et(n, 3));
        const s = new yr({
            vertexColors: !0,
            toneMapped: !1
        });
        super(i, s), this.type = "AxesHelper"
    }
    setColors(e, t, n) {
        const i = new rt,
            s = this.geometry.attributes.color.array;
        return i.set(e), i.toArray(s, 0), i.toArray(s, 3), i.set(t), i.toArray(s, 6), i.toArray(s, 9), i.set(n), i.toArray(s, 12), i.toArray(s, 15), this.geometry.attributes.color.needsUpdate = !0, this
    }
    dispose() {
        this.geometry.dispose(), this.material.dispose()
    }
}
class s8 {
    constructor() {
        this.type = "ShapePath", this.color = new rt, this.subPaths = [], this.currentPath = null
    }
    moveTo(e, t) {
        return this.currentPath = new yp, this.subPaths.push(this.currentPath), this.currentPath.moveTo(e, t), this
    }
    lineTo(e, t) {
        return this.currentPath.lineTo(e, t), this
    }
    quadraticCurveTo(e, t, n, i) {
        return this.currentPath.quadraticCurveTo(e, t, n, i), this
    }
    bezierCurveTo(e, t, n, i, s, o) {
        return this.currentPath.bezierCurveTo(e, t, n, i, s, o), this
    }
    splineThru(e) {
        return this.currentPath.splineThru(e), this
    }
    toShapes(e) {
        function t(_) {
            const A = [];
            for (let S = 0, M = _.length; S < M; S++) {
                const C = _[S],
                    E = new dl;
                E.curves = C.curves, A.push(E)
            }
            return A
        }

        function n(_, A) {
            const S = A.length;
            let M = !1;
            for (let C = S - 1, E = 0; E < S; C = E++) {
                let R = A[C],
                    P = A[E],
                    b = P.x - R.x,
                    T = P.y - R.y;
                if (Math.abs(T) > Number.EPSILON) {
                    if (T < 0 && (R = A[E], b = -b, P = A[C], T = -T), _.y < R.y || _.y > P.y) continue;
                    if (_.y === R.y) {
                        if (_.x === R.x) return !0
                    } else {
                        const L = T * (_.x - R.x) - b * (_.y - R.y);
                        if (L === 0) return !0;
                        if (L < 0) continue;
                        M = !M
                    }
                } else {
                    if (_.y !== R.y) continue;
                    if (P.x <= _.x && _.x <= R.x || R.x <= _.x && _.x <= P.x) return !0
                }
            }
            return M
        }
        const i = Fo.isClockWise,
            s = this.subPaths;
        if (s.length === 0) return [];
        let o, a, l;
        const c = [];
        if (s.length === 1) return a = s[0], l = new dl, l.curves = a.curves, c.push(l), c;
        let u = !i(s[0].getPoints());
        u = e ? !u : u;
        const f = [],
            d = [];
        let m = [],
            g = 0,
            y;
        d[g] = void 0, m[g] = [];
        for (let _ = 0, A = s.length; _ < A; _++) a = s[_], y = a.getPoints(), o = i(y), o = e ? !o : o, o ? (!u && d[g] && g++, d[g] = {
            s: new dl,
            p: y
        }, d[g].s.curves = a.curves, u && g++, m[g] = []) : m[g].push({
            h: a,
            p: y[0]
        });
        if (!d[0]) return t(s);
        if (d.length > 1) {
            let _ = !1,
                A = 0;
            for (let S = 0, M = d.length; S < M; S++) f[S] = [];
            for (let S = 0, M = d.length; S < M; S++) {
                const C = m[S];
                for (let E = 0; E < C.length; E++) {
                    const R = C[E];
                    let P = !0;
                    for (let b = 0; b < d.length; b++) n(R.p, d[b].p) && (S !== b && A++, P ? (P = !1, f[b].push(R)) : _ = !0);
                    P && f[S].push(R)
                }
            }
            A > 0 && _ === !1 && (m = f)
        }
        let v;
        for (let _ = 0, A = d.length; _ < A; _++) {
            l = d[_].s, c.push(l), v = m[_];
            for (let S = 0, M = v.length; S < M; S++) l.holes.push(v[S].h)
        }
        return c
    }
}
class o8 extends ws {
    constructor(e, t = null) {
        super(), this.object = e, this.domElement = t, this.enabled = !0, this.state = -1, this.keys = {}, this.mouseButtons = {
            LEFT: null,
            MIDDLE: null,
            RIGHT: null
        }, this.touches = {
            ONE: null,
            TWO: null
        }
    }
    connect() {}
    disconnect() {}
    dispose() {}
    update() {}
}
class a8 extends Zn {
    constructor(e = 1, t = 1, n = 1, i = {}) {
        console.warn('THREE.WebGLMultipleRenderTargets has been deprecated and will be removed in r172. Use THREE.WebGLRenderTarget and set the "count" parameter to enable MRT.'), super(e, t, { ...i,
            count: n
        }), this.isWebGLMultipleRenderTargets = !0
    }
    get texture() {
        return this.textures
    }
}
typeof __THREE_DEVTOOLS__ < "u" && __THREE_DEVTOOLS__.dispatchEvent(new CustomEvent("register", {
    detail: {
        revision: du
    }
}));
typeof window < "u" && (window.__THREE__ ? console.warn("WARNING: Multiple instances of Three.js being imported.") : window.__THREE__ = du);
const l8 = Object.freeze(Object.defineProperty({
    __proto__: null,
    ACESFilmicToneMapping: ry,
    AddEquation: tl,
    AddOperation: VI,
    AdditiveAnimationBlendMode: kS,
    AdditiveBlending: aA,
    AgXToneMapping: JI,
    AlphaFormat: DS,
    AlwaysCompare: lB,
    AlwaysDepth: $0,
    AlwaysStencilFunc: hA,
    AmbientLight: dM,
    AnimationAction: iD,
    AnimationClip: eh,
    AnimationLoader: fV,
    AnimationMixer: UV,
    AnimationObjectGroup: LV,
    AnimationUtils: aV,
    ArcCurve: TB,
    ArrayCamera: AB,
    ArrowHelper: i8,
    AttachedBindMode: uA,
    Audio: tD,
    AudioAnalyser: wV,
    AudioContext: mM,
    AudioListener: AV,
    AudioLoader: yV,
    AxesHelper: r8,
    BackSide: di,
    BasicDepthPacking: Bl,
    BasicShadowMap: MI,
    BatchedMesh: bB,
    Bone: xy,
    BooleanKeyframeTrack: gu,
    Box2: VV,
    Box3: Wi,
    Box3Helper: t8,
    BoxGeometry: pu,
    BoxHelper: e8,
    BufferAttribute: an,
    BufferGeometry: zt,
    BufferGeometryLoader: $B,
    ByteType: oy,
    Cache: pa,
    Camera: Fl,
    CameraHelper: $V,
    CanvasTexture: I5,
    CapsuleGeometry: wy,
    CatmullRomCurve3: EB,
    CineonToneMapping: XI,
    CircleGeometry: by,
    ClampToEdgeWrapping: Nn,
    Clock: gM,
    Color: rt,
    ColorKeyframeTrack: cM,
    ColorManagement: xn,
    CompressedArrayTexture: R5,
    CompressedCubeTexture: P5,
    CompressedTexture: Sy,
    CompressedTextureLoader: hV,
    ConeGeometry: Ty,
    ConstantAlphaFactor: zI,
    ConstantColorFactor: NI,
    Controls: o8,
    CubeCamera: YS,
    CubeReflectionMapping: ko,
    CubeRefractionMapping: Al,
    CubeTexture: jp,
    CubeTextureLoader: JB,
    CubeUVReflectionMapping: ah,
    CubicBezierCurve: tM,
    CubicBezierCurve3: CB,
    CubicInterpolant: WB,
    CullFaceBack: oA,
    CullFaceFront: SI,
    CullFaceFrontBack: fN,
    CullFaceNone: AI,
    Curve: mo,
    CurvePath: PB,
    CustomBlending: wI,
    CustomToneMapping: YI,
    CylinderGeometry: ch,
    Cylindrical: HV,
    Data3DTexture: WS,
    DataArrayTexture: dy,
    DataTexture: qr,
    DataTextureLoader: uM,
    DataUtils: Lc,
    DecrementStencilOp: AN,
    DecrementWrapStencilOp: MN,
    DefaultLoadingManager: YB,
    DepthFormat: Yc,
    DepthStencilFormat: wl,
    DepthTexture: Yp,
    DetachedBindMode: qI,
    DirectionalLight: Mp,
    DirectionalLightHelper: QV,
    DiscreteInterpolant: jB,
    DodecahedronGeometry: Ey,
    DoubleSide: hn,
    DstAlphaFactor: DI,
    DstColorFactor: FI,
    DynamicCopyUsage: NN,
    DynamicDrawUsage: BN,
    DynamicReadUsage: FN,
    EdgesGeometry: IB,
    EllipseCurve: My,
    EqualCompare: rB,
    EqualDepth: tv,
    EqualStencilFunc: EN,
    EquirectangularReflectionMapping: ou,
    EquirectangularRefractionMapping: dp,
    Euler: As,
    EventDispatcher: ws,
    ExtrudeGeometry: Ry,
    FileLoader: $i,
    Float16BufferAttribute: bk,
    Float32BufferAttribute: Et,
    FloatType: Bn,
    Fog: _y,
    FogExp2: yy,
    FramebufferTexture: C5,
    FrontSide: Zs,
    Frustum: Xp,
    GLBufferAttribute: zV,
    GLSL1: zN,
    GLSL3: dA,
    GreaterCompare: sB,
    GreaterDepth: iv,
    GreaterEqualCompare: aB,
    GreaterEqualDepth: nv,
    GreaterEqualStencilFunc: IN,
    GreaterStencilFunc: RN,
    GridHelper: qV,
    Group: da,
    HalfFloatType: Ri,
    HemisphereLight: KB,
    HemisphereLightHelper: KV,
    IcosahedronGeometry: Qp,
    ImageBitmapLoader: eD,
    ImageLoader: Sp,
    ImageUtils: fB,
    IncrementStencilOp: xN,
    IncrementWrapStencilOp: SN,
    InstancedBufferAttribute: El,
    InstancedBufferGeometry: pM,
    InstancedInterleavedBuffer: kV,
    InstancedMesh: QS,
    Int16BufferAttribute: Mk,
    Int32BufferAttribute: wk,
    Int8BufferAttribute: xk,
    IntType: Gp,
    InterleavedBuffer: Jp,
    InterleavedBufferAttribute: Tl,
    Interpolant: uh,
    InterpolateDiscrete: qf,
    InterpolateLinear: Zf,
    InterpolateSmooth: P0,
    InvertStencilOp: wN,
    KeepStencilOp: Mc,
    KeyframeTrack: go,
    LOD: wB,
    LatheGeometry: Zp,
    Layers: Kc,
    LessCompare: iB,
    LessDepth: ev,
    LessEqualCompare: HS,
    LessEqualDepth: su,
    LessEqualStencilFunc: CN,
    LessStencilFunc: TN,
    Light: Ol,
    LightProbe: QB,
    Line: Ta,
    Line3: WV,
    LineBasicMaterial: yr,
    LineCurve: nM,
    LineCurve3: RB,
    LineDashedMaterial: GB,
    LineLoop: $S,
    LineSegments: po,
    LinearFilter: nn,
    LinearInterpolant: lM,
    LinearMipMapLinearFilter: fA,
    LinearMipMapNearestFilter: pN,
    LinearMipmapLinearFilter: gs,
    LinearMipmapNearestFilter: If,
    LinearSRGBColorSpace: Qs,
    LinearToneMapping: WI,
    LinearTransfer: Wp,
    Loader: er,
    LoaderUtils: pl,
    LoadingManager: Fy,
    LoopOnce: ZI,
    LoopPingPong: $I,
    LoopRepeat: QI,
    LuminanceAlphaFormat: US,
    LuminanceFormat: FS,
    MOUSE: cN,
    Material: mi,
    MaterialLoader: Oy,
    MathUtils: ha,
    Matrix2: xM,
    Matrix3: jt,
    Matrix4: Ot,
    MaxEquation: CI,
    Mesh: Tn,
    MeshBasicMaterial: Mi,
    MeshDepthMaterial: gy,
    MeshDistanceMaterial: vy,
    MeshLambertMaterial: kB,
    MeshMatcapMaterial: zB,
    MeshNormalMaterial: oM,
    MeshPhongMaterial: OB,
    MeshPhysicalMaterial: Ts,
    MeshStandardMaterial: mu,
    MeshToonMaterial: NB,
    MinEquation: EI,
    MirroredRepeatWrapping: au,
    MixOperation: HI,
    MultiplyBlending: cA,
    MultiplyOperation: zp,
    NearestFilter: bn,
    NearestMipMapLinearFilter: dN,
    NearestMipMapNearestFilter: hN,
    NearestMipmapLinearFilter: Pc,
    NearestMipmapNearestFilter: sy,
    NeutralToneMapping: KI,
    NeverCompare: nB,
    NeverDepth: Q0,
    NeverStencilFunc: bN,
    NoBlending: pi,
    NoColorSpace: uo,
    NoToneMapping: Js,
    NormalAnimationBlendMode: hy,
    NormalBlending: Xc,
    NotEqualCompare: oB,
    NotEqualDepth: rv,
    NotEqualStencilFunc: PN,
    NumberKeyframeTrack: cu,
    Object3D: vn,
    ObjectLoader: gV,
    ObjectSpaceNormalMap: tB,
    OctahedronGeometry: $p,
    OneFactor: PI,
    OneMinusConstantAlphaFactor: GI,
    OneMinusConstantColorFactor: kI,
    OneMinusDstAlphaFactor: LI,
    OneMinusDstColorFactor: UI,
    OneMinusSrcAlphaFactor: Z0,
    OneMinusSrcColorFactor: BI,
    OrthographicCamera: Ca,
    PCFShadowMap: iy,
    PCFSoftShadowMap: zd,
    PMREMGenerator: pA,
    Path: yp,
    PerspectiveCamera: ri,
    Plane: Br,
    PlaneGeometry: bs,
    PlaneHelper: n8,
    PointLight: Uy,
    PointLightHelper: YV,
    Points: Ay,
    PointsMaterial: qp,
    PolarGridHelper: ZV,
    PolyhedronGeometry: Ul,
    PositionalAudio: MV,
    PropertyBinding: wn,
    PropertyMixer: nD,
    QuadraticBezierCurve: iM,
    QuadraticBezierCurve3: rM,
    Quaternion: gr,
    QuaternionKeyframeTrack: uu,
    QuaternionLinearInterpolant: XB,
    RED_GREEN_RGTC2_Format: Rv,
    RED_RGTC1_Format: NS,
    REVISION: du,
    RGBADepthPacking: GS,
    RGBAFormat: kn,
    RGBAIntegerFormat: fy,
    RGBA_ASTC_10x10_Format: Mv,
    RGBA_ASTC_10x5_Format: xv,
    RGBA_ASTC_10x6_Format: Av,
    RGBA_ASTC_10x8_Format: Sv,
    RGBA_ASTC_12x10_Format: wv,
    RGBA_ASTC_12x12_Format: bv,
    RGBA_ASTC_4x4_Format: hv,
    RGBA_ASTC_5x4_Format: dv,
    RGBA_ASTC_5x5_Format: pv,
    RGBA_ASTC_6x5_Format: mv,
    RGBA_ASTC_6x6_Format: gv,
    RGBA_ASTC_8x5_Format: vv,
    RGBA_ASTC_8x6_Format: yv,
    RGBA_ASTC_8x8_Format: _v,
    RGBA_BPTC_Format: jd,
    RGBA_ETC2_EAC_Format: fv,
    RGBA_PVRTC_2BPPV1_Format: lv,
    RGBA_PVRTC_4BPPV1_Format: av,
    RGBA_S3TC_DXT1_Format: Hd,
    RGBA_S3TC_DXT3_Format: Vd,
    RGBA_S3TC_DXT5_Format: Wd,
    RGBDepthPacking: gN,
    RGBFormat: LS,
    RGBIntegerFormat: mN,
    RGB_BPTC_SIGNED_Format: Tv,
    RGB_BPTC_UNSIGNED_Format: Ev,
    RGB_ETC1_Format: cv,
    RGB_ETC2_Format: uv,
    RGB_PVRTC_2BPPV1_Format: ov,
    RGB_PVRTC_4BPPV1_Format: sv,
    RGB_S3TC_DXT1_Format: Gd,
    RGDepthPacking: vN,
    RGFormat: OS,
    RGIntegerFormat: uy,
    RawShaderMaterial: Fv,
    Ray: Ll,
    Raycaster: _M,
    RectAreaLight: qB,
    RedFormat: Hp,
    RedIntegerFormat: Vp,
    ReinhardToneMapping: jI,
    RenderTarget: hB,
    RepeatWrapping: Sl,
    ReplaceStencilOp: _N,
    ReverseSubtractEquation: TI,
    RingGeometry: Py,
    SIGNED_RED_GREEN_RGTC2_Format: Pv,
    SIGNED_RED_RGTC1_Format: Cv,
    SRGBColorSpace: Jn,
    SRGBTransfer: Ln,
    Scene: ho,
    ShaderChunk: Jt,
    ShaderLib: Vs,
    ShaderMaterial: Fn,
    ShadowMaterial: UB,
    Shape: dl,
    ShapeGeometry: em,
    ShapePath: s8,
    ShapeUtils: Fo,
    ShortType: ay,
    Skeleton: Kp,
    SkeletonHelper: XV,
    SkinnedMesh: ZS,
    Source: Dc,
    Sphere: ji,
    SphereGeometry: tm,
    Spherical: GV,
    SphericalHarmonics3: ZB,
    SplineCurve: sM,
    SpotLight: hM,
    SpotLightHelper: jV,
    Sprite: MB,
    SpriteMaterial: qS,
    SrcAlphaFactor: q0,
    SrcAlphaSaturateFactor: OI,
    SrcColorFactor: II,
    StaticCopyUsage: ON,
    StaticDrawUsage: mp,
    StaticReadUsage: LN,
    StereoCamera: _V,
    StreamCopyUsage: kN,
    StreamDrawUsage: DN,
    StreamReadUsage: UN,
    StringKeyframeTrack: vu,
    SubtractEquation: bI,
    SubtractiveBlending: lA,
    TOUCH: uN,
    TangentSpaceNormalMap: Dl,
    TetrahedronGeometry: Iy,
    Texture: gn,
    TextureLoader: zo,
    TextureUtils: l5,
    TorusGeometry: By,
    TorusKnotGeometry: Dy,
    Triangle: Or,
    TriangleFanDrawMode: Iv,
    TriangleStripDrawMode: zS,
    TrianglesDrawMode: eB,
    TubeGeometry: Ly,
    UVMapping: xl,
    Uint16BufferAttribute: jS,
    Uint32BufferAttribute: XS,
    Uint8BufferAttribute: Ak,
    Uint8ClampedBufferAttribute: Sk,
    Uniform: Wn,
    UniformsGroup: NV,
    UniformsLib: dt,
    UniformsUtils: bl,
    UnsignedByteType: Yi,
    UnsignedInt248Type: Ml,
    UnsignedInt5999Type: BS,
    UnsignedIntType: fo,
    UnsignedShort4444Type: ly,
    UnsignedShort5551Type: cy,
    UnsignedShortType: Kf,
    VSMShadowMap: lo,
    Vector2: Ue,
    Vector3: K,
    Vector4: An,
    VectorKeyframeTrack: fu,
    VideoTexture: E5,
    WebGL3DRenderTarget: uk,
    WebGLArrayRenderTarget: ck,
    WebGLCoordinateSystem: Io,
    WebGLCubeRenderTarget: py,
    WebGLMultipleRenderTargets: a8,
    WebGLRenderTarget: Zn,
    WebGLRenderer: KS,
    WebGLUtils: xB,
    WebGPUCoordinateSystem: gp,
    WireframeGeometry: FB,
    WrapAroundEnding: pp,
    ZeroCurvatureEnding: Ic,
    ZeroFactor: RI,
    ZeroSlopeEnding: Bc,
    ZeroStencilOp: yN,
    createCanvasElement: uB
}, Symbol.toStringTag, {
    value: "Module"
}));
var sD = {
        exports: {}
    },
    yu = {};
/**
 * @license React
 * react-reconciler-constants.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
yu.ConcurrentRoot = 1;
yu.ContinuousEventPriority = 4;
yu.DefaultEventPriority = 16;
yu.DiscreteEventPriority = 1;
yu.IdleEventPriority = 536870912;
yu.LegacyRoot = 0;
sD.exports = yu;
var yf = sD.exports;

function c8(r) {
    let e;
    const t = new Set,
        n = (c, u) => {
            const f = typeof c == "function" ? c(e) : c;
            if (f !== e) {
                const d = e;
                e = u ? f : Object.assign({}, e, f), t.forEach(m => m(e, d))
            }
        },
        i = () => e,
        s = (c, u = i, f = Object.is) => {
            console.warn("[DEPRECATED] Please use `subscribeWithSelector` middleware");
            let d = u(e);

            function m() {
                const g = u(e);
                if (!f(d, g)) {
                    const y = d;
                    c(d = g, y)
                }
            }
            return t.add(m), () => t.delete(m)
        },
        l = {
            setState: n,
            getState: i,
            subscribe: (c, u, f) => u || f ? s(c, u, f) : (t.add(c), () => t.delete(c)),
            destroy: () => t.clear()
        };
    return e = r(n, i, l), l
}
const u8 = typeof window > "u" || !window.navigator || /ServerSideRendering|^Deno\//.test(window.navigator.userAgent),
    AC = u8 ? N.useEffect : N.useLayoutEffect;

function oD(r) {
    const e = typeof r == "function" ? c8(r) : r,
        t = (n = e.getState, i = Object.is) => {
            const [, s] = N.useReducer(v => v + 1, 0), o = e.getState(), a = N.useRef(o), l = N.useRef(n), c = N.useRef(i), u = N.useRef(!1), f = N.useRef();
            f.current === void 0 && (f.current = n(o));
            let d, m = !1;
            (a.current !== o || l.current !== n || c.current !== i || u.current) && (d = n(o), m = !i(f.current, d)), AC(() => {
                m && (f.current = d), a.current = o, l.current = n, c.current = i, u.current = !1
            });
            const g = N.useRef(o);
            AC(() => {
                const v = () => {
                        try {
                            const A = e.getState(),
                                S = l.current(A);
                            c.current(f.current, S) || (a.current = A, f.current = S, s())
                        } catch {
                            u.current = !0, s()
                        }
                    },
                    _ = e.subscribe(v);
                return e.getState() !== g.current && v(), _
            }, []);
            const y = m ? d : f.current;
            return N.useDebugValue(y), y
        };
    return Object.assign(t, e), t[Symbol.iterator] = function() {
        console.warn("[useStore, api] = create() is deprecated and will be removed in v4");
        const n = [t, e];
        return {
            next() {
                const i = n.length <= 0;
                return {
                    value: n.shift(),
                    done: i
                }
            }
        }
    }, t
}
const f8 = r => typeof r == "object" && typeof r.then == "function",
    Uc = [];

function aD(r, e, t = (n, i) => n === i) {
    if (r === e) return !0;
    if (!r || !e) return !1;
    const n = r.length;
    if (e.length !== n) return !1;
    for (let i = 0; i < n; i++)
        if (!t(r[i], e[i])) return !1;
    return !0
}

function lD(r, e = null, t = !1, n = {}) {
    e === null && (e = [r]);
    for (const s of Uc)
        if (aD(e, s.keys, s.equal)) {
            if (t) return;
            if (Object.prototype.hasOwnProperty.call(s, "error")) throw s.error;
            if (Object.prototype.hasOwnProperty.call(s, "response")) return n.lifespan && n.lifespan > 0 && (s.timeout && clearTimeout(s.timeout), s.timeout = setTimeout(s.remove, n.lifespan)), s.response;
            if (!t) throw s.promise
        }
    const i = {
        keys: e,
        equal: n.equal,
        remove: () => {
            const s = Uc.indexOf(i);
            s !== -1 && Uc.splice(s, 1)
        },
        promise: (f8(r) ? r : r(...e)).then(s => {
            i.response = s, n.lifespan && n.lifespan > 0 && (i.timeout = setTimeout(i.remove, n.lifespan))
        }).catch(s => i.error = s)
    };
    if (Uc.push(i), !t) throw i.promise
}
const cD = (r, e, t) => lD(r, e, !1, t),
    h8 = (r, e, t) => void lD(r, e, !0, t),
    d8 = r => {
        if (r === void 0 || r.length === 0) Uc.splice(0, Uc.length);
        else {
            const e = Uc.find(t => aD(r, t.keys, t.equal));
            e && e.remove()
        }
    };
var uD = {
        exports: {}
    },
    fD = {
        exports: {}
    },
    hD = {};
/**
 * @license React
 * scheduler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
(function(r) {
    function e(Y, Z) {
        var U = Y.length;
        Y.push(Z);
        e: for (; 0 < U;) {
            var j = U - 1 >>> 1,
                te = Y[j];
            if (0 < i(te, Z)) Y[j] = Z, Y[U] = te, U = j;
            else break e
        }
    }

    function t(Y) {
        return Y.length === 0 ? null : Y[0]
    }

    function n(Y) {
        if (Y.length === 0) return null;
        var Z = Y[0],
            U = Y.pop();
        if (U !== Z) {
            Y[0] = U;
            e: for (var j = 0, te = Y.length, he = te >>> 1; j < he;) {
                var $ = 2 * (j + 1) - 1,
                    ne = Y[$],
                    me = $ + 1,
                    ce = Y[me];
                if (0 > i(ne, U)) me < te && 0 > i(ce, ne) ? (Y[j] = ce, Y[me] = U, j = me) : (Y[j] = ne, Y[$] = U, j = $);
                else if (me < te && 0 > i(ce, U)) Y[j] = ce, Y[me] = U, j = me;
                else break e
            }
        }
        return Z
    }

    function i(Y, Z) {
        var U = Y.sortIndex - Z.sortIndex;
        return U !== 0 ? U : Y.id - Z.id
    }
    if (typeof performance == "object" && typeof performance.now == "function") {
        var s = performance;
        r.unstable_now = function() {
            return s.now()
        }
    } else {
        var o = Date,
            a = o.now();
        r.unstable_now = function() {
            return o.now() - a
        }
    }
    var l = [],
        c = [],
        u = 1,
        f = null,
        d = 3,
        m = !1,
        g = !1,
        y = !1,
        v = typeof setTimeout == "function" ? setTimeout : null,
        _ = typeof clearTimeout == "function" ? clearTimeout : null,
        A = typeof setImmediate < "u" ? setImmediate : null;
    typeof navigator < "u" && navigator.scheduling !== void 0 && navigator.scheduling.isInputPending !== void 0 && navigator.scheduling.isInputPending.bind(navigator.scheduling);

    function S(Y) {
        for (var Z = t(c); Z !== null;) {
            if (Z.callback === null) n(c);
            else if (Z.startTime <= Y) n(c), Z.sortIndex = Z.expirationTime, e(l, Z);
            else break;
            Z = t(c)
        }
    }

    function M(Y) {
        if (y = !1, S(Y), !g)
            if (t(l) !== null) g = !0, X(C);
            else {
                var Z = t(c);
                Z !== null && oe(M, Z.startTime - Y)
            }
    }

    function C(Y, Z) {
        g = !1, y && (y = !1, _(P), P = -1), m = !0;
        var U = d;
        try {
            for (S(Z), f = t(l); f !== null && (!(f.expirationTime > Z) || Y && !L());) {
                var j = f.callback;
                if (typeof j == "function") {
                    f.callback = null, d = f.priorityLevel;
                    var te = j(f.expirationTime <= Z);
                    Z = r.unstable_now(), typeof te == "function" ? f.callback = te : f === t(l) && n(l), S(Z)
                } else n(l);
                f = t(l)
            }
            if (f !== null) var he = !0;
            else {
                var $ = t(c);
                $ !== null && oe(M, $.startTime - Z), he = !1
            }
            return he
        } finally {
            f = null, d = U, m = !1
        }
    }
    var E = !1,
        R = null,
        P = -1,
        b = 5,
        T = -1;

    function L() {
        return !(r.unstable_now() - T < b)
    }

    function D() {
        if (R !== null) {
            var Y = r.unstable_now();
            T = Y;
            var Z = !0;
            try {
                Z = R(!0, Y)
            } finally {
                Z ? V() : (E = !1, R = null)
            }
        } else E = !1
    }
    var V;
    if (typeof A == "function") V = function() {
        A(D)
    };
    else if (typeof MessageChannel < "u") {
        var H = new MessageChannel,
            q = H.port2;
        H.port1.onmessage = D, V = function() {
            q.postMessage(null)
        }
    } else V = function() {
        v(D, 0)
    };

    function X(Y) {
        R = Y, E || (E = !0, V())
    }

    function oe(Y, Z) {
        P = v(function() {
            Y(r.unstable_now())
        }, Z)
    }
    r.unstable_IdlePriority = 5, r.unstable_ImmediatePriority = 1, r.unstable_LowPriority = 4, r.unstable_NormalPriority = 3, r.unstable_Profiling = null, r.unstable_UserBlockingPriority = 2, r.unstable_cancelCallback = function(Y) {
        Y.callback = null
    }, r.unstable_continueExecution = function() {
        g || m || (g = !0, X(C))
    }, r.unstable_forceFrameRate = function(Y) {
        0 > Y || 125 < Y ? console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported") : b = 0 < Y ? Math.floor(1e3 / Y) : 5
    }, r.unstable_getCurrentPriorityLevel = function() {
        return d
    }, r.unstable_getFirstCallbackNode = function() {
        return t(l)
    }, r.unstable_next = function(Y) {
        switch (d) {
            case 1:
            case 2:
            case 3:
                var Z = 3;
                break;
            default:
                Z = d
        }
        var U = d;
        d = Z;
        try {
            return Y()
        } finally {
            d = U
        }
    }, r.unstable_pauseExecution = function() {}, r.unstable_requestPaint = function() {}, r.unstable_runWithPriority = function(Y, Z) {
        switch (Y) {
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                break;
            default:
                Y = 3
        }
        var U = d;
        d = Y;
        try {
            return Z()
        } finally {
            d = U
        }
    }, r.unstable_scheduleCallback = function(Y, Z, U) {
        var j = r.unstable_now();
        switch (typeof U == "object" && U !== null ? (U = U.delay, U = typeof U == "number" && 0 < U ? j + U : j) : U = j, Y) {
            case 1:
                var te = -1;
                break;
            case 2:
                te = 250;
                break;
            case 5:
                te = 1073741823;
                break;
            case 4:
                te = 1e4;
                break;
            default:
                te = 5e3
        }
        return te = U + te, Y = {
            id: u++,
            callback: Z,
            priorityLevel: Y,
            startTime: U,
            expirationTime: te,
            sortIndex: -1
        }, U > j ? (Y.sortIndex = U, e(c, Y), t(l) === null && Y === t(c) && (y ? (_(P), P = -1) : y = !0, oe(M, U - j))) : (Y.sortIndex = te, e(l, Y), g || m || (g = !0, X(C))), Y
    }, r.unstable_shouldYield = L, r.unstable_wrapCallback = function(Y) {
        var Z = d;
        return function() {
            var U = d;
            d = Z;
            try {
                return Y.apply(this, arguments)
            } finally {
                d = U
            }
        }
    }
})(hD);
fD.exports = hD;
var SA = fD.exports;
/**
 * @license React
 * react-reconciler.production.min.js
 *
 * Copyright (c) Facebook, Inc. and its affiliates.
 *
 * This source code is licensed under the MIT license found in the
 * LICENSE file in the root directory of this source tree.
 */
var p8 = function(e) {
    var t = {},
        n = N,
        i = SA,
        s = Object.assign;

    function o(h) {
        for (var p = "https://reactjs.org/docs/error-decoder.html?invariant=" + h, x = 1; x < arguments.length; x++) p += "&args[]=" + encodeURIComponent(arguments[x]);
        return "Minified React error #" + h + "; visit " + p + " for the full message or use the non-minified dev environment for full errors and additional helpful warnings."
    }
    var a = n.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,
        l = Symbol.for("react.element"),
        c = Symbol.for("react.portal"),
        u = Symbol.for("react.fragment"),
        f = Symbol.for("react.strict_mode"),
        d = Symbol.for("react.profiler"),
        m = Symbol.for("react.provider"),
        g = Symbol.for("react.context"),
        y = Symbol.for("react.forward_ref"),
        v = Symbol.for("react.suspense"),
        _ = Symbol.for("react.suspense_list"),
        A = Symbol.for("react.memo"),
        S = Symbol.for("react.lazy"),
        M = Symbol.for("react.offscreen"),
        C = Symbol.iterator;

    function E(h) {
        return h === null || typeof h != "object" ? null : (h = C && h[C] || h["@@iterator"], typeof h == "function" ? h : null)
    }

    function R(h) {
        if (h == null) return null;
        if (typeof h == "function") return h.displayName || h.name || null;
        if (typeof h == "string") return h;
        switch (h) {
            case u:
                return "Fragment";
            case c:
                return "Portal";
            case d:
                return "Profiler";
            case f:
                return "StrictMode";
            case v:
                return "Suspense";
            case _:
                return "SuspenseList"
        }
        if (typeof h == "object") switch (h.$$typeof) {
            case g:
                return (h.displayName || "Context") + ".Consumer";
            case m:
                return (h._context.displayName || "Context") + ".Provider";
            case y:
                var p = h.render;
                return h = h.displayName, h || (h = p.displayName || p.name || "", h = h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef"), h;
            case A:
                return p = h.displayName || null, p !== null ? p : R(h.type) || "Memo";
            case S:
                p = h._payload, h = h._init;
                try {
                    return R(h(p))
                } catch {}
        }
        return null
    }

    function P(h) {
        var p = h.type;
        switch (h.tag) {
            case 24:
                return "Cache";
            case 9:
                return (p.displayName || "Context") + ".Consumer";
            case 10:
                return (p._context.displayName || "Context") + ".Provider";
            case 18:
                return "DehydratedFragment";
            case 11:
                return h = p.render, h = h.displayName || h.name || "", p.displayName || (h !== "" ? "ForwardRef(" + h + ")" : "ForwardRef");
            case 7:
                return "Fragment";
            case 5:
                return p;
            case 4:
                return "Portal";
            case 3:
                return "Root";
            case 6:
                return "Text";
            case 16:
                return R(p);
            case 8:
                return p === f ? "StrictMode" : "Mode";
            case 22:
                return "Offscreen";
            case 12:
                return "Profiler";
            case 21:
                return "Scope";
            case 13:
                return "Suspense";
            case 19:
                return "SuspenseList";
            case 25:
                return "TracingMarker";
            case 1:
            case 0:
            case 17:
            case 2:
            case 14:
            case 15:
                if (typeof p == "function") return p.displayName || p.name || null;
                if (typeof p == "string") return p
        }
        return null
    }

    function b(h) {
        var p = h,
            x = h;
        if (h.alternate)
            for (; p.return;) p = p.return;
        else {
            h = p;
            do p = h, p.flags & 4098 && (x = p.return), h = p.return; while (h)
        }
        return p.tag === 3 ? x : null
    }

    function T(h) {
        if (b(h) !== h) throw Error(o(188))
    }

    function L(h) {
        var p = h.alternate;
        if (!p) {
            if (p = b(h), p === null) throw Error(o(188));
            return p !== h ? null : h
        }
        for (var x = h, w = p;;) {
            var I = x.return;
            if (I === null) break;
            var B = I.alternate;
            if (B === null) {
                if (w = I.return, w !== null) {
                    x = w;
                    continue
                }
                break
            }
            if (I.child === B.child) {
                for (B = I.child; B;) {
                    if (B === x) return T(I), h;
                    if (B === w) return T(I), p;
                    B = B.sibling
                }
                throw Error(o(188))
            }
            if (x.return !== w.return) x = I, w = B;
            else {
                for (var ie = !1, Ae = I.child; Ae;) {
                    if (Ae === x) {
                        ie = !0, x = I, w = B;
                        break
                    }
                    if (Ae === w) {
                        ie = !0, w = I, x = B;
                        break
                    }
                    Ae = Ae.sibling
                }
                if (!ie) {
                    for (Ae = B.child; Ae;) {
                        if (Ae === x) {
                            ie = !0, x = B, w = I;
                            break
                        }
                        if (Ae === w) {
                            ie = !0, w = B, x = I;
                            break
                        }
                        Ae = Ae.sibling
                    }
                    if (!ie) throw Error(o(189))
                }
            }
            if (x.alternate !== w) throw Error(o(190))
        }
        if (x.tag !== 3) throw Error(o(188));
        return x.stateNode.current === x ? h : p
    }

    function D(h) {
        return h = L(h), h !== null ? V(h) : null
    }

    function V(h) {
        if (h.tag === 5 || h.tag === 6) return h;
        for (h = h.child; h !== null;) {
            var p = V(h);
            if (p !== null) return p;
            h = h.sibling
        }
        return null
    }

    function H(h) {
        if (h.tag === 5 || h.tag === 6) return h;
        for (h = h.child; h !== null;) {
            if (h.tag !== 4) {
                var p = H(h);
                if (p !== null) return p
            }
            h = h.sibling
        }
        return null
    }
    var q = Array.isArray,
        X = e.getPublicInstance,
        oe = e.getRootHostContext,
        Y = e.getChildHostContext,
        Z = e.prepareForCommit,
        U = e.resetAfterCommit,
        j = e.createInstance,
        te = e.appendInitialChild,
        he = e.finalizeInitialChildren,
        $ = e.prepareUpdate,
        ne = e.shouldSetTextContent,
        me = e.createTextInstance,
        ce = e.scheduleTimeout,
        _e = e.cancelTimeout,
        Oe = e.noTimeout,
        ke = e.isPrimaryRenderer,
        Ee = e.supportsMutation,
        pe = e.supportsPersistence,
        xe = e.supportsHydration,
        J = e.getInstanceFromNode,
        De = e.preparePortalMount,
        Ce = e.getCurrentEventPriority,
        se = e.detachDeletedInstance,
        Se = e.supportsMicrotasks,
        Xe = e.scheduleMicrotask,
        Le = e.supportsTestSelectors,
        k = e.findFiberRoot,
        z = e.getBoundingRect,
        ue = e.getTextContent,
        ye = e.isHiddenSubtree,
        ge = e.matchAccessibilityRole,
        Re = e.setFocusIfFocusable,
        Be = e.setupIntersectionObserver,
        Fe = e.appendChild,
        Ne = e.appendChildToContainer,
        ot = e.commitTextUpdate,
        je = e.commitMount,
        Ze = e.commitUpdate,
        it = e.insertBefore,
        $e = e.insertInContainerBefore,
        We = e.removeChild,
        yt = e.removeChildFromContainer,
        at = e.resetTextContent,
        Mt = e.hideInstance,
        ae = e.hideTextInstance,
        ve = e.unhideInstance,
        we = e.unhideTextInstance,
        He = e.clearContainer,
        Je = e.cloneInstance,
        Ye = e.createContainerChildSet,
        mt = e.appendChildToContainerChildSet,
        Pt = e.finalizeContainerChildren,
        St = e.replaceContainerChildren,
        tt = e.cloneHiddenInstance,
        ut = e.cloneHiddenTextInstance,
        Rt = e.canHydrateInstance,
        nt = e.canHydrateTextInstance,
        It = e.canHydrateSuspenseInstance,
        pt = e.isSuspenseInstancePending,
        Ct = e.isSuspenseInstanceFallback,
        ln = e.registerSuspenseInstanceRetry,
        Dt = e.getNextHydratableSibling,
        gt = e.getFirstHydratableChild,
        $t = e.getFirstHydratableChildWithinContainer,
        rn = e.getFirstHydratableChildWithinSuspenseInstance,
        O = e.hydrateInstance,
        W = e.hydrateTextInstance,
        de = e.hydrateSuspenseInstance,
        be = e.getNextHydratableInstanceAfterSuspenseInstance,
        Pe = e.commitHydratedContainer,
        F = e.commitHydratedSuspenseInstance,
        Q = e.clearSuspenseBoundary,
        re = e.clearSuspenseBoundaryFromContainer,
        le = e.shouldDeleteUnhydratedTailInstances,
        ee = e.didNotMatchHydratedContainerTextInstance,
        Te = e.didNotMatchHydratedTextInstance,
        fe;

    function Ke(h) {
        if (fe === void 0) try {
            throw Error()
        } catch (x) {
            var p = x.stack.trim().match(/\n( *(at )?)/);
            fe = p && p[1] || ""
        }
        return `
` + fe + h
    }
    var Ge = !1;

    function qe(h, p) {
        if (!h || Ge) return "";
        Ge = !0;
        var x = Error.prepareStackTrace;
        Error.prepareStackTrace = void 0;
        try {
            if (p)
                if (p = function() {
                        throw Error()
                    }, Object.defineProperty(p.prototype, "props", {
                        set: function() {
                            throw Error()
                        }
                    }), typeof Reflect == "object" && Reflect.construct) {
                    try {
                        Reflect.construct(p, [])
                    } catch (lt) {
                        var w = lt
                    }
                    Reflect.construct(h, [], p)
                } else {
                    try {
                        p.call()
                    } catch (lt) {
                        w = lt
                    }
                    h.call(p.prototype)
                }
            else {
                try {
                    throw Error()
                } catch (lt) {
                    w = lt
                }
                h()
            }
        } catch (lt) {
            if (lt && w && typeof lt.stack == "string") {
                for (var I = lt.stack.split(`
`), B = w.stack.split(`
`), ie = I.length - 1, Ae = B.length - 1; 1 <= ie && 0 <= Ae && I[ie] !== B[Ae];) Ae--;
                for (; 1 <= ie && 0 <= Ae; ie--, Ae--)
                    if (I[ie] !== B[Ae]) {
                        if (ie !== 1 || Ae !== 1)
                            do
                                if (ie--, Ae--, 0 > Ae || I[ie] !== B[Ae]) {
                                    var Ve = `
` + I[ie].replace(" at new ", " at ");
                                    return h.displayName && Ve.includes("<anonymous>") && (Ve = Ve.replace("<anonymous>", h.displayName)), Ve
                                }
                        while (1 <= ie && 0 <= Ae);
                        break
                    }
            }
        } finally {
            Ge = !1, Error.prepareStackTrace = x
        }
        return (h = h ? h.displayName || h.name : "") ? Ke(h) : ""
    }
    var st = Object.prototype.hasOwnProperty,
        Qe = [],
        ft = -1;

    function _t(h) {
        return {
            current: h
        }
    }

    function ht(h) {
        0 > ft || (h.current = Qe[ft], Qe[ft] = null, ft--)
    }

    function wt(h, p) {
        ft++, Qe[ft] = h.current, h.current = p
    }
    var At = {},
        ct = _t(At),
        Ut = _t(!1),
        Bt = At;

    function Mn(h, p) {
        var x = h.type.contextTypes;
        if (!x) return At;
        var w = h.stateNode;
        if (w && w.__reactInternalMemoizedUnmaskedChildContext === p) return w.__reactInternalMemoizedMaskedChildContext;
        var I = {},
            B;
        for (B in x) I[B] = p[B];
        return w && (h = h.stateNode, h.__reactInternalMemoizedUnmaskedChildContext = p, h.__reactInternalMemoizedMaskedChildContext = I), I
    }

    function In(h) {
        return h = h.childContextTypes, h != null
    }

    function cn() {
        ht(Ut), ht(ct)
    }

    function en(h, p, x) {
        if (ct.current !== At) throw Error(o(168));
        wt(ct, p), wt(Ut, x)
    }

    function Gt(h, p, x) {
        var w = h.stateNode;
        if (p = p.childContextTypes, typeof w.getChildContext != "function") return x;
        w = w.getChildContext();
        for (var I in w)
            if (!(I in p)) throw Error(o(108, P(h) || "Unknown", I));
        return s({}, x, w)
    }

    function Wt(h) {
        return h = (h = h.stateNode) && h.__reactInternalMemoizedMergedChildContext || At, Bt = ct.current, wt(ct, h), wt(Ut, Ut.current), !0
    }

    function Ht(h, p, x) {
        var w = h.stateNode;
        if (!w) throw Error(o(169));
        x ? (h = Gt(h, p, Bt), w.__reactInternalMemoizedMergedChildContext = h, ht(Ut), ht(ct), wt(ct, h)) : ht(Ut), wt(Ut, x)
    }
    var sn = Math.clz32 ? Math.clz32 : tr,
        Qn = Math.log,
        Dn = Math.LN2;

    function tr(h) {
        return h >>>= 0, h === 0 ? 32 : 31 - (Qn(h) / Dn | 0) | 0
    }
    var Go = 64,
        Ho = 4194304;

    function Vo(h) {
        switch (h & -h) {
            case 1:
                return 1;
            case 2:
                return 2;
            case 4:
                return 4;
            case 8:
                return 8;
            case 16:
                return 16;
            case 32:
                return 32;
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return h & 4194240;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return h & 130023424;
            case 134217728:
                return 134217728;
            case 268435456:
                return 268435456;
            case 536870912:
                return 536870912;
            case 1073741824:
                return 1073741824;
            default:
                return h
        }
    }

    function zl(h, p) {
        var x = h.pendingLanes;
        if (x === 0) return 0;
        var w = 0,
            I = h.suspendedLanes,
            B = h.pingedLanes,
            ie = x & 268435455;
        if (ie !== 0) {
            var Ae = ie & ~I;
            Ae !== 0 ? w = Vo(Ae) : (B &= ie, B !== 0 && (w = Vo(B)))
        } else ie = x & ~I, ie !== 0 ? w = Vo(ie) : B !== 0 && (w = Vo(B));
        if (w === 0) return 0;
        if (p !== 0 && p !== w && !(p & I) && (I = w & -w, B = p & -p, I >= B || I === 16 && (B & 4194240) !== 0)) return p;
        if (w & 4 && (w |= x & 16), p = h.entangledLanes, p !== 0)
            for (h = h.entanglements, p &= w; 0 < p;) x = 31 - sn(p), I = 1 << x, w |= h[x], p &= ~I;
        return w
    }

    function dm(h, p) {
        switch (h) {
            case 1:
            case 2:
            case 4:
                return p + 250;
            case 8:
            case 16:
            case 32:
            case 64:
            case 128:
            case 256:
            case 512:
            case 1024:
            case 2048:
            case 4096:
            case 8192:
            case 16384:
            case 32768:
            case 65536:
            case 131072:
            case 262144:
            case 524288:
            case 1048576:
            case 2097152:
                return p + 5e3;
            case 4194304:
            case 8388608:
            case 16777216:
            case 33554432:
            case 67108864:
                return -1;
            case 134217728:
            case 268435456:
            case 536870912:
            case 1073741824:
                return -1;
            default:
                return -1
        }
    }

    function yh(h, p) {
        for (var x = h.suspendedLanes, w = h.pingedLanes, I = h.expirationTimes, B = h.pendingLanes; 0 < B;) {
            var ie = 31 - sn(B),
                Ae = 1 << ie,
                Ve = I[ie];
            Ve === -1 ? (!(Ae & x) || Ae & w) && (I[ie] = dm(Ae, p)) : Ve <= p && (h.expiredLanes |= Ae), B &= ~Ae
        }
    }

    function Wo(h) {
        return h = h.pendingLanes & -1073741825, h !== 0 ? h : h & 1073741824 ? 1073741824 : 0
    }

    function Au(h) {
        for (var p = [], x = 0; 31 > x; x++) p.push(h);
        return p
    }

    function yo(h, p, x) {
        h.pendingLanes |= p, p !== 536870912 && (h.suspendedLanes = 0, h.pingedLanes = 0), h = h.eventTimes, p = 31 - sn(p), h[p] = x
    }

    function Ra(h, p) {
        var x = h.pendingLanes & ~p;
        h.pendingLanes = p, h.suspendedLanes = 0, h.pingedLanes = 0, h.expiredLanes &= p, h.mutableReadLanes &= p, h.entangledLanes &= p, p = h.entanglements;
        var w = h.eventTimes;
        for (h = h.expirationTimes; 0 < x;) {
            var I = 31 - sn(x),
                B = 1 << I;
            p[I] = 0, w[I] = -1, h[I] = -1, x &= ~B
        }
    }

    function _o(h, p) {
        var x = h.entangledLanes |= p;
        for (h = h.entanglements; x;) {
            var w = 31 - sn(x),
                I = 1 << w;
            I & p | h[w] & p && (h[w] |= p), x &= ~I
        }
    }
    var un = 0;

    function _h(h) {
        return h &= -h, 1 < h ? 4 < h ? h & 268435455 ? 16 : 536870912 : 4 : 1
    }
    var jo = i.unstable_scheduleCallback,
        Su = i.unstable_cancelCallback,
        xh = i.unstable_shouldYield,
        pm = i.unstable_requestPaint,
        $n = i.unstable_now,
        Gl = i.unstable_ImmediatePriority,
        mm = i.unstable_UserBlockingPriority,
        _r = i.unstable_NormalPriority,
        Ah = i.unstable_IdlePriority,
        Hl = null,
        Qr = null;

    function Sh(h) {
        if (Qr && typeof Qr.onCommitFiberRoot == "function") try {
            Qr.onCommitFiberRoot(Hl, h, void 0, (h.current.flags & 128) === 128)
        } catch {}
    }

    function gm(h, p) {
        return h === p && (h !== 0 || 1 / h === 1 / p) || h !== h && p !== p
    }
    var $r = typeof Object.is == "function" ? Object.is : gm,
        xr = null,
        xo = !1,
        Cs = !1;

    function Mh(h) {
        xr === null ? xr = [h] : xr.push(h)
    }

    function wh(h) {
        xo = !0, Mh(h)
    }

    function kr() {
        if (!Cs && xr !== null) {
            Cs = !0;
            var h = 0,
                p = un;
            try {
                var x = xr;
                for (un = 1; h < x.length; h++) {
                    var w = x[h];
                    do w = w(!0); while (w !== null)
                }
                xr = null, xo = !1
            } catch (I) {
                throw xr !== null && (xr = xr.slice(h + 1)), jo(Gl, kr), I
            } finally {
                un = p, Cs = !1
            }
        }
        return null
    }
    var Vl = a.ReactCurrentBatchConfig;

    function Wl(h, p) {
        if ($r(h, p)) return !0;
        if (typeof h != "object" || h === null || typeof p != "object" || p === null) return !1;
        var x = Object.keys(h),
            w = Object.keys(p);
        if (x.length !== w.length) return !1;
        for (w = 0; w < x.length; w++) {
            var I = x[w];
            if (!st.call(p, I) || !$r(h[I], p[I])) return !1
        }
        return !0
    }

    function jl(h) {
        switch (h.tag) {
            case 5:
                return Ke(h.type);
            case 16:
                return Ke("Lazy");
            case 13:
                return Ke("Suspense");
            case 19:
                return Ke("SuspenseList");
            case 0:
            case 2:
            case 15:
                return h = qe(h.type, !1), h;
            case 11:
                return h = qe(h.type.render, !1), h;
            case 1:
                return h = qe(h.type, !0), h;
            default:
                return ""
        }
    }

    function Ar(h, p) {
        if (h && h.defaultProps) {
            p = s({}, p), h = h.defaultProps;
            for (var x in h) p[x] === void 0 && (p[x] = h[x]);
            return p
        }
        return p
    }
    var Ui = _t(null),
        Mu = null,
        eo = null,
        Pa = null;

    function wu() {
        Pa = eo = Mu = null
    }

    function vm(h, p, x) {
        ke ? (wt(Ui, p._currentValue), p._currentValue = x) : (wt(Ui, p._currentValue2), p._currentValue2 = x)
    }

    function Oi(h) {
        var p = Ui.current;
        ht(Ui), ke ? h._currentValue = p : h._currentValue2 = p
    }

    function Sr(h, p, x) {
        for (; h !== null;) {
            var w = h.alternate;
            if ((h.childLanes & p) !== p ? (h.childLanes |= p, w !== null && (w.childLanes |= p)) : w !== null && (w.childLanes & p) !== p && (w.childLanes |= p), h === x) break;
            h = h.return
        }
    }

    function gi(h, p) {
        Mu = h, Pa = eo = null, h = h.dependencies, h !== null && h.firstContext !== null && (h.lanes & p && (is = !0), h.firstContext = null)
    }

    function vi(h) {
        var p = ke ? h._currentValue : h._currentValue2;
        if (Pa !== h)
            if (h = {
                    context: h,
                    memoizedValue: p,
                    next: null
                }, eo === null) {
                if (Mu === null) throw Error(o(308));
                eo = h, Mu.dependencies = {
                    lanes: 0,
                    firstContext: h
                }
            } else eo = eo.next = h;
        return p
    }
    var es = null,
        Ia = !1;

    function Ky(h) {
        h.updateQueue = {
            baseState: h.memoizedState,
            firstBaseUpdate: null,
            lastBaseUpdate: null,
            shared: {
                pending: null,
                interleaved: null,
                lanes: 0
            },
            effects: null
        }
    }

    function Cw(h, p) {
        h = h.updateQueue, p.updateQueue === h && (p.updateQueue = {
            baseState: h.baseState,
            firstBaseUpdate: h.firstBaseUpdate,
            lastBaseUpdate: h.lastBaseUpdate,
            shared: h.shared,
            effects: h.effects
        })
    }

    function Xo(h, p) {
        return {
            eventTime: h,
            lane: p,
            tag: 0,
            payload: null,
            callback: null,
            next: null
        }
    }

    function Ba(h, p) {
        var x = h.updateQueue;
        x !== null && (x = x.shared, wi !== null && h.mode & 1 && !(on & 2) ? (h = x.interleaved, h === null ? (p.next = p, es === null ? es = [x] : es.push(x)) : (p.next = h.next, h.next = p), x.interleaved = p) : (h = x.pending, h === null ? p.next = p : (p.next = h.next, h.next = p), x.pending = p))
    }

    function ym(h, p, x) {
        if (p = p.updateQueue, p !== null && (p = p.shared, (x & 4194240) !== 0)) {
            var w = p.lanes;
            w &= h.pendingLanes, x |= w, p.lanes = x, _o(h, x)
        }
    }

    function Rw(h, p) {
        var x = h.updateQueue,
            w = h.alternate;
        if (w !== null && (w = w.updateQueue, x === w)) {
            var I = null,
                B = null;
            if (x = x.firstBaseUpdate, x !== null) {
                do {
                    var ie = {
                        eventTime: x.eventTime,
                        lane: x.lane,
                        tag: x.tag,
                        payload: x.payload,
                        callback: x.callback,
                        next: null
                    };
                    B === null ? I = B = ie : B = B.next = ie, x = x.next
                } while (x !== null);
                B === null ? I = B = p : B = B.next = p
            } else I = B = p;
            x = {
                baseState: w.baseState,
                firstBaseUpdate: I,
                lastBaseUpdate: B,
                shared: w.shared,
                effects: w.effects
            }, h.updateQueue = x;
            return
        }
        h = x.lastBaseUpdate, h === null ? x.firstBaseUpdate = p : h.next = p, x.lastBaseUpdate = p
    }

    function _m(h, p, x, w) {
        var I = h.updateQueue;
        Ia = !1;
        var B = I.firstBaseUpdate,
            ie = I.lastBaseUpdate,
            Ae = I.shared.pending;
        if (Ae !== null) {
            I.shared.pending = null;
            var Ve = Ae,
                lt = Ve.next;
            Ve.next = null, ie === null ? B = lt : ie.next = lt, ie = Ve;
            var bt = h.alternate;
            bt !== null && (bt = bt.updateQueue, Ae = bt.lastBaseUpdate, Ae !== ie && (Ae === null ? bt.firstBaseUpdate = lt : Ae.next = lt, bt.lastBaseUpdate = Ve))
        }
        if (B !== null) {
            var Xt = I.baseState;
            ie = 0, bt = lt = Ve = null, Ae = B;
            do {
                var Nt = Ae.lane,
                    Un = Ae.eventTime;
                if ((w & Nt) === Nt) {
                    bt !== null && (bt = bt.next = {
                        eventTime: Un,
                        lane: 0,
                        tag: Ae.tag,
                        payload: Ae.payload,
                        callback: Ae.callback,
                        next: null
                    });
                    e: {
                        var Ft = h,
                            sr = Ae;
                        switch (Nt = p, Un = x, sr.tag) {
                            case 1:
                                if (Ft = sr.payload, typeof Ft == "function") {
                                    Xt = Ft.call(Un, Xt, Nt);
                                    break e
                                }
                                Xt = Ft;
                                break e;
                            case 3:
                                Ft.flags = Ft.flags & -65537 | 128;
                            case 0:
                                if (Ft = sr.payload, Nt = typeof Ft == "function" ? Ft.call(Un, Xt, Nt) : Ft, Nt == null) break e;
                                Xt = s({}, Xt, Nt);
                                break e;
                            case 2:
                                Ia = !0
                        }
                    }
                    Ae.callback !== null && Ae.lane !== 0 && (h.flags |= 64, Nt = I.effects, Nt === null ? I.effects = [Ae] : Nt.push(Ae))
                } else Un = {
                    eventTime: Un,
                    lane: Nt,
                    tag: Ae.tag,
                    payload: Ae.payload,
                    callback: Ae.callback,
                    next: null
                }, bt === null ? (lt = bt = Un, Ve = Xt) : bt = bt.next = Un, ie |= Nt;
                if (Ae = Ae.next, Ae === null) {
                    if (Ae = I.shared.pending, Ae === null) break;
                    Nt = Ae, Ae = Nt.next, Nt.next = null, I.lastBaseUpdate = Nt, I.shared.pending = null
                }
            } while (!0);
            if (bt === null && (Ve = Xt), I.baseState = Ve, I.firstBaseUpdate = lt, I.lastBaseUpdate = bt, p = I.shared.interleaved, p !== null) {
                I = p;
                do ie |= I.lane, I = I.next; while (I !== p)
            } else B === null && (I.shared.lanes = 0);
            Du |= ie, h.lanes = ie, h.memoizedState = Xt
        }
    }

    function Pw(h, p, x) {
        if (h = p.effects, p.effects = null, h !== null)
            for (p = 0; p < h.length; p++) {
                var w = h[p],
                    I = w.callback;
                if (I !== null) {
                    if (w.callback = null, w = x, typeof I != "function") throw Error(o(191, I));
                    I.call(w)
                }
            }
    }
    var Iw = new n.Component().refs;

    function qy(h, p, x, w) {
        p = h.memoizedState, x = x(w, p), x = x == null ? p : s({}, p, x), h.memoizedState = x, h.lanes === 0 && (h.updateQueue.baseState = x)
    }
    var xm = {
        isMounted: function(h) {
            return (h = h._reactInternals) ? b(h) === h : !1
        },
        enqueueSetState: function(h, p, x) {
            h = h._reactInternals;
            var w = wr(),
                I = Fa(h),
                B = Xo(w, I);
            B.payload = p, x != null && (B.callback = x), Ba(h, B), p = Ds(h, I, w), p !== null && ym(p, h, I)
        },
        enqueueReplaceState: function(h, p, x) {
            h = h._reactInternals;
            var w = wr(),
                I = Fa(h),
                B = Xo(w, I);
            B.tag = 1, B.payload = p, x != null && (B.callback = x), Ba(h, B), p = Ds(h, I, w), p !== null && ym(p, h, I)
        },
        enqueueForceUpdate: function(h, p) {
            h = h._reactInternals;
            var x = wr(),
                w = Fa(h),
                I = Xo(x, w);
            I.tag = 2, p != null && (I.callback = p), Ba(h, I), p = Ds(h, w, x), p !== null && ym(p, h, w)
        }
    };

    function Bw(h, p, x, w, I, B, ie) {
        return h = h.stateNode, typeof h.shouldComponentUpdate == "function" ? h.shouldComponentUpdate(w, B, ie) : p.prototype && p.prototype.isPureReactComponent ? !Wl(x, w) || !Wl(I, B) : !0
    }

    function Dw(h, p, x) {
        var w = !1,
            I = At,
            B = p.contextType;
        return typeof B == "object" && B !== null ? B = vi(B) : (I = In(p) ? Bt : ct.current, w = p.contextTypes, B = (w = w != null) ? Mn(h, I) : At), p = new p(x, B), h.memoizedState = p.state !== null && p.state !== void 0 ? p.state : null, p.updater = xm, h.stateNode = p, p._reactInternals = h, w && (h = h.stateNode, h.__reactInternalMemoizedUnmaskedChildContext = I, h.__reactInternalMemoizedMaskedChildContext = B), p
    }

    function Lw(h, p, x, w) {
        h = p.state, typeof p.componentWillReceiveProps == "function" && p.componentWillReceiveProps(x, w), typeof p.UNSAFE_componentWillReceiveProps == "function" && p.UNSAFE_componentWillReceiveProps(x, w), p.state !== h && xm.enqueueReplaceState(p, p.state, null)
    }

    function Zy(h, p, x, w) {
        var I = h.stateNode;
        I.props = x, I.state = h.memoizedState, I.refs = Iw, Ky(h);
        var B = p.contextType;
        typeof B == "object" && B !== null ? I.context = vi(B) : (B = In(p) ? Bt : ct.current, I.context = Mn(h, B)), I.state = h.memoizedState, B = p.getDerivedStateFromProps, typeof B == "function" && (qy(h, p, B, x), I.state = h.memoizedState), typeof p.getDerivedStateFromProps == "function" || typeof I.getSnapshotBeforeUpdate == "function" || typeof I.UNSAFE_componentWillMount != "function" && typeof I.componentWillMount != "function" || (p = I.state, typeof I.componentWillMount == "function" && I.componentWillMount(), typeof I.UNSAFE_componentWillMount == "function" && I.UNSAFE_componentWillMount(), p !== I.state && xm.enqueueReplaceState(I, I.state, null), _m(h, x, I, w), I.state = h.memoizedState), typeof I.componentDidMount == "function" && (h.flags |= 4194308)
    }
    var bu = [],
        Tu = 0,
        Am = null,
        Sm = 0,
        Rs = [],
        Ps = 0,
        Xl = null,
        Yo = 1,
        Jo = "";

    function Yl(h, p) {
        bu[Tu++] = Sm, bu[Tu++] = Am, Am = h, Sm = p
    }

    function Fw(h, p, x) {
        Rs[Ps++] = Yo, Rs[Ps++] = Jo, Rs[Ps++] = Xl, Xl = h;
        var w = Yo;
        h = Jo;
        var I = 32 - sn(w) - 1;
        w &= ~(1 << I), x += 1;
        var B = 32 - sn(p) + I;
        if (30 < B) {
            var ie = I - I % 5;
            B = (w & (1 << ie) - 1).toString(32), w >>= ie, I -= ie, Yo = 1 << 32 - sn(p) + I | x << I | w, Jo = B + h
        } else Yo = 1 << B | x << I | w, Jo = h
    }

    function Qy(h) {
        h.return !== null && (Yl(h, 1), Fw(h, 1, 0))
    }

    function $y(h) {
        for (; h === Am;) Am = bu[--Tu], bu[Tu] = null, Sm = bu[--Tu], bu[Tu] = null;
        for (; h === Xl;) Xl = Rs[--Ps], Rs[Ps] = null, Jo = Rs[--Ps], Rs[Ps] = null, Yo = Rs[--Ps], Rs[Ps] = null
    }
    var ts = null,
        ns = null,
        Yn = !1,
        bh = !1,
        to = null;

    function Uw(h, p) {
        var x = Ls(5, null, null, 0);
        x.elementType = "DELETED", x.stateNode = p, x.return = h, p = h.deletions, p === null ? (h.deletions = [x], h.flags |= 16) : p.push(x)
    }

    function Ow(h, p) {
        switch (h.tag) {
            case 5:
                return p = Rt(p, h.type, h.pendingProps), p !== null ? (h.stateNode = p, ts = h, ns = gt(p), !0) : !1;
            case 6:
                return p = nt(p, h.pendingProps), p !== null ? (h.stateNode = p, ts = h, ns = null, !0) : !1;
            case 13:
                if (p = It(p), p !== null) {
                    var x = Xl !== null ? {
                        id: Yo,
                        overflow: Jo
                    } : null;
                    return h.memoizedState = {
                        dehydrated: p,
                        treeContext: x,
                        retryLane: 1073741824
                    }, x = Ls(18, null, null, 0), x.stateNode = p, x.return = h, h.child = x, ts = h, ns = null, !0
                }
                return !1;
            default:
                return !1
        }
    }

    function e_(h) {
        return (h.mode & 1) !== 0 && (h.flags & 128) === 0
    }

    function t_(h) {
        if (Yn) {
            var p = ns;
            if (p) {
                var x = p;
                if (!Ow(h, p)) {
                    if (e_(h)) throw Error(o(418));
                    p = Dt(x);
                    var w = ts;
                    p && Ow(h, p) ? Uw(w, x) : (h.flags = h.flags & -4097 | 2, Yn = !1, ts = h)
                }
            } else {
                if (e_(h)) throw Error(o(418));
                h.flags = h.flags & -4097 | 2, Yn = !1, ts = h
            }
        }
    }

    function Nw(h) {
        for (h = h.return; h !== null && h.tag !== 5 && h.tag !== 3 && h.tag !== 13;) h = h.return;
        ts = h
    }

    function Th(h) {
        if (!xe || h !== ts) return !1;
        if (!Yn) return Nw(h), Yn = !0, !1;
        if (h.tag !== 3 && (h.tag !== 5 || le(h.type) && !ne(h.type, h.memoizedProps))) {
            var p = ns;
            if (p) {
                if (e_(h)) {
                    for (h = ns; h;) h = Dt(h);
                    throw Error(o(418))
                }
                for (; p;) Uw(h, p), p = Dt(p)
            }
        }
        if (Nw(h), h.tag === 13) {
            if (!xe) throw Error(o(316));
            if (h = h.memoizedState, h = h !== null ? h.dehydrated : null, !h) throw Error(o(317));
            ns = be(h)
        } else ns = ts ? Dt(h.stateNode) : null;
        return !0
    }

    function Eu() {
        xe && (ns = ts = null, bh = Yn = !1)
    }

    function n_(h) {
        to === null ? to = [h] : to.push(h)
    }

    function Eh(h, p, x) {
        if (h = x.ref, h !== null && typeof h != "function" && typeof h != "object") {
            if (x._owner) {
                if (x = x._owner, x) {
                    if (x.tag !== 1) throw Error(o(309));
                    var w = x.stateNode
                }
                if (!w) throw Error(o(147, h));
                var I = w,
                    B = "" + h;
                return p !== null && p.ref !== null && typeof p.ref == "function" && p.ref._stringRef === B ? p.ref : (p = function(ie) {
                    var Ae = I.refs;
                    Ae === Iw && (Ae = I.refs = {}), ie === null ? delete Ae[B] : Ae[B] = ie
                }, p._stringRef = B, p)
            }
            if (typeof h != "string") throw Error(o(284));
            if (!x._owner) throw Error(o(290, h))
        }
        return h
    }

    function Mm(h, p) {
        throw h = Object.prototype.toString.call(p), Error(o(31, h === "[object Object]" ? "object with keys {" + Object.keys(p).join(", ") + "}" : h))
    }

    function kw(h) {
        var p = h._init;
        return p(h._payload)
    }

    function zw(h) {
        function p(Ie, Me) {
            if (h) {
                var ze = Ie.deletions;
                ze === null ? (Ie.deletions = [Me], Ie.flags |= 16) : ze.push(Me)
            }
        }

        function x(Ie, Me) {
            if (!h) return null;
            for (; Me !== null;) p(Ie, Me), Me = Me.sibling;
            return null
        }

        function w(Ie, Me) {
            for (Ie = new Map; Me !== null;) Me.key !== null ? Ie.set(Me.key, Me) : Ie.set(Me.index, Me), Me = Me.sibling;
            return Ie
        }

        function I(Ie, Me) {
            return Ie = Oa(Ie, Me), Ie.index = 0, Ie.sibling = null, Ie
        }

        function B(Ie, Me, ze) {
            return Ie.index = ze, h ? (ze = Ie.alternate, ze !== null ? (ze = ze.index, ze < Me ? (Ie.flags |= 2, Me) : ze) : (Ie.flags |= 2, Me)) : (Ie.flags |= 1048576, Me)
        }

        function ie(Ie) {
            return h && Ie.alternate === null && (Ie.flags |= 2), Ie
        }

        function Ae(Ie, Me, ze, xt) {
            return Me === null || Me.tag !== 6 ? (Me = k_(ze, Ie.mode, xt), Me.return = Ie, Me) : (Me = I(Me, ze), Me.return = Ie, Me)
        }

        function Ve(Ie, Me, ze, xt) {
            var Lt = ze.type;
            return Lt === u ? bt(Ie, Me, ze.props.children, xt, ze.key) : Me !== null && (Me.elementType === Lt || typeof Lt == "object" && Lt !== null && Lt.$$typeof === S && kw(Lt) === Me.type) ? (xt = I(Me, ze.props), xt.ref = Eh(Ie, Me, ze), xt.return = Ie, xt) : (xt = eg(ze.type, ze.key, ze.props, null, Ie.mode, xt), xt.ref = Eh(Ie, Me, ze), xt.return = Ie, xt)
        }

        function lt(Ie, Me, ze, xt) {
            return Me === null || Me.tag !== 4 || Me.stateNode.containerInfo !== ze.containerInfo || Me.stateNode.implementation !== ze.implementation ? (Me = z_(ze, Ie.mode, xt), Me.return = Ie, Me) : (Me = I(Me, ze.children || []), Me.return = Ie, Me)
        }

        function bt(Ie, Me, ze, xt, Lt) {
            return Me === null || Me.tag !== 7 ? (Me = ec(ze, Ie.mode, xt, Lt), Me.return = Ie, Me) : (Me = I(Me, ze), Me.return = Ie, Me)
        }

        function Xt(Ie, Me, ze) {
            if (typeof Me == "string" && Me !== "" || typeof Me == "number") return Me = k_("" + Me, Ie.mode, ze), Me.return = Ie, Me;
            if (typeof Me == "object" && Me !== null) {
                switch (Me.$$typeof) {
                    case l:
                        return ze = eg(Me.type, Me.key, Me.props, null, Ie.mode, ze), ze.ref = Eh(Ie, null, Me), ze.return = Ie, ze;
                    case c:
                        return Me = z_(Me, Ie.mode, ze), Me.return = Ie, Me;
                    case S:
                        var xt = Me._init;
                        return Xt(Ie, xt(Me._payload), ze)
                }
                if (q(Me) || E(Me)) return Me = ec(Me, Ie.mode, ze, null), Me.return = Ie, Me;
                Mm(Ie, Me)
            }
            return null
        }

        function Nt(Ie, Me, ze, xt) {
            var Lt = Me !== null ? Me.key : null;
            if (typeof ze == "string" && ze !== "" || typeof ze == "number") return Lt !== null ? null : Ae(Ie, Me, "" + ze, xt);
            if (typeof ze == "object" && ze !== null) {
                switch (ze.$$typeof) {
                    case l:
                        return ze.key === Lt ? Ve(Ie, Me, ze, xt) : null;
                    case c:
                        return ze.key === Lt ? lt(Ie, Me, ze, xt) : null;
                    case S:
                        return Lt = ze._init, Nt(Ie, Me, Lt(ze._payload), xt)
                }
                if (q(ze) || E(ze)) return Lt !== null ? null : bt(Ie, Me, ze, xt, null);
                Mm(Ie, ze)
            }
            return null
        }

        function Un(Ie, Me, ze, xt, Lt) {
            if (typeof xt == "string" && xt !== "" || typeof xt == "number") return Ie = Ie.get(ze) || null, Ae(Me, Ie, "" + xt, Lt);
            if (typeof xt == "object" && xt !== null) {
                switch (xt.$$typeof) {
                    case l:
                        return Ie = Ie.get(xt.key === null ? ze : xt.key) || null, Ve(Me, Ie, xt, Lt);
                    case c:
                        return Ie = Ie.get(xt.key === null ? ze : xt.key) || null, lt(Me, Ie, xt, Lt);
                    case S:
                        var tn = xt._init;
                        return Un(Ie, Me, ze, tn(xt._payload), Lt)
                }
                if (q(xt) || E(xt)) return Ie = Ie.get(ze) || null, bt(Me, Ie, xt, Lt, null);
                Mm(Me, xt)
            }
            return null
        }

        function Ft(Ie, Me, ze, xt) {
            for (var Lt = null, tn = null, Yt = Me, Cn = Me = 0, ki = null; Yt !== null && Cn < ze.length; Cn++) {
                Yt.index > Cn ? (ki = Yt, Yt = null) : ki = Yt.sibling;
                var Rn = Nt(Ie, Yt, ze[Cn], xt);
                if (Rn === null) {
                    Yt === null && (Yt = ki);
                    break
                }
                h && Yt && Rn.alternate === null && p(Ie, Yt), Me = B(Rn, Me, Cn), tn === null ? Lt = Rn : tn.sibling = Rn, tn = Rn, Yt = ki
            }
            if (Cn === ze.length) return x(Ie, Yt), Yn && Yl(Ie, Cn), Lt;
            if (Yt === null) {
                for (; Cn < ze.length; Cn++) Yt = Xt(Ie, ze[Cn], xt), Yt !== null && (Me = B(Yt, Me, Cn), tn === null ? Lt = Yt : tn.sibling = Yt, tn = Yt);
                return Yn && Yl(Ie, Cn), Lt
            }
            for (Yt = w(Ie, Yt); Cn < ze.length; Cn++) ki = Un(Yt, Ie, Cn, ze[Cn], xt), ki !== null && (h && ki.alternate !== null && Yt.delete(ki.key === null ? Cn : ki.key), Me = B(ki, Me, Cn), tn === null ? Lt = ki : tn.sibling = ki, tn = ki);
            return h && Yt.forEach(function(Na) {
                return p(Ie, Na)
            }), Yn && Yl(Ie, Cn), Lt
        }

        function sr(Ie, Me, ze, xt) {
            var Lt = E(ze);
            if (typeof Lt != "function") throw Error(o(150));
            if (ze = Lt.call(ze), ze == null) throw Error(o(151));
            for (var tn = Lt = null, Yt = Me, Cn = Me = 0, ki = null, Rn = ze.next(); Yt !== null && !Rn.done; Cn++, Rn = ze.next()) {
                Yt.index > Cn ? (ki = Yt, Yt = null) : ki = Yt.sibling;
                var Na = Nt(Ie, Yt, Rn.value, xt);
                if (Na === null) {
                    Yt === null && (Yt = ki);
                    break
                }
                h && Yt && Na.alternate === null && p(Ie, Yt), Me = B(Na, Me, Cn), tn === null ? Lt = Na : tn.sibling = Na, tn = Na, Yt = ki
            }
            if (Rn.done) return x(Ie, Yt), Yn && Yl(Ie, Cn), Lt;
            if (Yt === null) {
                for (; !Rn.done; Cn++, Rn = ze.next()) Rn = Xt(Ie, Rn.value, xt), Rn !== null && (Me = B(Rn, Me, Cn), tn === null ? Lt = Rn : tn.sibling = Rn, tn = Rn);
                return Yn && Yl(Ie, Cn), Lt
            }
            for (Yt = w(Ie, Yt); !Rn.done; Cn++, Rn = ze.next()) Rn = Un(Yt, Ie, Cn, Rn.value, xt), Rn !== null && (h && Rn.alternate !== null && Yt.delete(Rn.key === null ? Cn : Rn.key), Me = B(Rn, Me, Cn), tn === null ? Lt = Rn : tn.sibling = Rn, tn = Rn);
            return h && Yt.forEach(function(GF) {
                return p(Ie, GF)
            }), Yn && Yl(Ie, Cn), Lt
        }

        function Fs(Ie, Me, ze, xt) {
            if (typeof ze == "object" && ze !== null && ze.type === u && ze.key === null && (ze = ze.props.children), typeof ze == "object" && ze !== null) {
                switch (ze.$$typeof) {
                    case l:
                        e: {
                            for (var Lt = ze.key, tn = Me; tn !== null;) {
                                if (tn.key === Lt) {
                                    if (Lt = ze.type, Lt === u) {
                                        if (tn.tag === 7) {
                                            x(Ie, tn.sibling), Me = I(tn, ze.props.children), Me.return = Ie, Ie = Me;
                                            break e
                                        }
                                    } else if (tn.elementType === Lt || typeof Lt == "object" && Lt !== null && Lt.$$typeof === S && kw(Lt) === tn.type) {
                                        x(Ie, tn.sibling), Me = I(tn, ze.props), Me.ref = Eh(Ie, tn, ze), Me.return = Ie, Ie = Me;
                                        break e
                                    }
                                    x(Ie, tn);
                                    break
                                } else p(Ie, tn);
                                tn = tn.sibling
                            }
                            ze.type === u ? (Me = ec(ze.props.children, Ie.mode, xt, ze.key), Me.return = Ie, Ie = Me) : (xt = eg(ze.type, ze.key, ze.props, null, Ie.mode, xt), xt.ref = Eh(Ie, Me, ze), xt.return = Ie, Ie = xt)
                        }
                        return ie(Ie);
                    case c:
                        e: {
                            for (tn = ze.key; Me !== null;) {
                                if (Me.key === tn)
                                    if (Me.tag === 4 && Me.stateNode.containerInfo === ze.containerInfo && Me.stateNode.implementation === ze.implementation) {
                                        x(Ie, Me.sibling), Me = I(Me, ze.children || []), Me.return = Ie, Ie = Me;
                                        break e
                                    } else {
                                        x(Ie, Me);
                                        break
                                    }
                                else p(Ie, Me);
                                Me = Me.sibling
                            }
                            Me = z_(ze, Ie.mode, xt),
                            Me.return = Ie,
                            Ie = Me
                        }
                        return ie(Ie);
                    case S:
                        return tn = ze._init, Fs(Ie, Me, tn(ze._payload), xt)
                }
                if (q(ze)) return Ft(Ie, Me, ze, xt);
                if (E(ze)) return sr(Ie, Me, ze, xt);
                Mm(Ie, ze)
            }
            return typeof ze == "string" && ze !== "" || typeof ze == "number" ? (ze = "" + ze, Me !== null && Me.tag === 6 ? (x(Ie, Me.sibling), Me = I(Me, ze), Me.return = Ie, Ie = Me) : (x(Ie, Me), Me = k_(ze, Ie.mode, xt), Me.return = Ie, Ie = Me), ie(Ie)) : x(Ie, Me)
        }
        return Fs
    }
    var Cu = zw(!0),
        Gw = zw(!1),
        Ch = {},
        Is = _t(Ch),
        Rh = _t(Ch),
        Ru = _t(Ch);

    function Ao(h) {
        if (h === Ch) throw Error(o(174));
        return h
    }

    function i_(h, p) {
        wt(Ru, p), wt(Rh, h), wt(Is, Ch), h = oe(p), ht(Is), wt(Is, h)
    }

    function Pu() {
        ht(Is), ht(Rh), ht(Ru)
    }

    function Hw(h) {
        var p = Ao(Ru.current),
            x = Ao(Is.current);
        p = Y(x, h.type, p), x !== p && (wt(Rh, h), wt(Is, p))
    }

    function r_(h) {
        Rh.current === h && (ht(Is), ht(Rh))
    }
    var ei = _t(0);

    function wm(h) {
        for (var p = h; p !== null;) {
            if (p.tag === 13) {
                var x = p.memoizedState;
                if (x !== null && (x = x.dehydrated, x === null || pt(x) || Ct(x))) return p
            } else if (p.tag === 19 && p.memoizedProps.revealOrder !== void 0) {
                if (p.flags & 128) return p
            } else if (p.child !== null) {
                p.child.return = p, p = p.child;
                continue
            }
            if (p === h) break;
            for (; p.sibling === null;) {
                if (p.return === null || p.return === h) return null;
                p = p.return
            }
            p.sibling.return = p.return, p = p.sibling
        }
        return null
    }
    var s_ = [];

    function o_() {
        for (var h = 0; h < s_.length; h++) {
            var p = s_[h];
            ke ? p._workInProgressVersionPrimary = null : p._workInProgressVersionSecondary = null
        }
        s_.length = 0
    }
    var bm = a.ReactCurrentDispatcher,
        Bs = a.ReactCurrentBatchConfig,
        Iu = 0,
        li = null,
        nr = null,
        Ni = null,
        Tm = !1,
        Ph = !1,
        Ih = 0,
        hF = 0;

    function ir() {
        throw Error(o(321))
    }

    function a_(h, p) {
        if (p === null) return !1;
        for (var x = 0; x < p.length && x < h.length; x++)
            if (!$r(h[x], p[x])) return !1;
        return !0
    }

    function l_(h, p, x, w, I, B) {
        if (Iu = B, li = p, p.memoizedState = null, p.updateQueue = null, p.lanes = 0, bm.current = h === null || h.memoizedState === null ? gF : vF, h = x(w, I), Ph) {
            B = 0;
            do {
                if (Ph = !1, Ih = 0, 25 <= B) throw Error(o(301));
                B += 1, Ni = nr = null, p.updateQueue = null, bm.current = yF, h = x(w, I)
            } while (Ph)
        }
        if (bm.current = Im, p = nr !== null && nr.next !== null, Iu = 0, Ni = nr = li = null, Tm = !1, p) throw Error(o(300));
        return h
    }

    function c_() {
        var h = Ih !== 0;
        return Ih = 0, h
    }

    function Ko() {
        var h = {
            memoizedState: null,
            baseState: null,
            baseQueue: null,
            queue: null,
            next: null
        };
        return Ni === null ? li.memoizedState = Ni = h : Ni = Ni.next = h, Ni
    }

    function So() {
        if (nr === null) {
            var h = li.alternate;
            h = h !== null ? h.memoizedState : null
        } else h = nr.next;
        var p = Ni === null ? li.memoizedState : Ni.next;
        if (p !== null) Ni = p, nr = h;
        else {
            if (h === null) throw Error(o(310));
            nr = h, h = {
                memoizedState: nr.memoizedState,
                baseState: nr.baseState,
                baseQueue: nr.baseQueue,
                queue: nr.queue,
                next: null
            }, Ni === null ? li.memoizedState = Ni = h : Ni = Ni.next = h
        }
        return Ni
    }

    function Jl(h, p) {
        return typeof p == "function" ? p(h) : p
    }

    function Em(h) {
        var p = So(),
            x = p.queue;
        if (x === null) throw Error(o(311));
        x.lastRenderedReducer = h;
        var w = nr,
            I = w.baseQueue,
            B = x.pending;
        if (B !== null) {
            if (I !== null) {
                var ie = I.next;
                I.next = B.next, B.next = ie
            }
            w.baseQueue = I = B, x.pending = null
        }
        if (I !== null) {
            B = I.next, w = w.baseState;
            var Ae = ie = null,
                Ve = null,
                lt = B;
            do {
                var bt = lt.lane;
                if ((Iu & bt) === bt) Ve !== null && (Ve = Ve.next = {
                    lane: 0,
                    action: lt.action,
                    hasEagerState: lt.hasEagerState,
                    eagerState: lt.eagerState,
                    next: null
                }), w = lt.hasEagerState ? lt.eagerState : h(w, lt.action);
                else {
                    var Xt = {
                        lane: bt,
                        action: lt.action,
                        hasEagerState: lt.hasEagerState,
                        eagerState: lt.eagerState,
                        next: null
                    };
                    Ve === null ? (Ae = Ve = Xt, ie = w) : Ve = Ve.next = Xt, li.lanes |= bt, Du |= bt
                }
                lt = lt.next
            } while (lt !== null && lt !== B);
            Ve === null ? ie = w : Ve.next = Ae, $r(w, p.memoizedState) || (is = !0), p.memoizedState = w, p.baseState = ie, p.baseQueue = Ve, x.lastRenderedState = w
        }
        if (h = x.interleaved, h !== null) {
            I = h;
            do B = I.lane, li.lanes |= B, Du |= B, I = I.next; while (I !== h)
        } else I === null && (x.lanes = 0);
        return [p.memoizedState, x.dispatch]
    }

    function Cm(h) {
        var p = So(),
            x = p.queue;
        if (x === null) throw Error(o(311));
        x.lastRenderedReducer = h;
        var w = x.dispatch,
            I = x.pending,
            B = p.memoizedState;
        if (I !== null) {
            x.pending = null;
            var ie = I = I.next;
            do B = h(B, ie.action), ie = ie.next; while (ie !== I);
            $r(B, p.memoizedState) || (is = !0), p.memoizedState = B, p.baseQueue === null && (p.baseState = B), x.lastRenderedState = B
        }
        return [B, w]
    }

    function Vw() {}

    function Ww(h, p) {
        var x = li,
            w = So(),
            I = p(),
            B = !$r(w.memoizedState, I);
        if (B && (w.memoizedState = I, is = !0), w = w.queue, Dh(Yw.bind(null, x, w, h), [h]), w.getSnapshot !== p || B || Ni !== null && Ni.memoizedState.tag & 1) {
            if (x.flags |= 2048, Bh(9, Xw.bind(null, x, w, I, p), void 0, null), wi === null) throw Error(o(349));
            Iu & 30 || jw(x, p, I)
        }
        return I
    }

    function jw(h, p, x) {
        h.flags |= 16384, h = {
            getSnapshot: p,
            value: x
        }, p = li.updateQueue, p === null ? (p = {
            lastEffect: null,
            stores: null
        }, li.updateQueue = p, p.stores = [h]) : (x = p.stores, x === null ? p.stores = [h] : x.push(h))
    }

    function Xw(h, p, x, w) {
        p.value = x, p.getSnapshot = w, Jw(p) && Ds(h, 1, -1)
    }

    function Yw(h, p, x) {
        return x(function() {
            Jw(p) && Ds(h, 1, -1)
        })
    }

    function Jw(h) {
        var p = h.getSnapshot;
        h = h.value;
        try {
            var x = p();
            return !$r(h, x)
        } catch {
            return !0
        }
    }

    function u_(h) {
        var p = Ko();
        return typeof h == "function" && (h = h()), p.memoizedState = p.baseState = h, h = {
            pending: null,
            interleaved: null,
            lanes: 0,
            dispatch: null,
            lastRenderedReducer: Jl,
            lastRenderedState: h
        }, p.queue = h, h = h.dispatch = mF.bind(null, li, h), [p.memoizedState, h]
    }

    function Bh(h, p, x, w) {
        return h = {
            tag: h,
            create: p,
            destroy: x,
            deps: w,
            next: null
        }, p = li.updateQueue, p === null ? (p = {
            lastEffect: null,
            stores: null
        }, li.updateQueue = p, p.lastEffect = h.next = h) : (x = p.lastEffect, x === null ? p.lastEffect = h.next = h : (w = x.next, x.next = h, h.next = w, p.lastEffect = h)), h
    }

    function Kw() {
        return So().memoizedState
    }

    function Rm(h, p, x, w) {
        var I = Ko();
        li.flags |= h, I.memoizedState = Bh(1 | p, x, void 0, w === void 0 ? null : w)
    }

    function Pm(h, p, x, w) {
        var I = So();
        w = w === void 0 ? null : w;
        var B = void 0;
        if (nr !== null) {
            var ie = nr.memoizedState;
            if (B = ie.destroy, w !== null && a_(w, ie.deps)) {
                I.memoizedState = Bh(p, x, B, w);
                return
            }
        }
        li.flags |= h, I.memoizedState = Bh(1 | p, x, B, w)
    }

    function f_(h, p) {
        return Rm(8390656, 8, h, p)
    }

    function Dh(h, p) {
        return Pm(2048, 8, h, p)
    }

    function qw(h, p) {
        return Pm(4, 2, h, p)
    }

    function Zw(h, p) {
        return Pm(4, 4, h, p)
    }

    function Qw(h, p) {
        if (typeof p == "function") return h = h(), p(h),
            function() {
                p(null)
            };
        if (p != null) return h = h(), p.current = h,
            function() {
                p.current = null
            }
    }

    function $w(h, p, x) {
        return x = x != null ? x.concat([h]) : null, Pm(4, 4, Qw.bind(null, p, h), x)
    }

    function h_() {}

    function eb(h, p) {
        var x = So();
        p = p === void 0 ? null : p;
        var w = x.memoizedState;
        return w !== null && p !== null && a_(p, w[1]) ? w[0] : (x.memoizedState = [h, p], h)
    }

    function tb(h, p) {
        var x = So();
        p = p === void 0 ? null : p;
        var w = x.memoizedState;
        return w !== null && p !== null && a_(p, w[1]) ? w[0] : (h = h(), x.memoizedState = [h, p], h)
    }

    function dF(h, p) {
        var x = un;
        un = x !== 0 && 4 > x ? x : 4, h(!0);
        var w = Bs.transition;
        Bs.transition = {};
        try {
            h(!1), p()
        } finally {
            un = x, Bs.transition = w
        }
    }

    function nb() {
        return So().memoizedState
    }

    function pF(h, p, x) {
        var w = Fa(h);
        x = {
            lane: w,
            action: x,
            hasEagerState: !1,
            eagerState: null,
            next: null
        }, ib(h) ? rb(p, x) : (sb(h, p, x), x = wr(), h = Ds(h, w, x), h !== null && ob(h, p, w))
    }

    function mF(h, p, x) {
        var w = Fa(h),
            I = {
                lane: w,
                action: x,
                hasEagerState: !1,
                eagerState: null,
                next: null
            };
        if (ib(h)) rb(p, I);
        else {
            sb(h, p, I);
            var B = h.alternate;
            if (h.lanes === 0 && (B === null || B.lanes === 0) && (B = p.lastRenderedReducer, B !== null)) try {
                var ie = p.lastRenderedState,
                    Ae = B(ie, x);
                if (I.hasEagerState = !0, I.eagerState = Ae, $r(Ae, ie)) return
            } catch {} finally {}
            x = wr(), h = Ds(h, w, x), h !== null && ob(h, p, w)
        }
    }

    function ib(h) {
        var p = h.alternate;
        return h === li || p !== null && p === li
    }

    function rb(h, p) {
        Ph = Tm = !0;
        var x = h.pending;
        x === null ? p.next = p : (p.next = x.next, x.next = p), h.pending = p
    }

    function sb(h, p, x) {
        wi !== null && h.mode & 1 && !(on & 2) ? (h = p.interleaved, h === null ? (x.next = x, es === null ? es = [p] : es.push(p)) : (x.next = h.next, h.next = x), p.interleaved = x) : (h = p.pending, h === null ? x.next = x : (x.next = h.next, h.next = x), p.pending = x)
    }

    function ob(h, p, x) {
        if (x & 4194240) {
            var w = p.lanes;
            w &= h.pendingLanes, x |= w, p.lanes = x, _o(h, x)
        }
    }
    var Im = {
            readContext: vi,
            useCallback: ir,
            useContext: ir,
            useEffect: ir,
            useImperativeHandle: ir,
            useInsertionEffect: ir,
            useLayoutEffect: ir,
            useMemo: ir,
            useReducer: ir,
            useRef: ir,
            useState: ir,
            useDebugValue: ir,
            useDeferredValue: ir,
            useTransition: ir,
            useMutableSource: ir,
            useSyncExternalStore: ir,
            useId: ir,
            unstable_isNewReconciler: !1
        },
        gF = {
            readContext: vi,
            useCallback: function(h, p) {
                return Ko().memoizedState = [h, p === void 0 ? null : p], h
            },
            useContext: vi,
            useEffect: f_,
            useImperativeHandle: function(h, p, x) {
                return x = x != null ? x.concat([h]) : null, Rm(4194308, 4, Qw.bind(null, p, h), x)
            },
            useLayoutEffect: function(h, p) {
                return Rm(4194308, 4, h, p)
            },
            useInsertionEffect: function(h, p) {
                return Rm(4, 2, h, p)
            },
            useMemo: function(h, p) {
                var x = Ko();
                return p = p === void 0 ? null : p, h = h(), x.memoizedState = [h, p], h
            },
            useReducer: function(h, p, x) {
                var w = Ko();
                return p = x !== void 0 ? x(p) : p, w.memoizedState = w.baseState = p, h = {
                    pending: null,
                    interleaved: null,
                    lanes: 0,
                    dispatch: null,
                    lastRenderedReducer: h,
                    lastRenderedState: p
                }, w.queue = h, h = h.dispatch = pF.bind(null, li, h), [w.memoizedState, h]
            },
            useRef: function(h) {
                var p = Ko();
                return h = {
                    current: h
                }, p.memoizedState = h
            },
            useState: u_,
            useDebugValue: h_,
            useDeferredValue: function(h) {
                var p = u_(h),
                    x = p[0],
                    w = p[1];
                return f_(function() {
                    var I = Bs.transition;
                    Bs.transition = {};
                    try {
                        w(h)
                    } finally {
                        Bs.transition = I
                    }
                }, [h]), x
            },
            useTransition: function() {
                var h = u_(!1),
                    p = h[0];
                return h = dF.bind(null, h[1]), Ko().memoizedState = h, [p, h]
            },
            useMutableSource: function() {},
            useSyncExternalStore: function(h, p, x) {
                var w = li,
                    I = Ko();
                if (Yn) {
                    if (x === void 0) throw Error(o(407));
                    x = x()
                } else {
                    if (x = p(), wi === null) throw Error(o(349));
                    Iu & 30 || jw(w, p, x)
                }
                I.memoizedState = x;
                var B = {
                    value: x,
                    getSnapshot: p
                };
                return I.queue = B, f_(Yw.bind(null, w, B, h), [h]), w.flags |= 2048, Bh(9, Xw.bind(null, w, B, x, p), void 0, null), x
            },
            useId: function() {
                var h = Ko(),
                    p = wi.identifierPrefix;
                if (Yn) {
                    var x = Jo,
                        w = Yo;
                    x = (w & ~(1 << 32 - sn(w) - 1)).toString(32) + x, p = ":" + p + "R" + x, x = Ih++, 0 < x && (p += "H" + x.toString(32)), p += ":"
                } else x = hF++, p = ":" + p + "r" + x.toString(32) + ":";
                return h.memoizedState = p
            },
            unstable_isNewReconciler: !1
        },
        vF = {
            readContext: vi,
            useCallback: eb,
            useContext: vi,
            useEffect: Dh,
            useImperativeHandle: $w,
            useInsertionEffect: qw,
            useLayoutEffect: Zw,
            useMemo: tb,
            useReducer: Em,
            useRef: Kw,
            useState: function() {
                return Em(Jl)
            },
            useDebugValue: h_,
            useDeferredValue: function(h) {
                var p = Em(Jl),
                    x = p[0],
                    w = p[1];
                return Dh(function() {
                    var I = Bs.transition;
                    Bs.transition = {};
                    try {
                        w(h)
                    } finally {
                        Bs.transition = I
                    }
                }, [h]), x
            },
            useTransition: function() {
                var h = Em(Jl)[0],
                    p = So().memoizedState;
                return [h, p]
            },
            useMutableSource: Vw,
            useSyncExternalStore: Ww,
            useId: nb,
            unstable_isNewReconciler: !1
        },
        yF = {
            readContext: vi,
            useCallback: eb,
            useContext: vi,
            useEffect: Dh,
            useImperativeHandle: $w,
            useInsertionEffect: qw,
            useLayoutEffect: Zw,
            useMemo: tb,
            useReducer: Cm,
            useRef: Kw,
            useState: function() {
                return Cm(Jl)
            },
            useDebugValue: h_,
            useDeferredValue: function(h) {
                var p = Cm(Jl),
                    x = p[0],
                    w = p[1];
                return Dh(function() {
                    var I = Bs.transition;
                    Bs.transition = {};
                    try {
                        w(h)
                    } finally {
                        Bs.transition = I
                    }
                }, [h]), x
            },
            useTransition: function() {
                var h = Cm(Jl)[0],
                    p = So().memoizedState;
                return [h, p]
            },
            useMutableSource: Vw,
            useSyncExternalStore: Ww,
            useId: nb,
            unstable_isNewReconciler: !1
        };

    function d_(h, p) {
        try {
            var x = "",
                w = p;
            do x += jl(w), w = w.return; while (w);
            var I = x
        } catch (B) {
            I = `
Error generating stack: ` + B.message + `
` + B.stack
        }
        return {
            value: h,
            source: p,
            stack: I
        }
    }

    function p_(h, p) {
        try {
            console.error(p.value)
        } catch (x) {
            setTimeout(function() {
                throw x
            })
        }
    }
    var _F = typeof WeakMap == "function" ? WeakMap : Map;

    function ab(h, p, x) {
        x = Xo(-1, x), x.tag = 3, x.payload = {
            element: null
        };
        var w = p.value;
        return x.callback = function() {
            Ym || (Ym = !0, B_ = w), p_(h, p)
        }, x
    }

    function lb(h, p, x) {
        x = Xo(-1, x), x.tag = 3;
        var w = h.type.getDerivedStateFromError;
        if (typeof w == "function") {
            var I = p.value;
            x.payload = function() {
                return w(I)
            }, x.callback = function() {
                p_(h, p)
            }
        }
        var B = h.stateNode;
        return B !== null && typeof B.componentDidCatch == "function" && (x.callback = function() {
            p_(h, p), typeof w != "function" && (Da === null ? Da = new Set([this]) : Da.add(this));
            var ie = p.stack;
            this.componentDidCatch(p.value, {
                componentStack: ie !== null ? ie : ""
            })
        }), x
    }

    function cb(h, p, x) {
        var w = h.pingCache;
        if (w === null) {
            w = h.pingCache = new _F;
            var I = new Set;
            w.set(p, I)
        } else I = w.get(p), I === void 0 && (I = new Set, w.set(p, I));
        I.has(x) || (I.add(x), h = DF.bind(null, h, p, x), p.then(h, h))
    }

    function ub(h) {
        do {
            var p;
            if ((p = h.tag === 13) && (p = h.memoizedState, p = p !== null ? p.dehydrated !== null : !0), p) return h;
            h = h.return
        } while (h !== null);
        return null
    }

    function fb(h, p, x, w, I) {
        return h.mode & 1 ? (h.flags |= 65536, h.lanes = I, h) : (h === p ? h.flags |= 65536 : (h.flags |= 128, x.flags |= 131072, x.flags &= -52805, x.tag === 1 && (x.alternate === null ? x.tag = 17 : (p = Xo(-1, 1), p.tag = 2, Ba(x, p))), x.lanes |= 1), h)
    }

    function Mo(h) {
        h.flags |= 4
    }

    function hb(h, p) {
        if (h !== null && h.child === p.child) return !0;
        if (p.flags & 16) return !1;
        for (h = p.child; h !== null;) {
            if (h.flags & 12854 || h.subtreeFlags & 12854) return !1;
            h = h.sibling
        }
        return !0
    }
    var Lh, Fh, Bm, Dm;
    if (Ee) Lh = function(h, p) {
        for (var x = p.child; x !== null;) {
            if (x.tag === 5 || x.tag === 6) te(h, x.stateNode);
            else if (x.tag !== 4 && x.child !== null) {
                x.child.return = x, x = x.child;
                continue
            }
            if (x === p) break;
            for (; x.sibling === null;) {
                if (x.return === null || x.return === p) return;
                x = x.return
            }
            x.sibling.return = x.return, x = x.sibling
        }
    }, Fh = function() {}, Bm = function(h, p, x, w, I) {
        if (h = h.memoizedProps, h !== w) {
            var B = p.stateNode,
                ie = Ao(Is.current);
            x = $(B, x, h, w, I, ie), (p.updateQueue = x) && Mo(p)
        }
    }, Dm = function(h, p, x, w) {
        x !== w && Mo(p)
    };
    else if (pe) {
        Lh = function(h, p, x, w) {
            for (var I = p.child; I !== null;) {
                if (I.tag === 5) {
                    var B = I.stateNode;
                    x && w && (B = tt(B, I.type, I.memoizedProps, I)), te(h, B)
                } else if (I.tag === 6) B = I.stateNode, x && w && (B = ut(B, I.memoizedProps, I)), te(h, B);
                else if (I.tag !== 4) {
                    if (I.tag === 22 && I.memoizedState !== null) B = I.child, B !== null && (B.return = I), Lh(h, I, !0, !0);
                    else if (I.child !== null) {
                        I.child.return = I, I = I.child;
                        continue
                    }
                }
                if (I === p) break;
                for (; I.sibling === null;) {
                    if (I.return === null || I.return === p) return;
                    I = I.return
                }
                I.sibling.return = I.return, I = I.sibling
            }
        };
        var db = function(h, p, x, w) {
            for (var I = p.child; I !== null;) {
                if (I.tag === 5) {
                    var B = I.stateNode;
                    x && w && (B = tt(B, I.type, I.memoizedProps, I)), mt(h, B)
                } else if (I.tag === 6) B = I.stateNode, x && w && (B = ut(B, I.memoizedProps, I)), mt(h, B);
                else if (I.tag !== 4) {
                    if (I.tag === 22 && I.memoizedState !== null) B = I.child, B !== null && (B.return = I), db(h, I, !0, !0);
                    else if (I.child !== null) {
                        I.child.return = I, I = I.child;
                        continue
                    }
                }
                if (I === p) break;
                for (; I.sibling === null;) {
                    if (I.return === null || I.return === p) return;
                    I = I.return
                }
                I.sibling.return = I.return, I = I.sibling
            }
        };
        Fh = function(h, p) {
            var x = p.stateNode;
            if (!hb(h, p)) {
                h = x.containerInfo;
                var w = Ye(h);
                db(w, p, !1, !1), x.pendingChildren = w, Mo(p), Pt(h, w)
            }
        }, Bm = function(h, p, x, w, I) {
            var B = h.stateNode,
                ie = h.memoizedProps;
            if ((h = hb(h, p)) && ie === w) p.stateNode = B;
            else {
                var Ae = p.stateNode,
                    Ve = Ao(Is.current),
                    lt = null;
                ie !== w && (lt = $(Ae, x, ie, w, I, Ve)), h && lt === null ? p.stateNode = B : (B = Je(B, lt, x, ie, w, p, h, Ae), he(B, x, w, I, Ve) && Mo(p), p.stateNode = B, h ? Mo(p) : Lh(B, p, !1, !1))
            }
        }, Dm = function(h, p, x, w) {
            x !== w ? (h = Ao(Ru.current), x = Ao(Is.current), p.stateNode = me(w, h, x, p), Mo(p)) : p.stateNode = h.stateNode
        }
    } else Fh = function() {}, Bm = function() {}, Dm = function() {};

    function Uh(h, p) {
        if (!Yn) switch (h.tailMode) {
            case "hidden":
                p = h.tail;
                for (var x = null; p !== null;) p.alternate !== null && (x = p), p = p.sibling;
                x === null ? h.tail = null : x.sibling = null;
                break;
            case "collapsed":
                x = h.tail;
                for (var w = null; x !== null;) x.alternate !== null && (w = x), x = x.sibling;
                w === null ? p || h.tail === null ? h.tail = null : h.tail.sibling = null : w.sibling = null
        }
    }

    function rr(h) {
        var p = h.alternate !== null && h.alternate.child === h.child,
            x = 0,
            w = 0;
        if (p)
            for (var I = h.child; I !== null;) x |= I.lanes | I.childLanes, w |= I.subtreeFlags & 14680064, w |= I.flags & 14680064, I.return = h, I = I.sibling;
        else
            for (I = h.child; I !== null;) x |= I.lanes | I.childLanes, w |= I.subtreeFlags, w |= I.flags, I.return = h, I = I.sibling;
        return h.subtreeFlags |= w, h.childLanes = x, p
    }

    function xF(h, p, x) {
        var w = p.pendingProps;
        switch ($y(p), p.tag) {
            case 2:
            case 16:
            case 15:
            case 0:
            case 11:
            case 7:
            case 8:
            case 12:
            case 9:
            case 14:
                return rr(p), null;
            case 1:
                return In(p.type) && cn(), rr(p), null;
            case 3:
                return w = p.stateNode, Pu(), ht(Ut), ht(ct), o_(), w.pendingContext && (w.context = w.pendingContext, w.pendingContext = null), (h === null || h.child === null) && (Th(p) ? Mo(p) : h === null || h.memoizedState.isDehydrated && !(p.flags & 256) || (p.flags |= 1024, to !== null && (F_(to), to = null))), Fh(h, p), rr(p), null;
            case 5:
                r_(p), x = Ao(Ru.current);
                var I = p.type;
                if (h !== null && p.stateNode != null) Bm(h, p, I, w, x), h.ref !== p.ref && (p.flags |= 512, p.flags |= 2097152);
                else {
                    if (!w) {
                        if (p.stateNode === null) throw Error(o(166));
                        return rr(p), null
                    }
                    if (h = Ao(Is.current), Th(p)) {
                        if (!xe) throw Error(o(175));
                        h = O(p.stateNode, p.type, p.memoizedProps, x, h, p, !bh), p.updateQueue = h, h !== null && Mo(p)
                    } else {
                        var B = j(I, w, x, h, p);
                        Lh(B, p, !1, !1), p.stateNode = B, he(B, I, w, x, h) && Mo(p)
                    }
                    p.ref !== null && (p.flags |= 512, p.flags |= 2097152)
                }
                return rr(p), null;
            case 6:
                if (h && p.stateNode != null) Dm(h, p, h.memoizedProps, w);
                else {
                    if (typeof w != "string" && p.stateNode === null) throw Error(o(166));
                    if (h = Ao(Ru.current), x = Ao(Is.current), Th(p)) {
                        if (!xe) throw Error(o(176));
                        if (h = p.stateNode, w = p.memoizedProps, (x = W(h, w, p, !bh)) && (I = ts, I !== null)) switch (B = (I.mode & 1) !== 0, I.tag) {
                            case 3:
                                ee(I.stateNode.containerInfo, h, w, B);
                                break;
                            case 5:
                                Te(I.type, I.memoizedProps, I.stateNode, h, w, B)
                        }
                        x && Mo(p)
                    } else p.stateNode = me(w, h, x, p)
                }
                return rr(p), null;
            case 13:
                if (ht(ei), w = p.memoizedState, Yn && ns !== null && p.mode & 1 && !(p.flags & 128)) {
                    for (h = ns; h;) h = Dt(h);
                    return Eu(), p.flags |= 98560, p
                }
                if (w !== null && w.dehydrated !== null) {
                    if (w = Th(p), h === null) {
                        if (!w) throw Error(o(318));
                        if (!xe) throw Error(o(344));
                        if (h = p.memoizedState, h = h !== null ? h.dehydrated : null, !h) throw Error(o(317));
                        de(h, p)
                    } else Eu(), !(p.flags & 128) && (p.memoizedState = null), p.flags |= 4;
                    return rr(p), null
                }
                return to !== null && (F_(to), to = null), p.flags & 128 ? (p.lanes = x, p) : (w = w !== null, x = !1, h === null ? Th(p) : x = h.memoizedState !== null, w && !x && (p.child.flags |= 8192, p.mode & 1 && (h === null || ei.current & 1 ? Pi === 0 && (Pi = 3) : O_())), p.updateQueue !== null && (p.flags |= 4), rr(p), null);
            case 4:
                return Pu(), Fh(h, p), h === null && De(p.stateNode.containerInfo), rr(p), null;
            case 10:
                return Oi(p.type._context), rr(p), null;
            case 17:
                return In(p.type) && cn(), rr(p), null;
            case 19:
                if (ht(ei), I = p.memoizedState, I === null) return rr(p), null;
                if (w = (p.flags & 128) !== 0, B = I.rendering, B === null)
                    if (w) Uh(I, !1);
                    else {
                        if (Pi !== 0 || h !== null && h.flags & 128)
                            for (h = p.child; h !== null;) {
                                if (B = wm(h), B !== null) {
                                    for (p.flags |= 128, Uh(I, !1), h = B.updateQueue, h !== null && (p.updateQueue = h, p.flags |= 4), p.subtreeFlags = 0, h = x, w = p.child; w !== null;) x = w, I = h, x.flags &= 14680066, B = x.alternate, B === null ? (x.childLanes = 0, x.lanes = I, x.child = null, x.subtreeFlags = 0, x.memoizedProps = null, x.memoizedState = null, x.updateQueue = null, x.dependencies = null, x.stateNode = null) : (x.childLanes = B.childLanes, x.lanes = B.lanes, x.child = B.child, x.subtreeFlags = 0, x.deletions = null, x.memoizedProps = B.memoizedProps, x.memoizedState = B.memoizedState, x.updateQueue = B.updateQueue, x.type = B.type, I = B.dependencies, x.dependencies = I === null ? null : {
                                        lanes: I.lanes,
                                        firstContext: I.firstContext
                                    }), w = w.sibling;
                                    return wt(ei, ei.current & 1 | 2), p.child
                                }
                                h = h.sibling
                            }
                        I.tail !== null && $n() > I_ && (p.flags |= 128, w = !0, Uh(I, !1), p.lanes = 4194304)
                    }
                else {
                    if (!w)
                        if (h = wm(B), h !== null) {
                            if (p.flags |= 128, w = !0, h = h.updateQueue, h !== null && (p.updateQueue = h, p.flags |= 4), Uh(I, !0), I.tail === null && I.tailMode === "hidden" && !B.alternate && !Yn) return rr(p), null
                        } else 2 * $n() - I.renderingStartTime > I_ && x !== 1073741824 && (p.flags |= 128, w = !0, Uh(I, !1), p.lanes = 4194304);
                    I.isBackwards ? (B.sibling = p.child, p.child = B) : (h = I.last, h !== null ? h.sibling = B : p.child = B, I.last = B)
                }
                return I.tail !== null ? (p = I.tail, I.rendering = p, I.tail = p.sibling, I.renderingStartTime = $n(), p.sibling = null, h = ei.current, wt(ei, w ? h & 1 | 2 : h & 1), p) : (rr(p), null);
            case 22:
            case 23:
                return U_(), w = p.memoizedState !== null, h !== null && h.memoizedState !== null !== w && (p.flags |= 8192), w && p.mode & 1 ? rs & 1073741824 && (rr(p), Ee && p.subtreeFlags & 6 && (p.flags |= 8192)) : rr(p), null;
            case 24:
                return null;
            case 25:
                return null
        }
        throw Error(o(156, p.tag))
    }
    var AF = a.ReactCurrentOwner,
        is = !1;

    function Mr(h, p, x, w) {
        p.child = h === null ? Gw(p, null, x, w) : Cu(p, h.child, x, w)
    }

    function pb(h, p, x, w, I) {
        x = x.render;
        var B = p.ref;
        return gi(p, I), w = l_(h, p, x, w, B, I), x = c_(), h !== null && !is ? (p.updateQueue = h.updateQueue, p.flags &= -2053, h.lanes &= ~I, qo(h, p, I)) : (Yn && x && Qy(p), p.flags |= 1, Mr(h, p, w, I), p.child)
    }

    function mb(h, p, x, w, I) {
        if (h === null) {
            var B = x.type;
            return typeof B == "function" && !N_(B) && B.defaultProps === void 0 && x.compare === null && x.defaultProps === void 0 ? (p.tag = 15, p.type = B, gb(h, p, B, w, I)) : (h = eg(x.type, null, w, p, p.mode, I), h.ref = p.ref, h.return = p, p.child = h)
        }
        if (B = h.child, !(h.lanes & I)) {
            var ie = B.memoizedProps;
            if (x = x.compare, x = x !== null ? x : Wl, x(ie, w) && h.ref === p.ref) return qo(h, p, I)
        }
        return p.flags |= 1, h = Oa(B, w), h.ref = p.ref, h.return = p, p.child = h
    }

    function gb(h, p, x, w, I) {
        if (h !== null && Wl(h.memoizedProps, w) && h.ref === p.ref)
            if (is = !1, (h.lanes & I) !== 0) h.flags & 131072 && (is = !0);
            else return p.lanes = h.lanes, qo(h, p, I);
        return m_(h, p, x, w, I)
    }

    function vb(h, p, x) {
        var w = p.pendingProps,
            I = w.children,
            B = h !== null ? h.memoizedState : null;
        if (w.mode === "hidden")
            if (!(p.mode & 1)) p.memoizedState = {
                baseLanes: 0,
                cachePool: null
            }, wt(Bu, rs), rs |= x;
            else if (x & 1073741824) p.memoizedState = {
            baseLanes: 0,
            cachePool: null
        }, w = B !== null ? B.baseLanes : x, wt(Bu, rs), rs |= w;
        else return h = B !== null ? B.baseLanes | x : x, p.lanes = p.childLanes = 1073741824, p.memoizedState = {
            baseLanes: h,
            cachePool: null
        }, p.updateQueue = null, wt(Bu, rs), rs |= h, null;
        else B !== null ? (w = B.baseLanes | x, p.memoizedState = null) : w = x, wt(Bu, rs), rs |= w;
        return Mr(h, p, I, x), p.child
    }

    function yb(h, p) {
        var x = p.ref;
        (h === null && x !== null || h !== null && h.ref !== x) && (p.flags |= 512, p.flags |= 2097152)
    }

    function m_(h, p, x, w, I) {
        var B = In(x) ? Bt : ct.current;
        return B = Mn(p, B), gi(p, I), x = l_(h, p, x, w, B, I), w = c_(), h !== null && !is ? (p.updateQueue = h.updateQueue, p.flags &= -2053, h.lanes &= ~I, qo(h, p, I)) : (Yn && w && Qy(p), p.flags |= 1, Mr(h, p, x, I), p.child)
    }

    function _b(h, p, x, w, I) {
        if (In(x)) {
            var B = !0;
            Wt(p)
        } else B = !1;
        if (gi(p, I), p.stateNode === null) h !== null && (h.alternate = null, p.alternate = null, p.flags |= 2), Dw(p, x, w), Zy(p, x, w, I), w = !0;
        else if (h === null) {
            var ie = p.stateNode,
                Ae = p.memoizedProps;
            ie.props = Ae;
            var Ve = ie.context,
                lt = x.contextType;
            typeof lt == "object" && lt !== null ? lt = vi(lt) : (lt = In(x) ? Bt : ct.current, lt = Mn(p, lt));
            var bt = x.getDerivedStateFromProps,
                Xt = typeof bt == "function" || typeof ie.getSnapshotBeforeUpdate == "function";
            Xt || typeof ie.UNSAFE_componentWillReceiveProps != "function" && typeof ie.componentWillReceiveProps != "function" || (Ae !== w || Ve !== lt) && Lw(p, ie, w, lt), Ia = !1;
            var Nt = p.memoizedState;
            ie.state = Nt, _m(p, w, ie, I), Ve = p.memoizedState, Ae !== w || Nt !== Ve || Ut.current || Ia ? (typeof bt == "function" && (qy(p, x, bt, w), Ve = p.memoizedState), (Ae = Ia || Bw(p, x, Ae, w, Nt, Ve, lt)) ? (Xt || typeof ie.UNSAFE_componentWillMount != "function" && typeof ie.componentWillMount != "function" || (typeof ie.componentWillMount == "function" && ie.componentWillMount(), typeof ie.UNSAFE_componentWillMount == "function" && ie.UNSAFE_componentWillMount()), typeof ie.componentDidMount == "function" && (p.flags |= 4194308)) : (typeof ie.componentDidMount == "function" && (p.flags |= 4194308), p.memoizedProps = w, p.memoizedState = Ve), ie.props = w, ie.state = Ve, ie.context = lt, w = Ae) : (typeof ie.componentDidMount == "function" && (p.flags |= 4194308), w = !1)
        } else {
            ie = p.stateNode, Cw(h, p), Ae = p.memoizedProps, lt = p.type === p.elementType ? Ae : Ar(p.type, Ae), ie.props = lt, Xt = p.pendingProps, Nt = ie.context, Ve = x.contextType, typeof Ve == "object" && Ve !== null ? Ve = vi(Ve) : (Ve = In(x) ? Bt : ct.current, Ve = Mn(p, Ve));
            var Un = x.getDerivedStateFromProps;
            (bt = typeof Un == "function" || typeof ie.getSnapshotBeforeUpdate == "function") || typeof ie.UNSAFE_componentWillReceiveProps != "function" && typeof ie.componentWillReceiveProps != "function" || (Ae !== Xt || Nt !== Ve) && Lw(p, ie, w, Ve), Ia = !1, Nt = p.memoizedState, ie.state = Nt, _m(p, w, ie, I);
            var Ft = p.memoizedState;
            Ae !== Xt || Nt !== Ft || Ut.current || Ia ? (typeof Un == "function" && (qy(p, x, Un, w), Ft = p.memoizedState), (lt = Ia || Bw(p, x, lt, w, Nt, Ft, Ve) || !1) ? (bt || typeof ie.UNSAFE_componentWillUpdate != "function" && typeof ie.componentWillUpdate != "function" || (typeof ie.componentWillUpdate == "function" && ie.componentWillUpdate(w, Ft, Ve), typeof ie.UNSAFE_componentWillUpdate == "function" && ie.UNSAFE_componentWillUpdate(w, Ft, Ve)), typeof ie.componentDidUpdate == "function" && (p.flags |= 4), typeof ie.getSnapshotBeforeUpdate == "function" && (p.flags |= 1024)) : (typeof ie.componentDidUpdate != "function" || Ae === h.memoizedProps && Nt === h.memoizedState || (p.flags |= 4), typeof ie.getSnapshotBeforeUpdate != "function" || Ae === h.memoizedProps && Nt === h.memoizedState || (p.flags |= 1024), p.memoizedProps = w, p.memoizedState = Ft), ie.props = w, ie.state = Ft, ie.context = Ve, w = lt) : (typeof ie.componentDidUpdate != "function" || Ae === h.memoizedProps && Nt === h.memoizedState || (p.flags |= 4), typeof ie.getSnapshotBeforeUpdate != "function" || Ae === h.memoizedProps && Nt === h.memoizedState || (p.flags |= 1024), w = !1)
        }
        return g_(h, p, x, w, B, I)
    }

    function g_(h, p, x, w, I, B) {
        yb(h, p);
        var ie = (p.flags & 128) !== 0;
        if (!w && !ie) return I && Ht(p, x, !1), qo(h, p, B);
        w = p.stateNode, AF.current = p;
        var Ae = ie && typeof x.getDerivedStateFromError != "function" ? null : w.render();
        return p.flags |= 1, h !== null && ie ? (p.child = Cu(p, h.child, null, B), p.child = Cu(p, null, Ae, B)) : Mr(h, p, Ae, B), p.memoizedState = w.state, I && Ht(p, x, !0), p.child
    }

    function xb(h) {
        var p = h.stateNode;
        p.pendingContext ? en(h, p.pendingContext, p.pendingContext !== p.context) : p.context && en(h, p.context, !1), i_(h, p.containerInfo)
    }

    function Ab(h, p, x, w, I) {
        return Eu(), n_(I), p.flags |= 256, Mr(h, p, x, w), p.child
    }
    var Lm = {
        dehydrated: null,
        treeContext: null,
        retryLane: 0
    };

    function Fm(h) {
        return {
            baseLanes: h,
            cachePool: null
        }
    }

    function Sb(h, p, x) {
        var w = p.pendingProps,
            I = ei.current,
            B = !1,
            ie = (p.flags & 128) !== 0,
            Ae;
        if ((Ae = ie) || (Ae = h !== null && h.memoizedState === null ? !1 : (I & 2) !== 0), Ae ? (B = !0, p.flags &= -129) : (h === null || h.memoizedState !== null) && (I |= 1), wt(ei, I & 1), h === null) return t_(p), h = p.memoizedState, h !== null && (h = h.dehydrated, h !== null) ? (p.mode & 1 ? Ct(h) ? p.lanes = 8 : p.lanes = 1073741824 : p.lanes = 1, null) : (I = w.children, h = w.fallback, B ? (w = p.mode, B = p.child, I = {
            mode: "hidden",
            children: I
        }, !(w & 1) && B !== null ? (B.childLanes = 0, B.pendingProps = I) : B = tg(I, w, 0, null), h = ec(h, w, x, null), B.return = p, h.return = p, B.sibling = h, p.child = B, p.child.memoizedState = Fm(x), p.memoizedState = Lm, h) : v_(p, I));
        if (I = h.memoizedState, I !== null) {
            if (Ae = I.dehydrated, Ae !== null) {
                if (ie) return p.flags & 256 ? (p.flags &= -257, Um(h, p, x, Error(o(422)))) : p.memoizedState !== null ? (p.child = h.child, p.flags |= 128, null) : (B = w.fallback, I = p.mode, w = tg({
                    mode: "visible",
                    children: w.children
                }, I, 0, null), B = ec(B, I, x, null), B.flags |= 2, w.return = p, B.return = p, w.sibling = B, p.child = w, p.mode & 1 && Cu(p, h.child, null, x), p.child.memoizedState = Fm(x), p.memoizedState = Lm, B);
                if (!(p.mode & 1)) p = Um(h, p, x, null);
                else if (Ct(Ae)) p = Um(h, p, x, Error(o(419)));
                else if (w = (x & h.childLanes) !== 0, is || w) {
                    if (w = wi, w !== null) {
                        switch (x & -x) {
                            case 4:
                                B = 2;
                                break;
                            case 16:
                                B = 8;
                                break;
                            case 64:
                            case 128:
                            case 256:
                            case 512:
                            case 1024:
                            case 2048:
                            case 4096:
                            case 8192:
                            case 16384:
                            case 32768:
                            case 65536:
                            case 131072:
                            case 262144:
                            case 524288:
                            case 1048576:
                            case 2097152:
                            case 4194304:
                            case 8388608:
                            case 16777216:
                            case 33554432:
                            case 67108864:
                                B = 32;
                                break;
                            case 536870912:
                                B = 268435456;
                                break;
                            default:
                                B = 0
                        }
                        w = B & (w.suspendedLanes | x) ? 0 : B, w !== 0 && w !== I.retryLane && (I.retryLane = w, Ds(h, w, -1))
                    }
                    O_(), p = Um(h, p, x, Error(o(421)))
                } else pt(Ae) ? (p.flags |= 128, p.child = h.child, p = LF.bind(null, h), ln(Ae, p), p = null) : (x = I.treeContext, xe && (ns = rn(Ae), ts = p, Yn = !0, to = null, bh = !1, x !== null && (Rs[Ps++] = Yo, Rs[Ps++] = Jo, Rs[Ps++] = Xl, Yo = x.id, Jo = x.overflow, Xl = p)), p = v_(p, p.pendingProps.children), p.flags |= 4096);
                return p
            }
            return B ? (w = wb(h, p, w.children, w.fallback, x), B = p.child, I = h.child.memoizedState, B.memoizedState = I === null ? Fm(x) : {
                baseLanes: I.baseLanes | x,
                cachePool: null
            }, B.childLanes = h.childLanes & ~x, p.memoizedState = Lm, w) : (x = Mb(h, p, w.children, x), p.memoizedState = null, x)
        }
        return B ? (w = wb(h, p, w.children, w.fallback, x), B = p.child, I = h.child.memoizedState, B.memoizedState = I === null ? Fm(x) : {
            baseLanes: I.baseLanes | x,
            cachePool: null
        }, B.childLanes = h.childLanes & ~x, p.memoizedState = Lm, w) : (x = Mb(h, p, w.children, x), p.memoizedState = null, x)
    }

    function v_(h, p) {
        return p = tg({
            mode: "visible",
            children: p
        }, h.mode, 0, null), p.return = h, h.child = p
    }

    function Mb(h, p, x, w) {
        var I = h.child;
        return h = I.sibling, x = Oa(I, {
            mode: "visible",
            children: x
        }), !(p.mode & 1) && (x.lanes = w), x.return = p, x.sibling = null, h !== null && (w = p.deletions, w === null ? (p.deletions = [h], p.flags |= 16) : w.push(h)), p.child = x
    }

    function wb(h, p, x, w, I) {
        var B = p.mode;
        h = h.child;
        var ie = h.sibling,
            Ae = {
                mode: "hidden",
                children: x
            };
        return !(B & 1) && p.child !== h ? (x = p.child, x.childLanes = 0, x.pendingProps = Ae, p.deletions = null) : (x = Oa(h, Ae), x.subtreeFlags = h.subtreeFlags & 14680064), ie !== null ? w = Oa(ie, w) : (w = ec(w, B, I, null), w.flags |= 2), w.return = p, x.return = p, x.sibling = w, p.child = x, w
    }

    function Um(h, p, x, w) {
        return w !== null && n_(w), Cu(p, h.child, null, x), h = v_(p, p.pendingProps.children), h.flags |= 2, p.memoizedState = null, h
    }

    function bb(h, p, x) {
        h.lanes |= p;
        var w = h.alternate;
        w !== null && (w.lanes |= p), Sr(h.return, p, x)
    }

    function y_(h, p, x, w, I) {
        var B = h.memoizedState;
        B === null ? h.memoizedState = {
            isBackwards: p,
            rendering: null,
            renderingStartTime: 0,
            last: w,
            tail: x,
            tailMode: I
        } : (B.isBackwards = p, B.rendering = null, B.renderingStartTime = 0, B.last = w, B.tail = x, B.tailMode = I)
    }

    function Tb(h, p, x) {
        var w = p.pendingProps,
            I = w.revealOrder,
            B = w.tail;
        if (Mr(h, p, w.children, x), w = ei.current, w & 2) w = w & 1 | 2, p.flags |= 128;
        else {
            if (h !== null && h.flags & 128) e: for (h = p.child; h !== null;) {
                if (h.tag === 13) h.memoizedState !== null && bb(h, x, p);
                else if (h.tag === 19) bb(h, x, p);
                else if (h.child !== null) {
                    h.child.return = h, h = h.child;
                    continue
                }
                if (h === p) break e;
                for (; h.sibling === null;) {
                    if (h.return === null || h.return === p) break e;
                    h = h.return
                }
                h.sibling.return = h.return, h = h.sibling
            }
            w &= 1
        }
        if (wt(ei, w), !(p.mode & 1)) p.memoizedState = null;
        else switch (I) {
            case "forwards":
                for (x = p.child, I = null; x !== null;) h = x.alternate, h !== null && wm(h) === null && (I = x), x = x.sibling;
                x = I, x === null ? (I = p.child, p.child = null) : (I = x.sibling, x.sibling = null), y_(p, !1, I, x, B);
                break;
            case "backwards":
                for (x = null, I = p.child, p.child = null; I !== null;) {
                    if (h = I.alternate, h !== null && wm(h) === null) {
                        p.child = I;
                        break
                    }
                    h = I.sibling, I.sibling = x, x = I, I = h
                }
                y_(p, !0, x, null, B);
                break;
            case "together":
                y_(p, !1, null, null, void 0);
                break;
            default:
                p.memoizedState = null
        }
        return p.child
    }

    function qo(h, p, x) {
        if (h !== null && (p.dependencies = h.dependencies), Du |= p.lanes, !(x & p.childLanes)) return null;
        if (h !== null && p.child !== h.child) throw Error(o(153));
        if (p.child !== null) {
            for (h = p.child, x = Oa(h, h.pendingProps), p.child = x, x.return = p; h.sibling !== null;) h = h.sibling, x = x.sibling = Oa(h, h.pendingProps), x.return = p;
            x.sibling = null
        }
        return p.child
    }

    function SF(h, p, x) {
        switch (p.tag) {
            case 3:
                xb(p), Eu();
                break;
            case 5:
                Hw(p);
                break;
            case 1:
                In(p.type) && Wt(p);
                break;
            case 4:
                i_(p, p.stateNode.containerInfo);
                break;
            case 10:
                vm(p, p.type._context, p.memoizedProps.value);
                break;
            case 13:
                var w = p.memoizedState;
                if (w !== null) return w.dehydrated !== null ? (wt(ei, ei.current & 1), p.flags |= 128, null) : x & p.child.childLanes ? Sb(h, p, x) : (wt(ei, ei.current & 1), h = qo(h, p, x), h !== null ? h.sibling : null);
                wt(ei, ei.current & 1);
                break;
            case 19:
                if (w = (x & p.childLanes) !== 0, h.flags & 128) {
                    if (w) return Tb(h, p, x);
                    p.flags |= 128
                }
                var I = p.memoizedState;
                if (I !== null && (I.rendering = null, I.tail = null, I.lastEffect = null), wt(ei, ei.current), w) break;
                return null;
            case 22:
            case 23:
                return p.lanes = 0, vb(h, p, x)
        }
        return qo(h, p, x)
    }

    function MF(h, p) {
        switch ($y(p), p.tag) {
            case 1:
                return In(p.type) && cn(), h = p.flags, h & 65536 ? (p.flags = h & -65537 | 128, p) : null;
            case 3:
                return Pu(), ht(Ut), ht(ct), o_(), h = p.flags, h & 65536 && !(h & 128) ? (p.flags = h & -65537 | 128, p) : null;
            case 5:
                return r_(p), null;
            case 13:
                if (ht(ei), h = p.memoizedState, h !== null && h.dehydrated !== null) {
                    if (p.alternate === null) throw Error(o(340));
                    Eu()
                }
                return h = p.flags, h & 65536 ? (p.flags = h & -65537 | 128, p) : null;
            case 19:
                return ht(ei), null;
            case 4:
                return Pu(), null;
            case 10:
                return Oi(p.type._context), null;
            case 22:
            case 23:
                return U_(), null;
            case 24:
                return null;
            default:
                return null
        }
    }
    var Om = !1,
        Kl = !1,
        wF = typeof WeakSet == "function" ? WeakSet : Set,
        vt = null;

    function Nm(h, p) {
        var x = h.ref;
        if (x !== null)
            if (typeof x == "function") try {
                x(null)
            } catch (w) {
                Hr(h, p, w)
            } else x.current = null
    }

    function __(h, p, x) {
        try {
            x()
        } catch (w) {
            Hr(h, p, w)
        }
    }
    var Eb = !1;

    function bF(h, p) {
        for (Z(h.containerInfo), vt = p; vt !== null;)
            if (h = vt, p = h.child, (h.subtreeFlags & 1028) !== 0 && p !== null) p.return = h, vt = p;
            else
                for (; vt !== null;) {
                    h = vt;
                    try {
                        var x = h.alternate;
                        if (h.flags & 1024) switch (h.tag) {
                            case 0:
                            case 11:
                            case 15:
                                break;
                            case 1:
                                if (x !== null) {
                                    var w = x.memoizedProps,
                                        I = x.memoizedState,
                                        B = h.stateNode,
                                        ie = B.getSnapshotBeforeUpdate(h.elementType === h.type ? w : Ar(h.type, w), I);
                                    B.__reactInternalSnapshotBeforeUpdate = ie
                                }
                                break;
                            case 3:
                                Ee && He(h.stateNode.containerInfo);
                                break;
                            case 5:
                            case 6:
                            case 4:
                            case 17:
                                break;
                            default:
                                throw Error(o(163))
                        }
                    } catch (Ae) {
                        Hr(h, h.return, Ae)
                    }
                    if (p = h.sibling, p !== null) {
                        p.return = h.return, vt = p;
                        break
                    }
                    vt = h.return
                }
        return x = Eb, Eb = !1, x
    }

    function ql(h, p, x) {
        var w = p.updateQueue;
        if (w = w !== null ? w.lastEffect : null, w !== null) {
            var I = w = w.next;
            do {
                if ((I.tag & h) === h) {
                    var B = I.destroy;
                    I.destroy = void 0, B !== void 0 && __(p, x, B)
                }
                I = I.next
            } while (I !== w)
        }
    }

    function Oh(h, p) {
        if (p = p.updateQueue, p = p !== null ? p.lastEffect : null, p !== null) {
            var x = p = p.next;
            do {
                if ((x.tag & h) === h) {
                    var w = x.create;
                    x.destroy = w()
                }
                x = x.next
            } while (x !== p)
        }
    }

    function x_(h) {
        var p = h.ref;
        if (p !== null) {
            var x = h.stateNode;
            switch (h.tag) {
                case 5:
                    h = X(x);
                    break;
                default:
                    h = x
            }
            typeof p == "function" ? p(h) : p.current = h
        }
    }

    function Cb(h, p, x) {
        if (Qr && typeof Qr.onCommitFiberUnmount == "function") try {
            Qr.onCommitFiberUnmount(Hl, p)
        } catch {}
        switch (p.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                if (h = p.updateQueue, h !== null && (h = h.lastEffect, h !== null)) {
                    var w = h = h.next;
                    do {
                        var I = w,
                            B = I.destroy;
                        I = I.tag, B !== void 0 && (I & 2 || I & 4) && __(p, x, B), w = w.next
                    } while (w !== h)
                }
                break;
            case 1:
                if (Nm(p, x), h = p.stateNode, typeof h.componentWillUnmount == "function") try {
                    h.props = p.memoizedProps, h.state = p.memoizedState, h.componentWillUnmount()
                } catch (ie) {
                    Hr(p, x, ie)
                }
                break;
            case 5:
                Nm(p, x);
                break;
            case 4:
                Ee ? Lb(h, p, x) : pe && pe && (p = p.stateNode.containerInfo, x = Ye(p), St(p, x))
        }
    }

    function Rb(h, p, x) {
        for (var w = p;;)
            if (Cb(h, w, x), w.child === null || Ee && w.tag === 4) {
                if (w === p) break;
                for (; w.sibling === null;) {
                    if (w.return === null || w.return === p) return;
                    w = w.return
                }
                w.sibling.return = w.return, w = w.sibling
            } else w.child.return = w, w = w.child
    }

    function Pb(h) {
        var p = h.alternate;
        p !== null && (h.alternate = null, Pb(p)), h.child = null, h.deletions = null, h.sibling = null, h.tag === 5 && (p = h.stateNode, p !== null && se(p)), h.stateNode = null, h.return = null, h.dependencies = null, h.memoizedProps = null, h.memoizedState = null, h.pendingProps = null, h.stateNode = null, h.updateQueue = null
    }

    function Ib(h) {
        return h.tag === 5 || h.tag === 3 || h.tag === 4
    }

    function Bb(h) {
        e: for (;;) {
            for (; h.sibling === null;) {
                if (h.return === null || Ib(h.return)) return null;
                h = h.return
            }
            for (h.sibling.return = h.return, h = h.sibling; h.tag !== 5 && h.tag !== 6 && h.tag !== 18;) {
                if (h.flags & 2 || h.child === null || h.tag === 4) continue e;
                h.child.return = h, h = h.child
            }
            if (!(h.flags & 2)) return h.stateNode
        }
    }

    function Db(h) {
        if (Ee) {
            e: {
                for (var p = h.return; p !== null;) {
                    if (Ib(p)) break e;
                    p = p.return
                }
                throw Error(o(160))
            }
            var x = p;
            switch (x.tag) {
                case 5:
                    p = x.stateNode, x.flags & 32 && (at(p), x.flags &= -33), x = Bb(h), S_(h, x, p);
                    break;
                case 3:
                case 4:
                    p = x.stateNode.containerInfo, x = Bb(h), A_(h, x, p);
                    break;
                default:
                    throw Error(o(161))
            }
        }
    }

    function A_(h, p, x) {
        var w = h.tag;
        if (w === 5 || w === 6) h = h.stateNode, p ? $e(x, h, p) : Ne(x, h);
        else if (w !== 4 && (h = h.child, h !== null))
            for (A_(h, p, x), h = h.sibling; h !== null;) A_(h, p, x), h = h.sibling
    }

    function S_(h, p, x) {
        var w = h.tag;
        if (w === 5 || w === 6) h = h.stateNode, p ? it(x, h, p) : Fe(x, h);
        else if (w !== 4 && (h = h.child, h !== null))
            for (S_(h, p, x), h = h.sibling; h !== null;) S_(h, p, x), h = h.sibling
    }

    function Lb(h, p, x) {
        for (var w = p, I = !1, B, ie;;) {
            if (!I) {
                I = w.return;
                e: for (;;) {
                    if (I === null) throw Error(o(160));
                    switch (B = I.stateNode, I.tag) {
                        case 5:
                            ie = !1;
                            break e;
                        case 3:
                            B = B.containerInfo, ie = !0;
                            break e;
                        case 4:
                            B = B.containerInfo, ie = !0;
                            break e
                    }
                    I = I.return
                }
                I = !0
            }
            if (w.tag === 5 || w.tag === 6) Rb(h, w, x), ie ? yt(B, w.stateNode) : We(B, w.stateNode);
            else if (w.tag === 18) ie ? re(B, w.stateNode) : Q(B, w.stateNode);
            else if (w.tag === 4) {
                if (w.child !== null) {
                    B = w.stateNode.containerInfo, ie = !0, w.child.return = w, w = w.child;
                    continue
                }
            } else if (Cb(h, w, x), w.child !== null) {
                w.child.return = w, w = w.child;
                continue
            }
            if (w === p) break;
            for (; w.sibling === null;) {
                if (w.return === null || w.return === p) return;
                w = w.return, w.tag === 4 && (I = !1)
            }
            w.sibling.return = w.return, w = w.sibling
        }
    }

    function M_(h, p) {
        if (Ee) {
            switch (p.tag) {
                case 0:
                case 11:
                case 14:
                case 15:
                    ql(3, p, p.return), Oh(3, p), ql(5, p, p.return);
                    return;
                case 1:
                    return;
                case 5:
                    var x = p.stateNode;
                    if (x != null) {
                        var w = p.memoizedProps;
                        h = h !== null ? h.memoizedProps : w;
                        var I = p.type,
                            B = p.updateQueue;
                        p.updateQueue = null, B !== null && Ze(x, B, I, h, w, p)
                    }
                    return;
                case 6:
                    if (p.stateNode === null) throw Error(o(162));
                    x = p.memoizedProps, ot(p.stateNode, h !== null ? h.memoizedProps : x, x);
                    return;
                case 3:
                    xe && h !== null && h.memoizedState.isDehydrated && Pe(p.stateNode.containerInfo);
                    return;
                case 12:
                    return;
                case 13:
                    km(p);
                    return;
                case 19:
                    km(p);
                    return;
                case 17:
                    return
            }
            throw Error(o(163))
        }
        switch (p.tag) {
            case 0:
            case 11:
            case 14:
            case 15:
                ql(3, p, p.return), Oh(3, p), ql(5, p, p.return);
                return;
            case 12:
                return;
            case 13:
                km(p);
                return;
            case 19:
                km(p);
                return;
            case 3:
                xe && h !== null && h.memoizedState.isDehydrated && Pe(p.stateNode.containerInfo);
                break;
            case 22:
            case 23:
                return
        }
        e: if (pe) {
            switch (p.tag) {
                case 1:
                case 5:
                case 6:
                    break e;
                case 3:
                case 4:
                    p = p.stateNode, St(p.containerInfo, p.pendingChildren);
                    break e
            }
            throw Error(o(163))
        }
    }

    function km(h) {
        var p = h.updateQueue;
        if (p !== null) {
            h.updateQueue = null;
            var x = h.stateNode;
            x === null && (x = h.stateNode = new wF), p.forEach(function(w) {
                var I = FF.bind(null, h, w);
                x.has(w) || (x.add(w), w.then(I, I))
            })
        }
    }

    function TF(h, p) {
        for (vt = p; vt !== null;) {
            p = vt;
            var x = p.deletions;
            if (x !== null)
                for (var w = 0; w < x.length; w++) {
                    var I = x[w];
                    try {
                        var B = h;
                        Ee ? Lb(B, I, p) : Rb(B, I, p);
                        var ie = I.alternate;
                        ie !== null && (ie.return = null), I.return = null
                    } catch (Lt) {
                        Hr(I, p, Lt)
                    }
                }
            if (x = p.child, p.subtreeFlags & 12854 && x !== null) x.return = p, vt = x;
            else
                for (; vt !== null;) {
                    p = vt;
                    try {
                        var Ae = p.flags;
                        if (Ae & 32 && Ee && at(p.stateNode), Ae & 512) {
                            var Ve = p.alternate;
                            if (Ve !== null) {
                                var lt = Ve.ref;
                                lt !== null && (typeof lt == "function" ? lt(null) : lt.current = null)
                            }
                        }
                        if (Ae & 8192) switch (p.tag) {
                            case 13:
                                if (p.memoizedState !== null) {
                                    var bt = p.alternate;
                                    (bt === null || bt.memoizedState === null) && (P_ = $n())
                                }
                                break;
                            case 22:
                                var Xt = p.memoizedState !== null,
                                    Nt = p.alternate,
                                    Un = Nt !== null && Nt.memoizedState !== null;
                                if (x = p, Ee) {
                                    e: if (w = x, I = Xt, B = null, Ee)
                                        for (var Ft = w;;) {
                                            if (Ft.tag === 5) {
                                                if (B === null) {
                                                    B = Ft;
                                                    var sr = Ft.stateNode;
                                                    I ? Mt(sr) : ve(Ft.stateNode, Ft.memoizedProps)
                                                }
                                            } else if (Ft.tag === 6) {
                                                if (B === null) {
                                                    var Fs = Ft.stateNode;
                                                    I ? ae(Fs) : we(Fs, Ft.memoizedProps)
                                                }
                                            } else if ((Ft.tag !== 22 && Ft.tag !== 23 || Ft.memoizedState === null || Ft === w) && Ft.child !== null) {
                                                Ft.child.return = Ft, Ft = Ft.child;
                                                continue
                                            }
                                            if (Ft === w) break;
                                            for (; Ft.sibling === null;) {
                                                if (Ft.return === null || Ft.return === w) break e;
                                                B === Ft && (B = null), Ft = Ft.return
                                            }
                                            B === Ft && (B = null), Ft.sibling.return = Ft.return, Ft = Ft.sibling
                                        }
                                }
                                if (Xt && !Un && x.mode & 1) {
                                    vt = x;
                                    for (var Ie = x.child; Ie !== null;) {
                                        for (x = vt = Ie; vt !== null;) {
                                            w = vt;
                                            var Me = w.child;
                                            switch (w.tag) {
                                                case 0:
                                                case 11:
                                                case 14:
                                                case 15:
                                                    ql(4, w, w.return);
                                                    break;
                                                case 1:
                                                    Nm(w, w.return);
                                                    var ze = w.stateNode;
                                                    if (typeof ze.componentWillUnmount == "function") {
                                                        var xt = w.return;
                                                        try {
                                                            ze.props = w.memoizedProps, ze.state = w.memoizedState, ze.componentWillUnmount()
                                                        } catch (Lt) {
                                                            Hr(w, xt, Lt)
                                                        }
                                                    }
                                                    break;
                                                case 5:
                                                    Nm(w, w.return);
                                                    break;
                                                case 22:
                                                    if (w.memoizedState !== null) {
                                                        Ob(x);
                                                        continue
                                                    }
                                            }
                                            Me !== null ? (Me.return = w, vt = Me) : Ob(x)
                                        }
                                        Ie = Ie.sibling
                                    }
                                }
                        }
                        switch (Ae & 4102) {
                            case 2:
                                Db(p), p.flags &= -3;
                                break;
                            case 6:
                                Db(p), p.flags &= -3, M_(p.alternate, p);
                                break;
                            case 4096:
                                p.flags &= -4097;
                                break;
                            case 4100:
                                p.flags &= -4097, M_(p.alternate, p);
                                break;
                            case 4:
                                M_(p.alternate, p)
                        }
                    } catch (Lt) {
                        Hr(p, p.return, Lt)
                    }
                    if (x = p.sibling, x !== null) {
                        x.return = p.return, vt = x;
                        break
                    }
                    vt = p.return
                }
        }
    }

    function EF(h, p, x) {
        vt = h, Fb(h)
    }

    function Fb(h, p, x) {
        for (var w = (h.mode & 1) !== 0; vt !== null;) {
            var I = vt,
                B = I.child;
            if (I.tag === 22 && w) {
                var ie = I.memoizedState !== null || Om;
                if (!ie) {
                    var Ae = I.alternate,
                        Ve = Ae !== null && Ae.memoizedState !== null || Kl;
                    Ae = Om;
                    var lt = Kl;
                    if (Om = ie, (Kl = Ve) && !lt)
                        for (vt = I; vt !== null;) ie = vt, Ve = ie.child, ie.tag === 22 && ie.memoizedState !== null ? Nb(I) : Ve !== null ? (Ve.return = ie, vt = Ve) : Nb(I);
                    for (; B !== null;) vt = B, Fb(B), B = B.sibling;
                    vt = I, Om = Ae, Kl = lt
                }
                Ub(h)
            } else I.subtreeFlags & 8772 && B !== null ? (B.return = I, vt = B) : Ub(h)
        }
    }

    function Ub(h) {
        for (; vt !== null;) {
            var p = vt;
            if (p.flags & 8772) {
                var x = p.alternate;
                try {
                    if (p.flags & 8772) switch (p.tag) {
                        case 0:
                        case 11:
                        case 15:
                            Kl || Oh(5, p);
                            break;
                        case 1:
                            var w = p.stateNode;
                            if (p.flags & 4 && !Kl)
                                if (x === null) w.componentDidMount();
                                else {
                                    var I = p.elementType === p.type ? x.memoizedProps : Ar(p.type, x.memoizedProps);
                                    w.componentDidUpdate(I, x.memoizedState, w.__reactInternalSnapshotBeforeUpdate)
                                }
                            var B = p.updateQueue;
                            B !== null && Pw(p, B, w);
                            break;
                        case 3:
                            var ie = p.updateQueue;
                            if (ie !== null) {
                                if (x = null, p.child !== null) switch (p.child.tag) {
                                    case 5:
                                        x = X(p.child.stateNode);
                                        break;
                                    case 1:
                                        x = p.child.stateNode
                                }
                                Pw(p, ie, x)
                            }
                            break;
                        case 5:
                            var Ae = p.stateNode;
                            x === null && p.flags & 4 && je(Ae, p.type, p.memoizedProps, p);
                            break;
                        case 6:
                            break;
                        case 4:
                            break;
                        case 12:
                            break;
                        case 13:
                            if (xe && p.memoizedState === null) {
                                var Ve = p.alternate;
                                if (Ve !== null) {
                                    var lt = Ve.memoizedState;
                                    if (lt !== null) {
                                        var bt = lt.dehydrated;
                                        bt !== null && F(bt)
                                    }
                                }
                            }
                            break;
                        case 19:
                        case 17:
                        case 21:
                        case 22:
                        case 23:
                            break;
                        default:
                            throw Error(o(163))
                    }
                    Kl || p.flags & 512 && x_(p)
                } catch (Xt) {
                    Hr(p, p.return, Xt)
                }
            }
            if (p === h) {
                vt = null;
                break
            }
            if (x = p.sibling, x !== null) {
                x.return = p.return, vt = x;
                break
            }
            vt = p.return
        }
    }

    function Ob(h) {
        for (; vt !== null;) {
            var p = vt;
            if (p === h) {
                vt = null;
                break
            }
            var x = p.sibling;
            if (x !== null) {
                x.return = p.return, vt = x;
                break
            }
            vt = p.return
        }
    }

    function Nb(h) {
        for (; vt !== null;) {
            var p = vt;
            try {
                switch (p.tag) {
                    case 0:
                    case 11:
                    case 15:
                        var x = p.return;
                        try {
                            Oh(4, p)
                        } catch (Ve) {
                            Hr(p, x, Ve)
                        }
                        break;
                    case 1:
                        var w = p.stateNode;
                        if (typeof w.componentDidMount == "function") {
                            var I = p.return;
                            try {
                                w.componentDidMount()
                            } catch (Ve) {
                                Hr(p, I, Ve)
                            }
                        }
                        var B = p.return;
                        try {
                            x_(p)
                        } catch (Ve) {
                            Hr(p, B, Ve)
                        }
                        break;
                    case 5:
                        var ie = p.return;
                        try {
                            x_(p)
                        } catch (Ve) {
                            Hr(p, ie, Ve)
                        }
                }
            } catch (Ve) {
                Hr(p, p.return, Ve)
            }
            if (p === h) {
                vt = null;
                break
            }
            var Ae = p.sibling;
            if (Ae !== null) {
                Ae.return = p.return, vt = Ae;
                break
            }
            vt = p.return
        }
    }
    var zm = 0,
        Gm = 1,
        Hm = 2,
        Vm = 3,
        Wm = 4;
    if (typeof Symbol == "function" && Symbol.for) {
        var Nh = Symbol.for;
        zm = Nh("selector.component"), Gm = Nh("selector.has_pseudo_class"), Hm = Nh("selector.role"), Vm = Nh("selector.test_id"), Wm = Nh("selector.text")
    }

    function w_(h) {
        var p = J(h);
        if (p != null) {
            if (typeof p.memoizedProps["data-testname"] != "string") throw Error(o(364));
            return p
        }
        if (h = k(h), h === null) throw Error(o(362));
        return h.stateNode.current
    }

    function b_(h, p) {
        switch (p.$$typeof) {
            case zm:
                if (h.type === p.value) return !0;
                break;
            case Gm:
                e: {
                    p = p.value,
                    h = [h, 0];
                    for (var x = 0; x < h.length;) {
                        var w = h[x++],
                            I = h[x++],
                            B = p[I];
                        if (w.tag !== 5 || !ye(w)) {
                            for (; B != null && b_(w, B);) I++, B = p[I];
                            if (I === p.length) {
                                p = !0;
                                break e
                            } else
                                for (w = w.child; w !== null;) h.push(w, I), w = w.sibling
                        }
                    }
                    p = !1
                }
                return p;
            case Hm:
                if (h.tag === 5 && ge(h.stateNode, p.value)) return !0;
                break;
            case Wm:
                if ((h.tag === 5 || h.tag === 6) && (h = ue(h), h !== null && 0 <= h.indexOf(p.value))) return !0;
                break;
            case Vm:
                if (h.tag === 5 && (h = h.memoizedProps["data-testname"], typeof h == "string" && h.toLowerCase() === p.value.toLowerCase())) return !0;
                break;
            default:
                throw Error(o(365))
        }
        return !1
    }

    function T_(h) {
        switch (h.$$typeof) {
            case zm:
                return "<" + (R(h.value) || "Unknown") + ">";
            case Gm:
                return ":has(" + (T_(h) || "") + ")";
            case Hm:
                return '[role="' + h.value + '"]';
            case Wm:
                return '"' + h.value + '"';
            case Vm:
                return '[data-testname="' + h.value + '"]';
            default:
                throw Error(o(365))
        }
    }

    function kb(h, p) {
        var x = [];
        h = [h, 0];
        for (var w = 0; w < h.length;) {
            var I = h[w++],
                B = h[w++],
                ie = p[B];
            if (I.tag !== 5 || !ye(I)) {
                for (; ie != null && b_(I, ie);) B++, ie = p[B];
                if (B === p.length) x.push(I);
                else
                    for (I = I.child; I !== null;) h.push(I, B), I = I.sibling
            }
        }
        return x
    }

    function E_(h, p) {
        if (!Le) throw Error(o(363));
        h = w_(h), h = kb(h, p), p = [], h = Array.from(h);
        for (var x = 0; x < h.length;) {
            var w = h[x++];
            if (w.tag === 5) ye(w) || p.push(w.stateNode);
            else
                for (w = w.child; w !== null;) h.push(w), w = w.sibling
        }
        return p
    }
    var CF = Math.ceil,
        jm = a.ReactCurrentDispatcher,
        C_ = a.ReactCurrentOwner,
        yi = a.ReactCurrentBatchConfig,
        on = 0,
        wi = null,
        bi = null,
        Ji = 0,
        rs = 0,
        Bu = _t(0),
        Pi = 0,
        kh = null,
        Du = 0,
        Xm = 0,
        R_ = 0,
        zh = null,
        zr = null,
        P_ = 0,
        I_ = 1 / 0;

    function Lu() {
        I_ = $n() + 500
    }
    var Ym = !1,
        B_ = null,
        Da = null,
        Jm = !1,
        La = null,
        Km = 0,
        Gh = 0,
        D_ = null,
        qm = -1,
        Zm = 0;

    function wr() {
        return on & 6 ? $n() : qm !== -1 ? qm : qm = $n()
    }

    function Fa(h) {
        return h.mode & 1 ? on & 2 && Ji !== 0 ? Ji & -Ji : Vl.transition !== null ? (Zm === 0 && (h = Go, Go <<= 1, !(Go & 4194240) && (Go = 64), Zm = h), Zm) : (h = un, h !== 0 ? h : Ce()) : 1
    }

    function Ds(h, p, x) {
        if (50 < Gh) throw Gh = 0, D_ = null, Error(o(185));
        var w = Qm(h, p);
        return w === null ? null : (yo(w, p, x), (!(on & 2) || w !== wi) && (w === wi && (!(on & 2) && (Xm |= p), Pi === 4 && Ua(w, Ji)), Gr(w, x), p === 1 && on === 0 && !(h.mode & 1) && (Lu(), xo && kr())), w)
    }

    function Qm(h, p) {
        h.lanes |= p;
        var x = h.alternate;
        for (x !== null && (x.lanes |= p), x = h, h = h.return; h !== null;) h.childLanes |= p, x = h.alternate, x !== null && (x.childLanes |= p), x = h, h = h.return;
        return x.tag === 3 ? x.stateNode : null
    }

    function Gr(h, p) {
        var x = h.callbackNode;
        yh(h, p);
        var w = zl(h, h === wi ? Ji : 0);
        if (w === 0) x !== null && Su(x), h.callbackNode = null, h.callbackPriority = 0;
        else if (p = w & -w, h.callbackPriority !== p) {
            if (x != null && Su(x), p === 1) h.tag === 0 ? wh(Gb.bind(null, h)) : Mh(Gb.bind(null, h)), Se ? Xe(function() {
                on === 0 && kr()
            }) : jo(Gl, kr), x = null;
            else {
                switch (_h(w)) {
                    case 1:
                        x = Gl;
                        break;
                    case 4:
                        x = mm;
                        break;
                    case 16:
                        x = _r;
                        break;
                    case 536870912:
                        x = Ah;
                        break;
                    default:
                        x = _r
                }
                x = qb(x, zb.bind(null, h))
            }
            h.callbackPriority = p, h.callbackNode = x
        }
    }

    function zb(h, p) {
        if (qm = -1, Zm = 0, on & 6) throw Error(o(327));
        var x = h.callbackNode;
        if ($l() && h.callbackNode !== x) return null;
        var w = zl(h, h === wi ? Ji : 0);
        if (w === 0) return null;
        if (w & 30 || w & h.expiredLanes || p) p = $m(h, w);
        else {
            p = w;
            var I = on;
            on |= 2;
            var B = Wb();
            (wi !== h || Ji !== p) && (Lu(), Zl(h, p));
            do try {
                IF();
                break
            } catch (Ae) {
                Vb(h, Ae)
            }
            while (!0);
            wu(), jm.current = B, on = I, bi !== null ? p = 0 : (wi = null, Ji = 0, p = Pi)
        }
        if (p !== 0) {
            if (p === 2 && (I = Wo(h), I !== 0 && (w = I, p = L_(h, I))), p === 1) throw x = kh, Zl(h, 0), Ua(h, w), Gr(h, $n()), x;
            if (p === 6) Ua(h, w);
            else {
                if (I = h.current.alternate, !(w & 30) && !RF(I) && (p = $m(h, w), p === 2 && (B = Wo(h), B !== 0 && (w = B, p = L_(h, B))), p === 1)) throw x = kh, Zl(h, 0), Ua(h, w), Gr(h, $n()), x;
                switch (h.finishedWork = I, h.finishedLanes = w, p) {
                    case 0:
                    case 1:
                        throw Error(o(345));
                    case 2:
                        Ql(h, zr);
                        break;
                    case 3:
                        if (Ua(h, w), (w & 130023424) === w && (p = P_ + 500 - $n(), 10 < p)) {
                            if (zl(h, 0) !== 0) break;
                            if (I = h.suspendedLanes, (I & w) !== w) {
                                wr(), h.pingedLanes |= h.suspendedLanes & I;
                                break
                            }
                            h.timeoutHandle = ce(Ql.bind(null, h, zr), p);
                            break
                        }
                        Ql(h, zr);
                        break;
                    case 4:
                        if (Ua(h, w), (w & 4194240) === w) break;
                        for (p = h.eventTimes, I = -1; 0 < w;) {
                            var ie = 31 - sn(w);
                            B = 1 << ie, ie = p[ie], ie > I && (I = ie), w &= ~B
                        }
                        if (w = I, w = $n() - w, w = (120 > w ? 120 : 480 > w ? 480 : 1080 > w ? 1080 : 1920 > w ? 1920 : 3e3 > w ? 3e3 : 4320 > w ? 4320 : 1960 * CF(w / 1960)) - w, 10 < w) {
                            h.timeoutHandle = ce(Ql.bind(null, h, zr), w);
                            break
                        }
                        Ql(h, zr);
                        break;
                    case 5:
                        Ql(h, zr);
                        break;
                    default:
                        throw Error(o(329))
                }
            }
        }
        return Gr(h, $n()), h.callbackNode === x ? zb.bind(null, h) : null
    }

    function L_(h, p) {
        var x = zh;
        return h.current.memoizedState.isDehydrated && (Zl(h, p).flags |= 256), h = $m(h, p), h !== 2 && (p = zr, zr = x, p !== null && F_(p)), h
    }

    function F_(h) {
        zr === null ? zr = h : zr.push.apply(zr, h)
    }

    function RF(h) {
        for (var p = h;;) {
            if (p.flags & 16384) {
                var x = p.updateQueue;
                if (x !== null && (x = x.stores, x !== null))
                    for (var w = 0; w < x.length; w++) {
                        var I = x[w],
                            B = I.getSnapshot;
                        I = I.value;
                        try {
                            if (!$r(B(), I)) return !1
                        } catch {
                            return !1
                        }
                    }
            }
            if (x = p.child, p.subtreeFlags & 16384 && x !== null) x.return = p, p = x;
            else {
                if (p === h) break;
                for (; p.sibling === null;) {
                    if (p.return === null || p.return === h) return !0;
                    p = p.return
                }
                p.sibling.return = p.return, p = p.sibling
            }
        }
        return !0
    }

    function Ua(h, p) {
        for (p &= ~R_, p &= ~Xm, h.suspendedLanes |= p, h.pingedLanes &= ~p, h = h.expirationTimes; 0 < p;) {
            var x = 31 - sn(p),
                w = 1 << x;
            h[x] = -1, p &= ~w
        }
    }

    function Gb(h) {
        if (on & 6) throw Error(o(327));
        $l();
        var p = zl(h, 0);
        if (!(p & 1)) return Gr(h, $n()), null;
        var x = $m(h, p);
        if (h.tag !== 0 && x === 2) {
            var w = Wo(h);
            w !== 0 && (p = w, x = L_(h, w))
        }
        if (x === 1) throw x = kh, Zl(h, 0), Ua(h, p), Gr(h, $n()), x;
        if (x === 6) throw Error(o(345));
        return h.finishedWork = h.current.alternate, h.finishedLanes = p, Ql(h, zr), Gr(h, $n()), null
    }

    function Hb(h) {
        La !== null && La.tag === 0 && !(on & 6) && $l();
        var p = on;
        on |= 1;
        var x = yi.transition,
            w = un;
        try {
            if (yi.transition = null, un = 1, h) return h()
        } finally {
            un = w, yi.transition = x, on = p, !(on & 6) && kr()
        }
    }

    function U_() {
        rs = Bu.current, ht(Bu)
    }

    function Zl(h, p) {
        h.finishedWork = null, h.finishedLanes = 0;
        var x = h.timeoutHandle;
        if (x !== Oe && (h.timeoutHandle = Oe, _e(x)), bi !== null)
            for (x = bi.return; x !== null;) {
                var w = x;
                switch ($y(w), w.tag) {
                    case 1:
                        w = w.type.childContextTypes, w != null && cn();
                        break;
                    case 3:
                        Pu(), ht(Ut), ht(ct), o_();
                        break;
                    case 5:
                        r_(w);
                        break;
                    case 4:
                        Pu();
                        break;
                    case 13:
                        ht(ei);
                        break;
                    case 19:
                        ht(ei);
                        break;
                    case 10:
                        Oi(w.type._context);
                        break;
                    case 22:
                    case 23:
                        U_()
                }
                x = x.return
            }
        if (wi = h, bi = h = Oa(h.current, null), Ji = rs = p, Pi = 0, kh = null, R_ = Xm = Du = 0, zr = zh = null, es !== null) {
            for (p = 0; p < es.length; p++)
                if (x = es[p], w = x.interleaved, w !== null) {
                    x.interleaved = null;
                    var I = w.next,
                        B = x.pending;
                    if (B !== null) {
                        var ie = B.next;
                        B.next = I, w.next = ie
                    }
                    x.pending = w
                }
            es = null
        }
        return h
    }

    function Vb(h, p) {
        do {
            var x = bi;
            try {
                if (wu(), bm.current = Im, Tm) {
                    for (var w = li.memoizedState; w !== null;) {
                        var I = w.queue;
                        I !== null && (I.pending = null), w = w.next
                    }
                    Tm = !1
                }
                if (Iu = 0, Ni = nr = li = null, Ph = !1, Ih = 0, C_.current = null, x === null || x.return === null) {
                    Pi = 1, kh = p, bi = null;
                    break
                }
                e: {
                    var B = h,
                        ie = x.return,
                        Ae = x,
                        Ve = p;
                    if (p = Ji, Ae.flags |= 32768, Ve !== null && typeof Ve == "object" && typeof Ve.then == "function") {
                        var lt = Ve,
                            bt = Ae,
                            Xt = bt.tag;
                        if (!(bt.mode & 1) && (Xt === 0 || Xt === 11 || Xt === 15)) {
                            var Nt = bt.alternate;
                            Nt ? (bt.updateQueue = Nt.updateQueue, bt.memoizedState = Nt.memoizedState, bt.lanes = Nt.lanes) : (bt.updateQueue = null, bt.memoizedState = null)
                        }
                        var Un = ub(ie);
                        if (Un !== null) {
                            Un.flags &= -257, fb(Un, ie, Ae, B, p), Un.mode & 1 && cb(B, lt, p), p = Un, Ve = lt;
                            var Ft = p.updateQueue;
                            if (Ft === null) {
                                var sr = new Set;
                                sr.add(Ve), p.updateQueue = sr
                            } else Ft.add(Ve);
                            break e
                        } else {
                            if (!(p & 1)) {
                                cb(B, lt, p), O_();
                                break e
                            }
                            Ve = Error(o(426))
                        }
                    } else if (Yn && Ae.mode & 1) {
                        var Fs = ub(ie);
                        if (Fs !== null) {
                            !(Fs.flags & 65536) && (Fs.flags |= 256), fb(Fs, ie, Ae, B, p), n_(Ve);
                            break e
                        }
                    }
                    B = Ve,
                    Pi !== 4 && (Pi = 2),
                    zh === null ? zh = [B] : zh.push(B),
                    Ve = d_(Ve, Ae),
                    Ae = ie;do {
                        switch (Ae.tag) {
                            case 3:
                                Ae.flags |= 65536, p &= -p, Ae.lanes |= p;
                                var Ie = ab(Ae, Ve, p);
                                Rw(Ae, Ie);
                                break e;
                            case 1:
                                B = Ve;
                                var Me = Ae.type,
                                    ze = Ae.stateNode;
                                if (!(Ae.flags & 128) && (typeof Me.getDerivedStateFromError == "function" || ze !== null && typeof ze.componentDidCatch == "function" && (Da === null || !Da.has(ze)))) {
                                    Ae.flags |= 65536, p &= -p, Ae.lanes |= p;
                                    var xt = lb(Ae, B, p);
                                    Rw(Ae, xt);
                                    break e
                                }
                        }
                        Ae = Ae.return
                    } while (Ae !== null)
                }
                Xb(x)
            } catch (Lt) {
                p = Lt, bi === x && x !== null && (bi = x = x.return);
                continue
            }
            break
        } while (!0)
    }

    function Wb() {
        var h = jm.current;
        return jm.current = Im, h === null ? Im : h
    }

    function O_() {
        (Pi === 0 || Pi === 3 || Pi === 2) && (Pi = 4), wi === null || !(Du & 268435455) && !(Xm & 268435455) || Ua(wi, Ji)
    }

    function $m(h, p) {
        var x = on;
        on |= 2;
        var w = Wb();
        wi === h && Ji === p || Zl(h, p);
        do try {
            PF();
            break
        } catch (I) {
            Vb(h, I)
        }
        while (!0);
        if (wu(), on = x, jm.current = w, bi !== null) throw Error(o(261));
        return wi = null, Ji = 0, Pi
    }

    function PF() {
        for (; bi !== null;) jb(bi)
    }

    function IF() {
        for (; bi !== null && !xh();) jb(bi)
    }

    function jb(h) {
        var p = Kb(h.alternate, h, rs);
        h.memoizedProps = h.pendingProps, p === null ? Xb(h) : bi = p, C_.current = null
    }

    function Xb(h) {
        var p = h;
        do {
            var x = p.alternate;
            if (h = p.return, p.flags & 32768) {
                if (x = MF(x, p), x !== null) {
                    x.flags &= 32767, bi = x;
                    return
                }
                if (h !== null) h.flags |= 32768, h.subtreeFlags = 0, h.deletions = null;
                else {
                    Pi = 6, bi = null;
                    return
                }
            } else if (x = xF(x, p, rs), x !== null) {
                bi = x;
                return
            }
            if (p = p.sibling, p !== null) {
                bi = p;
                return
            }
            bi = p = h
        } while (p !== null);
        Pi === 0 && (Pi = 5)
    }

    function Ql(h, p) {
        var x = un,
            w = yi.transition;
        try {
            yi.transition = null, un = 1, BF(h, p, x)
        } finally {
            yi.transition = w, un = x
        }
        return null
    }

    function BF(h, p, x) {
        do $l(); while (La !== null);
        if (on & 6) throw Error(o(327));
        var w = h.finishedWork,
            I = h.finishedLanes;
        if (w === null) return null;
        if (h.finishedWork = null, h.finishedLanes = 0, w === h.current) throw Error(o(177));
        h.callbackNode = null, h.callbackPriority = 0;
        var B = w.lanes | w.childLanes;
        if (Ra(h, B), h === wi && (bi = wi = null, Ji = 0), !(w.subtreeFlags & 2064) && !(w.flags & 2064) || Jm || (Jm = !0, qb(_r, function() {
                return $l(), null
            })), B = (w.flags & 15990) !== 0, w.subtreeFlags & 15990 || B) {
            B = yi.transition, yi.transition = null;
            var ie = un;
            un = 1;
            var Ae = on;
            on |= 4, C_.current = null, bF(h, w), TF(h, w), U(h.containerInfo), h.current = w, EF(w), pm(), on = Ae, un = ie, yi.transition = B
        } else h.current = w;
        if (Jm && (Jm = !1, La = h, Km = I), B = h.pendingLanes, B === 0 && (Da = null), Sh(w.stateNode), Gr(h, $n()), p !== null)
            for (x = h.onRecoverableError, w = 0; w < p.length; w++) x(p[w]);
        if (Ym) throw Ym = !1, h = B_, B_ = null, h;
        return Km & 1 && h.tag !== 0 && $l(), B = h.pendingLanes, B & 1 ? h === D_ ? Gh++ : (Gh = 0, D_ = h) : Gh = 0, kr(), null
    }

    function $l() {
        if (La !== null) {
            var h = _h(Km),
                p = yi.transition,
                x = un;
            try {
                if (yi.transition = null, un = 16 > h ? 16 : h, La === null) var w = !1;
                else {
                    if (h = La, La = null, Km = 0, on & 6) throw Error(o(331));
                    var I = on;
                    for (on |= 4, vt = h.current; vt !== null;) {
                        var B = vt,
                            ie = B.child;
                        if (vt.flags & 16) {
                            var Ae = B.deletions;
                            if (Ae !== null) {
                                for (var Ve = 0; Ve < Ae.length; Ve++) {
                                    var lt = Ae[Ve];
                                    for (vt = lt; vt !== null;) {
                                        var bt = vt;
                                        switch (bt.tag) {
                                            case 0:
                                            case 11:
                                            case 15:
                                                ql(8, bt, B)
                                        }
                                        var Xt = bt.child;
                                        if (Xt !== null) Xt.return = bt, vt = Xt;
                                        else
                                            for (; vt !== null;) {
                                                bt = vt;
                                                var Nt = bt.sibling,
                                                    Un = bt.return;
                                                if (Pb(bt), bt === lt) {
                                                    vt = null;
                                                    break
                                                }
                                                if (Nt !== null) {
                                                    Nt.return = Un, vt = Nt;
                                                    break
                                                }
                                                vt = Un
                                            }
                                    }
                                }
                                var Ft = B.alternate;
                                if (Ft !== null) {
                                    var sr = Ft.child;
                                    if (sr !== null) {
                                        Ft.child = null;
                                        do {
                                            var Fs = sr.sibling;
                                            sr.sibling = null, sr = Fs
                                        } while (sr !== null)
                                    }
                                }
                                vt = B
                            }
                        }
                        if (B.subtreeFlags & 2064 && ie !== null) ie.return = B, vt = ie;
                        else e: for (; vt !== null;) {
                            if (B = vt, B.flags & 2048) switch (B.tag) {
                                case 0:
                                case 11:
                                case 15:
                                    ql(9, B, B.return)
                            }
                            var Ie = B.sibling;
                            if (Ie !== null) {
                                Ie.return = B.return, vt = Ie;
                                break e
                            }
                            vt = B.return
                        }
                    }
                    var Me = h.current;
                    for (vt = Me; vt !== null;) {
                        ie = vt;
                        var ze = ie.child;
                        if (ie.subtreeFlags & 2064 && ze !== null) ze.return = ie, vt = ze;
                        else e: for (ie = Me; vt !== null;) {
                            if (Ae = vt, Ae.flags & 2048) try {
                                switch (Ae.tag) {
                                    case 0:
                                    case 11:
                                    case 15:
                                        Oh(9, Ae)
                                }
                            } catch (Lt) {
                                Hr(Ae, Ae.return, Lt)
                            }
                            if (Ae === ie) {
                                vt = null;
                                break e
                            }
                            var xt = Ae.sibling;
                            if (xt !== null) {
                                xt.return = Ae.return, vt = xt;
                                break e
                            }
                            vt = Ae.return
                        }
                    }
                    if (on = I, kr(), Qr && typeof Qr.onPostCommitFiberRoot == "function") try {
                        Qr.onPostCommitFiberRoot(Hl, h)
                    } catch {}
                    w = !0
                }
                return w
            } finally {
                un = x, yi.transition = p
            }
        }
        return !1
    }

    function Yb(h, p, x) {
        p = d_(x, p), p = ab(h, p, 1), Ba(h, p), p = wr(), h = Qm(h, 1), h !== null && (yo(h, 1, p), Gr(h, p))
    }

    function Hr(h, p, x) {
        if (h.tag === 3) Yb(h, h, x);
        else
            for (; p !== null;) {
                if (p.tag === 3) {
                    Yb(p, h, x);
                    break
                } else if (p.tag === 1) {
                    var w = p.stateNode;
                    if (typeof p.type.getDerivedStateFromError == "function" || typeof w.componentDidCatch == "function" && (Da === null || !Da.has(w))) {
                        h = d_(x, h), h = lb(p, h, 1), Ba(p, h), h = wr(), p = Qm(p, 1), p !== null && (yo(p, 1, h), Gr(p, h));
                        break
                    }
                }
                p = p.return
            }
    }

    function DF(h, p, x) {
        var w = h.pingCache;
        w !== null && w.delete(p), p = wr(), h.pingedLanes |= h.suspendedLanes & x, wi === h && (Ji & x) === x && (Pi === 4 || Pi === 3 && (Ji & 130023424) === Ji && 500 > $n() - P_ ? Zl(h, 0) : R_ |= x), Gr(h, p)
    }

    function Jb(h, p) {
        p === 0 && (h.mode & 1 ? (p = Ho, Ho <<= 1, !(Ho & 130023424) && (Ho = 4194304)) : p = 1);
        var x = wr();
        h = Qm(h, p), h !== null && (yo(h, p, x), Gr(h, x))
    }

    function LF(h) {
        var p = h.memoizedState,
            x = 0;
        p !== null && (x = p.retryLane), Jb(h, x)
    }

    function FF(h, p) {
        var x = 0;
        switch (h.tag) {
            case 13:
                var w = h.stateNode,
                    I = h.memoizedState;
                I !== null && (x = I.retryLane);
                break;
            case 19:
                w = h.stateNode;
                break;
            default:
                throw Error(o(314))
        }
        w !== null && w.delete(p), Jb(h, x)
    }
    var Kb;
    Kb = function(h, p, x) {
        if (h !== null)
            if (h.memoizedProps !== p.pendingProps || Ut.current) is = !0;
            else {
                if (!(h.lanes & x) && !(p.flags & 128)) return is = !1, SF(h, p, x);
                is = !!(h.flags & 131072)
            }
        else is = !1, Yn && p.flags & 1048576 && Fw(p, Sm, p.index);
        switch (p.lanes = 0, p.tag) {
            case 2:
                var w = p.type;
                h !== null && (h.alternate = null, p.alternate = null, p.flags |= 2), h = p.pendingProps;
                var I = Mn(p, ct.current);
                gi(p, x), I = l_(null, p, w, h, I, x);
                var B = c_();
                return p.flags |= 1, typeof I == "object" && I !== null && typeof I.render == "function" && I.$$typeof === void 0 ? (p.tag = 1, p.memoizedState = null, p.updateQueue = null, In(w) ? (B = !0, Wt(p)) : B = !1, p.memoizedState = I.state !== null && I.state !== void 0 ? I.state : null, Ky(p), I.updater = xm, p.stateNode = I, I._reactInternals = p, Zy(p, w, h, x), p = g_(null, p, w, !0, B, x)) : (p.tag = 0, Yn && B && Qy(p), Mr(null, p, I, x), p = p.child), p;
            case 16:
                w = p.elementType;
                e: {
                    switch (h !== null && (h.alternate = null, p.alternate = null, p.flags |= 2), h = p.pendingProps, I = w._init, w = I(w._payload), p.type = w, I = p.tag = OF(w), h = Ar(w, h), I) {
                        case 0:
                            p = m_(null, p, w, h, x);
                            break e;
                        case 1:
                            p = _b(null, p, w, h, x);
                            break e;
                        case 11:
                            p = pb(null, p, w, h, x);
                            break e;
                        case 14:
                            p = mb(null, p, w, Ar(w.type, h), x);
                            break e
                    }
                    throw Error(o(306, w, ""))
                }
                return p;
            case 0:
                return w = p.type, I = p.pendingProps, I = p.elementType === w ? I : Ar(w, I), m_(h, p, w, I, x);
            case 1:
                return w = p.type, I = p.pendingProps, I = p.elementType === w ? I : Ar(w, I), _b(h, p, w, I, x);
            case 3:
                e: {
                    if (xb(p), h === null) throw Error(o(387));w = p.pendingProps,
                    B = p.memoizedState,
                    I = B.element,
                    Cw(h, p),
                    _m(p, w, null, x);
                    var ie = p.memoizedState;
                    if (w = ie.element, xe && B.isDehydrated)
                        if (B = {
                                element: w,
                                isDehydrated: !1,
                                cache: ie.cache,
                                transitions: ie.transitions
                            }, p.updateQueue.baseState = B, p.memoizedState = B, p.flags & 256) {
                            I = Error(o(423)), p = Ab(h, p, w, x, I);
                            break e
                        } else if (w !== I) {
                        I = Error(o(424)), p = Ab(h, p, w, x, I);
                        break e
                    } else
                        for (xe && (ns = $t(p.stateNode.containerInfo), ts = p, Yn = !0, to = null, bh = !1), x = Gw(p, null, w, x), p.child = x; x;) x.flags = x.flags & -3 | 4096, x = x.sibling;
                    else {
                        if (Eu(), w === I) {
                            p = qo(h, p, x);
                            break e
                        }
                        Mr(h, p, w, x)
                    }
                    p = p.child
                }
                return p;
            case 5:
                return Hw(p), h === null && t_(p), w = p.type, I = p.pendingProps, B = h !== null ? h.memoizedProps : null, ie = I.children, ne(w, I) ? ie = null : B !== null && ne(w, B) && (p.flags |= 32), yb(h, p), Mr(h, p, ie, x), p.child;
            case 6:
                return h === null && t_(p), null;
            case 13:
                return Sb(h, p, x);
            case 4:
                return i_(p, p.stateNode.containerInfo), w = p.pendingProps, h === null ? p.child = Cu(p, null, w, x) : Mr(h, p, w, x), p.child;
            case 11:
                return w = p.type, I = p.pendingProps, I = p.elementType === w ? I : Ar(w, I), pb(h, p, w, I, x);
            case 7:
                return Mr(h, p, p.pendingProps, x), p.child;
            case 8:
                return Mr(h, p, p.pendingProps.children, x), p.child;
            case 12:
                return Mr(h, p, p.pendingProps.children, x), p.child;
            case 10:
                e: {
                    if (w = p.type._context, I = p.pendingProps, B = p.memoizedProps, ie = I.value, vm(p, w, ie), B !== null)
                        if ($r(B.value, ie)) {
                            if (B.children === I.children && !Ut.current) {
                                p = qo(h, p, x);
                                break e
                            }
                        } else
                            for (B = p.child, B !== null && (B.return = p); B !== null;) {
                                var Ae = B.dependencies;
                                if (Ae !== null) {
                                    ie = B.child;
                                    for (var Ve = Ae.firstContext; Ve !== null;) {
                                        if (Ve.context === w) {
                                            if (B.tag === 1) {
                                                Ve = Xo(-1, x & -x), Ve.tag = 2;
                                                var lt = B.updateQueue;
                                                if (lt !== null) {
                                                    lt = lt.shared;
                                                    var bt = lt.pending;
                                                    bt === null ? Ve.next = Ve : (Ve.next = bt.next, bt.next = Ve), lt.pending = Ve
                                                }
                                            }
                                            B.lanes |= x, Ve = B.alternate, Ve !== null && (Ve.lanes |= x), Sr(B.return, x, p), Ae.lanes |= x;
                                            break
                                        }
                                        Ve = Ve.next
                                    }
                                } else if (B.tag === 10) ie = B.type === p.type ? null : B.child;
                                else if (B.tag === 18) {
                                    if (ie = B.return, ie === null) throw Error(o(341));
                                    ie.lanes |= x, Ae = ie.alternate, Ae !== null && (Ae.lanes |= x), Sr(ie, x, p), ie = B.sibling
                                } else ie = B.child;
                                if (ie !== null) ie.return = B;
                                else
                                    for (ie = B; ie !== null;) {
                                        if (ie === p) {
                                            ie = null;
                                            break
                                        }
                                        if (B = ie.sibling, B !== null) {
                                            B.return = ie.return, ie = B;
                                            break
                                        }
                                        ie = ie.return
                                    }
                                B = ie
                            }
                    Mr(h, p, I.children, x),
                    p = p.child
                }
                return p;
            case 9:
                return I = p.type, w = p.pendingProps.children, gi(p, x), I = vi(I), w = w(I), p.flags |= 1, Mr(h, p, w, x), p.child;
            case 14:
                return w = p.type, I = Ar(w, p.pendingProps), I = Ar(w.type, I), mb(h, p, w, I, x);
            case 15:
                return gb(h, p, p.type, p.pendingProps, x);
            case 17:
                return w = p.type, I = p.pendingProps, I = p.elementType === w ? I : Ar(w, I), h !== null && (h.alternate = null, p.alternate = null, p.flags |= 2), p.tag = 1, In(w) ? (h = !0, Wt(p)) : h = !1, gi(p, x), Dw(p, w, I), Zy(p, w, I, x), g_(null, p, w, !0, h, x);
            case 19:
                return Tb(h, p, x);
            case 22:
                return vb(h, p, x)
        }
        throw Error(o(156, p.tag))
    };

    function qb(h, p) {
        return jo(h, p)
    }

    function UF(h, p, x, w) {
        this.tag = h, this.key = x, this.sibling = this.child = this.return = this.stateNode = this.type = this.elementType = null, this.index = 0, this.ref = null, this.pendingProps = p, this.dependencies = this.memoizedState = this.updateQueue = this.memoizedProps = null, this.mode = w, this.subtreeFlags = this.flags = 0, this.deletions = null, this.childLanes = this.lanes = 0, this.alternate = null
    }

    function Ls(h, p, x, w) {
        return new UF(h, p, x, w)
    }

    function N_(h) {
        return h = h.prototype, !(!h || !h.isReactComponent)
    }

    function OF(h) {
        if (typeof h == "function") return N_(h) ? 1 : 0;
        if (h != null) {
            if (h = h.$$typeof, h === y) return 11;
            if (h === A) return 14
        }
        return 2
    }

    function Oa(h, p) {
        var x = h.alternate;
        return x === null ? (x = Ls(h.tag, p, h.key, h.mode), x.elementType = h.elementType, x.type = h.type, x.stateNode = h.stateNode, x.alternate = h, h.alternate = x) : (x.pendingProps = p, x.type = h.type, x.flags = 0, x.subtreeFlags = 0, x.deletions = null), x.flags = h.flags & 14680064, x.childLanes = h.childLanes, x.lanes = h.lanes, x.child = h.child, x.memoizedProps = h.memoizedProps, x.memoizedState = h.memoizedState, x.updateQueue = h.updateQueue, p = h.dependencies, x.dependencies = p === null ? null : {
            lanes: p.lanes,
            firstContext: p.firstContext
        }, x.sibling = h.sibling, x.index = h.index, x.ref = h.ref, x
    }

    function eg(h, p, x, w, I, B) {
        var ie = 2;
        if (w = h, typeof h == "function") N_(h) && (ie = 1);
        else if (typeof h == "string") ie = 5;
        else e: switch (h) {
            case u:
                return ec(x.children, I, B, p);
            case f:
                ie = 8, I |= 8;
                break;
            case d:
                return h = Ls(12, x, p, I | 2), h.elementType = d, h.lanes = B, h;
            case v:
                return h = Ls(13, x, p, I), h.elementType = v, h.lanes = B, h;
            case _:
                return h = Ls(19, x, p, I), h.elementType = _, h.lanes = B, h;
            case M:
                return tg(x, I, B, p);
            default:
                if (typeof h == "object" && h !== null) switch (h.$$typeof) {
                    case m:
                        ie = 10;
                        break e;
                    case g:
                        ie = 9;
                        break e;
                    case y:
                        ie = 11;
                        break e;
                    case A:
                        ie = 14;
                        break e;
                    case S:
                        ie = 16, w = null;
                        break e
                }
                throw Error(o(130, h == null ? h : typeof h, ""))
        }
        return p = Ls(ie, x, p, I), p.elementType = h, p.type = w, p.lanes = B, p
    }

    function ec(h, p, x, w) {
        return h = Ls(7, h, w, p), h.lanes = x, h
    }

    function tg(h, p, x, w) {
        return h = Ls(22, h, w, p), h.elementType = M, h.lanes = x, h.stateNode = {}, h
    }

    function k_(h, p, x) {
        return h = Ls(6, h, null, p), h.lanes = x, h
    }

    function z_(h, p, x) {
        return p = Ls(4, h.children !== null ? h.children : [], h.key, p), p.lanes = x, p.stateNode = {
            containerInfo: h.containerInfo,
            pendingChildren: null,
            implementation: h.implementation
        }, p
    }

    function NF(h, p, x, w, I) {
        this.tag = p, this.containerInfo = h, this.finishedWork = this.pingCache = this.current = this.pendingChildren = null, this.timeoutHandle = Oe, this.callbackNode = this.pendingContext = this.context = null, this.callbackPriority = 0, this.eventTimes = Au(0), this.expirationTimes = Au(-1), this.entangledLanes = this.finishedLanes = this.mutableReadLanes = this.expiredLanes = this.pingedLanes = this.suspendedLanes = this.pendingLanes = 0, this.entanglements = Au(0), this.identifierPrefix = w, this.onRecoverableError = I, xe && (this.mutableSourceEagerHydrationData = null)
    }

    function Zb(h, p, x, w, I, B, ie, Ae, Ve) {
        return h = new NF(h, p, x, Ae, Ve), p === 1 ? (p = 1, B === !0 && (p |= 8)) : p = 0, B = Ls(3, null, null, p), h.current = B, B.stateNode = h, B.memoizedState = {
            element: w,
            isDehydrated: x,
            cache: null,
            transitions: null
        }, Ky(B), h
    }

    function Qb(h) {
        if (!h) return At;
        h = h._reactInternals;
        e: {
            if (b(h) !== h || h.tag !== 1) throw Error(o(170));
            var p = h;do {
                switch (p.tag) {
                    case 3:
                        p = p.stateNode.context;
                        break e;
                    case 1:
                        if (In(p.type)) {
                            p = p.stateNode.__reactInternalMemoizedMergedChildContext;
                            break e
                        }
                }
                p = p.return
            } while (p !== null);
            throw Error(o(171))
        }
        if (h.tag === 1) {
            var x = h.type;
            if (In(x)) return Gt(h, x, p)
        }
        return p
    }

    function $b(h) {
        var p = h._reactInternals;
        if (p === void 0) throw typeof h.render == "function" ? Error(o(188)) : (h = Object.keys(h).join(","), Error(o(268, h)));
        return h = D(p), h === null ? null : h.stateNode
    }

    function eT(h, p) {
        if (h = h.memoizedState, h !== null && h.dehydrated !== null) {
            var x = h.retryLane;
            h.retryLane = x !== 0 && x < p ? x : p
        }
    }

    function G_(h, p) {
        eT(h, p), (h = h.alternate) && eT(h, p)
    }

    function kF(h) {
        return h = D(h), h === null ? null : h.stateNode
    }

    function zF() {
        return null
    }
    return t.attemptContinuousHydration = function(h) {
        if (h.tag === 13) {
            var p = wr();
            Ds(h, 134217728, p), G_(h, 134217728)
        }
    }, t.attemptHydrationAtCurrentPriority = function(h) {
        if (h.tag === 13) {
            var p = wr(),
                x = Fa(h);
            Ds(h, x, p), G_(h, x)
        }
    }, t.attemptSynchronousHydration = function(h) {
        switch (h.tag) {
            case 3:
                var p = h.stateNode;
                if (p.current.memoizedState.isDehydrated) {
                    var x = Vo(p.pendingLanes);
                    x !== 0 && (_o(p, x | 1), Gr(p, $n()), !(on & 6) && (Lu(), kr()))
                }
                break;
            case 13:
                var w = wr();
                Hb(function() {
                    return Ds(h, 1, w)
                }), G_(h, 1)
        }
    }, t.batchedUpdates = function(h, p) {
        var x = on;
        on |= 1;
        try {
            return h(p)
        } finally {
            on = x, on === 0 && (Lu(), xo && kr())
        }
    }, t.createComponentSelector = function(h) {
        return {
            $$typeof: zm,
            value: h
        }
    }, t.createContainer = function(h, p, x, w, I, B, ie) {
        return Zb(h, p, !1, null, x, w, I, B, ie)
    }, t.createHasPseudoClassSelector = function(h) {
        return {
            $$typeof: Gm,
            value: h
        }
    }, t.createHydrationContainer = function(h, p, x, w, I, B, ie, Ae, Ve) {
        return h = Zb(x, w, !0, h, I, B, ie, Ae, Ve), h.context = Qb(null), x = h.current, w = wr(), I = Fa(x), B = Xo(w, I), B.callback = p ? ? null, Ba(x, B), h.current.lanes = I, yo(h, I, w), Gr(h, w), h
    }, t.createPortal = function(h, p, x) {
        var w = 3 < arguments.length && arguments[3] !== void 0 ? arguments[3] : null;
        return {
            $$typeof: c,
            key: w == null ? null : "" + w,
            children: h,
            containerInfo: p,
            implementation: x
        }
    }, t.createRoleSelector = function(h) {
        return {
            $$typeof: Hm,
            value: h
        }
    }, t.createTestNameSelector = function(h) {
        return {
            $$typeof: Vm,
            value: h
        }
    }, t.createTextSelector = function(h) {
        return {
            $$typeof: Wm,
            value: h
        }
    }, t.deferredUpdates = function(h) {
        var p = un,
            x = yi.transition;
        try {
            return yi.transition = null, un = 16, h()
        } finally {
            un = p, yi.transition = x
        }
    }, t.discreteUpdates = function(h, p, x, w, I) {
        var B = un,
            ie = yi.transition;
        try {
            return yi.transition = null, un = 1, h(p, x, w, I)
        } finally {
            un = B, yi.transition = ie, on === 0 && Lu()
        }
    }, t.findAllNodes = E_, t.findBoundingRects = function(h, p) {
        if (!Le) throw Error(o(363));
        p = E_(h, p), h = [];
        for (var x = 0; x < p.length; x++) h.push(z(p[x]));
        for (p = h.length - 1; 0 < p; p--) {
            x = h[p];
            for (var w = x.x, I = w + x.width, B = x.y, ie = B + x.height, Ae = p - 1; 0 <= Ae; Ae--)
                if (p !== Ae) {
                    var Ve = h[Ae],
                        lt = Ve.x,
                        bt = lt + Ve.width,
                        Xt = Ve.y,
                        Nt = Xt + Ve.height;
                    if (w >= lt && B >= Xt && I <= bt && ie <= Nt) {
                        h.splice(p, 1);
                        break
                    } else if (w !== lt || x.width !== Ve.width || Nt < B || Xt > ie) {
                        if (!(B !== Xt || x.height !== Ve.height || bt < w || lt > I)) {
                            lt > w && (Ve.width += lt - w, Ve.x = w), bt < I && (Ve.width = I - lt), h.splice(p, 1);
                            break
                        }
                    } else {
                        Xt > B && (Ve.height += Xt - B, Ve.y = B), Nt < ie && (Ve.height = ie - Xt), h.splice(p, 1);
                        break
                    }
                }
        }
        return h
    }, t.findHostInstance = $b, t.findHostInstanceWithNoPortals = function(h) {
        return h = L(h), h = h !== null ? H(h) : null, h === null ? null : h.stateNode
    }, t.findHostInstanceWithWarning = function(h) {
        return $b(h)
    }, t.flushControlled = function(h) {
        var p = on;
        on |= 1;
        var x = yi.transition,
            w = un;
        try {
            yi.transition = null, un = 1, h()
        } finally {
            un = w, yi.transition = x, on = p, on === 0 && (Lu(), kr())
        }
    }, t.flushPassiveEffects = $l, t.flushSync = Hb, t.focusWithin = function(h, p) {
        if (!Le) throw Error(o(363));
        for (h = w_(h), p = kb(h, p), p = Array.from(p), h = 0; h < p.length;) {
            var x = p[h++];
            if (!ye(x)) {
                if (x.tag === 5 && Re(x.stateNode)) return !0;
                for (x = x.child; x !== null;) p.push(x), x = x.sibling
            }
        }
        return !1
    }, t.getCurrentUpdatePriority = function() {
        return un
    }, t.getFindAllNodesFailureDescription = function(h, p) {
        if (!Le) throw Error(o(363));
        var x = 0,
            w = [];
        h = [w_(h), 0];
        for (var I = 0; I < h.length;) {
            var B = h[I++],
                ie = h[I++],
                Ae = p[ie];
            if ((B.tag !== 5 || !ye(B)) && (b_(B, Ae) && (w.push(T_(Ae)), ie++, ie > x && (x = ie)), ie < p.length))
                for (B = B.child; B !== null;) h.push(B, ie), B = B.sibling
        }
        if (x < p.length) {
            for (h = []; x < p.length; x++) h.push(T_(p[x]));
            return `findAllNodes was able to match part of the selector:
  ` + (w.join(" > ") + `

No matching component was found for:
  `) + h.join(" > ")
        }
        return null
    }, t.getPublicRootInstance = function(h) {
        if (h = h.current, !h.child) return null;
        switch (h.child.tag) {
            case 5:
                return X(h.child.stateNode);
            default:
                return h.child.stateNode
        }
    }, t.injectIntoDevTools = function(h) {
        if (h = {
                bundleType: h.bundleType,
                version: h.version,
                rendererPackageName: h.rendererPackageName,
                rendererConfig: h.rendererConfig,
                overrideHookState: null,
                overrideHookStateDeletePath: null,
                overrideHookStateRenamePath: null,
                overrideProps: null,
                overridePropsDeletePath: null,
                overridePropsRenamePath: null,
                setErrorHandler: null,
                setSuspenseHandler: null,
                scheduleUpdate: null,
                currentDispatcherRef: a.ReactCurrentDispatcher,
                findHostInstanceByFiber: kF,
                findFiberByHostInstance: h.findFiberByHostInstance || zF,
                findHostInstancesForRefresh: null,
                scheduleRefresh: null,
                scheduleRoot: null,
                setRefreshHandler: null,
                getCurrentFiber: null,
                reconcilerVersion: "18.0.0-fc46dba67-20220329"
            }, typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ > "u") h = !1;
        else {
            var p = __REACT_DEVTOOLS_GLOBAL_HOOK__;
            if (p.isDisabled || !p.supportsFiber) h = !0;
            else {
                try {
                    Hl = p.inject(h), Qr = p
                } catch {}
                h = !!p.checkDCE
            }
        }
        return h
    }, t.isAlreadyRendering = function() {
        return !1
    }, t.observeVisibleRects = function(h, p, x, w) {
        if (!Le) throw Error(o(363));
        h = E_(h, p);
        var I = Be(h, x, w).disconnect;
        return {
            disconnect: function() {
                I()
            }
        }
    }, t.registerMutableSourceForHydration = function(h, p) {
        var x = p._getVersion;
        x = x(p._source), h.mutableSourceEagerHydrationData == null ? h.mutableSourceEagerHydrationData = [p, x] : h.mutableSourceEagerHydrationData.push(p, x)
    }, t.runWithPriority = function(h, p) {
        var x = un;
        try {
            return un = h, p()
        } finally {
            un = x
        }
    }, t.shouldError = function() {
        return null
    }, t.shouldSuspend = function() {
        return !1
    }, t.updateContainer = function(h, p, x, w) {
        var I = p.current,
            B = wr(),
            ie = Fa(I);
        return x = Qb(x), p.context === null ? p.context = x : p.pendingContext = x, p = Xo(B, ie), p.payload = {
            element: h
        }, w = w === void 0 ? null : w, w !== null && (p.callback = w), Ba(I, p), h = Ds(I, ie, B), h !== null && ym(h, I, ie), ie
    }, t
};
uD.exports = p8;
var m8 = uD.exports;
const g8 = aS(m8),
    AM = {},
    Ny = r => void Object.assign(AM, r);

function v8(r, e) {
    function t(u, {
        args: f = [],
        attach: d,
        ...m
    }, g) {
        let y = `${u[0].toUpperCase()}${u.slice(1)}`,
            v;
        if (u === "primitive") {
            if (m.object === void 0) throw new Error("R3F: Primitives without 'object' are invalid!");
            const _ = m.object;
            v = lf(_, {
                type: u,
                root: g,
                attach: d,
                primitive: !0
            })
        } else {
            const _ = AM[y];
            if (!_) throw new Error(`R3F: ${y} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);
            if (!Array.isArray(f)) throw new Error("R3F: The args prop must be an array!");
            v = lf(new _(...f), {
                type: u,
                root: g,
                attach: d,
                memoizedProps: {
                    args: f
                }
            })
        }
        return v.__r3f.attach === void 0 && (v instanceof zt ? v.__r3f.attach = "geometry" : v instanceof mi && (v.__r3f.attach = "material")), y !== "inject" && Kx(v, m), v
    }

    function n(u, f) {
        let d = !1;
        if (f) {
            var m, g;
            (m = f.__r3f) != null && m.attach ? Jx(u, f, f.__r3f.attach) : f.isObject3D && u.isObject3D && (u.add(f), d = !0), d || (g = u.__r3f) == null || g.objects.push(f), f.__r3f || lf(f, {}), f.__r3f.parent = u, wA(f), cf(f)
        }
    }

    function i(u, f, d) {
        let m = !1;
        if (f) {
            var g, y;
            if ((g = f.__r3f) != null && g.attach) Jx(u, f, f.__r3f.attach);
            else if (f.isObject3D && u.isObject3D) {
                f.parent = u, f.dispatchEvent({
                    type: "added"
                }), u.dispatchEvent({
                    type: "childadded",
                    child: f
                });
                const v = u.children.filter(A => A !== f),
                    _ = v.indexOf(d);
                u.children = [...v.slice(0, _), f, ...v.slice(_)], m = !0
            }
            m || (y = u.__r3f) == null || y.objects.push(f), f.__r3f || lf(f, {}), f.__r3f.parent = u, wA(f), cf(f)
        }
    }

    function s(u, f, d = !1) {
        u && [...u].forEach(m => o(f, m, d))
    }

    function o(u, f, d) {
        if (f) {
            var m, g, y;
            if (f.__r3f && (f.__r3f.parent = null), (m = u.__r3f) != null && m.objects && (u.__r3f.objects = u.__r3f.objects.filter(M => M !== f)), (g = f.__r3f) != null && g.attach) TC(u, f, f.__r3f.attach);
            else if (f.isObject3D && u.isObject3D) {
                var v;
                u.remove(f), (v = f.__r3f) != null && v.root && b8(B0(f), f)
            }
            const A = (y = f.__r3f) == null ? void 0 : y.primitive,
                S = !A && (d === void 0 ? f.dispose !== null : d);
            if (!A) {
                var _;
                s((_ = f.__r3f) == null ? void 0 : _.objects, f, S), s(f.children, f, S)
            }
            if (delete f.__r3f, S && f.dispose && f.type !== "Scene") {
                const M = () => {
                    try {
                        f.dispose()
                    } catch {}
                };
                typeof IS_REACT_ACT_ENVIRONMENT > "u" ? SA.unstable_scheduleCallback(SA.unstable_IdlePriority, M) : M()
            }
            cf(u)
        }
    }

    function a(u, f, d, m) {
        var g;
        const y = (g = u.__r3f) == null ? void 0 : g.parent;
        if (!y) return;
        const v = t(f, d, u.__r3f.root);
        if (u.children) {
            for (const _ of u.children) _.__r3f && n(v, _);
            u.children = u.children.filter(_ => !_.__r3f)
        }
        u.__r3f.objects.forEach(_ => n(v, _)), u.__r3f.objects = [], u.__r3f.autoRemovedBeforeAppend || o(y, u), v.parent && (v.__r3f.autoRemovedBeforeAppend = !0), n(y, v), v.raycast && v.__r3f.eventCount && B0(v).getState().internal.interaction.push(v), [m, m.alternate].forEach(_ => {
            _ !== null && (_.stateNode = v, _.ref && (typeof _.ref == "function" ? _.ref(v) : _.ref.current = v))
        })
    }
    const l = () => {};
    return {
        reconciler: g8({
            createInstance: t,
            removeChild: o,
            appendChild: n,
            appendInitialChild: n,
            insertBefore: i,
            supportsMutation: !0,
            isPrimaryRenderer: !1,
            supportsPersistence: !1,
            supportsHydration: !1,
            noTimeout: -1,
            appendChildToContainer: (u, f) => {
                if (!f) return;
                const d = u.getState().scene;
                d.__r3f && (d.__r3f.root = u, n(d, f))
            },
            removeChildFromContainer: (u, f) => {
                f && o(u.getState().scene, f)
            },
            insertInContainerBefore: (u, f, d) => {
                if (!f || !d) return;
                const m = u.getState().scene;
                m.__r3f && i(m, f, d)
            },
            getRootHostContext: () => null,
            getChildHostContext: u => u,
            finalizeInitialChildren(u) {
                var f;
                return !!((f = u == null ? void 0 : u.__r3f) != null ? f : {}).handlers
            },
            prepareUpdate(u, f, d, m) {
                var g;
                if (((g = u == null ? void 0 : u.__r3f) != null ? g : {}).primitive && m.object && m.object !== u) return [!0]; {
                    const {
                        args: v = [],
                        children: _,
                        ...A
                    } = m, {
                        args: S = [],
                        children: M,
                        ...C
                    } = d;
                    if (!Array.isArray(v)) throw new Error("R3F: the args prop must be an array!");
                    if (v.some((R, P) => R !== S[P])) return [!0];
                    const E = _D(u, A, C, !0);
                    return E.changes.length ? [!1, E] : null
                }
            },
            commitUpdate(u, [f, d], m, g, y, v) {
                f ? a(u, m, y, v) : Kx(u, d)
            },
            commitMount(u, f, d, m) {
                var g;
                const y = (g = u.__r3f) != null ? g : {};
                u.raycast && y.handlers && y.eventCount && B0(u).getState().internal.interaction.push(u)
            },
            getPublicInstance: u => u,
            prepareForCommit: () => null,
            preparePortalMount: u => lf(u.getState().scene),
            resetAfterCommit: () => {},
            shouldSetTextContent: () => !1,
            clearContainer: () => !1,
            hideInstance(u) {
                var f;
                const {
                    attach: d,
                    parent: m
                } = (f = u.__r3f) != null ? f : {};
                d && m && TC(m, u, d), u.isObject3D && (u.visible = !1), cf(u)
            },
            unhideInstance(u, f) {
                var d;
                const {
                    attach: m,
                    parent: g
                } = (d = u.__r3f) != null ? d : {};
                m && g && Jx(g, u, m), (u.isObject3D && f.visible == null || f.visible) && (u.visible = !0), cf(u)
            },
            createTextInstance: l,
            hideTextInstance: l,
            unhideTextInstance: l,
            getCurrentEventPriority: () => e ? e() : yf.DefaultEventPriority,
            beforeActiveInstanceBlur: () => {},
            afterActiveInstanceBlur: () => {},
            detachDeletedInstance: () => {},
            now: typeof performance < "u" && zn.fun(performance.now) ? performance.now : zn.fun(Date.now) ? Date.now : () => 0,
            scheduleTimeout: zn.fun(setTimeout) ? setTimeout : void 0,
            cancelTimeout: zn.fun(clearTimeout) ? clearTimeout : void 0
        }),
        applyProps: Kx
    }
}
var SC, MC;
const Yx = r => "colorSpace" in r || "outputColorSpace" in r,
    dD = () => {
        var r;
        return (r = AM.ColorManagement) != null ? r : null
    },
    pD = r => r && r.isOrthographicCamera,
    y8 = r => r && r.hasOwnProperty("current"),
    fh = typeof window < "u" && ((SC = window.document) != null && SC.createElement || ((MC = window.navigator) == null ? void 0 : MC.product) === "ReactNative") ? N.useLayoutEffect : N.useEffect;

function mD(r) {
    const e = N.useRef(r);
    return fh(() => void(e.current = r), [r]), e
}

function _8({
    set: r
}) {
    return fh(() => (r(new Promise(() => null)), () => r(!1)), [r]), null
}
class gD extends N.Component {
    constructor(...e) {
        super(...e), this.state = {
            error: !1
        }
    }
    componentDidCatch(e) {
        this.props.set(e)
    }
    render() {
        return this.state.error ? null : this.props.children
    }
}
gD.getDerivedStateFromError = () => ({
    error: !0
});
const vD = "__default",
    wC = new Map,
    x8 = r => r && !!r.memoized && !!r.changes;

function yD(r) {
    var e;
    const t = typeof window < "u" ? (e = window.devicePixelRatio) != null ? e : 2 : 1;
    return Array.isArray(r) ? Math.min(Math.max(r[0], t), r[1]) : r
}
const id = r => {
    var e;
    return (e = r.__r3f) == null ? void 0 : e.root.getState()
};

function B0(r) {
    let e = r.__r3f.root;
    for (; e.getState().previousRoot;) e = e.getState().previousRoot;
    return e
}
const zn = {
    obj: r => r === Object(r) && !zn.arr(r) && typeof r != "function",
    fun: r => typeof r == "function",
    str: r => typeof r == "string",
    num: r => typeof r == "number",
    boo: r => typeof r == "boolean",
    und: r => r === void 0,
    arr: r => Array.isArray(r),
    equ(r, e, {
        arrays: t = "shallow",
        objects: n = "reference",
        strict: i = !0
    } = {}) {
        if (typeof r != typeof e || !!r != !!e) return !1;
        if (zn.str(r) || zn.num(r) || zn.boo(r)) return r === e;
        const s = zn.obj(r);
        if (s && n === "reference") return r === e;
        const o = zn.arr(r);
        if (o && t === "reference") return r === e;
        if ((o || s) && r === e) return !0;
        let a;
        for (a in r)
            if (!(a in e)) return !1;
        if (s && t === "shallow" && n === "shallow") {
            for (a in i ? e : r)
                if (!zn.equ(r[a], e[a], {
                        strict: i,
                        objects: "reference"
                    })) return !1
        } else
            for (a in i ? e : r)
                if (r[a] !== e[a]) return !1;
        if (zn.und(a)) {
            if (o && r.length === 0 && e.length === 0 || s && Object.keys(r).length === 0 && Object.keys(e).length === 0) return !0;
            if (r !== e) return !1
        }
        return !0
    }
};

function A8(r) {
    const e = {
        nodes: {},
        materials: {}
    };
    return r && r.traverse(t => {
        t.name && (e.nodes[t.name] = t), t.material && !e.materials[t.material.name] && (e.materials[t.material.name] = t.material)
    }), e
}

function S8(r) {
    r.dispose && r.type !== "Scene" && r.dispose();
    for (const e in r) e.dispose == null || e.dispose(), delete r[e]
}

function lf(r, e) {
    const t = r;
    return t.__r3f = {
        type: "",
        root: null,
        previousAttach: null,
        memoizedProps: {},
        eventCount: 0,
        handlers: {},
        objects: [],
        parent: null,
        ...e
    }, r
}

function MA(r, e) {
    let t = r;
    if (e.includes("-")) {
        const n = e.split("-"),
            i = n.pop();
        return t = n.reduce((s, o) => s[o], r), {
            target: t,
            key: i
        }
    } else return {
        target: t,
        key: e
    }
}
const bC = /-\d+$/;

function Jx(r, e, t) {
    if (zn.str(t)) {
        if (bC.test(t)) {
            const s = t.replace(bC, ""),
                {
                    target: o,
                    key: a
                } = MA(r, s);
            Array.isArray(o[a]) || (o[a] = [])
        }
        const {
            target: n,
            key: i
        } = MA(r, t);
        e.__r3f.previousAttach = n[i], n[i] = e
    } else e.__r3f.previousAttach = t(r, e)
}

function TC(r, e, t) {
    var n, i;
    if (zn.str(t)) {
        const {
            target: s,
            key: o
        } = MA(r, t), a = e.__r3f.previousAttach;
        a === void 0 ? delete s[o] : s[o] = a
    } else(n = e.__r3f) == null || n.previousAttach == null || n.previousAttach(r, e);
    (i = e.__r3f) == null || delete i.previousAttach
}

function _D(r, {
    children: e,
    key: t,
    ref: n,
    ...i
}, {
    children: s,
    key: o,
    ref: a,
    ...l
} = {}, c = !1) {
    const u = r.__r3f,
        f = Object.entries(i),
        d = [];
    if (c) {
        const g = Object.keys(l);
        for (let y = 0; y < g.length; y++) i.hasOwnProperty(g[y]) || f.unshift([g[y], vD + "remove"])
    }
    f.forEach(([g, y]) => {
        var v;
        if ((v = r.__r3f) != null && v.primitive && g === "object" || zn.equ(y, l[g])) return;
        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(g)) return d.push([g, y, !0, []]);
        let _ = [];
        g.includes("-") && (_ = g.split("-")), d.push([g, y, !1, _]);
        for (const A in i) {
            const S = i[A];
            A.startsWith(`${g}-`) && d.push([A, S, !1, A.split("-")])
        }
    });
    const m = { ...i
    };
    return u != null && u.memoizedProps && u != null && u.memoizedProps.args && (m.args = u.memoizedProps.args), u != null && u.memoizedProps && u != null && u.memoizedProps.attach && (m.attach = u.memoizedProps.attach), {
        memoized: m,
        changes: d
    }
}
const M8 = typeof process < "u" && !1;

function Kx(r, e) {
    var t;
    const n = r.__r3f,
        i = n == null ? void 0 : n.root,
        s = i == null || i.getState == null ? void 0 : i.getState(),
        {
            memoized: o,
            changes: a
        } = x8(e) ? e : _D(r, e),
        l = n == null ? void 0 : n.eventCount;
    r.__r3f && (r.__r3f.memoizedProps = o);
    for (let u = 0; u < a.length; u++) {
        let [f, d, m, g] = a[u];
        if (Yx(r)) {
            const A = "srgb",
                S = "srgb-linear";
            f === "encoding" ? (f = "colorSpace", d = d === 3001 ? A : S) : f === "outputEncoding" && (f = "outputColorSpace", d = d === 3001 ? A : S)
        }
        let y = r,
            v = y[f];
        if (g.length && (v = g.reduce((_, A) => _[A], r), !(v && v.set))) {
            const [_, ...A] = g.reverse();
            y = A.reverse().reduce((S, M) => S[M], r), f = _
        }
        if (d === vD + "remove")
            if (y.constructor) {
                let _ = wC.get(y.constructor);
                _ || (_ = new y.constructor, wC.set(y.constructor, _)), d = _[f]
            } else d = 0;
        if (m && n) d ? n.handlers[f] = d : delete n.handlers[f], n.eventCount = Object.keys(n.handlers).length;
        else if (v && v.set && (v.copy || v instanceof Kc)) {
            if (Array.isArray(d)) v.fromArray ? v.fromArray(d) : v.set(...d);
            else if (v.copy && d && d.constructor && (M8 ? v.constructor.name === d.constructor.name : v.constructor === d.constructor)) v.copy(d);
            else if (d !== void 0) {
                const _ = v instanceof rt;
                !_ && v.setScalar ? v.setScalar(d) : v instanceof Kc && d instanceof Kc ? v.mask = d.mask : v.set(d), !dD() && s && !s.linear && _ && v.convertSRGBToLinear()
            }
        } else if (y[f] = d, y[f] instanceof gn && y[f].format === kn && y[f].type === Yi && s) {
            const _ = y[f];
            Yx(_) && Yx(s.gl) ? _.colorSpace = s.gl.outputColorSpace : _.encoding = s.gl.outputEncoding
        }
        cf(r)
    }
    if (n && n.parent && r.raycast && l !== n.eventCount) {
        const u = B0(r).getState().internal,
            f = u.interaction.indexOf(r);
        f > -1 && u.interaction.splice(f, 1), n.eventCount && u.interaction.push(r)
    }
    return !(a.length === 1 && a[0][0] === "onUpdate") && a.length && (t = r.__r3f) != null && t.parent && wA(r), r
}

function cf(r) {
    var e, t;
    const n = (e = r.__r3f) == null || (t = e.root) == null || t.getState == null ? void 0 : t.getState();
    n && n.internal.frames === 0 && n.invalidate()
}

function wA(r) {
    r.onUpdate == null || r.onUpdate(r)
}

function xD(r, e) {
    r.manual || (pD(r) ? (r.left = e.width / -2, r.right = e.width / 2, r.top = e.height / 2, r.bottom = e.height / -2) : r.aspect = e.width / e.height, r.updateProjectionMatrix(), r.updateMatrixWorld())
}

function o0(r) {
    return (r.eventObject || r.object).uuid + "/" + r.index + r.instanceId
}

function w8() {
    var r;
    const e = typeof self < "u" && self || typeof window < "u" && window;
    if (!e) return yf.DefaultEventPriority;
    switch ((r = e.event) == null ? void 0 : r.type) {
        case "click":
        case "contextmenu":
        case "dblclick":
        case "pointercancel":
        case "pointerdown":
        case "pointerup":
            return yf.DiscreteEventPriority;
        case "pointermove":
        case "pointerout":
        case "pointerover":
        case "pointerenter":
        case "pointerleave":
        case "wheel":
            return yf.ContinuousEventPriority;
        default:
            return yf.DefaultEventPriority
    }
}

function AD(r, e, t, n) {
    const i = t.get(e);
    i && (t.delete(e), t.size === 0 && (r.delete(n), i.target.releasePointerCapture(n)))
}

function b8(r, e) {
    const {
        internal: t
    } = r.getState();
    t.interaction = t.interaction.filter(n => n !== e), t.initialHits = t.initialHits.filter(n => n !== e), t.hovered.forEach((n, i) => {
        (n.eventObject === e || n.object === e) && t.hovered.delete(i)
    }), t.capturedMap.forEach((n, i) => {
        AD(t.capturedMap, e, n, i)
    })
}

function T8(r) {
    function e(l) {
        const {
            internal: c
        } = r.getState(), u = l.offsetX - c.initialClick[0], f = l.offsetY - c.initialClick[1];
        return Math.round(Math.sqrt(u * u + f * f))
    }

    function t(l) {
        return l.filter(c => ["Move", "Over", "Enter", "Out", "Leave"].some(u => {
            var f;
            return (f = c.__r3f) == null ? void 0 : f.handlers["onPointer" + u]
        }))
    }

    function n(l, c) {
        const u = r.getState(),
            f = new Set,
            d = [],
            m = c ? c(u.internal.interaction) : u.internal.interaction;
        for (let _ = 0; _ < m.length; _++) {
            const A = id(m[_]);
            A && (A.raycaster.camera = void 0)
        }
        u.previousRoot || u.events.compute == null || u.events.compute(l, u);

        function g(_) {
            const A = id(_);
            if (!A || !A.events.enabled || A.raycaster.camera === null) return [];
            if (A.raycaster.camera === void 0) {
                var S;
                A.events.compute == null || A.events.compute(l, A, (S = A.previousRoot) == null ? void 0 : S.getState()), A.raycaster.camera === void 0 && (A.raycaster.camera = null)
            }
            return A.raycaster.camera ? A.raycaster.intersectObject(_, !0) : []
        }
        let y = m.flatMap(g).sort((_, A) => {
            const S = id(_.object),
                M = id(A.object);
            return !S || !M ? _.distance - A.distance : M.events.priority - S.events.priority || _.distance - A.distance
        }).filter(_ => {
            const A = o0(_);
            return f.has(A) ? !1 : (f.add(A), !0)
        });
        u.events.filter && (y = u.events.filter(y, u));
        for (const _ of y) {
            let A = _.object;
            for (; A;) {
                var v;
                (v = A.__r3f) != null && v.eventCount && d.push({ ..._,
                    eventObject: A
                }), A = A.parent
            }
        }
        if ("pointerId" in l && u.internal.capturedMap.has(l.pointerId))
            for (let _ of u.internal.capturedMap.get(l.pointerId).values()) f.has(o0(_.intersection)) || d.push(_.intersection);
        return d
    }

    function i(l, c, u, f) {
        const d = r.getState();
        if (l.length) {
            const m = {
                stopped: !1
            };
            for (const g of l) {
                const y = id(g.object) || d,
                    {
                        raycaster: v,
                        pointer: _,
                        camera: A,
                        internal: S
                    } = y,
                    M = new K(_.x, _.y, 0).unproject(A),
                    C = T => {
                        var L, D;
                        return (L = (D = S.capturedMap.get(T)) == null ? void 0 : D.has(g.eventObject)) != null ? L : !1
                    },
                    E = T => {
                        const L = {
                            intersection: g,
                            target: c.target
                        };
                        S.capturedMap.has(T) ? S.capturedMap.get(T).set(g.eventObject, L) : S.capturedMap.set(T, new Map([
                            [g.eventObject, L]
                        ])), c.target.setPointerCapture(T)
                    },
                    R = T => {
                        const L = S.capturedMap.get(T);
                        L && AD(S.capturedMap, g.eventObject, L, T)
                    };
                let P = {};
                for (let T in c) {
                    let L = c[T];
                    typeof L != "function" && (P[T] = L)
                }
                let b = { ...g,
                    ...P,
                    pointer: _,
                    intersections: l,
                    stopped: m.stopped,
                    delta: u,
                    unprojectedPoint: M,
                    ray: v.ray,
                    camera: A,
                    stopPropagation() {
                        const T = "pointerId" in c && S.capturedMap.get(c.pointerId);
                        if ((!T || T.has(g.eventObject)) && (b.stopped = m.stopped = !0, S.hovered.size && Array.from(S.hovered.values()).find(L => L.eventObject === g.eventObject))) {
                            const L = l.slice(0, l.indexOf(g));
                            s([...L, g])
                        }
                    },
                    target: {
                        hasPointerCapture: C,
                        setPointerCapture: E,
                        releasePointerCapture: R
                    },
                    currentTarget: {
                        hasPointerCapture: C,
                        setPointerCapture: E,
                        releasePointerCapture: R
                    },
                    nativeEvent: c
                };
                if (f(b), m.stopped === !0) break
            }
        }
        return l
    }

    function s(l) {
        const {
            internal: c
        } = r.getState();
        for (const u of c.hovered.values())
            if (!l.length || !l.find(f => f.object === u.object && f.index === u.index && f.instanceId === u.instanceId)) {
                const d = u.eventObject.__r3f,
                    m = d == null ? void 0 : d.handlers;
                if (c.hovered.delete(o0(u)), d != null && d.eventCount) {
                    const g = { ...u,
                        intersections: l
                    };
                    m.onPointerOut == null || m.onPointerOut(g), m.onPointerLeave == null || m.onPointerLeave(g)
                }
            }
    }

    function o(l, c) {
        for (let u = 0; u < c.length; u++) {
            const f = c[u].__r3f;
            f == null || f.handlers.onPointerMissed == null || f.handlers.onPointerMissed(l)
        }
    }

    function a(l) {
        switch (l) {
            case "onPointerLeave":
            case "onPointerCancel":
                return () => s([]);
            case "onLostPointerCapture":
                return c => {
                    const {
                        internal: u
                    } = r.getState();
                    "pointerId" in c && u.capturedMap.has(c.pointerId) && requestAnimationFrame(() => {
                        u.capturedMap.has(c.pointerId) && (u.capturedMap.delete(c.pointerId), s([]))
                    })
                }
        }
        return function(u) {
            const {
                onPointerMissed: f,
                internal: d
            } = r.getState();
            d.lastEvent.current = u;
            const m = l === "onPointerMove",
                g = l === "onClick" || l === "onContextMenu" || l === "onDoubleClick",
                v = n(u, m ? t : void 0),
                _ = g ? e(u) : 0;
            l === "onPointerDown" && (d.initialClick = [u.offsetX, u.offsetY], d.initialHits = v.map(S => S.eventObject)), g && !v.length && _ <= 2 && (o(u, d.interaction), f && f(u)), m && s(v);

            function A(S) {
                const M = S.eventObject,
                    C = M.__r3f,
                    E = C == null ? void 0 : C.handlers;
                if (C != null && C.eventCount)
                    if (m) {
                        if (E.onPointerOver || E.onPointerEnter || E.onPointerOut || E.onPointerLeave) {
                            const R = o0(S),
                                P = d.hovered.get(R);
                            P ? P.stopped && S.stopPropagation() : (d.hovered.set(R, S), E.onPointerOver == null || E.onPointerOver(S), E.onPointerEnter == null || E.onPointerEnter(S))
                        }
                        E.onPointerMove == null || E.onPointerMove(S)
                    } else {
                        const R = E[l];
                        R ? (!g || d.initialHits.includes(M)) && (o(u, d.interaction.filter(P => !d.initialHits.includes(P))), R(S)) : g && d.initialHits.includes(M) && o(u, d.interaction.filter(P => !d.initialHits.includes(P)))
                    }
            }
            i(v, u, _, A)
        }
    }
    return {
        handlePointer: a
    }
}
const E8 = ["set", "get", "setSize", "setFrameloop", "setDpr", "events", "invalidate", "advance", "size", "viewport"],
    SD = r => !!(r != null && r.render),
    SM = N.createContext(null),
    C8 = (r, e) => {
        const t = oD((a, l) => {
                const c = new K,
                    u = new K,
                    f = new K;

                function d(_ = l().camera, A = u, S = l().size) {
                    const {
                        width: M,
                        height: C,
                        top: E,
                        left: R
                    } = S, P = M / C;
                    A instanceof K ? f.copy(A) : f.set(...A);
                    const b = _.getWorldPosition(c).distanceTo(f);
                    if (pD(_)) return {
                        width: M / _.zoom,
                        height: C / _.zoom,
                        top: E,
                        left: R,
                        factor: 1,
                        distance: b,
                        aspect: P
                    }; {
                        const T = _.fov * Math.PI / 180,
                            L = 2 * Math.tan(T / 2) * b,
                            D = L * (M / C);
                        return {
                            width: D,
                            height: L,
                            top: E,
                            left: R,
                            factor: M / D,
                            distance: b,
                            aspect: P
                        }
                    }
                }
                let m;
                const g = _ => a(A => ({
                        performance: { ...A.performance,
                            current: _
                        }
                    })),
                    y = new Ue;
                return {
                    set: a,
                    get: l,
                    gl: null,
                    camera: null,
                    raycaster: null,
                    events: {
                        priority: 1,
                        enabled: !0,
                        connected: !1
                    },
                    xr: null,
                    scene: null,
                    invalidate: (_ = 1) => r(l(), _),
                    advance: (_, A) => e(_, A, l()),
                    legacy: !1,
                    linear: !1,
                    flat: !1,
                    controls: null,
                    clock: new gM,
                    pointer: y,
                    mouse: y,
                    frameloop: "always",
                    onPointerMissed: void 0,
                    performance: {
                        current: 1,
                        min: .5,
                        max: 1,
                        debounce: 200,
                        regress: () => {
                            const _ = l();
                            m && clearTimeout(m), _.performance.current !== _.performance.min && g(_.performance.min), m = setTimeout(() => g(l().performance.max), _.performance.debounce)
                        }
                    },
                    size: {
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        updateStyle: !1
                    },
                    viewport: {
                        initialDpr: 0,
                        dpr: 0,
                        width: 0,
                        height: 0,
                        top: 0,
                        left: 0,
                        aspect: 0,
                        distance: 0,
                        factor: 0,
                        getCurrentViewport: d
                    },
                    setEvents: _ => a(A => ({ ...A,
                        events: { ...A.events,
                            ..._
                        }
                    })),
                    setSize: (_, A, S, M, C) => {
                        const E = l().camera,
                            R = {
                                width: _,
                                height: A,
                                top: M || 0,
                                left: C || 0,
                                updateStyle: S
                            };
                        a(P => ({
                            size: R,
                            viewport: { ...P.viewport,
                                ...d(E, u, R)
                            }
                        }))
                    },
                    setDpr: _ => a(A => {
                        const S = yD(_);
                        return {
                            viewport: { ...A.viewport,
                                dpr: S,
                                initialDpr: A.viewport.initialDpr || S
                            }
                        }
                    }),
                    setFrameloop: (_ = "always") => {
                        const A = l().clock;
                        A.stop(), A.elapsedTime = 0, _ !== "never" && (A.start(), A.elapsedTime = 0), a(() => ({
                            frameloop: _
                        }))
                    },
                    previousRoot: void 0,
                    internal: {
                        active: !1,
                        priority: 0,
                        frames: 0,
                        lastEvent: N.createRef(),
                        interaction: [],
                        hovered: new Map,
                        subscribers: [],
                        initialClick: [0, 0],
                        initialHits: [],
                        capturedMap: new Map,
                        subscribe: (_, A, S) => {
                            const M = l().internal;
                            return M.priority = M.priority + (A > 0 ? 1 : 0), M.subscribers.push({
                                ref: _,
                                priority: A,
                                store: S
                            }), M.subscribers = M.subscribers.sort((C, E) => C.priority - E.priority), () => {
                                const C = l().internal;
                                C != null && C.subscribers && (C.priority = C.priority - (A > 0 ? 1 : 0), C.subscribers = C.subscribers.filter(E => E.ref !== _))
                            }
                        }
                    }
                }
            }),
            n = t.getState();
        let i = n.size,
            s = n.viewport.dpr,
            o = n.camera;
        return t.subscribe(() => {
            const {
                camera: a,
                size: l,
                viewport: c,
                gl: u,
                set: f
            } = t.getState();
            if (l.width !== i.width || l.height !== i.height || c.dpr !== s) {
                var d;
                i = l, s = c.dpr, xD(a, l), u.setPixelRatio(c.dpr);
                const m = (d = l.updateStyle) != null ? d : typeof HTMLCanvasElement < "u" && u.domElement instanceof HTMLCanvasElement;
                u.setSize(l.width, l.height, m)
            }
            a !== o && (o = a, f(m => ({
                viewport: { ...m.viewport,
                    ...m.viewport.getCurrentViewport(a)
                }
            })))
        }), t.subscribe(a => r(a)), t
    };
let a0, R8 = new Set,
    P8 = new Set,
    I8 = new Set;

function qx(r, e) {
    if (r.size)
        for (const {
                callback: t
            } of r.values()) t(e)
}

function rd(r, e) {
    switch (r) {
        case "before":
            return qx(R8, e);
        case "after":
            return qx(P8, e);
        case "tail":
            return qx(I8, e)
    }
}
let Zx, Qx;

function $x(r, e, t) {
    let n = e.clock.getDelta();
    for (e.frameloop === "never" && typeof r == "number" && (n = r - e.clock.elapsedTime, e.clock.oldTime = e.clock.elapsedTime, e.clock.elapsedTime = r), Zx = e.internal.subscribers, a0 = 0; a0 < Zx.length; a0++) Qx = Zx[a0], Qx.ref.current(Qx.store.getState(), n, t);
    return !e.internal.priority && e.gl.render && e.gl.render(e.scene, e.camera), e.internal.frames = Math.max(0, e.internal.frames - 1), e.frameloop === "always" ? 1 : e.internal.frames
}

function B8(r) {
    let e = !1,
        t = !1,
        n, i, s;

    function o(c) {
        i = requestAnimationFrame(o), e = !0, n = 0, rd("before", c), t = !0;
        for (const f of r.values()) {
            var u;
            s = f.store.getState(), s.internal.active && (s.frameloop === "always" || s.internal.frames > 0) && !((u = s.gl.xr) != null && u.isPresenting) && (n += $x(c, s))
        }
        if (t = !1, rd("after", c), n === 0) return rd("tail", c), e = !1, cancelAnimationFrame(i)
    }

    function a(c, u = 1) {
        var f;
        if (!c) return r.forEach(d => a(d.store.getState(), u));
        (f = c.gl.xr) != null && f.isPresenting || !c.internal.active || c.frameloop === "never" || (u > 1 ? c.internal.frames = Math.min(60, c.internal.frames + u) : t ? c.internal.frames = 2 : c.internal.frames = 1, e || (e = !0, requestAnimationFrame(o)))
    }

    function l(c, u = !0, f, d) {
        if (u && rd("before", c), f) $x(c, f, d);
        else
            for (const m of r.values()) $x(c, m.store.getState());
        u && rd("after", c)
    }
    return {
        loop: o,
        invalidate: a,
        advance: l
    }
}

function D8(r) {
    const e = N.useRef(null);
    return fh(() => void(e.current = r.current.__r3f), [r]), e
}

function MM() {
    const r = N.useContext(SM);
    if (!r) throw new Error("R3F: Hooks can only be used within the Canvas component!");
    return r
}

function qn(r = t => t, e) {
    return MM()(r, e)
}

function Es(r, e = 0) {
    const t = MM(),
        n = t.getState().internal.subscribe,
        i = mD(r);
    return fh(() => n(i, e, t), [e, n, t]), null
}
const EC = new WeakMap;

function MD(r, e) {
    return function(t, ...n) {
        let i = EC.get(t);
        return i || (i = new t, EC.set(t, i)), r && r(i), Promise.all(n.map(s => new Promise((o, a) => i.load(s, l => {
            l.scene && Object.assign(l, A8(l.scene)), o(l)
        }, e, l => a(new Error(`Could not load ${s}: ${l==null?void 0:l.message}`))))))
    }
}

function vr(r, e, t, n) {
    const i = Array.isArray(e) ? e : [e],
        s = cD(MD(t, n), [r, ...i], {
            equal: zn.equ
        });
    return Array.isArray(e) ? s : s[0]
}
vr.preload = function(r, e, t) {
    const n = Array.isArray(e) ? e : [e];
    return h8(MD(t), [r, ...n])
};
vr.clear = function(r, e) {
    const t = Array.isArray(e) ? e : [e];
    return d8([r, ...t])
};
const th = new Map,
    {
        invalidate: CC,
        advance: RC
    } = B8(th),
    {
        reconciler: wp,
        applyProps: $a
    } = v8(th, w8),
    nf = {
        objects: "shallow",
        strict: !1
    },
    L8 = (r, e) => {
        const t = typeof r == "function" ? r(e) : r;
        return SD(t) ? t : new KS({
            powerPreference: "high-performance",
            canvas: e,
            antialias: !0,
            alpha: !0,
            ...r
        })
    };

function F8(r, e) {
    const t = typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement;
    if (e) {
        const {
            width: n,
            height: i,
            top: s,
            left: o,
            updateStyle: a = t
        } = e;
        return {
            width: n,
            height: i,
            top: s,
            left: o,
            updateStyle: a
        }
    } else if (typeof HTMLCanvasElement < "u" && r instanceof HTMLCanvasElement && r.parentElement) {
        const {
            width: n,
            height: i,
            top: s,
            left: o
        } = r.parentElement.getBoundingClientRect();
        return {
            width: n,
            height: i,
            top: s,
            left: o,
            updateStyle: t
        }
    } else if (typeof OffscreenCanvas < "u" && r instanceof OffscreenCanvas) return {
        width: r.width,
        height: r.height,
        top: 0,
        left: 0,
        updateStyle: t
    };
    return {
        width: 0,
        height: 0,
        top: 0,
        left: 0
    }
}

function U8(r) {
    const e = th.get(r),
        t = e == null ? void 0 : e.fiber,
        n = e == null ? void 0 : e.store;
    e && console.warn("R3F.createRoot should only be called once!");
    const i = typeof reportError == "function" ? reportError : console.error,
        s = n || C8(CC, RC),
        o = t || wp.createContainer(s, yf.ConcurrentRoot, null, !1, null, "", i, null);
    e || th.set(r, {
        fiber: o,
        store: s
    });
    let a, l = !1,
        c;
    return {
        configure(u = {}) {
            let {
                gl: f,
                size: d,
                scene: m,
                events: g,
                onCreated: y,
                shadows: v = !1,
                linear: _ = !1,
                flat: A = !1,
                legacy: S = !1,
                orthographic: M = !1,
                frameloop: C = "always",
                dpr: E = [1, 2],
                performance: R,
                raycaster: P,
                camera: b,
                onPointerMissed: T
            } = u, L = s.getState(), D = L.gl;
            L.gl || L.set({
                gl: D = L8(f, r)
            });
            let V = L.raycaster;
            V || L.set({
                raycaster: V = new _M
            });
            const {
                params: H,
                ...q
            } = P || {};
            if (zn.equ(q, V, nf) || $a(V, { ...q
                }), zn.equ(H, V.params, nf) || $a(V, {
                    params: { ...V.params,
                        ...H
                    }
                }), !L.camera || L.camera === c && !zn.equ(c, b, nf)) {
                c = b;
                const U = b instanceof Fl,
                    j = U ? b : M ? new Ca(0, 0, 0, 0, .1, 1e3) : new ri(75, 0, .1, 1e3);
                U || (j.position.z = 5, b && ($a(j, b), ("aspect" in b || "left" in b || "right" in b || "bottom" in b || "top" in b) && (j.manual = !0, j.updateProjectionMatrix())), !L.camera && !(b != null && b.rotation) && j.lookAt(0, 0, 0)), L.set({
                    camera: j
                }), V.camera = j
            }
            if (!L.scene) {
                let U;
                m instanceof ho ? U = m : (U = new ho, m && $a(U, m)), L.set({
                    scene: lf(U)
                })
            }
            if (!L.xr) {
                var X;
                const U = (he, $) => {
                        const ne = s.getState();
                        ne.frameloop !== "never" && RC(he, !0, ne, $)
                    },
                    j = () => {
                        const he = s.getState();
                        he.gl.xr.enabled = he.gl.xr.isPresenting, he.gl.xr.setAnimationLoop(he.gl.xr.isPresenting ? U : null), he.gl.xr.isPresenting || CC(he)
                    },
                    te = {
                        connect() {
                            const he = s.getState().gl;
                            he.xr.addEventListener("sessionstart", j), he.xr.addEventListener("sessionend", j)
                        },
                        disconnect() {
                            const he = s.getState().gl;
                            he.xr.removeEventListener("sessionstart", j), he.xr.removeEventListener("sessionend", j)
                        }
                    };
                typeof((X = D.xr) == null ? void 0 : X.addEventListener) == "function" && te.connect(), L.set({
                    xr: te
                })
            }
            if (D.shadowMap) {
                const U = D.shadowMap.enabled,
                    j = D.shadowMap.type;
                if (D.shadowMap.enabled = !!v, zn.boo(v)) D.shadowMap.type = zd;
                else if (zn.str(v)) {
                    var oe;
                    const te = {
                        basic: MI,
                        percentage: iy,
                        soft: zd,
                        variance: lo
                    };
                    D.shadowMap.type = (oe = te[v]) != null ? oe : zd
                } else zn.obj(v) && Object.assign(D.shadowMap, v);
                (U !== D.shadowMap.enabled || j !== D.shadowMap.type) && (D.shadowMap.needsUpdate = !0)
            }
            const Y = dD();
            Y && ("enabled" in Y ? Y.enabled = !S : "legacyMode" in Y && (Y.legacyMode = S)), l || $a(D, {
                outputEncoding: _ ? 3e3 : 3001,
                toneMapping: A ? Js : ry
            }), L.legacy !== S && L.set(() => ({
                legacy: S
            })), L.linear !== _ && L.set(() => ({
                linear: _
            })), L.flat !== A && L.set(() => ({
                flat: A
            })), f && !zn.fun(f) && !SD(f) && !zn.equ(f, D, nf) && $a(D, f), g && !L.events.handlers && L.set({
                events: g(s)
            });
            const Z = F8(r, d);
            return zn.equ(Z, L.size, nf) || L.setSize(Z.width, Z.height, Z.updateStyle, Z.top, Z.left), E && L.viewport.dpr !== yD(E) && L.setDpr(E), L.frameloop !== C && L.setFrameloop(C), L.onPointerMissed || L.set({
                onPointerMissed: T
            }), R && !zn.equ(R, L.performance, nf) && L.set(U => ({
                performance: { ...U.performance,
                    ...R
                }
            })), a = y, l = !0, this
        },
        render(u) {
            return l || this.configure(), wp.updateContainer(G.jsx(O8, {
                store: s,
                children: u,
                onCreated: a,
                rootElement: r
            }), o, null, () => {}), s
        },
        unmount() {
            wD(r)
        }
    }
}

function O8({
    store: r,
    children: e,
    onCreated: t,
    rootElement: n
}) {
    return fh(() => {
        const i = r.getState();
        i.set(s => ({
            internal: { ...s.internal,
                active: !0
            }
        })), t && t(i), r.getState().events.connected || i.events.connect == null || i.events.connect(n)
    }, []), G.jsx(SM.Provider, {
        value: r,
        children: e
    })
}

function wD(r, e) {
    const t = th.get(r),
        n = t == null ? void 0 : t.fiber;
    if (n) {
        const i = t == null ? void 0 : t.store.getState();
        i && (i.internal.active = !1), wp.updateContainer(null, n, null, () => {
            i && setTimeout(() => {
                try {
                    var s, o, a, l;
                    i.events.disconnect == null || i.events.disconnect(), (s = i.gl) == null || (o = s.renderLists) == null || o.dispose == null || o.dispose(), (a = i.gl) == null || a.forceContextLoss == null || a.forceContextLoss(), (l = i.gl) != null && l.xr && i.xr.disconnect(), S8(i), th.delete(r)
                } catch {}
            }, 500)
        })
    }
}

function N8(r, e, t) {
    return G.jsx(k8, {
        children: r,
        container: e,
        state: t
    }, e.uuid)
}

function k8({
    state: r = {},
    children: e,
    container: t
}) {
    const {
        events: n,
        size: i,
        ...s
    } = r, o = MM(), [a] = N.useState(() => new _M), [l] = N.useState(() => new Ue), c = N.useCallback((f, d) => {
        const m = { ...f
        };
        Object.keys(f).forEach(y => {
            (E8.includes(y) || f[y] !== d[y] && d[y]) && delete m[y]
        });
        let g;
        if (d && i) {
            const y = d.camera;
            g = f.viewport.getCurrentViewport(y, new K, i), y !== f.camera && xD(y, i)
        }
        return { ...m,
            scene: t,
            raycaster: a,
            pointer: l,
            mouse: l,
            previousRoot: o,
            events: { ...f.events,
                ...d == null ? void 0 : d.events,
                ...n
            },
            size: { ...f.size,
                ...i
            },
            viewport: { ...f.viewport,
                ...g
            },
            ...s
        }
    }, [r]), [u] = N.useState(() => {
        const f = o.getState();
        return oD((m, g) => ({ ...f,
            scene: t,
            raycaster: a,
            pointer: l,
            mouse: l,
            previousRoot: o,
            events: { ...f.events,
                ...n
            },
            size: { ...f.size,
                ...i
            },
            ...s,
            set: m,
            get: g,
            setEvents: y => m(v => ({ ...v,
                events: { ...v.events,
                    ...y
                }
            }))
        }))
    });
    return N.useEffect(() => {
        const f = o.subscribe(d => u.setState(m => c(d, m)));
        return () => {
            f()
        }
    }, [c]), N.useEffect(() => {
        u.setState(f => c(o.getState(), f))
    }, [c]), N.useEffect(() => () => {
        u.destroy()
    }, []), G.jsx(G.Fragment, {
        children: wp.createPortal(G.jsx(SM.Provider, {
            value: u,
            children: e
        }), u, null)
    })
}
wp.injectIntoDevTools({
    bundleType: 0,
    rendererPackageName: "@react-three/fiber",
    version: N.version
});
const e1 = {
    onClick: ["click", !1],
    onContextMenu: ["contextmenu", !1],
    onDoubleClick: ["dblclick", !1],
    onWheel: ["wheel", !0],
    onPointerDown: ["pointerdown", !0],
    onPointerUp: ["pointerup", !0],
    onPointerLeave: ["pointerleave", !0],
    onPointerMove: ["pointermove", !0],
    onPointerCancel: ["pointercancel", !0],
    onLostPointerCapture: ["lostpointercapture", !0]
};

function z8(r) {
    const {
        handlePointer: e
    } = T8(r);
    return {
        priority: 1,
        enabled: !0,
        compute(t, n, i) {
            n.pointer.set(t.offsetX / n.size.width * 2 - 1, -(t.offsetY / n.size.height) * 2 + 1), n.raycaster.setFromCamera(n.pointer, n.camera)
        },
        connected: void 0,
        handlers: Object.keys(e1).reduce((t, n) => ({ ...t,
            [n]: e(n)
        }), {}),
        update: () => {
            var t;
            const {
                events: n,
                internal: i
            } = r.getState();
            (t = i.lastEvent) != null && t.current && n.handlers && n.handlers.onPointerMove(i.lastEvent.current)
        },
        connect: t => {
            var n;
            const {
                set: i,
                events: s
            } = r.getState();
            s.disconnect == null || s.disconnect(), i(o => ({
                events: { ...o.events,
                    connected: t
                }
            })), Object.entries((n = s.handlers) != null ? n : []).forEach(([o, a]) => {
                const [l, c] = e1[o];
                t.addEventListener(l, a, {
                    passive: c
                })
            })
        },
        disconnect: () => {
            const {
                set: t,
                events: n
            } = r.getState();
            if (n.connected) {
                var i;
                Object.entries((i = n.handlers) != null ? i : []).forEach(([s, o]) => {
                    if (n && n.connected instanceof HTMLElement) {
                        const [a] = e1[s];
                        n.connected.removeEventListener(a, o)
                    }
                }), t(s => ({
                    events: { ...s.events,
                        connected: void 0
                    }
                }))
            }
        }
    }
}

function bA(r, e, t) {
    var n, i, s, o, a;
    e == null && (e = 100);

    function l() {
        var u = Date.now() - o;
        u < e && u >= 0 ? n = setTimeout(l, e - u) : (n = null, t || (a = r.apply(s, i), s = i = null))
    }
    var c = function() {
        s = this, i = arguments, o = Date.now();
        var u = t && !n;
        return n || (n = setTimeout(l, e)), u && (a = r.apply(s, i), s = i = null), a
    };
    return c.clear = function() {
        n && (clearTimeout(n), n = null)
    }, c.flush = function() {
        n && (a = r.apply(s, i), s = i = null, clearTimeout(n), n = null)
    }, c
}
bA.debounce = bA;
var G8 = bA;
const PC = aS(G8);
var H8 = Object.defineProperty,
    V8 = Object.defineProperties,
    W8 = Object.getOwnPropertyDescriptors,
    IC = Object.getOwnPropertySymbols,
    j8 = Object.prototype.hasOwnProperty,
    X8 = Object.prototype.propertyIsEnumerable,
    BC = (r, e, t) => e in r ? H8(r, e, {
        enumerable: !0,
        configurable: !0,
        writable: !0,
        value: t
    }) : r[e] = t,
    DC = (r, e) => {
        for (var t in e || (e = {})) j8.call(e, t) && BC(r, t, e[t]);
        if (IC)
            for (var t of IC(e)) X8.call(e, t) && BC(r, t, e[t]);
        return r
    },
    Y8 = (r, e) => V8(r, W8(e)),
    LC, FC;
typeof window < "u" && ((LC = window.document) != null && LC.createElement || ((FC = window.navigator) == null ? void 0 : FC.product) === "ReactNative") ? N.useLayoutEffect : N.useEffect;

function bD(r, e, t) {
    if (!r) return;
    if (t(r) === !0) return r;
    let n = r.child;
    for (; n;) {
        const i = bD(n, e, t);
        if (i) return i;
        n = n.sibling
    }
}

function TD(r) {
    try {
        return Object.defineProperties(r, {
            _currentRenderer: {
                get() {
                    return null
                },
                set() {}
            },
            _currentRenderer2: {
                get() {
                    return null
                },
                set() {}
            }
        })
    } catch {
        return r
    }
}
const UC = console.error;
console.error = function() {
    const r = [...arguments].join("");
    if (r != null && r.startsWith("Warning:") && r.includes("useContext")) {
        console.error = UC;
        return
    }
    return UC.apply(this, arguments)
};
const wM = TD(N.createContext(null));
class ED extends N.Component {
    render() {
        return N.createElement(wM.Provider, {
            value: this._reactInternals
        }, this.props.children)
    }
}

function J8() {
    const r = N.useContext(wM);
    if (r === null) throw new Error("its-fine: useFiber must be called within a <FiberProvider />!");
    const e = N.useId();
    return N.useMemo(() => {
        for (const n of [r, r == null ? void 0 : r.alternate]) {
            if (!n) continue;
            const i = bD(n, !1, s => {
                let o = s.memoizedState;
                for (; o;) {
                    if (o.memoizedState === e) return !0;
                    o = o.next
                }
            });
            if (i) return i
        }
    }, [r, e])
}

function K8() {
    const r = J8(),
        [e] = N.useState(() => new Map);
    e.clear();
    let t = r;
    for (; t;) {
        if (t.type && typeof t.type == "object") {
            const i = t.type._context === void 0 && t.type.Provider === t.type ? t.type : t.type._context;
            i && i !== wM && !e.has(i) && e.set(i, N.useContext(TD(i)))
        }
        t = t.return
    }
    return e
}

function q8() {
    const r = K8();
    return N.useMemo(() => Array.from(r.keys()).reduce((e, t) => n => N.createElement(e, null, N.createElement(t.Provider, Y8(DC({}, n), {
        value: r.get(t)
    }))), e => N.createElement(ED, DC({}, e))), [r])
}

function Z8({
    debounce: r,
    scroll: e,
    polyfill: t,
    offsetSize: n
} = {
    debounce: 0,
    scroll: !1,
    offsetSize: !1
}) {
    const i = t || typeof window < "u" && window.ResizeObserver,
        [s, o] = N.useState({
            left: 0,
            top: 0,
            width: 0,
            height: 0,
            bottom: 0,
            right: 0,
            x: 0,
            y: 0
        });
    if (!i) return s.width = 1280, s.height = 800, [() => {}, s, () => {}];
    const a = N.useRef({
            element: null,
            scrollContainers: null,
            resizeObserver: null,
            lastBounds: s,
            orientationHandler: null
        }),
        l = r ? typeof r == "number" ? r : r.scroll : null,
        c = r ? typeof r == "number" ? r : r.resize : null,
        u = N.useRef(!1);
    N.useEffect(() => (u.current = !0, () => void(u.current = !1)));
    const [f, d, m] = N.useMemo(() => {
        const _ = () => {
            if (!a.current.element) return;
            const {
                left: A,
                top: S,
                width: M,
                height: C,
                bottom: E,
                right: R,
                x: P,
                y: b
            } = a.current.element.getBoundingClientRect(), T = {
                left: A,
                top: S,
                width: M,
                height: C,
                bottom: E,
                right: R,
                x: P,
                y: b
            };
            a.current.element instanceof HTMLElement && n && (T.height = a.current.element.offsetHeight, T.width = a.current.element.offsetWidth), Object.freeze(T), u.current && !t6(a.current.lastBounds, T) && o(a.current.lastBounds = T)
        };
        return [_, c ? PC(_, c) : _, l ? PC(_, l) : _]
    }, [o, n, l, c]);

    function g() {
        a.current.scrollContainers && (a.current.scrollContainers.forEach(_ => _.removeEventListener("scroll", m, !0)), a.current.scrollContainers = null), a.current.resizeObserver && (a.current.resizeObserver.disconnect(), a.current.resizeObserver = null), a.current.orientationHandler && ("orientation" in screen && "removeEventListener" in screen.orientation ? screen.orientation.removeEventListener("change", a.current.orientationHandler) : "onorientationchange" in window && window.removeEventListener("orientationchange", a.current.orientationHandler))
    }

    function y() {
        var _;
        a.current.element && (a.current.resizeObserver = new i(d), (_ = a.current.resizeObserver) == null || _.observe(a.current.element), e && a.current.scrollContainers && a.current.scrollContainers.forEach(A => A.addEventListener("scroll", m, {
            capture: !0,
            passive: !0
        })), a.current.orientationHandler = () => {
            m()
        }, "orientation" in screen && "addEventListener" in screen.orientation ? screen.orientation.addEventListener("change", a.current.orientationHandler) : "onorientationchange" in window && window.addEventListener("orientationchange", a.current.orientationHandler))
    }
    const v = _ => {
        !_ || _ === a.current.element || (g(), a.current.element = _, a.current.scrollContainers = CD(_), y())
    };
    return $8(m, !!e), Q8(d), N.useEffect(() => {
        g(), y()
    }, [e, m, d]), N.useEffect(() => g, []), [v, s, f]
}

function Q8(r) {
    N.useEffect(() => {
        const e = r;
        return window.addEventListener("resize", e), () => void window.removeEventListener("resize", e)
    }, [r])
}

function $8(r, e) {
    N.useEffect(() => {
        if (e) {
            const t = r;
            return window.addEventListener("scroll", t, {
                capture: !0,
                passive: !0
            }), () => void window.removeEventListener("scroll", t, !0)
        }
    }, [r, e])
}

function CD(r) {
    const e = [];
    if (!r || r === document.body) return e;
    const {
        overflow: t,
        overflowX: n,
        overflowY: i
    } = window.getComputedStyle(r);
    return [t, n, i].some(s => s === "auto" || s === "scroll") && e.push(r), [...e, ...CD(r.parentElement)]
}
const e6 = ["x", "y", "top", "bottom", "left", "right", "width", "height"],
    t6 = (r, e) => e6.every(t => r[t] === e[t]),
    n6 = N.forwardRef(function({
        children: e,
        fallback: t,
        resize: n,
        style: i,
        gl: s,
        events: o = z8,
        eventSource: a,
        eventPrefix: l,
        shadows: c,
        linear: u,
        flat: f,
        legacy: d,
        orthographic: m,
        frameloop: g,
        dpr: y,
        performance: v,
        raycaster: _,
        camera: A,
        scene: S,
        onPointerMissed: M,
        onCreated: C,
        ...E
    }, R) {
        N.useMemo(() => Ny(l8), []);
        const P = q8(),
            [b, T] = Z8({
                scroll: !0,
                debounce: {
                    scroll: 50,
                    resize: 0
                },
                ...n
            }),
            L = N.useRef(null),
            D = N.useRef(null);
        N.useImperativeHandle(R, () => L.current);
        const V = mD(M),
            [H, q] = N.useState(!1),
            [X, oe] = N.useState(!1);
        if (H) throw H;
        if (X) throw X;
        const Y = N.useRef(null);
        fh(() => {
            const U = L.current;
            T.width > 0 && T.height > 0 && U && (Y.current || (Y.current = U8(U)), Y.current.configure({
                gl: s,
                events: o,
                shadows: c,
                linear: u,
                flat: f,
                legacy: d,
                orthographic: m,
                frameloop: g,
                dpr: y,
                performance: v,
                raycaster: _,
                camera: A,
                scene: S,
                size: T,
                onPointerMissed: (...j) => V.current == null ? void 0 : V.current(...j),
                onCreated: j => {
                    j.events.connect == null || j.events.connect(a ? y8(a) ? a.current : a : D.current), l && j.setEvents({
                        compute: (te, he) => {
                            const $ = te[l + "X"],
                                ne = te[l + "Y"];
                            he.pointer.set($ / he.size.width * 2 - 1, -(ne / he.size.height) * 2 + 1), he.raycaster.setFromCamera(he.pointer, he.camera)
                        }
                    }), C == null || C(j)
                }
            }), Y.current.render(G.jsx(P, {
                children: G.jsx(gD, {
                    set: oe,
                    children: G.jsx(N.Suspense, {
                        fallback: G.jsx(_8, {
                            set: q
                        }),
                        children: e
                    })
                })
            })))
        }), N.useEffect(() => {
            const U = L.current;
            if (U) return () => wD(U)
        }, []);
        const Z = a ? "none" : "auto";
        return G.jsx("div", {
            ref: D,
            style: {
                position: "relative",
                width: "100%",
                height: "100%",
                overflow: "hidden",
                pointerEvents: Z,
                ...i
            },
            ...E,
            children: G.jsx("div", {
                ref: b,
                style: {
                    width: "100%",
                    height: "100%"
                },
                children: G.jsx("canvas", {
                    ref: L,
                    style: {
                        display: "block"
                    },
                    children: t
                })
            })
        })
    }),
    TA = N.forwardRef(function(e, t) {
        return G.jsx(ED, {
            children: G.jsx(n6, { ...e,
                ref: t
            })
        })
    });

function Cl() {
    return Cl = Object.assign ? Object.assign.bind() : function(r) {
        for (var e = 1; e < arguments.length; e++) {
            var t = arguments[e];
            for (var n in t)({}).hasOwnProperty.call(t, n) && (r[n] = t[n])
        }
        return r
    }, Cl.apply(null, arguments)
}
const nm = new K,
    bM = new K,
    i6 = new K,
    OC = new Ue;

function r6(r, e, t) {
    const n = nm.setFromMatrixPosition(r.matrixWorld);
    n.project(e);
    const i = t.width / 2,
        s = t.height / 2;
    return [n.x * i + i, -(n.y * s) + s]
}

function s6(r, e) {
    const t = nm.setFromMatrixPosition(r.matrixWorld),
        n = bM.setFromMatrixPosition(e.matrixWorld),
        i = t.sub(n),
        s = e.getWorldDirection(i6);
    return i.angleTo(s) > Math.PI / 2
}

function o6(r, e, t, n) {
    const i = nm.setFromMatrixPosition(r.matrixWorld),
        s = i.clone();
    s.project(e), OC.set(s.x, s.y), t.setFromCamera(OC, e);
    const o = t.intersectObjects(n, !0);
    if (o.length) {
        const a = o[0].distance;
        return i.distanceTo(t.ray.origin) < a
    }
    return !0
}

function a6(r, e) {
    if (e instanceof Ca) return e.zoom;
    if (e instanceof ri) {
        const t = nm.setFromMatrixPosition(r.matrixWorld),
            n = bM.setFromMatrixPosition(e.matrixWorld),
            i = e.fov * Math.PI / 180,
            s = t.distanceTo(n);
        return 1 / (2 * Math.tan(i / 2) * s)
    } else return 1
}

function l6(r, e, t) {
    if (e instanceof ri || e instanceof Ca) {
        const n = nm.setFromMatrixPosition(r.matrixWorld),
            i = bM.setFromMatrixPosition(e.matrixWorld),
            s = n.distanceTo(i),
            o = (t[1] - t[0]) / (e.far - e.near),
            a = t[1] - o * e.far;
        return Math.round(o * s + a)
    }
}
const EA = r => Math.abs(r) < 1e-10 ? 0 : r;

function RD(r, e, t = "") {
    let n = "matrix3d(";
    for (let i = 0; i !== 16; i++) n += EA(e[i] * r.elements[i]) + (i !== 15 ? "," : ")");
    return t + n
}
const c6 = (r => e => RD(e, r))([1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1, 1, -1, 1, 1]),
    u6 = (r => (e, t) => RD(e, r(t), "translate(-50%,-50%)"))(r => [1 / r, 1 / r, 1 / r, 1, -1 / r, -1 / r, -1 / r, -1, 1 / r, 1 / r, 1 / r, 1, 1, 1, 1, 1]);

function f6(r) {
    return r && typeof r == "object" && "current" in r
}
const Uv = N.forwardRef(({
        children: r,
        eps: e = .001,
        style: t,
        className: n,
        prepend: i,
        center: s,
        fullscreen: o,
        portal: a,
        distanceFactor: l,
        sprite: c = !1,
        transform: u = !1,
        occlude: f,
        onOcclude: d,
        castShadow: m,
        receiveShadow: g,
        material: y,
        geometry: v,
        zIndexRange: _ = [16777271, 0],
        calculatePosition: A = r6,
        as: S = "div",
        wrapperClass: M,
        pointerEvents: C = "auto",
        ...E
    }, R) => {
        const {
            gl: P,
            camera: b,
            scene: T,
            size: L,
            raycaster: D,
            events: V,
            viewport: H
        } = qn(), [q] = N.useState(() => document.createElement(S)), X = N.useRef(), oe = N.useRef(null), Y = N.useRef(0), Z = N.useRef([0, 0]), U = N.useRef(null), j = N.useRef(null), te = (a == null ? void 0 : a.current) || V.connected || P.domElement.parentNode, he = N.useRef(null), $ = N.useRef(!1), ne = N.useMemo(() => f && f !== "blending" || Array.isArray(f) && f.length && f6(f[0]), [f]);
        N.useLayoutEffect(() => {
            const ke = P.domElement;
            f && f === "blending" ? (ke.style.zIndex = `${Math.floor(_[0]/2)}`, ke.style.position = "absolute", ke.style.pointerEvents = "none") : (ke.style.zIndex = null, ke.style.position = null, ke.style.pointerEvents = null)
        }, [f]), N.useLayoutEffect(() => {
            if (oe.current) {
                const ke = X.current = G2(q);
                if (T.updateMatrixWorld(), u) q.style.cssText = "position:absolute;top:0;left:0;pointer-events:none;overflow:hidden;";
                else {
                    const Ee = A(oe.current, b, L);
                    q.style.cssText = `position:absolute;top:0;left:0;transform:translate3d(${Ee[0]}px,${Ee[1]}px,0);transform-origin:0 0;`
                }
                return te && (i ? te.prepend(q) : te.appendChild(q)), () => {
                    te && te.removeChild(q), ke.unmount()
                }
            }
        }, [te, u]), N.useLayoutEffect(() => {
            M && (q.className = M)
        }, [M]);
        const me = N.useMemo(() => u ? {
                position: "absolute",
                top: 0,
                left: 0,
                width: L.width,
                height: L.height,
                transformStyle: "preserve-3d",
                pointerEvents: "none"
            } : {
                position: "absolute",
                transform: s ? "translate3d(-50%,-50%,0)" : "none",
                ...o && {
                    top: -L.height / 2,
                    left: -L.width / 2,
                    width: L.width,
                    height: L.height
                },
                ...t
            }, [t, s, o, L, u]),
            ce = N.useMemo(() => ({
                position: "absolute",
                pointerEvents: C
            }), [C]);
        N.useLayoutEffect(() => {
            if ($.current = !1, u) {
                var ke;
                (ke = X.current) == null || ke.render(N.createElement("div", {
                    ref: U,
                    style: me
                }, N.createElement("div", {
                    ref: j,
                    style: ce
                }, N.createElement("div", {
                    ref: R,
                    className: n,
                    style: t,
                    children: r
                }))))
            } else {
                var Ee;
                (Ee = X.current) == null || Ee.render(N.createElement("div", {
                    ref: R,
                    style: me,
                    className: n,
                    children: r
                }))
            }
        });
        const _e = N.useRef(!0);
        Es(ke => {
            if (oe.current) {
                b.updateMatrixWorld(), oe.current.updateWorldMatrix(!0, !1);
                const Ee = u ? Z.current : A(oe.current, b, L);
                if (u || Math.abs(Y.current - b.zoom) > e || Math.abs(Z.current[0] - Ee[0]) > e || Math.abs(Z.current[1] - Ee[1]) > e) {
                    const pe = s6(oe.current, b);
                    let xe = !1;
                    ne && (Array.isArray(f) ? xe = f.map(se => se.current) : f !== "blending" && (xe = [T]));
                    const J = _e.current;
                    if (xe) {
                        const se = o6(oe.current, b, D, xe);
                        _e.current = se && !pe
                    } else _e.current = !pe;
                    J !== _e.current && (d ? d(!_e.current) : q.style.display = _e.current ? "block" : "none");
                    const De = Math.floor(_[0] / 2),
                        Ce = f ? ne ? [_[0], De] : [De - 1, 0] : _;
                    if (q.style.zIndex = `${l6(oe.current,b,Ce)}`, u) {
                        const [se, Se] = [L.width / 2, L.height / 2], Xe = b.projectionMatrix.elements[5] * Se, {
                            isOrthographicCamera: Le,
                            top: k,
                            left: z,
                            bottom: ue,
                            right: ye
                        } = b, ge = c6(b.matrixWorldInverse), Re = Le ? `scale(${Xe})translate(${EA(-(ye+z)/2)}px,${EA((k+ue)/2)}px)` : `translateZ(${Xe}px)`;
                        let Be = oe.current.matrixWorld;
                        c && (Be = b.matrixWorldInverse.clone().transpose().copyPosition(Be).scale(oe.current.scale), Be.elements[3] = Be.elements[7] = Be.elements[11] = 0, Be.elements[15] = 1), q.style.width = L.width + "px", q.style.height = L.height + "px", q.style.perspective = Le ? "" : `${Xe}px`, U.current && j.current && (U.current.style.transform = `${Re}${ge}translate(${se}px,${Se}px)`, j.current.style.transform = u6(Be, 1 / ((l || 10) / 400)))
                    } else {
                        const se = l === void 0 ? 1 : a6(oe.current, b) * l;
                        q.style.transform = `translate3d(${Ee[0]}px,${Ee[1]}px,0) scale(${se})`
                    }
                    Z.current = Ee, Y.current = b.zoom
                }
            }
            if (!ne && he.current && !$.current)
                if (u) {
                    if (U.current) {
                        const Ee = U.current.children[0];
                        if (Ee != null && Ee.clientWidth && Ee != null && Ee.clientHeight) {
                            const {
                                isOrthographicCamera: pe
                            } = b;
                            if (pe || v) E.scale && (Array.isArray(E.scale) ? E.scale instanceof K ? he.current.scale.copy(E.scale.clone().divideScalar(1)) : he.current.scale.set(1 / E.scale[0], 1 / E.scale[1], 1 / E.scale[2]) : he.current.scale.setScalar(1 / E.scale));
                            else {
                                const xe = (l || 10) / 400,
                                    J = Ee.clientWidth * xe,
                                    De = Ee.clientHeight * xe;
                                he.current.scale.set(J, De, 1)
                            }
                            $.current = !0
                        }
                    }
                } else {
                    const Ee = q.children[0];
                    if (Ee != null && Ee.clientWidth && Ee != null && Ee.clientHeight) {
                        const pe = 1 / H.factor,
                            xe = Ee.clientWidth * pe,
                            J = Ee.clientHeight * pe;
                        he.current.scale.set(xe, J, 1), $.current = !0
                    }
                    he.current.lookAt(ke.camera.position)
                }
        });
        const Oe = N.useMemo(() => ({
            vertexShader: u ? void 0 : `
          /*
            This shader is from the THREE's SpriteMaterial.
            We need to turn the backing plane into a Sprite
            (make it always face the camera) if "transfrom"
            is false.
          */
          #include <common>

          void main() {
            vec2 center = vec2(0., 1.);
            float rotation = 0.0;

            // This is somewhat arbitrary, but it seems to work well
            // Need to figure out how to derive this dynamically if it even matters
            float size = 0.03;

            vec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );
            vec2 scale;
            scale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );
            scale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );

            bool isPerspective = isPerspectiveMatrix( projectionMatrix );
            if ( isPerspective ) scale *= - mvPosition.z;

            vec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale * size;
            vec2 rotatedPosition;
            rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;
            rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;
            mvPosition.xy += rotatedPosition;

            gl_Position = projectionMatrix * mvPosition;
          }
      `,
            fragmentShader: `
        void main() {
          gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0);
        }
      `
        }), [u]);
        return N.createElement("group", Cl({}, E, {
            ref: oe
        }), f && !ne && N.createElement("mesh", {
            castShadow: m,
            receiveShadow: g,
            ref: he
        }, v || N.createElement("planeGeometry", null), y || N.createElement("shaderMaterial", {
            side: hn,
            vertexShader: Oe.vertexShader,
            fragmentShader: Oe.fragmentShader
        })))
    }),
    NC = r => {
        let e;
        const t = new Set,
            n = (c, u) => {
                const f = typeof c == "function" ? c(e) : c;
                if (!Object.is(f, e)) {
                    const d = e;
                    e = u ? ? (typeof f != "object" || f === null) ? f : Object.assign({}, e, f), t.forEach(m => m(e, d))
                }
            },
            i = () => e,
            a = {
                setState: n,
                getState: i,
                getInitialState: () => l,
                subscribe: c => (t.add(c), () => t.delete(c))
            },
            l = e = r(n, i, a);
        return a
    },
    h6 = r => r ? NC(r) : NC,
    d6 = r => r;

function p6(r, e = d6) {
    const t = ga.useSyncExternalStore(r.subscribe, () => e(r.getState()), () => e(r.getInitialState()));
    return ga.useDebugValue(t), t
}
const kC = r => {
        const e = h6(r),
            t = n => p6(e, n);
        return Object.assign(t, e), t
    },
    TM = r => r ? kC(r) : kC;
let sd;

function m6() {
    var r;
    if (sd !== void 0) return sd;
    try {
        let e;
        const t = document.createElement("canvas");
        return sd = !!(window.WebGL2RenderingContext && (e = t.getContext("webgl2"))), e && ((r = e.getExtension("WEBGL_lose_context")) == null || r.loseContext()), sd
    } catch {
        return sd = !1
    }
}
const g6 = parseInt(du.replace(/\D+/g, ""));

function zC(r, e) {
    if (e === eB) return console.warn("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Geometry already defined as triangles."), r;
    if (e === Iv || e === zS) {
        let t = r.getIndex();
        if (t === null) {
            const o = [],
                a = r.getAttribute("position");
            if (a !== void 0) {
                for (let l = 0; l < a.count; l++) o.push(l);
                r.setIndex(o), t = r.getIndex()
            } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Undefined position attribute. Processing not possible."), r
        }
        const n = t.count - 2,
            i = [];
        if (t)
            if (e === Iv)
                for (let o = 1; o <= n; o++) i.push(t.getX(0)), i.push(t.getX(o)), i.push(t.getX(o + 1));
            else
                for (let o = 0; o < n; o++) o % 2 === 0 ? (i.push(t.getX(o)), i.push(t.getX(o + 1)), i.push(t.getX(o + 2))) : (i.push(t.getX(o + 2)), i.push(t.getX(o + 1)), i.push(t.getX(o)));
        i.length / 3 !== n && console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unable to generate correct amount of triangles.");
        const s = r.clone();
        return s.setIndex(i), s.clearGroups(), s
    } else return console.error("THREE.BufferGeometryUtils.toTrianglesDrawMode(): Unknown draw mode:", e), r
}
var Ws = Uint8Array,
    al = Uint16Array,
    CA = Uint32Array,
    PD = new Ws([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
    ID = new Ws([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
    v6 = new Ws([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
    BD = function(r, e) {
        for (var t = new al(31), n = 0; n < 31; ++n) t[n] = e += 1 << r[n - 1];
        for (var i = new CA(t[30]), n = 1; n < 30; ++n)
            for (var s = t[n]; s < t[n + 1]; ++s) i[s] = s - t[n] << 5 | n;
        return [t, i]
    },
    DD = BD(PD, 2),
    LD = DD[0],
    y6 = DD[1];
LD[28] = 258, y6[258] = 28;
var _6 = BD(ID, 0),
    x6 = _6[0],
    RA = new al(32768);
for (var jn = 0; jn < 32768; ++jn) {
    var Xa = (jn & 43690) >>> 1 | (jn & 21845) << 1;
    Xa = (Xa & 52428) >>> 2 | (Xa & 13107) << 2, Xa = (Xa & 61680) >>> 4 | (Xa & 3855) << 4, RA[jn] = ((Xa & 65280) >>> 8 | (Xa & 255) << 8) >>> 1
}
var Kd = function(r, e, t) {
        for (var n = r.length, i = 0, s = new al(e); i < n; ++i) ++s[r[i] - 1];
        var o = new al(e);
        for (i = 0; i < e; ++i) o[i] = o[i - 1] + s[i - 1] << 1;
        var a;
        if (t) {
            a = new al(1 << e);
            var l = 15 - e;
            for (i = 0; i < n; ++i)
                if (r[i])
                    for (var c = i << 4 | r[i], u = e - r[i], f = o[r[i] - 1]++ << u, d = f | (1 << u) - 1; f <= d; ++f) a[RA[f] >>> l] = c
        } else
            for (a = new al(n), i = 0; i < n; ++i) r[i] && (a[i] = RA[o[r[i] - 1]++] >>> 15 - r[i]);
        return a
    },
    im = new Ws(288);
for (var jn = 0; jn < 144; ++jn) im[jn] = 8;
for (var jn = 144; jn < 256; ++jn) im[jn] = 9;
for (var jn = 256; jn < 280; ++jn) im[jn] = 7;
for (var jn = 280; jn < 288; ++jn) im[jn] = 8;
var FD = new Ws(32);
for (var jn = 0; jn < 32; ++jn) FD[jn] = 5;
var A6 = Kd(im, 9, 1),
    S6 = Kd(FD, 5, 1),
    t1 = function(r) {
        for (var e = r[0], t = 1; t < r.length; ++t) r[t] > e && (e = r[t]);
        return e
    },
    so = function(r, e, t) {
        var n = e / 8 | 0;
        return (r[n] | r[n + 1] << 8) >> (e & 7) & t
    },
    n1 = function(r, e) {
        var t = e / 8 | 0;
        return (r[t] | r[t + 1] << 8 | r[t + 2] << 16) >> (e & 7)
    },
    M6 = function(r) {
        return (r / 8 | 0) + (r & 7 && 1)
    },
    w6 = function(r, e, t) {
        (t == null || t > r.length) && (t = r.length);
        var n = new(r instanceof al ? al : r instanceof CA ? CA : Ws)(t - e);
        return n.set(r.subarray(e, t)), n
    },
    b6 = function(r, e, t) {
        var n = r.length;
        if (!n || t && !t.l && n < 5) return e || new Ws(0);
        var i = !e || t,
            s = !t || t.i;
        t || (t = {}), e || (e = new Ws(n * 3));
        var o = function(me) {
                var ce = e.length;
                if (me > ce) {
                    var _e = new Ws(Math.max(ce * 2, me));
                    _e.set(e), e = _e
                }
            },
            a = t.f || 0,
            l = t.p || 0,
            c = t.b || 0,
            u = t.l,
            f = t.d,
            d = t.m,
            m = t.n,
            g = n * 8;
        do {
            if (!u) {
                t.f = a = so(r, l, 1);
                var y = so(r, l + 1, 3);
                if (l += 3, y)
                    if (y == 1) u = A6, f = S6, d = 9, m = 5;
                    else if (y == 2) {
                    var S = so(r, l, 31) + 257,
                        M = so(r, l + 10, 15) + 4,
                        C = S + so(r, l + 5, 31) + 1;
                    l += 14;
                    for (var E = new Ws(C), R = new Ws(19), P = 0; P < M; ++P) R[v6[P]] = so(r, l + P * 3, 7);
                    l += M * 3;
                    for (var b = t1(R), T = (1 << b) - 1, L = Kd(R, b, 1), P = 0; P < C;) {
                        var D = L[so(r, l, T)];
                        l += D & 15;
                        var v = D >>> 4;
                        if (v < 16) E[P++] = v;
                        else {
                            var V = 0,
                                H = 0;
                            for (v == 16 ? (H = 3 + so(r, l, 3), l += 2, V = E[P - 1]) : v == 17 ? (H = 3 + so(r, l, 7), l += 3) : v == 18 && (H = 11 + so(r, l, 127), l += 7); H--;) E[P++] = V
                        }
                    }
                    var q = E.subarray(0, S),
                        X = E.subarray(S);
                    d = t1(q), m = t1(X), u = Kd(q, d, 1), f = Kd(X, m, 1)
                } else throw "invalid block type";
                else {
                    var v = M6(l) + 4,
                        _ = r[v - 4] | r[v - 3] << 8,
                        A = v + _;
                    if (A > n) {
                        if (s) throw "unexpected EOF";
                        break
                    }
                    i && o(c + _), e.set(r.subarray(v, A), c), t.b = c += _, t.p = l = A * 8;
                    continue
                }
                if (l > g) {
                    if (s) throw "unexpected EOF";
                    break
                }
            }
            i && o(c + 131072);
            for (var oe = (1 << d) - 1, Y = (1 << m) - 1, Z = l;; Z = l) {
                var V = u[n1(r, l) & oe],
                    U = V >>> 4;
                if (l += V & 15, l > g) {
                    if (s) throw "unexpected EOF";
                    break
                }
                if (!V) throw "invalid length/literal";
                if (U < 256) e[c++] = U;
                else if (U == 256) {
                    Z = l, u = null;
                    break
                } else {
                    var j = U - 254;
                    if (U > 264) {
                        var P = U - 257,
                            te = PD[P];
                        j = so(r, l, (1 << te) - 1) + LD[P], l += te
                    }
                    var he = f[n1(r, l) & Y],
                        $ = he >>> 4;
                    if (!he) throw "invalid distance";
                    l += he & 15;
                    var X = x6[$];
                    if ($ > 3) {
                        var te = ID[$];
                        X += n1(r, l) & (1 << te) - 1, l += te
                    }
                    if (l > g) {
                        if (s) throw "unexpected EOF";
                        break
                    }
                    i && o(c + 131072);
                    for (var ne = c + j; c < ne; c += 4) e[c] = e[c - X], e[c + 1] = e[c + 1 - X], e[c + 2] = e[c + 2 - X], e[c + 3] = e[c + 3 - X];
                    c = ne
                }
            }
            t.l = u, t.p = Z, t.b = c, u && (a = 1, t.m = d, t.d = f, t.n = m)
        } while (!a);
        return c == e.length ? e : w6(e, 0, c)
    },
    T6 = new Ws(0),
    E6 = function(r) {
        if ((r[0] & 15) != 8 || r[0] >>> 4 > 7 || (r[0] << 8 | r[1]) % 31) throw "invalid zlib data";
        if (r[1] & 32) throw "invalid zlib data: preset dictionaries not supported"
    };

function l0(r, e) {
    return b6((E6(r), r.subarray(2, -4)), e)
}
var C6 = typeof TextDecoder < "u" && new TextDecoder,
    R6 = 0;
try {
    C6.decode(T6, {
        stream: !0
    }), R6 = 1
} catch {}
const P6 = r => r && r.isCubeTexture;
class I6 extends Tn {
    constructor(e, t) {
        var n, i;
        const s = P6(e),
            a = ((i = s ? (n = e.image[0]) == null ? void 0 : n.width : e.image.width) != null ? i : 1024) / 4,
            l = Math.floor(Math.log2(a)),
            c = Math.pow(2, l),
            u = 3 * Math.max(c, 16 * 7),
            f = 4 * c,
            d = [s ? "#define ENVMAP_TYPE_CUBE" : "", `#define CUBEUV_TEXEL_WIDTH ${1/u}`, `#define CUBEUV_TEXEL_HEIGHT ${1/f}`, `#define CUBEUV_MAX_MIP ${l}.0`],
            m = `
        varying vec3 vWorldPosition;
        void main() 
        {
            vec4 worldPosition = ( modelMatrix * vec4( position, 1.0 ) );
            vWorldPosition = worldPosition.xyz;
            
            gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );
        }
        `,
            g = d.join(`
`) + `
        #define ENVMAP_TYPE_CUBE_UV
        varying vec3 vWorldPosition;
        uniform float radius;
        uniform float height;
        uniform float angle;
        #ifdef ENVMAP_TYPE_CUBE
            uniform samplerCube map;
        #else
            uniform sampler2D map;
        #endif
        // From: https://www.shadertoy.com/view/4tsBD7
        float diskIntersectWithBackFaceCulling( vec3 ro, vec3 rd, vec3 c, vec3 n, float r ) 
        {
            float d = dot ( rd, n );
            
            if( d > 0.0 ) { return 1e6; }
            
            vec3  o = ro - c;
            float t = - dot( n, o ) / d;
            vec3  q = o + rd * t;
            
            return ( dot( q, q ) < r * r ) ? t : 1e6;
        }
        // From: https://www.iquilezles.org/www/articles/intersectors/intersectors.htm
        float sphereIntersect( vec3 ro, vec3 rd, vec3 ce, float ra ) 
        {
            vec3 oc = ro - ce;
            float b = dot( oc, rd );
            float c = dot( oc, oc ) - ra * ra;
            float h = b * b - c;
            
            if( h < 0.0 ) { return -1.0; }
            
            h = sqrt( h );
            
            return - b + h;
        }
        vec3 project() 
        {
            vec3 p = normalize( vWorldPosition );
            vec3 camPos = cameraPosition;
            camPos.y -= height;
            float intersection = sphereIntersect( camPos, p, vec3( 0.0 ), radius );
            if( intersection > 0.0 ) {
                
                vec3 h = vec3( 0.0, - height, 0.0 );
                float intersection2 = diskIntersectWithBackFaceCulling( camPos, p, h, vec3( 0.0, 1.0, 0.0 ), radius );
                p = ( camPos + min( intersection, intersection2 ) * p ) / radius;
            } else {
                p = vec3( 0.0, 1.0, 0.0 );
            }
            return p;
        }
        #include <common>
        #include <cube_uv_reflection_fragment>
        void main() 
        {
            vec3 projectedWorldPosition = project();
            
            #ifdef ENVMAP_TYPE_CUBE
                vec3 outcolor = textureCube( map, projectedWorldPosition ).rgb;
            #else
                vec3 direction = normalize( projectedWorldPosition );
                vec2 uv = equirectUv( direction );
                vec3 outcolor = texture2D( map, uv ).rgb;
            #endif
            gl_FragColor = vec4( outcolor, 1.0 );
            #include <tonemapping_fragment>
            #include <${parseInt(du.replace(/\D+/g,""))>=154?"colorspace_fragment":"encodings_fragment"}>
        }
        `,
            y = {
                map: {
                    value: e
                },
                height: {
                    value: (t == null ? void 0 : t.height) || 15
                },
                radius: {
                    value: (t == null ? void 0 : t.radius) || 100
                }
            },
            v = new Qp(1, 16),
            _ = new Fn({
                uniforms: y,
                fragmentShader: g,
                vertexShader: m,
                side: hn
            });
        super(v, _)
    }
    set radius(e) {
        this.material.uniforms.radius.value = e
    }
    get radius() {
        return this.material.uniforms.radius.value
    }
    set height(e) {
        this.material.uniforms.height.value = e
    }
    get height() {
        return this.material.uniforms.height.value
    }
}

function Ov(r) {
    if (typeof TextDecoder < "u") return new TextDecoder().decode(r);
    let e = "";
    for (let t = 0, n = r.length; t < n; t++) e += String.fromCharCode(r[t]);
    try {
        return decodeURIComponent(escape(e))
    } catch {
        return e
    }
}
const Oc = "srgb",
    _a = "srgb-linear",
    GC = 3001,
    B6 = 3e3;
class EM extends er {
    constructor(e) {
        super(e), this.dracoLoader = null, this.ktx2Loader = null, this.meshoptDecoder = null, this.pluginCallbacks = [], this.register(function(t) {
            return new O6(t)
        }), this.register(function(t) {
            return new N6(t)
        }), this.register(function(t) {
            return new Y6(t)
        }), this.register(function(t) {
            return new J6(t)
        }), this.register(function(t) {
            return new K6(t)
        }), this.register(function(t) {
            return new z6(t)
        }), this.register(function(t) {
            return new G6(t)
        }), this.register(function(t) {
            return new H6(t)
        }), this.register(function(t) {
            return new V6(t)
        }), this.register(function(t) {
            return new U6(t)
        }), this.register(function(t) {
            return new W6(t)
        }), this.register(function(t) {
            return new k6(t)
        }), this.register(function(t) {
            return new X6(t)
        }), this.register(function(t) {
            return new j6(t)
        }), this.register(function(t) {
            return new L6(t)
        }), this.register(function(t) {
            return new q6(t)
        }), this.register(function(t) {
            return new Z6(t)
        })
    }
    load(e, t, n, i) {
        const s = this;
        let o;
        if (this.resourcePath !== "") o = this.resourcePath;
        else if (this.path !== "") {
            const c = pl.extractUrlBase(e);
            o = pl.resolveURL(c, this.path)
        } else o = pl.extractUrlBase(e);
        this.manager.itemStart(e);
        const a = function(c) {
                i ? i(c) : console.error(c), s.manager.itemError(e), s.manager.itemEnd(e)
            },
            l = new $i(this.manager);
        l.setPath(this.path), l.setResponseType("arraybuffer"), l.setRequestHeader(this.requestHeader), l.setWithCredentials(this.withCredentials), l.load(e, function(c) {
            try {
                s.parse(c, o, function(u) {
                    t(u), s.manager.itemEnd(e)
                }, a)
            } catch (u) {
                a(u)
            }
        }, n, a)
    }
    setDRACOLoader(e) {
        return this.dracoLoader = e, this
    }
    setDDSLoader() {
        throw new Error('THREE.GLTFLoader: "MSFT_texture_dds" no longer supported. Please update to "KHR_texture_basisu".')
    }
    setKTX2Loader(e) {
        return this.ktx2Loader = e, this
    }
    setMeshoptDecoder(e) {
        return this.meshoptDecoder = e, this
    }
    register(e) {
        return this.pluginCallbacks.indexOf(e) === -1 && this.pluginCallbacks.push(e), this
    }
    unregister(e) {
        return this.pluginCallbacks.indexOf(e) !== -1 && this.pluginCallbacks.splice(this.pluginCallbacks.indexOf(e), 1), this
    }
    parse(e, t, n, i) {
        let s;
        const o = {},
            a = {};
        if (typeof e == "string") s = JSON.parse(e);
        else if (e instanceof ArrayBuffer)
            if (Ov(new Uint8Array(e.slice(0, 4))) === UD) {
                try {
                    o[mn.KHR_BINARY_GLTF] = new Q6(e)
                } catch (u) {
                    i && i(u);
                    return
                }
                s = JSON.parse(o[mn.KHR_BINARY_GLTF].content)
            } else s = JSON.parse(Ov(new Uint8Array(e)));
        else s = e;
        if (s.asset === void 0 || s.asset.version[0] < 2) {
            i && i(new Error("THREE.GLTFLoader: Unsupported asset. glTF versions >=2.0 are supported."));
            return
        }
        const l = new f9(s, {
            path: t || this.resourcePath || "",
            crossOrigin: this.crossOrigin,
            requestHeader: this.requestHeader,
            manager: this.manager,
            ktx2Loader: this.ktx2Loader,
            meshoptDecoder: this.meshoptDecoder
        });
        l.fileLoader.setRequestHeader(this.requestHeader);
        for (let c = 0; c < this.pluginCallbacks.length; c++) {
            const u = this.pluginCallbacks[c](l);
            u.name || console.error("THREE.GLTFLoader: Invalid plugin found: missing name"), a[u.name] = u, o[u.name] = !0
        }
        if (s.extensionsUsed)
            for (let c = 0; c < s.extensionsUsed.length; ++c) {
                const u = s.extensionsUsed[c],
                    f = s.extensionsRequired || [];
                switch (u) {
                    case mn.KHR_MATERIALS_UNLIT:
                        o[u] = new F6;
                        break;
                    case mn.KHR_DRACO_MESH_COMPRESSION:
                        o[u] = new $6(s, this.dracoLoader);
                        break;
                    case mn.KHR_TEXTURE_TRANSFORM:
                        o[u] = new e9;
                        break;
                    case mn.KHR_MESH_QUANTIZATION:
                        o[u] = new t9;
                        break;
                    default:
                        f.indexOf(u) >= 0 && a[u] === void 0 && console.warn('THREE.GLTFLoader: Unknown extension "' + u + '".')
                }
            }
        l.setExtensions(o), l.setPlugins(a), l.parse(n, i)
    }
    parseAsync(e, t) {
        const n = this;
        return new Promise(function(i, s) {
            n.parse(e, t, i, s)
        })
    }
}

function D6() {
    let r = {};
    return {
        get: function(e) {
            return r[e]
        },
        add: function(e, t) {
            r[e] = t
        },
        remove: function(e) {
            delete r[e]
        },
        removeAll: function() {
            r = {}
        }
    }
}
const mn = {
    KHR_BINARY_GLTF: "KHR_binary_glTF",
    KHR_DRACO_MESH_COMPRESSION: "KHR_draco_mesh_compression",
    KHR_LIGHTS_PUNCTUAL: "KHR_lights_punctual",
    KHR_MATERIALS_CLEARCOAT: "KHR_materials_clearcoat",
    KHR_MATERIALS_DISPERSION: "KHR_materials_dispersion",
    KHR_MATERIALS_IOR: "KHR_materials_ior",
    KHR_MATERIALS_SHEEN: "KHR_materials_sheen",
    KHR_MATERIALS_SPECULAR: "KHR_materials_specular",
    KHR_MATERIALS_TRANSMISSION: "KHR_materials_transmission",
    KHR_MATERIALS_IRIDESCENCE: "KHR_materials_iridescence",
    KHR_MATERIALS_ANISOTROPY: "KHR_materials_anisotropy",
    KHR_MATERIALS_UNLIT: "KHR_materials_unlit",
    KHR_MATERIALS_VOLUME: "KHR_materials_volume",
    KHR_TEXTURE_BASISU: "KHR_texture_basisu",
    KHR_TEXTURE_TRANSFORM: "KHR_texture_transform",
    KHR_MESH_QUANTIZATION: "KHR_mesh_quantization",
    KHR_MATERIALS_EMISSIVE_STRENGTH: "KHR_materials_emissive_strength",
    EXT_MATERIALS_BUMP: "EXT_materials_bump",
    EXT_TEXTURE_WEBP: "EXT_texture_webp",
    EXT_TEXTURE_AVIF: "EXT_texture_avif",
    EXT_MESHOPT_COMPRESSION: "EXT_meshopt_compression",
    EXT_MESH_GPU_INSTANCING: "EXT_mesh_gpu_instancing"
};
class L6 {
    constructor(e) {
        this.parser = e, this.name = mn.KHR_LIGHTS_PUNCTUAL, this.cache = {
            refs: {},
            uses: {}
        }
    }
    _markDefs() {
        const e = this.parser,
            t = this.parser.json.nodes || [];
        for (let n = 0, i = t.length; n < i; n++) {
            const s = t[n];
            s.extensions && s.extensions[this.name] && s.extensions[this.name].light !== void 0 && e._addNodeRef(this.cache, s.extensions[this.name].light)
        }
    }
    _loadLight(e) {
        const t = this.parser,
            n = "light:" + e;
        let i = t.cache.get(n);
        if (i) return i;
        const s = t.json,
            l = ((s.extensions && s.extensions[this.name] || {}).lights || [])[e];
        let c;
        const u = new rt(16777215);
        l.color !== void 0 && u.setRGB(l.color[0], l.color[1], l.color[2], _a);
        const f = l.range !== void 0 ? l.range : 0;
        switch (l.type) {
            case "directional":
                c = new Mp(u), c.target.position.set(0, 0, -1), c.add(c.target);
                break;
            case "point":
                c = new Uy(u), c.distance = f;
                break;
            case "spot":
                c = new hM(u), c.distance = f, l.spot = l.spot || {}, l.spot.innerConeAngle = l.spot.innerConeAngle !== void 0 ? l.spot.innerConeAngle : 0, l.spot.outerConeAngle = l.spot.outerConeAngle !== void 0 ? l.spot.outerConeAngle : Math.PI / 4, c.angle = l.spot.outerConeAngle, c.penumbra = 1 - l.spot.innerConeAngle / l.spot.outerConeAngle, c.target.position.set(0, 0, -1), c.add(c.target);
                break;
            default:
                throw new Error("THREE.GLTFLoader: Unexpected light type: " + l.type)
        }
        return c.position.set(0, 0, 0), c.decay = 2, sa(c, l), l.intensity !== void 0 && (c.intensity = l.intensity), c.name = t.createUniqueName(l.name || "light_" + e), i = Promise.resolve(c), t.cache.add(n, i), i
    }
    getDependency(e, t) {
        if (e === "light") return this._loadLight(t)
    }
    createNodeAttachment(e) {
        const t = this,
            n = this.parser,
            s = n.json.nodes[e],
            a = (s.extensions && s.extensions[this.name] || {}).light;
        return a === void 0 ? null : this._loadLight(a).then(function(l) {
            return n._getNodeRef(t.cache, a, l)
        })
    }
}
class F6 {
    constructor() {
        this.name = mn.KHR_MATERIALS_UNLIT
    }
    getMaterialType() {
        return Mi
    }
    extendParams(e, t, n) {
        const i = [];
        e.color = new rt(1, 1, 1), e.opacity = 1;
        const s = t.pbrMetallicRoughness;
        if (s) {
            if (Array.isArray(s.baseColorFactor)) {
                const o = s.baseColorFactor;
                e.color.setRGB(o[0], o[1], o[2], _a), e.opacity = o[3]
            }
            s.baseColorTexture !== void 0 && i.push(n.assignTexture(e, "map", s.baseColorTexture, Oc))
        }
        return Promise.all(i)
    }
}
class U6 {
    constructor(e) {
        this.parser = e, this.name = mn.KHR_MATERIALS_EMISSIVE_STRENGTH
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = i.extensions[this.name].emissiveStrength;
        return s !== void 0 && (t.emissiveIntensity = s), Promise.resolve()
    }
}
class O6 {
    constructor(e) {
        this.parser = e, this.name = mn.KHR_MATERIALS_CLEARCOAT
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Ts
    }
    extendMaterialParams(e, t) {
        const n = this.parser,
            i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        if (o.clearcoatFactor !== void 0 && (t.clearcoat = o.clearcoatFactor), o.clearcoatTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatMap", o.clearcoatTexture)), o.clearcoatRoughnessFactor !== void 0 && (t.clearcoatRoughness = o.clearcoatRoughnessFactor), o.clearcoatRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "clearcoatRoughnessMap", o.clearcoatRoughnessTexture)), o.clearcoatNormalTexture !== void 0 && (s.push(n.assignTexture(t, "clearcoatNormalMap", o.clearcoatNormalTexture)), o.clearcoatNormalTexture.scale !== void 0)) {
            const a = o.clearcoatNormalTexture.scale;
            t.clearcoatNormalScale = new Ue(a, a)
        }
        return Promise.all(s)
    }
}
class N6 {
    constructor(e) {
        this.parser = e, this.name = mn.KHR_MATERIALS_DISPERSION
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Ts
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = i.extensions[this.name];
        return t.dispersion = s.dispersion !== void 0 ? s.dispersion : 0, Promise.resolve()
    }
}
class k6 {
    constructor(e) {
        this.parser = e, this.name = mn.KHR_MATERIALS_IRIDESCENCE
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Ts
    }
    extendMaterialParams(e, t) {
        const n = this.parser,
            i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        return o.iridescenceFactor !== void 0 && (t.iridescence = o.iridescenceFactor), o.iridescenceTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceMap", o.iridescenceTexture)), o.iridescenceIor !== void 0 && (t.iridescenceIOR = o.iridescenceIor), t.iridescenceThicknessRange === void 0 && (t.iridescenceThicknessRange = [100, 400]), o.iridescenceThicknessMinimum !== void 0 && (t.iridescenceThicknessRange[0] = o.iridescenceThicknessMinimum), o.iridescenceThicknessMaximum !== void 0 && (t.iridescenceThicknessRange[1] = o.iridescenceThicknessMaximum), o.iridescenceThicknessTexture !== void 0 && s.push(n.assignTexture(t, "iridescenceThicknessMap", o.iridescenceThicknessTexture)), Promise.all(s)
    }
}
class z6 {
    constructor(e) {
        this.parser = e, this.name = mn.KHR_MATERIALS_SHEEN
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Ts
    }
    extendMaterialParams(e, t) {
        const n = this.parser,
            i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [];
        t.sheenColor = new rt(0, 0, 0), t.sheenRoughness = 0, t.sheen = 1;
        const o = i.extensions[this.name];
        if (o.sheenColorFactor !== void 0) {
            const a = o.sheenColorFactor;
            t.sheenColor.setRGB(a[0], a[1], a[2], _a)
        }
        return o.sheenRoughnessFactor !== void 0 && (t.sheenRoughness = o.sheenRoughnessFactor), o.sheenColorTexture !== void 0 && s.push(n.assignTexture(t, "sheenColorMap", o.sheenColorTexture, Oc)), o.sheenRoughnessTexture !== void 0 && s.push(n.assignTexture(t, "sheenRoughnessMap", o.sheenRoughnessTexture)), Promise.all(s)
    }
}
class G6 {
    constructor(e) {
        this.parser = e, this.name = mn.KHR_MATERIALS_TRANSMISSION
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Ts
    }
    extendMaterialParams(e, t) {
        const n = this.parser,
            i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        return o.transmissionFactor !== void 0 && (t.transmission = o.transmissionFactor), o.transmissionTexture !== void 0 && s.push(n.assignTexture(t, "transmissionMap", o.transmissionTexture)), Promise.all(s)
    }
}
class H6 {
    constructor(e) {
        this.parser = e, this.name = mn.KHR_MATERIALS_VOLUME
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Ts
    }
    extendMaterialParams(e, t) {
        const n = this.parser,
            i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        t.thickness = o.thicknessFactor !== void 0 ? o.thicknessFactor : 0, o.thicknessTexture !== void 0 && s.push(n.assignTexture(t, "thicknessMap", o.thicknessTexture)), t.attenuationDistance = o.attenuationDistance || 1 / 0;
        const a = o.attenuationColor || [1, 1, 1];
        return t.attenuationColor = new rt().setRGB(a[0], a[1], a[2], _a), Promise.all(s)
    }
}
class V6 {
    constructor(e) {
        this.parser = e, this.name = mn.KHR_MATERIALS_IOR
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Ts
    }
    extendMaterialParams(e, t) {
        const i = this.parser.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = i.extensions[this.name];
        return t.ior = s.ior !== void 0 ? s.ior : 1.5, Promise.resolve()
    }
}
class W6 {
    constructor(e) {
        this.parser = e, this.name = mn.KHR_MATERIALS_SPECULAR
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Ts
    }
    extendMaterialParams(e, t) {
        const n = this.parser,
            i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        t.specularIntensity = o.specularFactor !== void 0 ? o.specularFactor : 1, o.specularTexture !== void 0 && s.push(n.assignTexture(t, "specularIntensityMap", o.specularTexture));
        const a = o.specularColorFactor || [1, 1, 1];
        return t.specularColor = new rt().setRGB(a[0], a[1], a[2], _a), o.specularColorTexture !== void 0 && s.push(n.assignTexture(t, "specularColorMap", o.specularColorTexture, Oc)), Promise.all(s)
    }
}
class j6 {
    constructor(e) {
        this.parser = e, this.name = mn.EXT_MATERIALS_BUMP
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Ts
    }
    extendMaterialParams(e, t) {
        const n = this.parser,
            i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        return t.bumpScale = o.bumpFactor !== void 0 ? o.bumpFactor : 1, o.bumpTexture !== void 0 && s.push(n.assignTexture(t, "bumpMap", o.bumpTexture)), Promise.all(s)
    }
}
class X6 {
    constructor(e) {
        this.parser = e, this.name = mn.KHR_MATERIALS_ANISOTROPY
    }
    getMaterialType(e) {
        const n = this.parser.json.materials[e];
        return !n.extensions || !n.extensions[this.name] ? null : Ts
    }
    extendMaterialParams(e, t) {
        const n = this.parser,
            i = n.json.materials[e];
        if (!i.extensions || !i.extensions[this.name]) return Promise.resolve();
        const s = [],
            o = i.extensions[this.name];
        return o.anisotropyStrength !== void 0 && (t.anisotropy = o.anisotropyStrength), o.anisotropyRotation !== void 0 && (t.anisotropyRotation = o.anisotropyRotation), o.anisotropyTexture !== void 0 && s.push(n.assignTexture(t, "anisotropyMap", o.anisotropyTexture)), Promise.all(s)
    }
}
class Y6 {
    constructor(e) {
        this.parser = e, this.name = mn.KHR_TEXTURE_BASISU
    }
    loadTexture(e) {
        const t = this.parser,
            n = t.json,
            i = n.textures[e];
        if (!i.extensions || !i.extensions[this.name]) return null;
        const s = i.extensions[this.name],
            o = t.options.ktx2Loader;
        if (!o) {
            if (n.extensionsRequired && n.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setKTX2Loader must be called before loading KTX2 textures");
            return null
        }
        return t.loadTextureImage(e, s.source, o)
    }
}
class J6 {
    constructor(e) {
        this.parser = e, this.name = mn.EXT_TEXTURE_WEBP, this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name,
            n = this.parser,
            i = n.json,
            s = i.textures[e];
        if (!s.extensions || !s.extensions[t]) return null;
        const o = s.extensions[t],
            a = i.images[o.source];
        let l = n.textureLoader;
        if (a.uri) {
            const c = n.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c) return n.loadTextureImage(e, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: WebP required by asset but unsupported.");
            return n.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/webp;base64,UklGRiIAAABXRUJQVlA4IBYAAAAwAQCdASoBAAEADsD+JaQAA3AAAAAA", t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        })), this.isSupported
    }
}
class K6 {
    constructor(e) {
        this.parser = e, this.name = mn.EXT_TEXTURE_AVIF, this.isSupported = null
    }
    loadTexture(e) {
        const t = this.name,
            n = this.parser,
            i = n.json,
            s = i.textures[e];
        if (!s.extensions || !s.extensions[t]) return null;
        const o = s.extensions[t],
            a = i.images[o.source];
        let l = n.textureLoader;
        if (a.uri) {
            const c = n.options.manager.getHandler(a.uri);
            c !== null && (l = c)
        }
        return this.detectSupport().then(function(c) {
            if (c) return n.loadTextureImage(e, o.source, l);
            if (i.extensionsRequired && i.extensionsRequired.indexOf(t) >= 0) throw new Error("THREE.GLTFLoader: AVIF required by asset but unsupported.");
            return n.loadTexture(e)
        })
    }
    detectSupport() {
        return this.isSupported || (this.isSupported = new Promise(function(e) {
            const t = new Image;
            t.src = "data:image/avif;base64,AAAAIGZ0eXBhdmlmAAAAAGF2aWZtaWYxbWlhZk1BMUIAAADybWV0YQAAAAAAAAAoaGRscgAAAAAAAAAAcGljdAAAAAAAAAAAAAAAAGxpYmF2aWYAAAAADnBpdG0AAAAAAAEAAAAeaWxvYwAAAABEAAABAAEAAAABAAABGgAAABcAAAAoaWluZgAAAAAAAQAAABppbmZlAgAAAAABAABhdjAxQ29sb3IAAAAAamlwcnAAAABLaXBjbwAAABRpc3BlAAAAAAAAAAEAAAABAAAAEHBpeGkAAAAAAwgICAAAAAxhdjFDgQAMAAAAABNjb2xybmNseAACAAIABoAAAAAXaXBtYQAAAAAAAAABAAEEAQKDBAAAAB9tZGF0EgAKCBgABogQEDQgMgkQAAAAB8dSLfI=", t.onload = t.onerror = function() {
                e(t.height === 1)
            }
        })), this.isSupported
    }
}
class q6 {
    constructor(e) {
        this.name = mn.EXT_MESHOPT_COMPRESSION, this.parser = e
    }
    loadBufferView(e) {
        const t = this.parser.json,
            n = t.bufferViews[e];
        if (n.extensions && n.extensions[this.name]) {
            const i = n.extensions[this.name],
                s = this.parser.getDependency("buffer", i.buffer),
                o = this.parser.options.meshoptDecoder;
            if (!o || !o.supported) {
                if (t.extensionsRequired && t.extensionsRequired.indexOf(this.name) >= 0) throw new Error("THREE.GLTFLoader: setMeshoptDecoder must be called before loading compressed files");
                return null
            }
            return s.then(function(a) {
                const l = i.byteOffset || 0,
                    c = i.byteLength || 0,
                    u = i.count,
                    f = i.byteStride,
                    d = new Uint8Array(a, l, c);
                return o.decodeGltfBufferAsync ? o.decodeGltfBufferAsync(u, f, d, i.mode, i.filter).then(function(m) {
                    return m.buffer
                }) : o.ready.then(function() {
                    const m = new ArrayBuffer(u * f);
                    return o.decodeGltfBuffer(new Uint8Array(m), u, f, d, i.mode, i.filter), m
                })
            })
        } else return null
    }
}
class Z6 {
    constructor(e) {
        this.name = mn.EXT_MESH_GPU_INSTANCING, this.parser = e
    }
    createNodeMesh(e) {
        const t = this.parser.json,
            n = t.nodes[e];
        if (!n.extensions || !n.extensions[this.name] || n.mesh === void 0) return null;
        const i = t.meshes[n.mesh];
        for (const c of i.primitives)
            if (c.mode !== zs.TRIANGLES && c.mode !== zs.TRIANGLE_STRIP && c.mode !== zs.TRIANGLE_FAN && c.mode !== void 0) return null;
        const o = n.extensions[this.name].attributes,
            a = [],
            l = {};
        for (const c in o) a.push(this.parser.getDependency("accessor", o[c]).then(u => (l[c] = u, l[c])));
        return a.length < 1 ? null : (a.push(this.parser.createNodeMesh(e)), Promise.all(a).then(c => {
            const u = c.pop(),
                f = u.isGroup ? u.children : [u],
                d = c[0].count,
                m = [];
            for (const g of f) {
                const y = new Ot,
                    v = new K,
                    _ = new gr,
                    A = new K(1, 1, 1),
                    S = new QS(g.geometry, g.material, d);
                for (let M = 0; M < d; M++) l.TRANSLATION && v.fromBufferAttribute(l.TRANSLATION, M), l.ROTATION && _.fromBufferAttribute(l.ROTATION, M), l.SCALE && A.fromBufferAttribute(l.SCALE, M), S.setMatrixAt(M, y.compose(v, _, A));
                for (const M in l)
                    if (M === "_COLOR_0") {
                        const C = l[M];
                        S.instanceColor = new El(C.array, C.itemSize, C.normalized)
                    } else M !== "TRANSLATION" && M !== "ROTATION" && M !== "SCALE" && g.geometry.setAttribute(M, l[M]);
                vn.prototype.copy.call(S, g), this.parser.assignFinalMaterial(S), m.push(S)
            }
            return u.isGroup ? (u.clear(), u.add(...m), u) : m[0]
        }))
    }
}
const UD = "glTF",
    od = 12,
    HC = {
        JSON: 1313821514,
        BIN: 5130562
    };
class Q6 {
    constructor(e) {
        this.name = mn.KHR_BINARY_GLTF, this.content = null, this.body = null;
        const t = new DataView(e, 0, od);
        if (this.header = {
                magic: Ov(new Uint8Array(e.slice(0, 4))),
                version: t.getUint32(4, !0),
                length: t.getUint32(8, !0)
            }, this.header.magic !== UD) throw new Error("THREE.GLTFLoader: Unsupported glTF-Binary header.");
        if (this.header.version < 2) throw new Error("THREE.GLTFLoader: Legacy binary file detected.");
        const n = this.header.length - od,
            i = new DataView(e, od);
        let s = 0;
        for (; s < n;) {
            const o = i.getUint32(s, !0);
            s += 4;
            const a = i.getUint32(s, !0);
            if (s += 4, a === HC.JSON) {
                const l = new Uint8Array(e, od + s, o);
                this.content = Ov(l)
            } else if (a === HC.BIN) {
                const l = od + s;
                this.body = e.slice(l, l + o)
            }
            s += o
        }
        if (this.content === null) throw new Error("THREE.GLTFLoader: JSON content not found.")
    }
}
class $6 {
    constructor(e, t) {
        if (!t) throw new Error("THREE.GLTFLoader: No DRACOLoader instance provided.");
        this.name = mn.KHR_DRACO_MESH_COMPRESSION, this.json = e, this.dracoLoader = t, this.dracoLoader.preload()
    }
    decodePrimitive(e, t) {
        const n = this.json,
            i = this.dracoLoader,
            s = e.extensions[this.name].bufferView,
            o = e.extensions[this.name].attributes,
            a = {},
            l = {},
            c = {};
        for (const u in o) {
            const f = PA[u] || u.toLowerCase();
            a[f] = o[u]
        }
        for (const u in e.attributes) {
            const f = PA[u] || u.toLowerCase();
            if (o[u] !== void 0) {
                const d = n.accessors[e.attributes[u]],
                    m = Df[d.componentType];
                c[f] = m.name, l[f] = d.normalized === !0
            }
        }
        return t.getDependency("bufferView", s).then(function(u) {
            return new Promise(function(f, d) {
                i.decodeDracoFile(u, function(m) {
                    for (const g in m.attributes) {
                        const y = m.attributes[g],
                            v = l[g];
                        v !== void 0 && (y.normalized = v)
                    }
                    f(m)
                }, a, c, _a, d)
            })
        })
    }
}
class e9 {
    constructor() {
        this.name = mn.KHR_TEXTURE_TRANSFORM
    }
    extendTexture(e, t) {
        return (t.texCoord === void 0 || t.texCoord === e.channel) && t.offset === void 0 && t.rotation === void 0 && t.scale === void 0 || (e = e.clone(), t.texCoord !== void 0 && (e.channel = t.texCoord), t.offset !== void 0 && e.offset.fromArray(t.offset), t.rotation !== void 0 && (e.rotation = t.rotation), t.scale !== void 0 && e.repeat.fromArray(t.scale), e.needsUpdate = !0), e
    }
}
class t9 {
    constructor() {
        this.name = mn.KHR_MESH_QUANTIZATION
    }
}
class OD extends uh {
    constructor(e, t, n, i) {
        super(e, t, n, i)
    }
    copySampleValue_(e) {
        const t = this.resultBuffer,
            n = this.sampleValues,
            i = this.valueSize,
            s = e * i * 3 + i;
        for (let o = 0; o !== i; o++) t[o] = n[s + o];
        return t
    }
    interpolate_(e, t, n, i) {
        const s = this.resultBuffer,
            o = this.sampleValues,
            a = this.valueSize,
            l = a * 2,
            c = a * 3,
            u = i - t,
            f = (n - t) / u,
            d = f * f,
            m = d * f,
            g = e * c,
            y = g - c,
            v = -2 * m + 3 * d,
            _ = m - d,
            A = 1 - v,
            S = _ - d + f;
        for (let M = 0; M !== a; M++) {
            const C = o[y + M + a],
                E = o[y + M + l] * u,
                R = o[g + M + a],
                P = o[g + M] * u;
            s[M] = A * C + S * E + v * R + _ * P
        }
        return s
    }
}
const n9 = new gr;
class i9 extends OD {
    interpolate_(e, t, n, i) {
        const s = super.interpolate_(e, t, n, i);
        return n9.fromArray(s).normalize().toArray(s), s
    }
}
const zs = {
        FLOAT: 5126,
        FLOAT_MAT3: 35675,
        FLOAT_MAT4: 35676,
        FLOAT_VEC2: 35664,
        FLOAT_VEC3: 35665,
        FLOAT_VEC4: 35666,
        LINEAR: 9729,
        REPEAT: 10497,
        SAMPLER_2D: 35678,
        POINTS: 0,
        LINES: 1,
        LINE_LOOP: 2,
        LINE_STRIP: 3,
        TRIANGLES: 4,
        TRIANGLE_STRIP: 5,
        TRIANGLE_FAN: 6,
        UNSIGNED_BYTE: 5121,
        UNSIGNED_SHORT: 5123
    },
    Df = {
        5120: Int8Array,
        5121: Uint8Array,
        5122: Int16Array,
        5123: Uint16Array,
        5125: Uint32Array,
        5126: Float32Array
    },
    VC = {
        9728: bn,
        9729: nn,
        9984: sy,
        9985: If,
        9986: Pc,
        9987: gs
    },
    WC = {
        33071: Nn,
        33648: au,
        10497: Sl
    },
    i1 = {
        SCALAR: 1,
        VEC2: 2,
        VEC3: 3,
        VEC4: 4,
        MAT2: 4,
        MAT3: 9,
        MAT4: 16
    },
    PA = {
        POSITION: "position",
        NORMAL: "normal",
        TANGENT: "tangent",
        ...g6 >= 152 ? {
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv1",
            TEXCOORD_2: "uv2",
            TEXCOORD_3: "uv3"
        } : {
            TEXCOORD_0: "uv",
            TEXCOORD_1: "uv2"
        },
        COLOR_0: "color",
        WEIGHTS_0: "skinWeight",
        JOINTS_0: "skinIndex"
    },
    Ya = {
        scale: "scale",
        translation: "position",
        rotation: "quaternion",
        weights: "morphTargetInfluences"
    },
    r9 = {
        CUBICSPLINE: void 0,
        LINEAR: Zf,
        STEP: qf
    },
    r1 = {
        OPAQUE: "OPAQUE",
        MASK: "MASK",
        BLEND: "BLEND"
    };

function s9(r) {
    return r.DefaultMaterial === void 0 && (r.DefaultMaterial = new mu({
        color: 16777215,
        emissive: 0,
        metalness: 1,
        roughness: 1,
        transparent: !1,
        depthTest: !0,
        side: Zs
    })), r.DefaultMaterial
}

function gc(r, e, t) {
    for (const n in t.extensions) r[n] === void 0 && (e.userData.gltfExtensions = e.userData.gltfExtensions || {}, e.userData.gltfExtensions[n] = t.extensions[n])
}

function sa(r, e) {
    e.extras !== void 0 && (typeof e.extras == "object" ? Object.assign(r.userData, e.extras) : console.warn("THREE.GLTFLoader: Ignoring primitive type .extras, " + e.extras))
}

function o9(r, e, t) {
    let n = !1,
        i = !1,
        s = !1;
    for (let c = 0, u = e.length; c < u; c++) {
        const f = e[c];
        if (f.POSITION !== void 0 && (n = !0), f.NORMAL !== void 0 && (i = !0), f.COLOR_0 !== void 0 && (s = !0), n && i && s) break
    }
    if (!n && !i && !s) return Promise.resolve(r);
    const o = [],
        a = [],
        l = [];
    for (let c = 0, u = e.length; c < u; c++) {
        const f = e[c];
        if (n) {
            const d = f.POSITION !== void 0 ? t.getDependency("accessor", f.POSITION) : r.attributes.position;
            o.push(d)
        }
        if (i) {
            const d = f.NORMAL !== void 0 ? t.getDependency("accessor", f.NORMAL) : r.attributes.normal;
            a.push(d)
        }
        if (s) {
            const d = f.COLOR_0 !== void 0 ? t.getDependency("accessor", f.COLOR_0) : r.attributes.color;
            l.push(d)
        }
    }
    return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l)]).then(function(c) {
        const u = c[0],
            f = c[1],
            d = c[2];
        return n && (r.morphAttributes.position = u), i && (r.morphAttributes.normal = f), s && (r.morphAttributes.color = d), r.morphTargetsRelative = !0, r
    })
}

function a9(r, e) {
    if (r.updateMorphTargets(), e.weights !== void 0)
        for (let t = 0, n = e.weights.length; t < n; t++) r.morphTargetInfluences[t] = e.weights[t];
    if (e.extras && Array.isArray(e.extras.targetNames)) {
        const t = e.extras.targetNames;
        if (r.morphTargetInfluences.length === t.length) {
            r.morphTargetDictionary = {};
            for (let n = 0, i = t.length; n < i; n++) r.morphTargetDictionary[t[n]] = n
        } else console.warn("THREE.GLTFLoader: Invalid extras.targetNames length. Ignoring names.")
    }
}

function l9(r) {
    let e;
    const t = r.extensions && r.extensions[mn.KHR_DRACO_MESH_COMPRESSION];
    if (t ? e = "draco:" + t.bufferView + ":" + t.indices + ":" + s1(t.attributes) : e = r.indices + ":" + s1(r.attributes) + ":" + r.mode, r.targets !== void 0)
        for (let n = 0, i = r.targets.length; n < i; n++) e += ":" + s1(r.targets[n]);
    return e
}

function s1(r) {
    let e = "";
    const t = Object.keys(r).sort();
    for (let n = 0, i = t.length; n < i; n++) e += t[n] + ":" + r[t[n]] + ";";
    return e
}

function IA(r) {
    switch (r) {
        case Int8Array:
            return 1 / 127;
        case Uint8Array:
            return 1 / 255;
        case Int16Array:
            return 1 / 32767;
        case Uint16Array:
            return 1 / 65535;
        default:
            throw new Error("THREE.GLTFLoader: Unsupported normalized accessor component type.")
    }
}

function c9(r) {
    return r.search(/\.jpe?g($|\?)/i) > 0 || r.search(/^data\:image\/jpeg/) === 0 ? "image/jpeg" : r.search(/\.webp($|\?)/i) > 0 || r.search(/^data\:image\/webp/) === 0 ? "image/webp" : "image/png"
}
const u9 = new Ot;
class f9 {
    constructor(e = {}, t = {}) {
        this.json = e, this.extensions = {}, this.plugins = {}, this.options = t, this.cache = new D6, this.associations = new Map, this.primitiveCache = {}, this.nodeCache = {}, this.meshCache = {
            refs: {},
            uses: {}
        }, this.cameraCache = {
            refs: {},
            uses: {}
        }, this.lightCache = {
            refs: {},
            uses: {}
        }, this.sourceCache = {}, this.textureCache = {}, this.nodeNamesUsed = {};
        let n = !1,
            i = !1,
            s = -1;
        typeof navigator < "u" && typeof navigator.userAgent < "u" && (n = /^((?!chrome|android).)*safari/i.test(navigator.userAgent) === !0, i = navigator.userAgent.indexOf("Firefox") > -1, s = i ? navigator.userAgent.match(/Firefox\/([0-9]+)\./)[1] : -1), typeof createImageBitmap > "u" || n || i && s < 98 ? this.textureLoader = new zo(this.options.manager) : this.textureLoader = new eD(this.options.manager), this.textureLoader.setCrossOrigin(this.options.crossOrigin), this.textureLoader.setRequestHeader(this.options.requestHeader), this.fileLoader = new $i(this.options.manager), this.fileLoader.setResponseType("arraybuffer"), this.options.crossOrigin === "use-credentials" && this.fileLoader.setWithCredentials(!0)
    }
    setExtensions(e) {
        this.extensions = e
    }
    setPlugins(e) {
        this.plugins = e
    }
    parse(e, t) {
        const n = this,
            i = this.json,
            s = this.extensions;
        this.cache.removeAll(), this.nodeCache = {}, this._invokeAll(function(o) {
            return o._markDefs && o._markDefs()
        }), Promise.all(this._invokeAll(function(o) {
            return o.beforeRoot && o.beforeRoot()
        })).then(function() {
            return Promise.all([n.getDependencies("scene"), n.getDependencies("animation"), n.getDependencies("camera")])
        }).then(function(o) {
            const a = {
                scene: o[0][i.scene || 0],
                scenes: o[0],
                animations: o[1],
                cameras: o[2],
                asset: i.asset,
                parser: n,
                userData: {}
            };
            return gc(s, a, i), sa(a, i), Promise.all(n._invokeAll(function(l) {
                return l.afterRoot && l.afterRoot(a)
            })).then(function() {
                for (const l of a.scenes) l.updateMatrixWorld();
                e(a)
            })
        }).catch(t)
    }
    _markDefs() {
        const e = this.json.nodes || [],
            t = this.json.skins || [],
            n = this.json.meshes || [];
        for (let i = 0, s = t.length; i < s; i++) {
            const o = t[i].joints;
            for (let a = 0, l = o.length; a < l; a++) e[o[a]].isBone = !0
        }
        for (let i = 0, s = e.length; i < s; i++) {
            const o = e[i];
            o.mesh !== void 0 && (this._addNodeRef(this.meshCache, o.mesh), o.skin !== void 0 && (n[o.mesh].isSkinnedMesh = !0)), o.camera !== void 0 && this._addNodeRef(this.cameraCache, o.camera)
        }
    }
    _addNodeRef(e, t) {
        t !== void 0 && (e.refs[t] === void 0 && (e.refs[t] = e.uses[t] = 0), e.refs[t]++)
    }
    _getNodeRef(e, t, n) {
        if (e.refs[t] <= 1) return n;
        const i = n.clone(),
            s = (o, a) => {
                const l = this.associations.get(o);
                l != null && this.associations.set(a, l);
                for (const [c, u] of o.children.entries()) s(u, a.children[c])
            };
        return s(n, i), i.name += "_instance_" + e.uses[t]++, i
    }
    _invokeOne(e) {
        const t = Object.values(this.plugins);
        t.push(this);
        for (let n = 0; n < t.length; n++) {
            const i = e(t[n]);
            if (i) return i
        }
        return null
    }
    _invokeAll(e) {
        const t = Object.values(this.plugins);
        t.unshift(this);
        const n = [];
        for (let i = 0; i < t.length; i++) {
            const s = e(t[i]);
            s && n.push(s)
        }
        return n
    }
    getDependency(e, t) {
        const n = e + ":" + t;
        let i = this.cache.get(n);
        if (!i) {
            switch (e) {
                case "scene":
                    i = this.loadScene(t);
                    break;
                case "node":
                    i = this._invokeOne(function(s) {
                        return s.loadNode && s.loadNode(t)
                    });
                    break;
                case "mesh":
                    i = this._invokeOne(function(s) {
                        return s.loadMesh && s.loadMesh(t)
                    });
                    break;
                case "accessor":
                    i = this.loadAccessor(t);
                    break;
                case "bufferView":
                    i = this._invokeOne(function(s) {
                        return s.loadBufferView && s.loadBufferView(t)
                    });
                    break;
                case "buffer":
                    i = this.loadBuffer(t);
                    break;
                case "material":
                    i = this._invokeOne(function(s) {
                        return s.loadMaterial && s.loadMaterial(t)
                    });
                    break;
                case "texture":
                    i = this._invokeOne(function(s) {
                        return s.loadTexture && s.loadTexture(t)
                    });
                    break;
                case "skin":
                    i = this.loadSkin(t);
                    break;
                case "animation":
                    i = this._invokeOne(function(s) {
                        return s.loadAnimation && s.loadAnimation(t)
                    });
                    break;
                case "camera":
                    i = this.loadCamera(t);
                    break;
                default:
                    if (i = this._invokeOne(function(s) {
                            return s != this && s.getDependency && s.getDependency(e, t)
                        }), !i) throw new Error("Unknown type: " + e);
                    break
            }
            this.cache.add(n, i)
        }
        return i
    }
    getDependencies(e) {
        let t = this.cache.get(e);
        if (!t) {
            const n = this,
                i = this.json[e + (e === "mesh" ? "es" : "s")] || [];
            t = Promise.all(i.map(function(s, o) {
                return n.getDependency(e, o)
            })), this.cache.add(e, t)
        }
        return t
    }
    loadBuffer(e) {
        const t = this.json.buffers[e],
            n = this.fileLoader;
        if (t.type && t.type !== "arraybuffer") throw new Error("THREE.GLTFLoader: " + t.type + " buffer type is not supported.");
        if (t.uri === void 0 && e === 0) return Promise.resolve(this.extensions[mn.KHR_BINARY_GLTF].body);
        const i = this.options;
        return new Promise(function(s, o) {
            n.load(pl.resolveURL(t.uri, i.path), s, void 0, function() {
                o(new Error('THREE.GLTFLoader: Failed to load buffer "' + t.uri + '".'))
            })
        })
    }
    loadBufferView(e) {
        const t = this.json.bufferViews[e];
        return this.getDependency("buffer", t.buffer).then(function(n) {
            const i = t.byteLength || 0,
                s = t.byteOffset || 0;
            return n.slice(s, s + i)
        })
    }
    loadAccessor(e) {
        const t = this,
            n = this.json,
            i = this.json.accessors[e];
        if (i.bufferView === void 0 && i.sparse === void 0) {
            const o = i1[i.type],
                a = Df[i.componentType],
                l = i.normalized === !0,
                c = new a(i.count * o);
            return Promise.resolve(new an(c, o, l))
        }
        const s = [];
        return i.bufferView !== void 0 ? s.push(this.getDependency("bufferView", i.bufferView)) : s.push(null), i.sparse !== void 0 && (s.push(this.getDependency("bufferView", i.sparse.indices.bufferView)), s.push(this.getDependency("bufferView", i.sparse.values.bufferView))), Promise.all(s).then(function(o) {
            const a = o[0],
                l = i1[i.type],
                c = Df[i.componentType],
                u = c.BYTES_PER_ELEMENT,
                f = u * l,
                d = i.byteOffset || 0,
                m = i.bufferView !== void 0 ? n.bufferViews[i.bufferView].byteStride : void 0,
                g = i.normalized === !0;
            let y, v;
            if (m && m !== f) {
                const _ = Math.floor(d / m),
                    A = "InterleavedBuffer:" + i.bufferView + ":" + i.componentType + ":" + _ + ":" + i.count;
                let S = t.cache.get(A);
                S || (y = new c(a, _ * m, i.count * m / u), S = new Jp(y, m / u), t.cache.add(A, S)), v = new Tl(S, l, d % m / u, g)
            } else a === null ? y = new c(i.count * l) : y = new c(a, d, i.count * l), v = new an(y, l, g);
            if (i.sparse !== void 0) {
                const _ = i1.SCALAR,
                    A = Df[i.sparse.indices.componentType],
                    S = i.sparse.indices.byteOffset || 0,
                    M = i.sparse.values.byteOffset || 0,
                    C = new A(o[1], S, i.sparse.count * _),
                    E = new c(o[2], M, i.sparse.count * l);
                a !== null && (v = new an(v.array.slice(), v.itemSize, v.normalized));
                for (let R = 0, P = C.length; R < P; R++) {
                    const b = C[R];
                    if (v.setX(b, E[R * l]), l >= 2 && v.setY(b, E[R * l + 1]), l >= 3 && v.setZ(b, E[R * l + 2]), l >= 4 && v.setW(b, E[R * l + 3]), l >= 5) throw new Error("THREE.GLTFLoader: Unsupported itemSize in sparse BufferAttribute.")
                }
            }
            return v
        })
    }
    loadTexture(e) {
        const t = this.json,
            n = this.options,
            s = t.textures[e].source,
            o = t.images[s];
        let a = this.textureLoader;
        if (o.uri) {
            const l = n.manager.getHandler(o.uri);
            l !== null && (a = l)
        }
        return this.loadTextureImage(e, s, a)
    }
    loadTextureImage(e, t, n) {
        const i = this,
            s = this.json,
            o = s.textures[e],
            a = s.images[t],
            l = (a.uri || a.bufferView) + ":" + o.sampler;
        if (this.textureCache[l]) return this.textureCache[l];
        const c = this.loadImageSource(t, n).then(function(u) {
            u.flipY = !1, u.name = o.name || a.name || "", u.name === "" && typeof a.uri == "string" && a.uri.startsWith("data:image/") === !1 && (u.name = a.uri);
            const d = (s.samplers || {})[o.sampler] || {};
            return u.magFilter = VC[d.magFilter] || nn, u.minFilter = VC[d.minFilter] || gs, u.wrapS = WC[d.wrapS] || Sl, u.wrapT = WC[d.wrapT] || Sl, i.associations.set(u, {
                textures: e
            }), u
        }).catch(function() {
            return null
        });
        return this.textureCache[l] = c, c
    }
    loadImageSource(e, t) {
        const n = this,
            i = this.json,
            s = this.options;
        if (this.sourceCache[e] !== void 0) return this.sourceCache[e].then(f => f.clone());
        const o = i.images[e],
            a = self.URL || self.webkitURL;
        let l = o.uri || "",
            c = !1;
        if (o.bufferView !== void 0) l = n.getDependency("bufferView", o.bufferView).then(function(f) {
            c = !0;
            const d = new Blob([f], {
                type: o.mimeType
            });
            return l = a.createObjectURL(d), l
        });
        else if (o.uri === void 0) throw new Error("THREE.GLTFLoader: Image " + e + " is missing URI and bufferView");
        const u = Promise.resolve(l).then(function(f) {
            return new Promise(function(d, m) {
                let g = d;
                t.isImageBitmapLoader === !0 && (g = function(y) {
                    const v = new gn(y);
                    v.needsUpdate = !0, d(v)
                }), t.load(pl.resolveURL(f, s.path), g, void 0, m)
            })
        }).then(function(f) {
            return c === !0 && a.revokeObjectURL(l), sa(f, o), f.userData.mimeType = o.mimeType || c9(o.uri), f
        }).catch(function(f) {
            throw console.error("THREE.GLTFLoader: Couldn't load texture", l), f
        });
        return this.sourceCache[e] = u, u
    }
    assignTexture(e, t, n, i) {
        const s = this;
        return this.getDependency("texture", n.index).then(function(o) {
            if (!o) return null;
            if (n.texCoord !== void 0 && n.texCoord > 0 && (o = o.clone(), o.channel = n.texCoord), s.extensions[mn.KHR_TEXTURE_TRANSFORM]) {
                const a = n.extensions !== void 0 ? n.extensions[mn.KHR_TEXTURE_TRANSFORM] : void 0;
                if (a) {
                    const l = s.associations.get(o);
                    o = s.extensions[mn.KHR_TEXTURE_TRANSFORM].extendTexture(o, a), s.associations.set(o, l)
                }
            }
            return i !== void 0 && (typeof i == "number" && (i = i === GC ? Oc : _a), "colorSpace" in o ? o.colorSpace = i : o.encoding = i === Oc ? GC : B6), e[t] = o, o
        })
    }
    assignFinalMaterial(e) {
        const t = e.geometry;
        let n = e.material;
        const i = t.attributes.tangent === void 0,
            s = t.attributes.color !== void 0,
            o = t.attributes.normal === void 0;
        if (e.isPoints) {
            const a = "PointsMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l || (l = new qp, mi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, l.sizeAttenuation = !1, this.cache.add(a, l)), n = l
        } else if (e.isLine) {
            const a = "LineBasicMaterial:" + n.uuid;
            let l = this.cache.get(a);
            l || (l = new yr, mi.prototype.copy.call(l, n), l.color.copy(n.color), l.map = n.map, this.cache.add(a, l)), n = l
        }
        if (i || s || o) {
            let a = "ClonedMaterial:" + n.uuid + ":";
            i && (a += "derivative-tangents:"), s && (a += "vertex-colors:"), o && (a += "flat-shading:");
            let l = this.cache.get(a);
            l || (l = n.clone(), s && (l.vertexColors = !0), o && (l.flatShading = !0), i && (l.normalScale && (l.normalScale.y *= -1), l.clearcoatNormalScale && (l.clearcoatNormalScale.y *= -1)), this.cache.add(a, l), this.associations.set(l, this.associations.get(n))), n = l
        }
        e.material = n
    }
    getMaterialType() {
        return mu
    }
    loadMaterial(e) {
        const t = this,
            n = this.json,
            i = this.extensions,
            s = n.materials[e];
        let o;
        const a = {},
            l = s.extensions || {},
            c = [];
        if (l[mn.KHR_MATERIALS_UNLIT]) {
            const f = i[mn.KHR_MATERIALS_UNLIT];
            o = f.getMaterialType(), c.push(f.extendParams(a, s, t))
        } else {
            const f = s.pbrMetallicRoughness || {};
            if (a.color = new rt(1, 1, 1), a.opacity = 1, Array.isArray(f.baseColorFactor)) {
                const d = f.baseColorFactor;
                a.color.setRGB(d[0], d[1], d[2], _a), a.opacity = d[3]
            }
            f.baseColorTexture !== void 0 && c.push(t.assignTexture(a, "map", f.baseColorTexture, Oc)), a.metalness = f.metallicFactor !== void 0 ? f.metallicFactor : 1, a.roughness = f.roughnessFactor !== void 0 ? f.roughnessFactor : 1, f.metallicRoughnessTexture !== void 0 && (c.push(t.assignTexture(a, "metalnessMap", f.metallicRoughnessTexture)), c.push(t.assignTexture(a, "roughnessMap", f.metallicRoughnessTexture))), o = this._invokeOne(function(d) {
                return d.getMaterialType && d.getMaterialType(e)
            }), c.push(Promise.all(this._invokeAll(function(d) {
                return d.extendMaterialParams && d.extendMaterialParams(e, a)
            })))
        }
        s.doubleSided === !0 && (a.side = hn);
        const u = s.alphaMode || r1.OPAQUE;
        if (u === r1.BLEND ? (a.transparent = !0, a.depthWrite = !1) : (a.transparent = !1, u === r1.MASK && (a.alphaTest = s.alphaCutoff !== void 0 ? s.alphaCutoff : .5)), s.normalTexture !== void 0 && o !== Mi && (c.push(t.assignTexture(a, "normalMap", s.normalTexture)), a.normalScale = new Ue(1, 1), s.normalTexture.scale !== void 0)) {
            const f = s.normalTexture.scale;
            a.normalScale.set(f, f)
        }
        if (s.occlusionTexture !== void 0 && o !== Mi && (c.push(t.assignTexture(a, "aoMap", s.occlusionTexture)), s.occlusionTexture.strength !== void 0 && (a.aoMapIntensity = s.occlusionTexture.strength)), s.emissiveFactor !== void 0 && o !== Mi) {
            const f = s.emissiveFactor;
            a.emissive = new rt().setRGB(f[0], f[1], f[2], _a)
        }
        return s.emissiveTexture !== void 0 && o !== Mi && c.push(t.assignTexture(a, "emissiveMap", s.emissiveTexture, Oc)), Promise.all(c).then(function() {
            const f = new o(a);
            return s.name && (f.name = s.name), sa(f, s), t.associations.set(f, {
                materials: e
            }), s.extensions && gc(i, f, s), f
        })
    }
    createUniqueName(e) {
        const t = wn.sanitizeNodeName(e || "");
        return t in this.nodeNamesUsed ? t + "_" + ++this.nodeNamesUsed[t] : (this.nodeNamesUsed[t] = 0, t)
    }
    loadGeometries(e) {
        const t = this,
            n = this.extensions,
            i = this.primitiveCache;

        function s(a) {
            return n[mn.KHR_DRACO_MESH_COMPRESSION].decodePrimitive(a, t).then(function(l) {
                return jC(l, a, t)
            })
        }
        const o = [];
        for (let a = 0, l = e.length; a < l; a++) {
            const c = e[a],
                u = l9(c),
                f = i[u];
            if (f) o.push(f.promise);
            else {
                let d;
                c.extensions && c.extensions[mn.KHR_DRACO_MESH_COMPRESSION] ? d = s(c) : d = jC(new zt, c, t), i[u] = {
                    primitive: c,
                    promise: d
                }, o.push(d)
            }
        }
        return Promise.all(o)
    }
    loadMesh(e) {
        const t = this,
            n = this.json,
            i = this.extensions,
            s = n.meshes[e],
            o = s.primitives,
            a = [];
        for (let l = 0, c = o.length; l < c; l++) {
            const u = o[l].material === void 0 ? s9(this.cache) : this.getDependency("material", o[l].material);
            a.push(u)
        }
        return a.push(t.loadGeometries(o)), Promise.all(a).then(function(l) {
            const c = l.slice(0, l.length - 1),
                u = l[l.length - 1],
                f = [];
            for (let m = 0, g = u.length; m < g; m++) {
                const y = u[m],
                    v = o[m];
                let _;
                const A = c[m];
                if (v.mode === zs.TRIANGLES || v.mode === zs.TRIANGLE_STRIP || v.mode === zs.TRIANGLE_FAN || v.mode === void 0) _ = s.isSkinnedMesh === !0 ? new ZS(y, A) : new Tn(y, A), _.isSkinnedMesh === !0 && _.normalizeSkinWeights(), v.mode === zs.TRIANGLE_STRIP ? _.geometry = zC(_.geometry, zS) : v.mode === zs.TRIANGLE_FAN && (_.geometry = zC(_.geometry, Iv));
                else if (v.mode === zs.LINES) _ = new po(y, A);
                else if (v.mode === zs.LINE_STRIP) _ = new Ta(y, A);
                else if (v.mode === zs.LINE_LOOP) _ = new $S(y, A);
                else if (v.mode === zs.POINTS) _ = new Ay(y, A);
                else throw new Error("THREE.GLTFLoader: Primitive mode unsupported: " + v.mode);
                Object.keys(_.geometry.morphAttributes).length > 0 && a9(_, s), _.name = t.createUniqueName(s.name || "mesh_" + e), sa(_, s), v.extensions && gc(i, _, v), t.assignFinalMaterial(_), f.push(_)
            }
            for (let m = 0, g = f.length; m < g; m++) t.associations.set(f[m], {
                meshes: e,
                primitives: m
            });
            if (f.length === 1) return s.extensions && gc(i, f[0], s), f[0];
            const d = new da;
            s.extensions && gc(i, d, s), t.associations.set(d, {
                meshes: e
            });
            for (let m = 0, g = f.length; m < g; m++) d.add(f[m]);
            return d
        })
    }
    loadCamera(e) {
        let t;
        const n = this.json.cameras[e],
            i = n[n.type];
        if (!i) {
            console.warn("THREE.GLTFLoader: Missing camera parameters.");
            return
        }
        return n.type === "perspective" ? t = new ri(ha.radToDeg(i.yfov), i.aspectRatio || 1, i.znear || 1, i.zfar || 2e6) : n.type === "orthographic" && (t = new Ca(-i.xmag, i.xmag, i.ymag, -i.ymag, i.znear, i.zfar)), n.name && (t.name = this.createUniqueName(n.name)), sa(t, n), Promise.resolve(t)
    }
    loadSkin(e) {
        const t = this.json.skins[e],
            n = [];
        for (let i = 0, s = t.joints.length; i < s; i++) n.push(this._loadNodeShallow(t.joints[i]));
        return t.inverseBindMatrices !== void 0 ? n.push(this.getDependency("accessor", t.inverseBindMatrices)) : n.push(null), Promise.all(n).then(function(i) {
            const s = i.pop(),
                o = i,
                a = [],
                l = [];
            for (let c = 0, u = o.length; c < u; c++) {
                const f = o[c];
                if (f) {
                    a.push(f);
                    const d = new Ot;
                    s !== null && d.fromArray(s.array, c * 16), l.push(d)
                } else console.warn('THREE.GLTFLoader: Joint "%s" could not be found.', t.joints[c])
            }
            return new Kp(a, l)
        })
    }
    loadAnimation(e) {
        const t = this.json,
            n = this,
            i = t.animations[e],
            s = i.name ? i.name : "animation_" + e,
            o = [],
            a = [],
            l = [],
            c = [],
            u = [];
        for (let f = 0, d = i.channels.length; f < d; f++) {
            const m = i.channels[f],
                g = i.samplers[m.sampler],
                y = m.target,
                v = y.node,
                _ = i.parameters !== void 0 ? i.parameters[g.input] : g.input,
                A = i.parameters !== void 0 ? i.parameters[g.output] : g.output;
            y.node !== void 0 && (o.push(this.getDependency("node", v)), a.push(this.getDependency("accessor", _)), l.push(this.getDependency("accessor", A)), c.push(g), u.push(y))
        }
        return Promise.all([Promise.all(o), Promise.all(a), Promise.all(l), Promise.all(c), Promise.all(u)]).then(function(f) {
            const d = f[0],
                m = f[1],
                g = f[2],
                y = f[3],
                v = f[4],
                _ = [];
            for (let A = 0, S = d.length; A < S; A++) {
                const M = d[A],
                    C = m[A],
                    E = g[A],
                    R = y[A],
                    P = v[A];
                if (M === void 0) continue;
                M.updateMatrix && M.updateMatrix();
                const b = n._createAnimationTracks(M, C, E, R, P);
                if (b)
                    for (let T = 0; T < b.length; T++) _.push(b[T])
            }
            return new eh(s, void 0, _)
        })
    }
    createNodeMesh(e) {
        const t = this.json,
            n = this,
            i = t.nodes[e];
        return i.mesh === void 0 ? null : n.getDependency("mesh", i.mesh).then(function(s) {
            const o = n._getNodeRef(n.meshCache, i.mesh, s);
            return i.weights !== void 0 && o.traverse(function(a) {
                if (a.isMesh)
                    for (let l = 0, c = i.weights.length; l < c; l++) a.morphTargetInfluences[l] = i.weights[l]
            }), o
        })
    }
    loadNode(e) {
        const t = this.json,
            n = this,
            i = t.nodes[e],
            s = n._loadNodeShallow(e),
            o = [],
            a = i.children || [];
        for (let c = 0, u = a.length; c < u; c++) o.push(n.getDependency("node", a[c]));
        const l = i.skin === void 0 ? Promise.resolve(null) : n.getDependency("skin", i.skin);
        return Promise.all([s, Promise.all(o), l]).then(function(c) {
            const u = c[0],
                f = c[1],
                d = c[2];
            d !== null && u.traverse(function(m) {
                m.isSkinnedMesh && m.bind(d, u9)
            });
            for (let m = 0, g = f.length; m < g; m++) u.add(f[m]);
            return u
        })
    }
    _loadNodeShallow(e) {
        const t = this.json,
            n = this.extensions,
            i = this;
        if (this.nodeCache[e] !== void 0) return this.nodeCache[e];
        const s = t.nodes[e],
            o = s.name ? i.createUniqueName(s.name) : "",
            a = [],
            l = i._invokeOne(function(c) {
                return c.createNodeMesh && c.createNodeMesh(e)
            });
        return l && a.push(l), s.camera !== void 0 && a.push(i.getDependency("camera", s.camera).then(function(c) {
            return i._getNodeRef(i.cameraCache, s.camera, c)
        })), i._invokeAll(function(c) {
            return c.createNodeAttachment && c.createNodeAttachment(e)
        }).forEach(function(c) {
            a.push(c)
        }), this.nodeCache[e] = Promise.all(a).then(function(c) {
            let u;
            if (s.isBone === !0 ? u = new xy : c.length > 1 ? u = new da : c.length === 1 ? u = c[0] : u = new vn, u !== c[0])
                for (let f = 0, d = c.length; f < d; f++) u.add(c[f]);
            if (s.name && (u.userData.name = s.name, u.name = o), sa(u, s), s.extensions && gc(n, u, s), s.matrix !== void 0) {
                const f = new Ot;
                f.fromArray(s.matrix), u.applyMatrix4(f)
            } else s.translation !== void 0 && u.position.fromArray(s.translation), s.rotation !== void 0 && u.quaternion.fromArray(s.rotation), s.scale !== void 0 && u.scale.fromArray(s.scale);
            return i.associations.has(u) || i.associations.set(u, {}), i.associations.get(u).nodes = e, u
        }), this.nodeCache[e]
    }
    loadScene(e) {
        const t = this.extensions,
            n = this.json.scenes[e],
            i = this,
            s = new da;
        n.name && (s.name = i.createUniqueName(n.name)), sa(s, n), n.extensions && gc(t, s, n);
        const o = n.nodes || [],
            a = [];
        for (let l = 0, c = o.length; l < c; l++) a.push(i.getDependency("node", o[l]));
        return Promise.all(a).then(function(l) {
            for (let u = 0, f = l.length; u < f; u++) s.add(l[u]);
            const c = u => {
                const f = new Map;
                for (const [d, m] of i.associations)(d instanceof mi || d instanceof gn) && f.set(d, m);
                return u.traverse(d => {
                    const m = i.associations.get(d);
                    m != null && f.set(d, m)
                }), f
            };
            return i.associations = c(s), s
        })
    }
    _createAnimationTracks(e, t, n, i, s) {
        const o = [],
            a = e.name ? e.name : e.uuid,
            l = [];
        Ya[s.path] === Ya.weights ? e.traverse(function(d) {
            d.morphTargetInfluences && l.push(d.name ? d.name : d.uuid)
        }) : l.push(a);
        let c;
        switch (Ya[s.path]) {
            case Ya.weights:
                c = cu;
                break;
            case Ya.rotation:
                c = uu;
                break;
            case Ya.position:
            case Ya.scale:
                c = fu;
                break;
            default:
                switch (n.itemSize) {
                    case 1:
                        c = cu;
                        break;
                    case 2:
                    case 3:
                    default:
                        c = fu;
                        break
                }
                break
        }
        const u = i.interpolation !== void 0 ? r9[i.interpolation] : Zf,
            f = this._getArrayFromAccessor(n);
        for (let d = 0, m = l.length; d < m; d++) {
            const g = new c(l[d] + "." + Ya[s.path], t.array, f, u);
            i.interpolation === "CUBICSPLINE" && this._createCubicSplineTrackInterpolant(g), o.push(g)
        }
        return o
    }
    _getArrayFromAccessor(e) {
        let t = e.array;
        if (e.normalized) {
            const n = IA(t.constructor),
                i = new Float32Array(t.length);
            for (let s = 0, o = t.length; s < o; s++) i[s] = t[s] * n;
            t = i
        }
        return t
    }
    _createCubicSplineTrackInterpolant(e) {
        e.createInterpolant = function(n) {
            const i = this instanceof uu ? i9 : OD;
            return new i(this.times, this.values, this.getValueSize() / 3, n)
        }, e.createInterpolant.isInterpolantFactoryMethodGLTFCubicSpline = !0
    }
}

function h9(r, e, t) {
    const n = e.attributes,
        i = new Wi;
    if (n.POSITION !== void 0) {
        const a = t.json.accessors[n.POSITION],
            l = a.min,
            c = a.max;
        if (l !== void 0 && c !== void 0) {
            if (i.set(new K(l[0], l[1], l[2]), new K(c[0], c[1], c[2])), a.normalized) {
                const u = IA(Df[a.componentType]);
                i.min.multiplyScalar(u), i.max.multiplyScalar(u)
            }
        } else {
            console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.");
            return
        }
    } else return;
    const s = e.targets;
    if (s !== void 0) {
        const a = new K,
            l = new K;
        for (let c = 0, u = s.length; c < u; c++) {
            const f = s[c];
            if (f.POSITION !== void 0) {
                const d = t.json.accessors[f.POSITION],
                    m = d.min,
                    g = d.max;
                if (m !== void 0 && g !== void 0) {
                    if (l.setX(Math.max(Math.abs(m[0]), Math.abs(g[0]))), l.setY(Math.max(Math.abs(m[1]), Math.abs(g[1]))), l.setZ(Math.max(Math.abs(m[2]), Math.abs(g[2]))), d.normalized) {
                        const y = IA(Df[d.componentType]);
                        l.multiplyScalar(y)
                    }
                    a.max(l)
                } else console.warn("THREE.GLTFLoader: Missing min/max properties for accessor POSITION.")
            }
        }
        i.expandByVector(a)
    }
    r.boundingBox = i;
    const o = new ji;
    i.getCenter(o.center), o.radius = i.min.distanceTo(i.max) / 2, r.boundingSphere = o
}

function jC(r, e, t) {
    const n = e.attributes,
        i = [];

    function s(o, a) {
        return t.getDependency("accessor", o).then(function(l) {
            r.setAttribute(a, l)
        })
    }
    for (const o in n) {
        const a = PA[o] || o.toLowerCase();
        a in r.attributes || i.push(s(n[o], a))
    }
    if (e.indices !== void 0 && !r.index) {
        const o = t.getDependency("accessor", e.indices).then(function(a) {
            r.setIndex(a)
        });
        i.push(o)
    }
    return sa(r, e), h9(r, e, t), Promise.all(i).then(function() {
        return e.targets !== void 0 ? o9(r, e.targets, t) : r
    })
}
class d9 extends uM {
    constructor(e) {
        super(e), this.type = Ri
    }
    parse(e) {
        const o = function(P, b) {
                switch (P) {
                    case 1:
                        throw new Error("THREE.RGBELoader: Read Error: " + (b || ""));
                    case 2:
                        throw new Error("THREE.RGBELoader: Write Error: " + (b || ""));
                    case 3:
                        throw new Error("THREE.RGBELoader: Bad File Format: " + (b || ""));
                    default:
                    case 4:
                        throw new Error("THREE.RGBELoader: Memory Error: " + (b || ""))
                }
            },
            u = `
`,
            f = function(P, b, T) {
                b = b || 1024;
                let D = P.pos,
                    V = -1,
                    H = 0,
                    q = "",
                    X = String.fromCharCode.apply(null, new Uint16Array(P.subarray(D, D + 128)));
                for (; 0 > (V = X.indexOf(u)) && H < b && D < P.byteLength;) q += X, H += X.length, D += 128, X += String.fromCharCode.apply(null, new Uint16Array(P.subarray(D, D + 128)));
                return -1 < V ? (P.pos += H + V + 1, q + X.slice(0, V)) : !1
            },
            d = function(P) {
                const b = /^#\?(\S+)/,
                    T = /^\s*GAMMA\s*=\s*(\d+(\.\d+)?)\s*$/,
                    L = /^\s*EXPOSURE\s*=\s*(\d+(\.\d+)?)\s*$/,
                    D = /^\s*FORMAT=(\S+)\s*$/,
                    V = /^\s*\-Y\s+(\d+)\s+\+X\s+(\d+)\s*$/,
                    H = {
                        valid: 0,
                        string: "",
                        comments: "",
                        programtype: "RGBE",
                        format: "",
                        gamma: 1,
                        exposure: 1,
                        width: 0,
                        height: 0
                    };
                let q, X;
                for ((P.pos >= P.byteLength || !(q = f(P))) && o(1, "no header found"), (X = q.match(b)) || o(3, "bad initial token"), H.valid |= 1, H.programtype = X[1], H.string += q + `
`; q = f(P), q !== !1;) {
                    if (H.string += q + `
`, q.charAt(0) === "#") {
                        H.comments += q + `
`;
                        continue
                    }
                    if ((X = q.match(T)) && (H.gamma = parseFloat(X[1])), (X = q.match(L)) && (H.exposure = parseFloat(X[1])), (X = q.match(D)) && (H.valid |= 2, H.format = X[1]), (X = q.match(V)) && (H.valid |= 4, H.height = parseInt(X[1], 10), H.width = parseInt(X[2], 10)), H.valid & 2 && H.valid & 4) break
                }
                return H.valid & 2 || o(3, "missing format specifier"), H.valid & 4 || o(3, "missing image size specifier"), H
            },
            m = function(P, b, T) {
                const L = b;
                if (L < 8 || L > 32767 || P[0] !== 2 || P[1] !== 2 || P[2] & 128) return new Uint8Array(P);
                L !== (P[2] << 8 | P[3]) && o(3, "wrong scanline width");
                const D = new Uint8Array(4 * b * T);
                D.length || o(4, "unable to allocate buffer space");
                let V = 0,
                    H = 0;
                const q = 4 * L,
                    X = new Uint8Array(4),
                    oe = new Uint8Array(q);
                let Y = T;
                for (; Y > 0 && H < P.byteLength;) {
                    H + 4 > P.byteLength && o(1), X[0] = P[H++], X[1] = P[H++], X[2] = P[H++], X[3] = P[H++], (X[0] != 2 || X[1] != 2 || (X[2] << 8 | X[3]) != L) && o(3, "bad rgbe scanline format");
                    let Z = 0,
                        U;
                    for (; Z < q && H < P.byteLength;) {
                        U = P[H++];
                        const te = U > 128;
                        if (te && (U -= 128), (U === 0 || Z + U > q) && o(3, "bad scanline data"), te) {
                            const he = P[H++];
                            for (let $ = 0; $ < U; $++) oe[Z++] = he
                        } else oe.set(P.subarray(H, H + U), Z), Z += U, H += U
                    }
                    const j = L;
                    for (let te = 0; te < j; te++) {
                        let he = 0;
                        D[V] = oe[te + he], he += L, D[V + 1] = oe[te + he], he += L, D[V + 2] = oe[te + he], he += L, D[V + 3] = oe[te + he], V += 4
                    }
                    Y--
                }
                return D
            },
            g = function(P, b, T, L) {
                const D = P[b + 3],
                    V = Math.pow(2, D - 128) / 255;
                T[L + 0] = P[b + 0] * V, T[L + 1] = P[b + 1] * V, T[L + 2] = P[b + 2] * V, T[L + 3] = 1
            },
            y = function(P, b, T, L) {
                const D = P[b + 3],
                    V = Math.pow(2, D - 128) / 255;
                T[L + 0] = Lc.toHalfFloat(Math.min(P[b + 0] * V, 65504)), T[L + 1] = Lc.toHalfFloat(Math.min(P[b + 1] * V, 65504)), T[L + 2] = Lc.toHalfFloat(Math.min(P[b + 2] * V, 65504)), T[L + 3] = Lc.toHalfFloat(1)
            },
            v = new Uint8Array(e);
        v.pos = 0;
        const _ = d(v),
            A = _.width,
            S = _.height,
            M = m(v.subarray(v.pos), A, S);
        let C, E, R;
        switch (this.type) {
            case Bn:
                R = M.length / 4;
                const P = new Float32Array(R * 4);
                for (let T = 0; T < R; T++) g(M, T * 4, P, T * 4);
                C = P, E = Bn;
                break;
            case Ri:
                R = M.length / 4;
                const b = new Uint16Array(R * 4);
                for (let T = 0; T < R; T++) y(M, T * 4, b, T * 4);
                C = b, E = Ri;
                break;
            default:
                throw new Error("THREE.RGBELoader: Unsupported type: " + this.type)
        }
        return {
            width: A,
            height: S,
            data: C,
            header: _.string,
            gamma: _.gamma,
            exposure: _.exposure,
            type: E
        }
    }
    setDataType(e) {
        return this.type = e, this
    }
    load(e, t, n, i) {
        function s(o, a) {
            switch (o.type) {
                case Bn:
                case Ri:
                    "colorSpace" in o ? o.colorSpace = "srgb-linear" : o.encoding = 3e3, o.minFilter = nn, o.magFilter = nn, o.generateMipmaps = !1, o.flipY = !0;
                    break
            }
            t && t(o, a)
        }
        return super.load(e, s, n, i)
    }
}
const ad = "colorSpace" in new gn;
class p9 extends uM {
    constructor(e) {
        super(e), this.type = Ri
    }
    parse(e) {
        const b = Math.pow(2.7182818, 2.2);

        function T(O, W) {
            for (var de = 0, be = 0; be < 65536; ++be)(be == 0 || O[be >> 3] & 1 << (be & 7)) && (W[de++] = be);
            for (var Pe = de - 1; de < 65536;) W[de++] = 0;
            return Pe
        }

        function L(O) {
            for (var W = 0; W < 16384; W++) O[W] = {}, O[W].len = 0, O[W].lit = 0, O[W].p = null
        }
        const D = {
            l: 0,
            c: 0,
            lc: 0
        };

        function V(O, W, de, be, Pe) {
            for (; de < O;) W = W << 8 | We(be, Pe), de += 8;
            de -= O, D.l = W >> de & (1 << O) - 1, D.c = W, D.lc = de
        }
        const H = new Array(59);

        function q(O) {
            for (var W = 0; W <= 58; ++W) H[W] = 0;
            for (var W = 0; W < 65537; ++W) H[O[W]] += 1;
            for (var de = 0, W = 58; W > 0; --W) {
                var be = de + H[W] >> 1;
                H[W] = de, de = be
            }
            for (var W = 0; W < 65537; ++W) {
                var Pe = O[W];
                Pe > 0 && (O[W] = Pe | H[Pe]++ << 6)
            }
        }

        function X(O, W, de, be, Pe, F, Q) {
            for (var re = de, le = 0, ee = 0; Pe <= F; Pe++) {
                if (re.value - de.value > be) return !1;
                V(6, le, ee, O, re);
                var Te = D.l;
                if (le = D.c, ee = D.lc, Q[Pe] = Te, Te == 63) {
                    if (re.value - de.value > be) throw "Something wrong with hufUnpackEncTable";
                    V(8, le, ee, O, re);
                    var fe = D.l + 6;
                    if (le = D.c, ee = D.lc, Pe + fe > F + 1) throw "Something wrong with hufUnpackEncTable";
                    for (; fe--;) Q[Pe++] = 0;
                    Pe--
                } else if (Te >= 59) {
                    var fe = Te - 59 + 2;
                    if (Pe + fe > F + 1) throw "Something wrong with hufUnpackEncTable";
                    for (; fe--;) Q[Pe++] = 0;
                    Pe--
                }
            }
            q(Q)
        }

        function oe(O) {
            return O & 63
        }

        function Y(O) {
            return O >> 6
        }

        function Z(O, W, de, be) {
            for (; W <= de; W++) {
                var Pe = Y(O[W]),
                    F = oe(O[W]);
                if (Pe >> F) throw "Invalid table entry";
                if (F > 14) {
                    var Q = be[Pe >> F - 14];
                    if (Q.len) throw "Invalid table entry";
                    if (Q.lit++, Q.p) {
                        var re = Q.p;
                        Q.p = new Array(Q.lit);
                        for (var le = 0; le < Q.lit - 1; ++le) Q.p[le] = re[le]
                    } else Q.p = new Array(1);
                    Q.p[Q.lit - 1] = W
                } else if (F)
                    for (var ee = 0, le = 1 << 14 - F; le > 0; le--) {
                        var Q = be[(Pe << 14 - F) + ee];
                        if (Q.len || Q.p) throw "Invalid table entry";
                        Q.len = F, Q.lit = W, ee++
                    }
            }
            return !0
        }
        const U = {
            c: 0,
            lc: 0
        };

        function j(O, W, de, be) {
            O = O << 8 | We(de, be), W += 8, U.c = O, U.lc = W
        }
        const te = {
            c: 0,
            lc: 0
        };

        function he(O, W, de, be, Pe, F, Q, re, le, ee) {
            if (O == W) {
                be < 8 && (j(de, be, Pe, Q), de = U.c, be = U.lc), be -= 8;
                var Te = de >> be,
                    Te = new Uint8Array([Te])[0];
                if (le.value + Te > ee) return !1;
                for (var fe = re[le.value - 1]; Te-- > 0;) re[le.value++] = fe
            } else if (le.value < ee) re[le.value++] = O;
            else return !1;
            te.c = de, te.lc = be
        }

        function $(O) {
            return O & 65535
        }

        function ne(O) {
            var W = $(O);
            return W > 32767 ? W - 65536 : W
        }
        const me = {
            a: 0,
            b: 0
        };

        function ce(O, W) {
            var de = ne(O),
                be = ne(W),
                Pe = be,
                F = de + (Pe & 1) + (Pe >> 1),
                Q = F,
                re = F - Pe;
            me.a = Q, me.b = re
        }

        function _e(O, W) {
            var de = $(O),
                be = $(W),
                Pe = de - (be >> 1) & 65535,
                F = be + Pe - 32768 & 65535;
            me.a = F, me.b = Pe
        }

        function Oe(O, W, de, be, Pe, F, Q) {
            for (var re = Q < 16384, le = de > Pe ? Pe : de, ee = 1, Te; ee <= le;) ee <<= 1;
            for (ee >>= 1, Te = ee, ee >>= 1; ee >= 1;) {
                for (var fe = 0, Ke = fe + F * (Pe - Te), Ge = F * ee, qe = F * Te, st = be * ee, Qe = be * Te, ft, _t, ht, wt; fe <= Ke; fe += qe) {
                    for (var At = fe, ct = fe + be * (de - Te); At <= ct; At += Qe) {
                        var Ut = At + st,
                            Bt = At + Ge,
                            Mn = Bt + st;
                        re ? (ce(O[At + W], O[Bt + W]), ft = me.a, ht = me.b, ce(O[Ut + W], O[Mn + W]), _t = me.a, wt = me.b, ce(ft, _t), O[At + W] = me.a, O[Ut + W] = me.b, ce(ht, wt), O[Bt + W] = me.a, O[Mn + W] = me.b) : (_e(O[At + W], O[Bt + W]), ft = me.a, ht = me.b, _e(O[Ut + W], O[Mn + W]), _t = me.a, wt = me.b, _e(ft, _t), O[At + W] = me.a, O[Ut + W] = me.b, _e(ht, wt), O[Bt + W] = me.a, O[Mn + W] = me.b)
                    }
                    if (de & ee) {
                        var Bt = At + Ge;
                        re ? ce(O[At + W], O[Bt + W]) : _e(O[At + W], O[Bt + W]), ft = me.a, O[Bt + W] = me.b, O[At + W] = ft
                    }
                }
                if (Pe & ee)
                    for (var At = fe, ct = fe + be * (de - Te); At <= ct; At += Qe) {
                        var Ut = At + st;
                        re ? ce(O[At + W], O[Ut + W]) : _e(O[At + W], O[Ut + W]), ft = me.a, O[Ut + W] = me.b, O[At + W] = ft
                    }
                Te = ee, ee >>= 1
            }
            return fe
        }

        function ke(O, W, de, be, Pe, F, Q, re, le, ee) {
            for (var Te = 0, fe = 0, Ke = re, Ge = Math.trunc(Pe.value + (F + 7) / 8); Pe.value < Ge;)
                for (j(Te, fe, de, Pe), Te = U.c, fe = U.lc; fe >= 14;) {
                    var qe = Te >> fe - 14 & 16383,
                        st = W[qe];
                    if (st.len) fe -= st.len, he(st.lit, Q, Te, fe, de, be, Pe, le, ee, Ke), Te = te.c, fe = te.lc;
                    else {
                        if (!st.p) throw "hufDecode issues";
                        var Qe;
                        for (Qe = 0; Qe < st.lit; Qe++) {
                            for (var ft = oe(O[st.p[Qe]]); fe < ft && Pe.value < Ge;) j(Te, fe, de, Pe), Te = U.c, fe = U.lc;
                            if (fe >= ft && Y(O[st.p[Qe]]) == (Te >> fe - ft & (1 << ft) - 1)) {
                                fe -= ft, he(st.p[Qe], Q, Te, fe, de, be, Pe, le, ee, Ke), Te = te.c, fe = te.lc;
                                break
                            }
                        }
                        if (Qe == st.lit) throw "hufDecode issues"
                    }
                }
            var _t = 8 - F & 7;
            for (Te >>= _t, fe -= _t; fe > 0;) {
                var st = W[Te << 14 - fe & 16383];
                if (st.len) fe -= st.len, he(st.lit, Q, Te, fe, de, be, Pe, le, ee, Ke), Te = te.c, fe = te.lc;
                else throw "hufDecode issues"
            }
            return !0
        }

        function Ee(O, W, de, be, Pe, F) {
            var Q = {
                    value: 0
                },
                re = de.value,
                le = $e(W, de),
                ee = $e(W, de);
            de.value += 4;
            var Te = $e(W, de);
            if (de.value += 4, le < 0 || le >= 65537 || ee < 0 || ee >= 65537) throw "Something wrong with HUF_ENCSIZE";
            var fe = new Array(65537),
                Ke = new Array(16384);
            L(Ke);
            var Ge = be - (de.value - re);
            if (X(O, W, de, Ge, le, ee, fe), Te > 8 * (be - (de.value - re))) throw "Something wrong with hufUncompress";
            Z(fe, le, ee, Ke), ke(fe, Ke, O, W, de, Te, ee, F, Pe, Q)
        }

        function pe(O, W, de) {
            for (var be = 0; be < de; ++be) W[be] = O[W[be]]
        }

        function xe(O) {
            for (var W = 1; W < O.length; W++) {
                var de = O[W - 1] + O[W] - 128;
                O[W] = de
            }
        }

        function J(O, W) {
            for (var de = 0, be = Math.floor((O.length + 1) / 2), Pe = 0, F = O.length - 1; !(Pe > F || (W[Pe++] = O[de++], Pe > F));) W[Pe++] = O[be++]
        }

        function De(O) {
            for (var W = O.byteLength, de = new Array, be = 0, Pe = new DataView(O); W > 0;) {
                var F = Pe.getInt8(be++);
                if (F < 0) {
                    var Q = -F;
                    W -= Q + 1;
                    for (var re = 0; re < Q; re++) de.push(Pe.getUint8(be++))
                } else {
                    var Q = F;
                    W -= 2;
                    for (var le = Pe.getUint8(be++), re = 0; re < Q + 1; re++) de.push(le)
                }
            }
            return de
        }

        function Ce(O, W, de, be, Pe, F) {
            var Ut = new DataView(F.buffer),
                Q = de[O.idx[0]].width,
                re = de[O.idx[0]].height,
                le = 3,
                ee = Math.floor(Q / 8),
                Te = Math.ceil(Q / 8),
                fe = Math.ceil(re / 8),
                Ke = Q - (Te - 1) * 8,
                Ge = re - (fe - 1) * 8,
                qe = {
                    value: 0
                },
                st = new Array(le),
                Qe = new Array(le),
                ft = new Array(le),
                _t = new Array(le),
                ht = new Array(le);
            for (let en = 0; en < le; ++en) ht[en] = W[O.idx[en]], st[en] = en < 1 ? 0 : st[en - 1] + Te * fe, Qe[en] = new Float32Array(64), ft[en] = new Uint16Array(64), _t[en] = new Uint16Array(Te * 64);
            for (let en = 0; en < fe; ++en) {
                var wt = 8;
                en == fe - 1 && (wt = Ge);
                var At = 8;
                for (let Wt = 0; Wt < Te; ++Wt) {
                    Wt == Te - 1 && (At = Ke);
                    for (let Ht = 0; Ht < le; ++Ht) ft[Ht].fill(0), ft[Ht][0] = Pe[st[Ht]++], se(qe, be, ft[Ht]), Se(ft[Ht], Qe[Ht]), Xe(Qe[Ht]);
                    Le(Qe);
                    for (let Ht = 0; Ht < le; ++Ht) k(Qe[Ht], _t[Ht], Wt * 64)
                }
                let Gt = 0;
                for (let Wt = 0; Wt < le; ++Wt) {
                    const Ht = de[O.idx[Wt]].type;
                    for (let sn = 8 * en; sn < 8 * en + wt; ++sn) {
                        Gt = ht[Wt][sn];
                        for (let Qn = 0; Qn < ee; ++Qn) {
                            const Dn = Qn * 64 + (sn & 7) * 8;
                            Ut.setUint16(Gt + 0 * 2 * Ht, _t[Wt][Dn + 0], !0), Ut.setUint16(Gt + 1 * 2 * Ht, _t[Wt][Dn + 1], !0), Ut.setUint16(Gt + 2 * 2 * Ht, _t[Wt][Dn + 2], !0), Ut.setUint16(Gt + 3 * 2 * Ht, _t[Wt][Dn + 3], !0), Ut.setUint16(Gt + 4 * 2 * Ht, _t[Wt][Dn + 4], !0), Ut.setUint16(Gt + 5 * 2 * Ht, _t[Wt][Dn + 5], !0), Ut.setUint16(Gt + 6 * 2 * Ht, _t[Wt][Dn + 6], !0), Ut.setUint16(Gt + 7 * 2 * Ht, _t[Wt][Dn + 7], !0), Gt += 8 * 2 * Ht
                        }
                    }
                    if (ee != Te)
                        for (let sn = 8 * en; sn < 8 * en + wt; ++sn) {
                            const Qn = ht[Wt][sn] + 8 * ee * 2 * Ht,
                                Dn = ee * 64 + (sn & 7) * 8;
                            for (let tr = 0; tr < At; ++tr) Ut.setUint16(Qn + tr * 2 * Ht, _t[Wt][Dn + tr], !0)
                        }
                }
            }
            for (var ct = new Uint16Array(Q), Ut = new DataView(F.buffer), Bt = 0; Bt < le; ++Bt) {
                de[O.idx[Bt]].decoded = !0;
                var Mn = de[O.idx[Bt]].type;
                if (de[Bt].type == 2)
                    for (var In = 0; In < re; ++In) {
                        const en = ht[Bt][In];
                        for (var cn = 0; cn < Q; ++cn) ct[cn] = Ut.getUint16(en + cn * 2 * Mn, !0);
                        for (var cn = 0; cn < Q; ++cn) Ut.setFloat32(en + cn * 2 * Mn, ve(ct[cn]), !0)
                    }
            }
        }

        function se(O, W, de) {
            for (var be, Pe = 1; Pe < 64;) be = W[O.value], be == 65280 ? Pe = 64 : be >> 8 == 255 ? Pe += be & 255 : (de[Pe] = be, Pe++), O.value++
        }

        function Se(O, W) {
            W[0] = ve(O[0]), W[1] = ve(O[1]), W[2] = ve(O[5]), W[3] = ve(O[6]), W[4] = ve(O[14]), W[5] = ve(O[15]), W[6] = ve(O[27]), W[7] = ve(O[28]), W[8] = ve(O[2]), W[9] = ve(O[4]), W[10] = ve(O[7]), W[11] = ve(O[13]), W[12] = ve(O[16]), W[13] = ve(O[26]), W[14] = ve(O[29]), W[15] = ve(O[42]), W[16] = ve(O[3]), W[17] = ve(O[8]), W[18] = ve(O[12]), W[19] = ve(O[17]), W[20] = ve(O[25]), W[21] = ve(O[30]), W[22] = ve(O[41]), W[23] = ve(O[43]), W[24] = ve(O[9]), W[25] = ve(O[11]), W[26] = ve(O[18]), W[27] = ve(O[24]), W[28] = ve(O[31]), W[29] = ve(O[40]), W[30] = ve(O[44]), W[31] = ve(O[53]), W[32] = ve(O[10]), W[33] = ve(O[19]), W[34] = ve(O[23]), W[35] = ve(O[32]), W[36] = ve(O[39]), W[37] = ve(O[45]), W[38] = ve(O[52]), W[39] = ve(O[54]), W[40] = ve(O[20]), W[41] = ve(O[22]), W[42] = ve(O[33]), W[43] = ve(O[38]), W[44] = ve(O[46]), W[45] = ve(O[51]), W[46] = ve(O[55]), W[47] = ve(O[60]), W[48] = ve(O[21]), W[49] = ve(O[34]), W[50] = ve(O[37]), W[51] = ve(O[47]), W[52] = ve(O[50]), W[53] = ve(O[56]), W[54] = ve(O[59]), W[55] = ve(O[61]), W[56] = ve(O[35]), W[57] = ve(O[36]), W[58] = ve(O[48]), W[59] = ve(O[49]), W[60] = ve(O[57]), W[61] = ve(O[58]), W[62] = ve(O[62]), W[63] = ve(O[63])
        }

        function Xe(O) {
            const W = .5 * Math.cos(.7853975),
                de = .5 * Math.cos(3.14159 / 16),
                be = .5 * Math.cos(3.14159 / 8),
                Pe = .5 * Math.cos(3 * 3.14159 / 16),
                F = .5 * Math.cos(5 * 3.14159 / 16),
                Q = .5 * Math.cos(3 * 3.14159 / 8),
                re = .5 * Math.cos(7 * 3.14159 / 16);
            for (var le = new Array(4), ee = new Array(4), Te = new Array(4), fe = new Array(4), Ke = 0; Ke < 8; ++Ke) {
                var Ge = Ke * 8;
                le[0] = be * O[Ge + 2], le[1] = Q * O[Ge + 2], le[2] = be * O[Ge + 6], le[3] = Q * O[Ge + 6], ee[0] = de * O[Ge + 1] + Pe * O[Ge + 3] + F * O[Ge + 5] + re * O[Ge + 7], ee[1] = Pe * O[Ge + 1] - re * O[Ge + 3] - de * O[Ge + 5] - F * O[Ge + 7], ee[2] = F * O[Ge + 1] - de * O[Ge + 3] + re * O[Ge + 5] + Pe * O[Ge + 7], ee[3] = re * O[Ge + 1] - F * O[Ge + 3] + Pe * O[Ge + 5] - de * O[Ge + 7], Te[0] = W * (O[Ge + 0] + O[Ge + 4]), Te[3] = W * (O[Ge + 0] - O[Ge + 4]), Te[1] = le[0] + le[3], Te[2] = le[1] - le[2], fe[0] = Te[0] + Te[1], fe[1] = Te[3] + Te[2], fe[2] = Te[3] - Te[2], fe[3] = Te[0] - Te[1], O[Ge + 0] = fe[0] + ee[0], O[Ge + 1] = fe[1] + ee[1], O[Ge + 2] = fe[2] + ee[2], O[Ge + 3] = fe[3] + ee[3], O[Ge + 4] = fe[3] - ee[3], O[Ge + 5] = fe[2] - ee[2], O[Ge + 6] = fe[1] - ee[1], O[Ge + 7] = fe[0] - ee[0]
            }
            for (var qe = 0; qe < 8; ++qe) le[0] = be * O[16 + qe], le[1] = Q * O[16 + qe], le[2] = be * O[48 + qe], le[3] = Q * O[48 + qe], ee[0] = de * O[8 + qe] + Pe * O[24 + qe] + F * O[40 + qe] + re * O[56 + qe], ee[1] = Pe * O[8 + qe] - re * O[24 + qe] - de * O[40 + qe] - F * O[56 + qe], ee[2] = F * O[8 + qe] - de * O[24 + qe] + re * O[40 + qe] + Pe * O[56 + qe], ee[3] = re * O[8 + qe] - F * O[24 + qe] + Pe * O[40 + qe] - de * O[56 + qe], Te[0] = W * (O[qe] + O[32 + qe]), Te[3] = W * (O[qe] - O[32 + qe]), Te[1] = le[0] + le[3], Te[2] = le[1] - le[2], fe[0] = Te[0] + Te[1], fe[1] = Te[3] + Te[2], fe[2] = Te[3] - Te[2], fe[3] = Te[0] - Te[1], O[0 + qe] = fe[0] + ee[0], O[8 + qe] = fe[1] + ee[1], O[16 + qe] = fe[2] + ee[2], O[24 + qe] = fe[3] + ee[3], O[32 + qe] = fe[3] - ee[3], O[40 + qe] = fe[2] - ee[2], O[48 + qe] = fe[1] - ee[1], O[56 + qe] = fe[0] - ee[0]
        }

        function Le(O) {
            for (var W = 0; W < 64; ++W) {
                var de = O[0][W],
                    be = O[1][W],
                    Pe = O[2][W];
                O[0][W] = de + 1.5747 * Pe, O[1][W] = de - .1873 * be - .4682 * Pe, O[2][W] = de + 1.8556 * be
            }
        }

        function k(O, W, de) {
            for (var be = 0; be < 64; ++be) W[de + be] = Lc.toHalfFloat(z(O[be]))
        }

        function z(O) {
            return O <= 1 ? Math.sign(O) * Math.pow(Math.abs(O), 2.2) : Math.sign(O) * Math.pow(b, Math.abs(O) - 1)
        }

        function ue(O) {
            return new DataView(O.array.buffer, O.offset.value, O.size)
        }

        function ye(O) {
            var W = O.viewer.buffer.slice(O.offset.value, O.offset.value + O.size),
                de = new Uint8Array(De(W)),
                be = new Uint8Array(de.length);
            return xe(de), J(de, be), new DataView(be.buffer)
        }

        function ge(O) {
            var W = O.array.slice(O.offset.value, O.offset.value + O.size),
                de = l0(W),
                be = new Uint8Array(de.length);
            return xe(de), J(de, be), new DataView(be.buffer)
        }

        function Re(O) {
            for (var W = O.viewer, de = {
                    value: O.offset.value
                }, be = new Uint16Array(O.width * O.scanlineBlockSize * (O.channels * O.type)), Pe = new Uint8Array(8192), F = 0, Q = new Array(O.channels), re = 0; re < O.channels; re++) Q[re] = {}, Q[re].start = F, Q[re].end = Q[re].start, Q[re].nx = O.width, Q[re].ny = O.lines, Q[re].size = O.type, F += Q[re].nx * Q[re].ny * Q[re].size;
            var le = we(W, de),
                ee = we(W, de);
            if (ee >= 8192) throw "Something is wrong with PIZ_COMPRESSION BITMAP_SIZE";
            if (le <= ee)
                for (var re = 0; re < ee - le + 1; re++) Pe[re + le] = yt(W, de);
            var Te = new Uint16Array(65536),
                fe = T(Pe, Te),
                Ke = $e(W, de);
            Ee(O.array, W, de, Ke, be, F);
            for (var re = 0; re < O.channels; ++re)
                for (var Ge = Q[re], qe = 0; qe < Q[re].size; ++qe) Oe(be, Ge.start + qe, Ge.nx, Ge.size, Ge.ny, Ge.nx * Ge.size, fe);
            pe(Te, be, F);
            for (var st = 0, Qe = new Uint8Array(be.buffer.byteLength), ft = 0; ft < O.lines; ft++)
                for (var _t = 0; _t < O.channels; _t++) {
                    var Ge = Q[_t],
                        ht = Ge.nx * Ge.size,
                        wt = new Uint8Array(be.buffer, Ge.end * 2, ht * 2);
                    Qe.set(wt, st), st += ht * 2, Ge.end += ht
                }
            return new DataView(Qe.buffer)
        }

        function Be(O) {
            var W = O.array.slice(O.offset.value, O.offset.value + O.size),
                de = l0(W);
            const be = O.lines * O.channels * O.width,
                Pe = O.type == 1 ? new Uint16Array(be) : new Uint32Array(be);
            let F = 0,
                Q = 0;
            const re = new Array(4);
            for (let le = 0; le < O.lines; le++)
                for (let ee = 0; ee < O.channels; ee++) {
                    let Te = 0;
                    switch (O.type) {
                        case 1:
                            re[0] = F, re[1] = re[0] + O.width, F = re[1] + O.width;
                            for (let fe = 0; fe < O.width; ++fe) {
                                const Ke = de[re[0]++] << 8 | de[re[1]++];
                                Te += Ke, Pe[Q] = Te, Q++
                            }
                            break;
                        case 2:
                            re[0] = F, re[1] = re[0] + O.width, re[2] = re[1] + O.width, F = re[2] + O.width;
                            for (let fe = 0; fe < O.width; ++fe) {
                                const Ke = de[re[0]++] << 24 | de[re[1]++] << 16 | de[re[2]++] << 8;
                                Te += Ke, Pe[Q] = Te, Q++
                            }
                            break
                    }
                }
            return new DataView(Pe.buffer)
        }

        function Fe(O) {
            var W = O.viewer,
                de = {
                    value: O.offset.value
                },
                be = new Uint8Array(O.width * O.lines * (O.channels * O.type * 2)),
                Pe = {
                    version: at(W, de),
                    unknownUncompressedSize: at(W, de),
                    unknownCompressedSize: at(W, de),
                    acCompressedSize: at(W, de),
                    dcCompressedSize: at(W, de),
                    rleCompressedSize: at(W, de),
                    rleUncompressedSize: at(W, de),
                    rleRawSize: at(W, de),
                    totalAcUncompressedCount: at(W, de),
                    totalDcUncompressedCount: at(W, de),
                    acCompression: at(W, de)
                };
            if (Pe.version < 2) throw "EXRLoader.parse: " + Dt.compression + " version " + Pe.version + " is unsupported";
            for (var F = new Array, Q = we(W, de) - 2; Q > 0;) {
                var re = Ne(W.buffer, de),
                    le = yt(W, de),
                    ee = le >> 2 & 3,
                    Te = (le >> 4) - 1,
                    fe = new Int8Array([Te])[0],
                    Ke = yt(W, de);
                F.push({
                    name: re,
                    index: fe,
                    type: Ke,
                    compression: ee
                }), Q -= re.length + 3
            }
            for (var Ge = Dt.channels, qe = new Array(O.channels), st = 0; st < O.channels; ++st) {
                var Qe = qe[st] = {},
                    ft = Ge[st];
                Qe.name = ft.name, Qe.compression = 0, Qe.decoded = !1, Qe.type = ft.pixelType, Qe.pLinear = ft.pLinear, Qe.width = O.width, Qe.height = O.lines
            }
            for (var _t = {
                    idx: new Array(3)
                }, ht = 0; ht < O.channels; ++ht)
                for (var Qe = qe[ht], st = 0; st < F.length; ++st) {
                    var wt = F[st];
                    Qe.name == wt.name && (Qe.compression = wt.compression, wt.index >= 0 && (_t.idx[wt.index] = ht), Qe.offset = ht)
                }
            if (Pe.acCompressedSize > 0) switch (Pe.acCompression) {
                case 0:
                    var Ut = new Uint16Array(Pe.totalAcUncompressedCount);
                    Ee(O.array, W, de, Pe.acCompressedSize, Ut, Pe.totalAcUncompressedCount);
                    break;
                case 1:
                    var At = O.array.slice(de.value, de.value + Pe.totalAcUncompressedCount),
                        ct = l0(At),
                        Ut = new Uint16Array(ct.buffer);
                    de.value += Pe.totalAcUncompressedCount;
                    break
            }
            if (Pe.dcCompressedSize > 0) {
                var Bt = {
                        array: O.array,
                        offset: de,
                        size: Pe.dcCompressedSize
                    },
                    Mn = new Uint16Array(ge(Bt).buffer);
                de.value += Pe.dcCompressedSize
            }
            if (Pe.rleRawSize > 0) {
                var At = O.array.slice(de.value, de.value + Pe.rleCompressedSize),
                    ct = l0(At),
                    In = De(ct.buffer);
                de.value += Pe.rleCompressedSize
            }
            for (var cn = 0, en = new Array(qe.length), st = 0; st < en.length; ++st) en[st] = new Array;
            for (var Gt = 0; Gt < O.lines; ++Gt)
                for (var Wt = 0; Wt < qe.length; ++Wt) en[Wt].push(cn), cn += qe[Wt].width * O.type * 2;
            Ce(_t, en, qe, Ut, Mn, be);
            for (var st = 0; st < qe.length; ++st) {
                var Qe = qe[st];
                if (!Qe.decoded) switch (Qe.compression) {
                    case 2:
                        for (var Ht = 0, sn = 0, Gt = 0; Gt < O.lines; ++Gt) {
                            for (var Qn = en[st][Ht], Dn = 0; Dn < Qe.width; ++Dn) {
                                for (var tr = 0; tr < 2 * Qe.type; ++tr) be[Qn++] = In[sn + tr * Qe.width * Qe.height];
                                sn++
                            }
                            Ht++
                        }
                        break;
                    case 1:
                    default:
                        throw "EXRLoader.parse: unsupported channel compression"
                }
            }
            return new DataView(be.buffer)
        }

        function Ne(O, W) {
            for (var de = new Uint8Array(O), be = 0; de[W.value + be] != 0;) be += 1;
            var Pe = new TextDecoder().decode(de.slice(W.value, W.value + be));
            return W.value = W.value + be + 1, Pe
        }

        function ot(O, W, de) {
            var be = new TextDecoder().decode(new Uint8Array(O).slice(W.value, W.value + de));
            return W.value = W.value + de, be
        }

        function je(O, W) {
            var de = it(O, W),
                be = $e(O, W);
            return [de, be]
        }

        function Ze(O, W) {
            var de = $e(O, W),
                be = $e(O, W);
            return [de, be]
        }

        function it(O, W) {
            var de = O.getInt32(W.value, !0);
            return W.value = W.value + 4, de
        }

        function $e(O, W) {
            var de = O.getUint32(W.value, !0);
            return W.value = W.value + 4, de
        }

        function We(O, W) {
            var de = O[W.value];
            return W.value = W.value + 1, de
        }

        function yt(O, W) {
            var de = O.getUint8(W.value);
            return W.value = W.value + 1, de
        }
        const at = function(O, W) {
            let de;
            return "getBigInt64" in DataView.prototype ? de = Number(O.getBigInt64(W.value, !0)) : de = O.getUint32(W.value + 4, !0) + Number(O.getUint32(W.value, !0) << 32), W.value += 8, de
        };

        function Mt(O, W) {
            var de = O.getFloat32(W.value, !0);
            return W.value += 4, de
        }

        function ae(O, W) {
            return Lc.toHalfFloat(Mt(O, W))
        }

        function ve(O) {
            var W = (O & 31744) >> 10,
                de = O & 1023;
            return (O >> 15 ? -1 : 1) * (W ? W === 31 ? de ? NaN : 1 / 0 : Math.pow(2, W - 15) * (1 + de / 1024) : 6103515625e-14 * (de / 1024))
        }

        function we(O, W) {
            var de = O.getUint16(W.value, !0);
            return W.value += 2, de
        }

        function He(O, W) {
            return ve(we(O, W))
        }

        function Je(O, W, de, be) {
            for (var Pe = de.value, F = []; de.value < Pe + be - 1;) {
                var Q = Ne(W, de),
                    re = it(O, de),
                    le = yt(O, de);
                de.value += 3;
                var ee = it(O, de),
                    Te = it(O, de);
                F.push({
                    name: Q,
                    pixelType: re,
                    pLinear: le,
                    xSampling: ee,
                    ySampling: Te
                })
            }
            return de.value += 1, F
        }

        function Ye(O, W) {
            var de = Mt(O, W),
                be = Mt(O, W),
                Pe = Mt(O, W),
                F = Mt(O, W),
                Q = Mt(O, W),
                re = Mt(O, W),
                le = Mt(O, W),
                ee = Mt(O, W);
            return {
                redX: de,
                redY: be,
                greenX: Pe,
                greenY: F,
                blueX: Q,
                blueY: re,
                whiteX: le,
                whiteY: ee
            }
        }

        function mt(O, W) {
            var de = ["NO_COMPRESSION", "RLE_COMPRESSION", "ZIPS_COMPRESSION", "ZIP_COMPRESSION", "PIZ_COMPRESSION", "PXR24_COMPRESSION", "B44_COMPRESSION", "B44A_COMPRESSION", "DWAA_COMPRESSION", "DWAB_COMPRESSION"],
                be = yt(O, W);
            return de[be]
        }

        function Pt(O, W) {
            var de = $e(O, W),
                be = $e(O, W),
                Pe = $e(O, W),
                F = $e(O, W);
            return {
                xMin: de,
                yMin: be,
                xMax: Pe,
                yMax: F
            }
        }

        function St(O, W) {
            var de = ["INCREASING_Y"],
                be = yt(O, W);
            return de[be]
        }

        function tt(O, W) {
            var de = Mt(O, W),
                be = Mt(O, W);
            return [de, be]
        }

        function ut(O, W) {
            var de = Mt(O, W),
                be = Mt(O, W),
                Pe = Mt(O, W);
            return [de, be, Pe]
        }

        function Rt(O, W, de, be, Pe) {
            if (be === "string" || be === "stringvector" || be === "iccProfile") return ot(W, de, Pe);
            if (be === "chlist") return Je(O, W, de, Pe);
            if (be === "chromaticities") return Ye(O, de);
            if (be === "compression") return mt(O, de);
            if (be === "box2i") return Pt(O, de);
            if (be === "lineOrder") return St(O, de);
            if (be === "float") return Mt(O, de);
            if (be === "v2f") return tt(O, de);
            if (be === "v3f") return ut(O, de);
            if (be === "int") return it(O, de);
            if (be === "rational") return je(O, de);
            if (be === "timecode") return Ze(O, de);
            if (be === "preview") return de.value += Pe, "skipped";
            de.value += Pe
        }

        function nt(O, W, de) {
            const be = {};
            if (O.getUint32(0, !0) != 20000630) throw "THREE.EXRLoader: provided file doesn't appear to be in OpenEXR format.";
            be.version = O.getUint8(4);
            const Pe = O.getUint8(5);
            be.spec = {
                singleTile: !!(Pe & 2),
                longName: !!(Pe & 4),
                deepFormat: !!(Pe & 8),
                multiPart: !!(Pe & 16)
            }, de.value = 8;
            for (var F = !0; F;) {
                var Q = Ne(W, de);
                if (Q == 0) F = !1;
                else {
                    var re = Ne(W, de),
                        le = $e(O, de),
                        ee = Rt(O, W, de, re, le);
                    ee === void 0 ? console.warn(`EXRLoader.parse: skipped unknown header attribute type '${re}'.`) : be[Q] = ee
                }
            }
            if (Pe & -5) throw console.error("EXRHeader:", be), "THREE.EXRLoader: provided file is currently unsupported.";
            return be
        }

        function It(O, W, de, be, Pe) {
            const F = {
                size: 0,
                viewer: W,
                array: de,
                offset: be,
                width: O.dataWindow.xMax - O.dataWindow.xMin + 1,
                height: O.dataWindow.yMax - O.dataWindow.yMin + 1,
                channels: O.channels.length,
                bytesPerLine: null,
                lines: null,
                inputSize: null,
                type: O.channels[0].pixelType,
                uncompress: null,
                getter: null,
                format: null,
                [ad ? "colorSpace" : "encoding"]: null
            };
            switch (O.compression) {
                case "NO_COMPRESSION":
                    F.lines = 1, F.uncompress = ue;
                    break;
                case "RLE_COMPRESSION":
                    F.lines = 1, F.uncompress = ye;
                    break;
                case "ZIPS_COMPRESSION":
                    F.lines = 1, F.uncompress = ge;
                    break;
                case "ZIP_COMPRESSION":
                    F.lines = 16, F.uncompress = ge;
                    break;
                case "PIZ_COMPRESSION":
                    F.lines = 32, F.uncompress = Re;
                    break;
                case "PXR24_COMPRESSION":
                    F.lines = 16, F.uncompress = Be;
                    break;
                case "DWAA_COMPRESSION":
                    F.lines = 32, F.uncompress = Fe;
                    break;
                case "DWAB_COMPRESSION":
                    F.lines = 256, F.uncompress = Fe;
                    break;
                default:
                    throw "EXRLoader.parse: " + O.compression + " is unsupported"
            }
            if (F.scanlineBlockSize = F.lines, F.type == 1) switch (Pe) {
                case Bn:
                    F.getter = He, F.inputSize = 2;
                    break;
                case Ri:
                    F.getter = we, F.inputSize = 2;
                    break
            } else if (F.type == 2) switch (Pe) {
                case Bn:
                    F.getter = Mt, F.inputSize = 4;
                    break;
                case Ri:
                    F.getter = ae, F.inputSize = 4
            } else throw "EXRLoader.parse: unsupported pixelType " + F.type + " for " + O.compression + ".";
            F.blockCount = (O.dataWindow.yMax + 1) / F.scanlineBlockSize;
            for (var Q = 0; Q < F.blockCount; Q++) at(W, be);
            F.outputChannels = F.channels == 3 ? 4 : F.channels;
            const re = F.width * F.height * F.outputChannels;
            switch (Pe) {
                case Bn:
                    F.byteArray = new Float32Array(re), F.channels < F.outputChannels && F.byteArray.fill(1, 0, re);
                    break;
                case Ri:
                    F.byteArray = new Uint16Array(re), F.channels < F.outputChannels && F.byteArray.fill(15360, 0, re);
                    break;
                default:
                    console.error("THREE.EXRLoader: unsupported type: ", Pe);
                    break
            }
            return F.bytesPerLine = F.width * F.inputSize * F.channels, F.outputChannels == 4 ? F.format = kn : F.format = Hp, ad ? F.colorSpace = "srgb-linear" : F.encoding = 3e3, F
        }
        const pt = new DataView(e),
            Ct = new Uint8Array(e),
            ln = {
                value: 0
            },
            Dt = nt(pt, e, ln),
            gt = It(Dt, pt, Ct, ln, this.type),
            $t = {
                value: 0
            },
            rn = {
                R: 0,
                G: 1,
                B: 2,
                A: 3,
                Y: 0
            };
        for (let O = 0; O < gt.height / gt.scanlineBlockSize; O++) {
            const W = $e(pt, ln);
            gt.size = $e(pt, ln), gt.lines = W + gt.scanlineBlockSize > gt.height ? gt.height - W : gt.scanlineBlockSize;
            const be = gt.size < gt.lines * gt.bytesPerLine ? gt.uncompress(gt) : ue(gt);
            ln.value += gt.size;
            for (let Pe = 0; Pe < gt.scanlineBlockSize; Pe++) {
                const F = Pe + O * gt.scanlineBlockSize;
                if (F >= gt.height) break;
                for (let Q = 0; Q < gt.channels; Q++) {
                    const re = rn[Dt.channels[Q].name];
                    for (let le = 0; le < gt.width; le++) {
                        $t.value = (Pe * (gt.channels * gt.width) + Q * gt.width + le) * gt.inputSize;
                        const ee = (gt.height - 1 - F) * (gt.width * gt.outputChannels) + le * gt.outputChannels + re;
                        gt.byteArray[ee] = gt.getter(be, $t)
                    }
                }
            }
        }
        return {
            header: Dt,
            width: gt.width,
            height: gt.height,
            data: gt.byteArray,
            format: gt.format,
            [ad ? "colorSpace" : "encoding"]: gt[ad ? "colorSpace" : "encoding"],
            type: this.type
        }
    }
    setDataType(e) {
        return this.type = e, this
    }
    load(e, t, n, i) {
        function s(o, a) {
            ad ? o.colorSpace = a.colorSpace : o.encoding = a.encoding, o.minFilter = nn, o.magFilter = nn, o.generateMipmaps = !1, o.flipY = !1, t && t(o, a)
        }
        return super.load(e, s, n, i)
    }
}
const o1 = new WeakMap;
class m9 extends er {
    constructor(e) {
        super(e), this.decoderPath = "", this.decoderConfig = {}, this.decoderBinary = null, this.decoderPending = null, this.workerLimit = 4, this.workerPool = [], this.workerNextTaskID = 1, this.workerSourceURL = "", this.defaultAttributeIDs = {
            position: "POSITION",
            normal: "NORMAL",
            color: "COLOR",
            uv: "TEX_COORD"
        }, this.defaultAttributeTypes = {
            position: "Float32Array",
            normal: "Float32Array",
            color: "Float32Array",
            uv: "Float32Array"
        }
    }
    setDecoderPath(e) {
        return this.decoderPath = e, this
    }
    setDecoderConfig(e) {
        return this.decoderConfig = e, this
    }
    setWorkerLimit(e) {
        return this.workerLimit = e, this
    }
    load(e, t, n, i) {
        const s = new $i(this.manager);
        s.setPath(this.path), s.setResponseType("arraybuffer"), s.setRequestHeader(this.requestHeader), s.setWithCredentials(this.withCredentials), s.load(e, o => {
            const a = {
                attributeIDs: this.defaultAttributeIDs,
                attributeTypes: this.defaultAttributeTypes,
                useUniqueIDs: !1
            };
            this.decodeGeometry(o, a).then(t).catch(i)
        }, n, i)
    }
    decodeDracoFile(e, t, n, i) {
        const s = {
            attributeIDs: n || this.defaultAttributeIDs,
            attributeTypes: i || this.defaultAttributeTypes,
            useUniqueIDs: !!n
        };
        this.decodeGeometry(e, s).then(t)
    }
    decodeGeometry(e, t) {
        for (const l in t.attributeTypes) {
            const c = t.attributeTypes[l];
            c.BYTES_PER_ELEMENT !== void 0 && (t.attributeTypes[l] = c.name)
        }
        const n = JSON.stringify(t);
        if (o1.has(e)) {
            const l = o1.get(e);
            if (l.key === n) return l.promise;
            if (e.byteLength === 0) throw new Error("THREE.DRACOLoader: Unable to re-decode a buffer with different settings. Buffer has already been transferred.")
        }
        let i;
        const s = this.workerNextTaskID++,
            o = e.byteLength,
            a = this._getWorker(s, o).then(l => (i = l, new Promise((c, u) => {
                i._callbacks[s] = {
                    resolve: c,
                    reject: u
                }, i.postMessage({
                    type: "decode",
                    id: s,
                    taskConfig: t,
                    buffer: e
                }, [e])
            }))).then(l => this._createGeometry(l.geometry));
        return a.catch(() => !0).then(() => {
            i && s && this._releaseTask(i, s)
        }), o1.set(e, {
            key: n,
            promise: a
        }), a
    }
    _createGeometry(e) {
        const t = new zt;
        e.index && t.setIndex(new an(e.index.array, 1));
        for (let n = 0; n < e.attributes.length; n++) {
            const i = e.attributes[n],
                s = i.name,
                o = i.array,
                a = i.itemSize;
            t.setAttribute(s, new an(o, a))
        }
        return t
    }
    _loadLibrary(e, t) {
        const n = new $i(this.manager);
        return n.setPath(this.decoderPath), n.setResponseType(t), n.setWithCredentials(this.withCredentials), new Promise((i, s) => {
            n.load(e, i, void 0, s)
        })
    }
    preload() {
        return this._initDecoder(), this
    }
    _initDecoder() {
        if (this.decoderPending) return this.decoderPending;
        const e = typeof WebAssembly != "object" || this.decoderConfig.type === "js",
            t = [];
        return e ? t.push(this._loadLibrary("draco_decoder.js", "text")) : (t.push(this._loadLibrary("draco_wasm_wrapper.js", "text")), t.push(this._loadLibrary("draco_decoder.wasm", "arraybuffer"))), this.decoderPending = Promise.all(t).then(n => {
            const i = n[0];
            e || (this.decoderConfig.wasmBinary = n[1]);
            const s = g9.toString(),
                o = ["/* draco decoder */", i, "", "/* worker */", s.substring(s.indexOf("{") + 1, s.lastIndexOf("}"))].join(`
`);
            this.workerSourceURL = URL.createObjectURL(new Blob([o]))
        }), this.decoderPending
    }
    _getWorker(e, t) {
        return this._initDecoder().then(() => {
            if (this.workerPool.length < this.workerLimit) {
                const i = new Worker(this.workerSourceURL);
                i._callbacks = {}, i._taskCosts = {}, i._taskLoad = 0, i.postMessage({
                    type: "init",
                    decoderConfig: this.decoderConfig
                }), i.onmessage = function(s) {
                    const o = s.data;
                    switch (o.type) {
                        case "decode":
                            i._callbacks[o.id].resolve(o);
                            break;
                        case "error":
                            i._callbacks[o.id].reject(o);
                            break;
                        default:
                            console.error('THREE.DRACOLoader: Unexpected message, "' + o.type + '"')
                    }
                }, this.workerPool.push(i)
            } else this.workerPool.sort(function(i, s) {
                return i._taskLoad > s._taskLoad ? -1 : 1
            });
            const n = this.workerPool[this.workerPool.length - 1];
            return n._taskCosts[e] = t, n._taskLoad += t, n
        })
    }
    _releaseTask(e, t) {
        e._taskLoad -= e._taskCosts[t], delete e._callbacks[t], delete e._taskCosts[t]
    }
    debug() {
        console.log("Task load: ", this.workerPool.map(e => e._taskLoad))
    }
    dispose() {
        for (let e = 0; e < this.workerPool.length; ++e) this.workerPool[e].terminate();
        return this.workerPool.length = 0, this
    }
}

function g9() {
    let r, e;
    onmessage = function(o) {
        const a = o.data;
        switch (a.type) {
            case "init":
                r = a.decoderConfig, e = new Promise(function(u) {
                    r.onModuleLoaded = function(f) {
                        u({
                            draco: f
                        })
                    }, DracoDecoderModule(r)
                });
                break;
            case "decode":
                const l = a.buffer,
                    c = a.taskConfig;
                e.then(u => {
                    const f = u.draco,
                        d = new f.Decoder,
                        m = new f.DecoderBuffer;
                    m.Init(new Int8Array(l), l.byteLength);
                    try {
                        const g = t(f, d, m, c),
                            y = g.attributes.map(v => v.array.buffer);
                        g.index && y.push(g.index.array.buffer), self.postMessage({
                            type: "decode",
                            id: a.id,
                            geometry: g
                        }, y)
                    } catch (g) {
                        console.error(g), self.postMessage({
                            type: "error",
                            id: a.id,
                            error: g.message
                        })
                    } finally {
                        f.destroy(m), f.destroy(d)
                    }
                });
                break
        }
    };

    function t(o, a, l, c) {
        const u = c.attributeIDs,
            f = c.attributeTypes;
        let d, m;
        const g = a.GetEncodedGeometryType(l);
        if (g === o.TRIANGULAR_MESH) d = new o.Mesh, m = a.DecodeBufferToMesh(l, d);
        else if (g === o.POINT_CLOUD) d = new o.PointCloud, m = a.DecodeBufferToPointCloud(l, d);
        else throw new Error("THREE.DRACOLoader: Unexpected geometry type.");
        if (!m.ok() || d.ptr === 0) throw new Error("THREE.DRACOLoader: Decoding failed: " + m.error_msg());
        const y = {
            index: null,
            attributes: []
        };
        for (const v in u) {
            const _ = self[f[v]];
            let A, S;
            if (c.useUniqueIDs) S = u[v], A = a.GetAttributeByUniqueId(d, S);
            else {
                if (S = a.GetAttributeId(d, o[u[v]]), S === -1) continue;
                A = a.GetAttribute(d, S)
            }
            y.attributes.push(i(o, a, d, v, _, A))
        }
        return g === o.TRIANGULAR_MESH && (y.index = n(o, a, d)), o.destroy(d), y
    }

    function n(o, a, l) {
        const u = l.num_faces() * 3,
            f = u * 4,
            d = o._malloc(f);
        a.GetTrianglesUInt32Array(l, f, d);
        const m = new Uint32Array(o.HEAPF32.buffer, d, u).slice();
        return o._free(d), {
            array: m,
            itemSize: 1
        }
    }

    function i(o, a, l, c, u, f) {
        const d = f.num_components(),
            g = l.num_points() * d,
            y = g * u.BYTES_PER_ELEMENT,
            v = s(o, u),
            _ = o._malloc(y);
        a.GetAttributeDataArrayForAllPoints(l, f, v, y, _);
        const A = new u(o.HEAPF32.buffer, _, g).slice();
        return o._free(_), {
            name: c,
            array: A,
            itemSize: d
        }
    }

    function s(o, a) {
        switch (a) {
            case Float32Array:
                return o.DT_FLOAT32;
            case Int8Array:
                return o.DT_INT8;
            case Int16Array:
                return o.DT_INT16;
            case Int32Array:
                return o.DT_INT32;
            case Uint8Array:
                return o.DT_UINT8;
            case Uint16Array:
                return o.DT_UINT16;
            case Uint32Array:
                return o.DT_UINT32
        }
    }
}
let c0;
const a1 = () => {
    if (c0) return c0;
    const r = "B9h9z9tFBBBF8fL9gBB9gLaaaaaFa9gEaaaB9gFaFa9gEaaaFaEMcBFFFGGGEIIILF9wFFFLEFBFKNFaFCx/IFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBF8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBGy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBEn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBIi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBKI9z9iqlBOc+x8ycGBM/qQFTa8jUUUUBCU/EBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAGTkUUUBRNCUoBAG9uC/wgBZHKCUGAKCUG9JyRVAECFJRICBRcGXEXAcAF9PQFAVAFAclAcAVJAF9JyRMGXGXAG9FQBAMCbJHKC9wZRSAKCIrCEJCGrRQANCUGJRfCBRbAIRTEXGXAOATlAQ9PQBCBRISEMATAQJRIGXAS9FQBCBRtCBREEXGXAOAIlCi9PQBCBRISLMANCU/CBJAEJRKGXGXGXGXGXATAECKrJ2BBAtCKZrCEZfIBFGEBMAKhB83EBAKCNJhB83EBSEMAKAI2BIAI2BBHmCKrHYAYCE6HYy86BBAKCFJAICIJAYJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCGJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCEJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCIJAYAmJHY2BBAI2BFHmCKrHPAPCE6HPy86BBAKCLJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCKJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCOJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCNJAYAmJHY2BBAI2BGHmCKrHPAPCE6HPy86BBAKCVJAYAPJHY2BBAmCIrCEZHPAPCE6HPy86BBAKCcJAYAPJHY2BBAmCGrCEZHPAPCE6HPy86BBAKCMJAYAPJHY2BBAmCEZHmAmCE6Hmy86BBAKCSJAYAmJHm2BBAI2BEHICKrHYAYCE6HYy86BBAKCQJAmAYJHm2BBAICIrCEZHYAYCE6HYy86BBAKCfJAmAYJHm2BBAICGrCEZHYAYCE6HYy86BBAKCbJAmAYJHK2BBAICEZHIAICE6HIy86BBAKAIJRISGMAKAI2BNAI2BBHmCIrHYAYCb6HYy86BBAKCFJAICNJAYJHY2BBAmCbZHmAmCb6Hmy86BBAKCGJAYAmJHm2BBAI2BFHYCIrHPAPCb6HPy86BBAKCEJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCIJAmAYJHm2BBAI2BGHYCIrHPAPCb6HPy86BBAKCLJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCKJAmAYJHm2BBAI2BEHYCIrHPAPCb6HPy86BBAKCOJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCNJAmAYJHm2BBAI2BIHYCIrHPAPCb6HPy86BBAKCVJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCcJAmAYJHm2BBAI2BLHYCIrHPAPCb6HPy86BBAKCMJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCSJAmAYJHm2BBAI2BKHYCIrHPAPCb6HPy86BBAKCQJAmAPJHm2BBAYCbZHYAYCb6HYy86BBAKCfJAmAYJHm2BBAI2BOHICIrHYAYCb6HYy86BBAKCbJAmAYJHK2BBAICbZHIAICb6HIy86BBAKAIJRISFMAKAI8pBB83BBAKCNJAICNJ8pBB83BBAICTJRIMAtCGJRtAECTJHEAS9JQBMMGXAIQBCBRISEMGXAM9FQBANAbJ2BBRtCBRKAfREEXAEANCU/CBJAKJ2BBHTCFrCBATCFZl9zAtJHt86BBAEAGJREAKCFJHKAM9HQBMMAfCFJRfAIRTAbCFJHbAG9HQBMMABAcAG9sJANCUGJAMAG9sTkUUUBpANANCUGJAMCaJAG9sJAGTkUUUBpMAMCBAIyAcJRcAIQBMC9+RKSFMCBC99AOAIlAGCAAGCA9Ly6yRKMALCU/EBJ8kUUUUBAKM+OmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUFT+JUUUBpALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM+lLKFaF99GaG99FaG99GXGXAGCI9HQBAF9FQFEXGXGX9DBBB8/9DBBB+/ABCGJHG1BB+yAB1BBHE+yHI+L+TABCFJHL1BBHK+yHO+L+THN9DBBBB9gHVyAN9DBB/+hANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE86BBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG86BBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG86BBABCIJRBAFCaJHFQBSGMMAF9FQBEXGXGX9DBBB8/9DBBB+/ABCIJHG8uFB+yAB8uFBHE+yHI+L+TABCGJHL8uFBHK+yHO+L+THN9DBBBB9gHVyAN9DB/+g6ANAN+U9DBBBBANAVyHcAc+MHMAECa3yAI+SHIAI+UAcAMAKCa3yAO+SHcAc+U+S+S+R+VHO+U+SHN+L9DBBB9P9d9FQBAN+oRESFMCUUUU94REMAGAE87FBGXGX9DBBB8/9DBBB+/Ac9DBBBB9gyAcAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMALAG87FBGXGX9DBBB8/9DBBB+/AI9DBBBB9gyAIAO+U+SHN+L9DBBB9P9d9FQBAN+oRGSFMCUUUU94RGMABAG87FBABCNJRBAFCaJHFQBMMM/SEIEaE99EaF99GXAF9FQBCBREABRIEXGXGX9D/zI818/AICKJ8uFBHLCEq+y+VHKAI8uFB+y+UHO9DB/+g6+U9DBBB8/9DBBB+/AO9DBBBB9gy+SHN+L9DBBB9P9d9FQBAN+oRVSFMCUUUU94RVMAICIJ8uFBRcAICGJ8uFBRMABALCFJCEZAEqCFWJAV87FBGXGXAKAM+y+UHN9DB/+g6+U9DBBB8/9DBBB+/AN9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRMSFMCUUUU94RMMABALCGJCEZAEqCFWJAM87FBGXGXAKAc+y+UHK9DB/+g6+U9DBBB8/9DBBB+/AK9DBBBB9gy+SHS+L9DBBB9P9d9FQBAS+oRcSFMCUUUU94RcMABALCaJCEZAEqCFWJAc87FBGXGX9DBBU8/AOAO+U+TANAN+U+TAKAK+U+THO9DBBBBAO9DBBBB9gy+R9DB/+g6+U9DBBB8/+SHO+L9DBBB9P9d9FQBAO+oRcSFMCUUUU94RcMABALCEZAEqCFWJAc87FBAICNJRIAECIJREAFCaJHFQBMMM9JBGXAGCGrAF9sHF9FQBEXABAB8oGBHGCNWCN91+yAGCi91CnWCUUU/8EJ+++U84GBABCIJRBAFCaJHFQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEM/lFFFaGXGXAFABqCEZ9FQBABRESFMGXGXAGCT9PQBABRESFMABREEXAEAF8oGBjGBAECIJAFCIJ8oGBjGBAECNJAFCNJ8oGBjGBAECSJAFCSJ8oGBjGBAECTJREAFCTJRFAGC9wJHGCb9LQBMMAGCI9JQBEXAEAF8oGBjGBAFCIJRFAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF2BB86BBAECFJREAFCFJRFAGCaJHGQBMMABMoFFGaGXGXABCEZ9FQBABRESFMAFCgFZC+BwsN9sRIGXGXAGCT9PQBABRESFMABREEXAEAIjGBAECSJAIjGBAECNJAIjGBAECIJAIjGBAECTJREAGC9wJHGCb9LQBMMAGCI9JQBEXAEAIjGBAECIJREAGC98JHGCE9LQBMMGXAG9FQBEXAEAF86BBAECFJREAGCaJHGQBMMABMMMFBCUNMIT9kBB",
        e = "B9h9z9tFBBBFiI9gBB9gLaaaaaFa9gEaaaB9gFaFaEMcBBFBFFGGGEILF9wFFFLEFBFKNFaFCx/aFMO/LFVK9tv9t9vq95GBt9f9f939h9z9t9f9j9h9s9s9f9jW9vq9zBBp9tv9z9o9v9wW9f9kv9j9v9kv9WvqWv94h919m9mvqBG8Z9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv94h919m9mvqBIy9tv9z9o9v9wW9f9kv9j9v9kv9J9u9kv949TvZ91v9u9jvBLn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9P9jWBKi9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9R919hWBOn9tv9z9o9v9wW9f9kv9j9v9kv69p9sWvq9F949wBNI9z9iqlBVc+N9IcIBTEM9+FLa8jUUUUBCTlRBCBRFEXCBRGCBREEXABCNJAGJAECUaAFAGrCFZHIy86BBAEAIJREAGCFJHGCN9HQBMAFCx+YUUBJAE86BBAFCEWCxkUUBJAB8pEN83EBAFCFJHFCUG9HQBMMk8lLbaE97F9+FaL978jUUUUBCU/KBlHL8kUUUUBC9+RKGXAGCFJAI9LQBCaRKAE2BBC+gF9HQBALAEAIJHOAGlAG/8cBBCUoBAG9uC/wgBZHKCUGAKCUG9JyRNAECFJRKCBRVGXEXAVAF9PQFANAFAVlAVANJAF9JyRcGXGXAG9FQBAcCbJHIC9wZHMCE9sRSAMCFWRQAICIrCEJCGrRfCBRbEXAKRTCBRtGXEXGXAOATlAf9PQBCBRKSLMALCU/CBJAtAM9sJRmATAfJRKCBREGXAMCoB9JQBAOAKlC/gB9JQBCBRIEXAmAIJREGXGXGXGXGXATAICKrJ2BBHYCEZfIBFGEBMAECBDtDMIBSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIBAKCTJRKMGXGXGXGXGXAYCGrCEZfIBFGEBMAECBDtDMITSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMITAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMITAKCTJRKMGXGXGXGXGXAYCIrCEZfIBFGEBMAECBDtDMIASEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIAAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAEAKDBBBDMIAAKCTJRKMGXGXGXGXGXAYCKrfIBFGEBMAECBDtDMI8wSEMAEAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCIJAeDeBJAYCx+YUUBJ2BBJRKSGMAEAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHYCEWCxkUUBJDBEBAYCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHYCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMI8wAKCNJAeDeBJAYCx+YUUBJ2BBJRKSFMAEAKDBBBDMI8wAKCTJRKMAICoBJREAICUFJAM9LQFAERIAOAKlC/fB9LQBMMGXAEAM9PQBAECErRIEXGXAOAKlCi9PQBCBRKSOMAmAEJRYGXGXGXGXGXATAECKrJ2BBAICKZrCEZfIBFGEBMAYCBDtDMIBSEMAYAKDBBIAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnHPCGD+MFAPDQBTFtGmEYIPLdKeOnC0+G+MiDtD9OHdCEDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCIJAeDeBJAiCx+YUUBJ2BBJRKSGMAYAKDBBNAKDBBBHPCID+MFAPDQBTFtGmEYIPLdKeOnC+P+e+8/4BDtD9OHdCbDbD8jHPAPDQBFGENVcMILKOSQfbHeD8dBh+BsxoxoUwN0AeD8dFhxoUwkwk+gUa0sHnhTkAnsHnhNkAnsHn7CgFZHiCEWCxkUUBJDBEBAiCx+YUUBJDBBBHeAeDQBBBBBBBBBBBBBBBBAnhAk7CgFZHiCEWCxkUUBJDBEBD9uDQBFGEILKOTtmYPdenDfAdAPD9SDMIBAKCNJAeDeBJAiCx+YUUBJ2BBJRKSFMAYAKDBBBDMIBAKCTJRKMAICGJRIAECTJHEAM9JQBMMGXAK9FQBAKRTAtCFJHtCI6QGSFMMCBRKSEMGXAM9FQBALCUGJAbJREALAbJDBGBReCBRYEXAEALCU/CBJAYJHIDBIBHdCFD9tAdCFDbHPD9OD9hD9RHdAIAMJDBIBH8ZCFD9tA8ZAPD9OD9hD9RH8ZDQBTFtGmEYIPLdKeOnHpAIAQJDBIBHyCFD9tAyAPD9OD9hD9RHyAIASJDBIBH8cCFD9tA8cAPD9OD9hD9RH8cDQBTFtGmEYIPLdKeOnH8dDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGEAeD9uHeDyBjGBAEAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeApA8dDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNiV8ZcpMyS8cQ8df8eb8fHdAyA8cDQNiV8ZcpMyS8cQ8df8eb8fH8ZDQBFTtGEmYILPdKOenHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJHIAeAdA8ZDQNVi8ZcMpySQ8c8dfb8e8fHPAPDQBFGEBFGEBFGEBFGED9uHeDyBjGBAIAGJHIAeAPAPDQILKOILKOILKOILKOD9uHeDyBjGBAIAGJHIAeAPAPDQNVcMNVcMNVcMNVcMD9uHeDyBjGBAIAGJHIAeAPAPDQSQfbSQfbSQfbSQfbD9uHeDyBjGBAIAGJREAYCTJHYAM9JQBMMAbCIJHbAG9JQBMMABAVAG9sJALCUGJAcAG9s/8cBBALALCUGJAcCaJAG9sJAG/8cBBMAcCBAKyAVJRVAKQBMC9+RKSFMCBC99AOAKlAGCAAGCA9Ly6yRKMALCU/KBJ8kUUUUBAKMNBT+BUUUBM+KmFTa8jUUUUBCoFlHL8kUUUUBC9+RKGXAFCE9uHOCtJAI9LQBCaRKAE2BBHNC/wFZC/gF9HQBANCbZHVCF9LQBALCoBJCgFCUF/8MBALC84Jha83EBALC8wJha83EBALC8oJha83EBALCAJha83EBALCiJha83EBALCTJha83EBALha83ENALha83EBAEAIJC9wJRcAECFJHNAOJRMGXAF9FQBCQCbAVCF6yRSABRECBRVCBRQCBRfCBRICBRKEXGXAMAcuQBC9+RKSEMGXGXAN2BBHOC/vF9LQBALCoBJAOCIrCa9zAKJCbZCEWJHb8oGIRTAb8oGBRtGXAOCbZHbAS9PQBALAOCa9zAIJCbZCGWJ8oGBAVAbyROAb9FRbGXGXAGCG9HQBABAt87FBABCIJAO87FBABCGJAT87FBSFMAEAtjGBAECNJAOjGBAECIJATjGBMAVAbJRVALCoBJAKCEWJHmAOjGBAmATjGIALAICGWJAOjGBALCoBJAKCFJCbZHKCEWJHTAtjGBATAOjGIAIAbJRIAKCFJRKSGMGXGXAbCb6QBAQAbJAbC989zJCFJRQSFMAM1BBHbCgFZROGXGXAbCa9MQBAMCFJRMSFMAM1BFHbCgBZCOWAOCgBZqROGXAbCa9MQBAMCGJRMSFMAM1BGHbCgBZCfWAOqROGXAbCa9MQBAMCEJRMSFMAM1BEHbCgBZCdWAOqROGXAbCa9MQBAMCIJRMSFMAM2BIC8cWAOqROAMCLJRMMAOCFrCBAOCFZl9zAQJRQMGXGXAGCG9HQBABAt87FBABCIJAQ87FBABCGJAT87FBSFMAEAtjGBAECNJAQjGBAECIJATjGBMALCoBJAKCEWJHOAQjGBAOATjGIALAICGWJAQjGBALCoBJAKCFJCbZHKCEWJHOAtjGBAOAQjGIAICFJRIAKCFJRKSFMGXAOCDF9LQBALAIAcAOCbZJ2BBHbCIrHTlCbZCGWJ8oGBAVCFJHtATyROALAIAblCbZCGWJ8oGBAtAT9FHmJHtAbCbZHTyRbAT9FRTGXGXAGCG9HQBABAV87FBABCIJAb87FBABCGJAO87FBSFMAEAVjGBAECNJAbjGBAECIJAOjGBMALAICGWJAVjGBALCoBJAKCEWJHYAOjGBAYAVjGIALAICFJHICbZCGWJAOjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAIAmJCbZHICGWJAbjGBALCoBJAKCGJCbZHKCEWJHOAVjGBAOAbjGIAKCFJRKAIATJRIAtATJRVSFMAVCBAM2BBHYyHTAOC/+F6HPJROAYCbZRtGXGXAYCIrHmQBAOCFJRbSFMAORbALAIAmlCbZCGWJ8oGBROMGXGXAtQBAbCFJRVSFMAbRVALAIAYlCbZCGWJ8oGBRbMGXGXAP9FQBAMCFJRYSFMAM1BFHYCgFZRTGXGXAYCa9MQBAMCGJRYSFMAM1BGHYCgBZCOWATCgBZqRTGXAYCa9MQBAMCEJRYSFMAM1BEHYCgBZCfWATqRTGXAYCa9MQBAMCIJRYSFMAM1BIHYCgBZCdWATqRTGXAYCa9MQBAMCLJRYSFMAMCKJRYAM2BLC8cWATqRTMATCFrCBATCFZl9zAQJHQRTMGXGXAmCb6QBAYRPSFMAY1BBHMCgFZROGXGXAMCa9MQBAYCFJRPSFMAY1BFHMCgBZCOWAOCgBZqROGXAMCa9MQBAYCGJRPSFMAY1BGHMCgBZCfWAOqROGXAMCa9MQBAYCEJRPSFMAY1BEHMCgBZCdWAOqROGXAMCa9MQBAYCIJRPSFMAYCLJRPAY2BIC8cWAOqROMAOCFrCBAOCFZl9zAQJHQROMGXGXAtCb6QBAPRMSFMAP1BBHMCgFZRbGXGXAMCa9MQBAPCFJRMSFMAP1BFHMCgBZCOWAbCgBZqRbGXAMCa9MQBAPCGJRMSFMAP1BGHMCgBZCfWAbqRbGXAMCa9MQBAPCEJRMSFMAP1BEHMCgBZCdWAbqRbGXAMCa9MQBAPCIJRMSFMAPCLJRMAP2BIC8cWAbqRbMAbCFrCBAbCFZl9zAQJHQRbMGXGXAGCG9HQBABAT87FBABCIJAb87FBABCGJAO87FBSFMAEATjGBAECNJAbjGBAECIJAOjGBMALCoBJAKCEWJHYAOjGBAYATjGIALAICGWJATjGBALCoBJAKCFJCbZCEWJHYAbjGBAYAOjGIALAICFJHICbZCGWJAOjGBALCoBJAKCGJCbZCEWJHOATjGBAOAbjGIALAIAm9FAmCb6qJHICbZCGWJAbjGBAIAt9FAtCb6qJRIAKCEJRKMANCFJRNABCKJRBAECSJREAKCbZRKAICbZRIAfCEJHfAF9JQBMMCBC99AMAc6yRKMALCoFJ8kUUUUBAKM/tIFGa8jUUUUBCTlRLC9+RKGXAFCLJAI9LQBCaRKAE2BBC/+FZC/QF9HQBALhB83ENAECFJRKAEAIJC98JREGXAF9FQBGXAGCG6QBEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMALCNJAICFZCGWqHGAICGrCBAICFrCFZl9zAG8oGBJHIjGBABAIjGBABCIJRBAFCaJHFQBSGMMEXGXAKAE9JQBC9+bMAK1BBHGCgFZRIGXGXAGCa9MQBAKCFJRKSFMAK1BFHGCgBZCOWAICgBZqRIGXAGCa9MQBAKCGJRKSFMAK1BGHGCgBZCfWAIqRIGXAGCa9MQBAKCEJRKSFMAK1BEHGCgBZCdWAIqRIGXAGCa9MQBAKCIJRKSFMAK2BIC8cWAIqRIAKCLJRKMABAICGrCBAICFrCFZl9zALCNJAICFZCGWqHI8oGBJHG87FBAIAGjGBABCGJRBAFCaJHFQBMMCBC99AKAE6yRKMAKM/dLEK97FaF97GXGXAGCI9HQBAF9FQFCBRGEXABABDBBBHECiD+rFCiD+sFD/6FHIAECND+rFCiD+sFD/6FAID/gFAECTD+rFCiD+sFD/6FHLD/gFD/kFD/lFHKCBDtD+2FHOAICUUUU94DtHND9OD9RD/kFHI9DBB/+hDYAIAID/mFAKAKD/mFALAOALAND9OD9RD/kFHIAID/mFD/kFD/kFD/jFD/nFHLD/mF9DBBX9LDYHOD/kFCgFDtD9OAECUUU94DtD9OD9QAIALD/mFAOD/kFCND+rFCU/+EDtD9OD9QAKALD/mFAOD/kFCTD+rFCUU/8ODtD9OD9QDMBBABCTJRBAGCIJHGAF9JQBSGMMAF9FQBCBRGEXABCTJHVAVDBBBHECBDtHOCUU98D8cFCUU98D8cEHND9OABDBBBHKAEDQILKOSQfbPden8c8d8e8fCggFDtD9OD/6FAKAEDQBFGENVcMTtmYi8ZpyHECTD+sFD/6FHID/gFAECTD+rFCTD+sFD/6FHLD/gFD/kFD/lFHE9DB/+g6DYALAEAOD+2FHOALCUUUU94DtHcD9OD9RD/kFHLALD/mFAEAED/mFAIAOAIAcD9OD9RD/kFHEAED/mFD/kFD/kFD/jFD/nFHID/mF9DBBX9LDYHOD/kFCTD+rFALAID/mFAOD/kFCggEDtD9OD9QHLAEAID/mFAOD/kFCaDbCBDnGCBDnECBDnKCBDnOCBDncCBDnMCBDnfCBDnbD9OHEDQNVi8ZcMpySQ8c8dfb8e8fD9QDMBBABAKAND9OALAEDQBFTtGEmYILPdKOenD9QDMBBABCAJRBAGCIJHGAF9JQBMMM/hEIGaF97FaL978jUUUUBCTlREGXAF9FQBCBRIEXAEABDBBBHLABCTJHKDBBBHODQILKOSQfbPden8c8d8e8fHNCTD+sFHVCID+rFDMIBAB9DBBU8/DY9D/zI818/DYAVCEDtD9QD/6FD/nFHVALAODQBFGENVcMTtmYi8ZpyHLCTD+rFCTD+sFD/6FD/mFHOAOD/mFAVALCTD+sFD/6FD/mFHcAcD/mFAVANCTD+rFCTD+sFD/6FD/mFHNAND/mFD/kFD/kFD/lFCBDtD+4FD/jF9DB/+g6DYHVD/mF9DBBX9LDYHLD/kFCggEDtHMD9OAcAVD/mFALD/kFCTD+rFD9QHcANAVD/mFALD/kFCTD+rFAOAVD/mFALD/kFAMD9OD9QHVDQBFTtGEmYILPdKOenHLD8dBAEDBIBDyB+t+J83EBABCNJALD8dFAEDBIBDyF+t+J83EBAKAcAVDQNVi8ZcMpySQ8c8dfb8e8fHVD8dBAEDBIBDyG+t+J83EBABCiJAVD8dFAEDBIBDyE+t+J83EBABCAJRBAICIJHIAF9JQBMMM9jFF97GXAGCGrAF9sHG9FQBCBRFEXABABDBBBHECND+rFCND+sFD/6FAECiD+sFCnD+rFCUUU/8EDtD+uFD/mFDMBBABCTJRBAFCIJHFAG9JQBMMM9TFEaCBCB8oGUkUUBHFABCEJC98ZJHBjGUkUUBGXGXAB8/BCTWHGuQBCaREABAGlCggEJCTrXBCa6QFMAFREMAEMMMFBCUNMIT9tBB",
        t = new Uint8Array([0, 97, 115, 109, 1, 0, 0, 0, 1, 4, 1, 96, 0, 0, 3, 3, 2, 0, 0, 5, 3, 1, 0, 1, 12, 1, 0, 10, 22, 2, 12, 0, 65, 0, 65, 0, 65, 0, 252, 10, 0, 0, 11, 7, 0, 65, 0, 253, 15, 26, 11]),
        n = new Uint8Array([32, 0, 65, 253, 3, 1, 2, 34, 4, 106, 6, 5, 11, 8, 7, 20, 13, 33, 12, 16, 128, 9, 116, 64, 19, 113, 127, 15, 10, 21, 22, 14, 255, 66, 24, 54, 136, 107, 18, 23, 192, 26, 114, 118, 132, 17, 77, 101, 130, 144, 27, 87, 131, 44, 45, 74, 156, 154, 70, 167]);
    if (typeof WebAssembly != "object") return {
        supported: !1
    };
    let i = r;
    WebAssembly.validate(t) && (i = e);
    let s;
    const o = WebAssembly.instantiate(a(i), {}).then(f => {
        s = f.instance, s.exports.__wasm_call_ctors()
    });

    function a(f) {
        const d = new Uint8Array(f.length);
        for (let g = 0; g < f.length; ++g) {
            const y = f.charCodeAt(g);
            d[g] = y > 96 ? y - 71 : y > 64 ? y - 65 : y > 47 ? y + 4 : y > 46 ? 63 : 62
        }
        let m = 0;
        for (let g = 0; g < f.length; ++g) d[m++] = d[g] < 60 ? n[d[g]] : (d[g] - 60) * 64 + d[++g];
        return d.buffer.slice(0, m)
    }

    function l(f, d, m, g, y, v) {
        const _ = s.exports.sbrk,
            A = m + 3 & -4,
            S = _(A * g),
            M = _(y.length),
            C = new Uint8Array(s.exports.memory.buffer);
        C.set(y, M);
        const E = f(S, m, g, M, y.length);
        if (E === 0 && v && v(S, A, g), d.set(C.subarray(S, S + m * g)), _(S - _(0)), E !== 0) throw new Error(`Malformed buffer data: ${E}`)
    }
    const c = {
            0: "",
            1: "meshopt_decodeFilterOct",
            2: "meshopt_decodeFilterQuat",
            3: "meshopt_decodeFilterExp",
            NONE: "",
            OCTAHEDRAL: "meshopt_decodeFilterOct",
            QUATERNION: "meshopt_decodeFilterQuat",
            EXPONENTIAL: "meshopt_decodeFilterExp"
        },
        u = {
            0: "meshopt_decodeVertexBuffer",
            1: "meshopt_decodeIndexBuffer",
            2: "meshopt_decodeIndexSequence",
            ATTRIBUTES: "meshopt_decodeVertexBuffer",
            TRIANGLES: "meshopt_decodeIndexBuffer",
            INDICES: "meshopt_decodeIndexSequence"
        };
    return c0 = {
        ready: o,
        supported: !0,
        decodeVertexBuffer(f, d, m, g, y) {
            l(s.exports.meshopt_decodeVertexBuffer, f, d, m, g, s.exports[c[y]])
        },
        decodeIndexBuffer(f, d, m, g) {
            l(s.exports.meshopt_decodeIndexBuffer, f, d, m, g)
        },
        decodeIndexSequence(f, d, m, g) {
            l(s.exports.meshopt_decodeIndexSequence, f, d, m, g)
        },
        decodeGltfBuffer(f, d, m, g, y, v) {
            l(s.exports[u[y]], f, d, m, g, s.exports[c[v]])
        }
    }, c0
};

function v9() {
    var r = Object.create(null);

    function e(i, s) {
        var o = i.id,
            a = i.name,
            l = i.dependencies;
        l === void 0 && (l = []);
        var c = i.init;
        c === void 0 && (c = function() {});
        var u = i.getTransferables;
        if (u === void 0 && (u = null), !r[o]) try {
            l = l.map(function(d) {
                return d && d.isWorkerModule && (e(d, function(m) {
                    if (m instanceof Error) throw m
                }), d = r[d.id].value), d
            }), c = n("<" + a + ">.init", c), u && (u = n("<" + a + ">.getTransferables", u));
            var f = null;
            typeof c == "function" ? f = c.apply(void 0, l) : console.error("worker module init function failed to rehydrate"), r[o] = {
                id: o,
                value: f,
                getTransferables: u
            }, s(f)
        } catch (d) {
            d && d.noLog || console.error(d), s(d)
        }
    }

    function t(i, s) {
        var o, a = i.id,
            l = i.args;
        (!r[a] || typeof r[a].value != "function") && s(new Error("Worker module " + a + ": not found or its 'init' did not return a function"));
        try {
            var c = (o = r[a]).value.apply(o, l);
            c && typeof c.then == "function" ? c.then(u, function(f) {
                return s(f instanceof Error ? f : new Error("" + f))
            }) : u(c)
        } catch (f) {
            s(f)
        }

        function u(f) {
            try {
                var d = r[a].getTransferables && r[a].getTransferables(f);
                (!d || !Array.isArray(d) || !d.length) && (d = void 0), s(f, d)
            } catch (m) {
                console.error(m), s(m)
            }
        }
    }

    function n(i, s) {
        var o = void 0;
        self.troikaDefine = function(l) {
            return o = l
        };
        var a = URL.createObjectURL(new Blob(["/** " + i.replace(/\*/g, "") + ` **/

troikaDefine(
` + s + `
)`], {
            type: "application/javascript"
        }));
        try {
            importScripts(a)
        } catch (l) {
            console.error(l)
        }
        return URL.revokeObjectURL(a), delete self.troikaDefine, o
    }
    self.addEventListener("message", function(i) {
        var s = i.data,
            o = s.messageId,
            a = s.action,
            l = s.data;
        try {
            a === "registerModule" && e(l, function(c) {
                c instanceof Error ? postMessage({
                    messageId: o,
                    success: !1,
                    error: c.message
                }) : postMessage({
                    messageId: o,
                    success: !0,
                    result: {
                        isCallable: typeof c == "function"
                    }
                })
            }), a === "callModule" && t(l, function(c, u) {
                c instanceof Error ? postMessage({
                    messageId: o,
                    success: !1,
                    error: c.message
                }) : postMessage({
                    messageId: o,
                    success: !0,
                    result: c
                }, u || void 0)
            })
        } catch (c) {
            postMessage({
                messageId: o,
                success: !1,
                error: c.stack
            })
        }
    })
}

function y9(r) {
    var e = function() {
        for (var t = [], n = arguments.length; n--;) t[n] = arguments[n];
        return e._getInitResult().then(function(i) {
            if (typeof i == "function") return i.apply(void 0, t);
            throw new Error("Worker module function was called but `init` did not return a callable function")
        })
    };
    return e._getInitResult = function() {
        var t = r.dependencies,
            n = r.init;
        t = Array.isArray(t) ? t.map(function(s) {
            return s && (s = s.onMainThread || s, s._getInitResult && (s = s._getInitResult())), s
        }) : [];
        var i = Promise.all(t).then(function(s) {
            return n.apply(null, s)
        });
        return e._getInitResult = function() {
            return i
        }, i
    }, e
}
var ND = function() {
        var r = !1;
        if (typeof window < "u" && typeof window.document < "u") try {
            var e = new Worker(URL.createObjectURL(new Blob([""], {
                type: "application/javascript"
            })));
            e.terminate(), r = !0
        } catch (t) {
            typeof process < "u", console.log("Troika createWorkerModule: web workers not allowed; falling back to main thread execution. Cause: [" + t.message + "]")
        }
        return ND = function() {
            return r
        }, r
    },
    _9 = 0,
    x9 = 0,
    l1 = !1,
    qd = Object.create(null),
    Zd = Object.create(null),
    BA = Object.create(null);

function hh(r) {
    if ((!r || typeof r.init != "function") && !l1) throw new Error("requires `options.init` function");
    var e = r.dependencies,
        t = r.init,
        n = r.getTransferables,
        i = r.workerId,
        s = y9(r);
    i == null && (i = "#default");
    var o = "workerModule" + ++_9,
        a = r.name || o,
        l = null;
    e = e && e.map(function(u) {
        return typeof u == "function" && !u.workerModuleData && (l1 = !0, u = hh({
            workerId: i,
            name: "<" + a + "> function dependency: " + u.name,
            init: `function(){return (
` + D0(u) + `
)}`
        }), l1 = !1), u && u.workerModuleData && (u = u.workerModuleData), u
    });

    function c() {
        for (var u = [], f = arguments.length; f--;) u[f] = arguments[f];
        if (!ND()) return s.apply(void 0, u);
        if (!l) {
            l = XC(i, "registerModule", c.workerModuleData);
            var d = function() {
                l = null, Zd[i].delete(d)
            };
            (Zd[i] || (Zd[i] = new Set)).add(d)
        }
        return l.then(function(m) {
            var g = m.isCallable;
            if (g) return XC(i, "callModule", {
                id: o,
                args: u
            });
            throw new Error("Worker module function was called but `init` did not return a callable function")
        })
    }
    return c.workerModuleData = {
        isWorkerModule: !0,
        id: o,
        name: a,
        dependencies: e,
        init: D0(t),
        getTransferables: n && D0(n)
    }, c.onMainThread = s, c
}

function A9(r) {
    Zd[r] && Zd[r].forEach(function(e) {
        e()
    }), qd[r] && (qd[r].terminate(), delete qd[r])
}

function D0(r) {
    var e = r.toString();
    return !/^function/.test(e) && /^\w+\s*\(/.test(e) && (e = "function " + e), e
}

function S9(r) {
    var e = qd[r];
    if (!e) {
        var t = D0(v9);
        e = qd[r] = new Worker(URL.createObjectURL(new Blob(["/** Worker Module Bootstrap: " + r.replace(/\*/g, "") + ` **/

;(` + t + ")()"], {
            type: "application/javascript"
        }))), e.onmessage = function(n) {
            var i = n.data,
                s = i.messageId,
                o = BA[s];
            if (!o) throw new Error("WorkerModule response with empty or unknown messageId");
            delete BA[s], o(i)
        }
    }
    return e
}

function XC(r, e, t) {
    return new Promise(function(n, i) {
        var s = ++x9;
        BA[s] = function(o) {
            o.success ? n(o.result) : i(new Error("Error in worker " + e + " call: " + o.error))
        }, S9(r).postMessage({
            messageId: s,
            action: e,
            data: t
        })
    })
}

function kD() {
    var r = function(e) {
        function t(Z, U, j, te, he, $, ne, me) {
            var ce = 1 - ne;
            me.x = ce * ce * Z + 2 * ce * ne * j + ne * ne * he, me.y = ce * ce * U + 2 * ce * ne * te + ne * ne * $
        }

        function n(Z, U, j, te, he, $, ne, me, ce, _e) {
            var Oe = 1 - ce;
            _e.x = Oe * Oe * Oe * Z + 3 * Oe * Oe * ce * j + 3 * Oe * ce * ce * he + ce * ce * ce * ne, _e.y = Oe * Oe * Oe * U + 3 * Oe * Oe * ce * te + 3 * Oe * ce * ce * $ + ce * ce * ce * me
        }

        function i(Z, U) {
            for (var j = /([MLQCZ])([^MLQCZ]*)/g, te, he, $, ne, me; te = j.exec(Z);) {
                var ce = te[2].replace(/^\s*|\s*$/g, "").split(/[,\s]+/).map(function(_e) {
                    return parseFloat(_e)
                });
                switch (te[1]) {
                    case "M":
                        ne = he = ce[0], me = $ = ce[1];
                        break;
                    case "L":
                        (ce[0] !== ne || ce[1] !== me) && U("L", ne, me, ne = ce[0], me = ce[1]);
                        break;
                    case "Q":
                        {
                            U("Q", ne, me, ne = ce[2], me = ce[3], ce[0], ce[1]);
                            break
                        }
                    case "C":
                        {
                            U("C", ne, me, ne = ce[4], me = ce[5], ce[0], ce[1], ce[2], ce[3]);
                            break
                        }
                    case "Z":
                        (ne !== he || me !== $) && U("L", ne, me, he, $);
                        break
                }
            }
        }

        function s(Z, U, j) {
            j === void 0 && (j = 16);
            var te = {
                x: 0,
                y: 0
            };
            i(Z, function(he, $, ne, me, ce, _e, Oe, ke, Ee) {
                switch (he) {
                    case "L":
                        U($, ne, me, ce);
                        break;
                    case "Q":
                        {
                            for (var pe = $, xe = ne, J = 1; J < j; J++) t($, ne, _e, Oe, me, ce, J / (j - 1), te),
                            U(pe, xe, te.x, te.y),
                            pe = te.x,
                            xe = te.y;
                            break
                        }
                    case "C":
                        {
                            for (var De = $, Ce = ne, se = 1; se < j; se++) n($, ne, _e, Oe, ke, Ee, me, ce, se / (j - 1), te),
                            U(De, Ce, te.x, te.y),
                            De = te.x,
                            Ce = te.y;
                            break
                        }
                }
            })
        }
        var o = "precision highp float;attribute vec2 aUV;varying vec2 vUV;void main(){vUV=aUV;gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
            a = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){gl_FragColor=texture2D(tex,vUV);}",
            l = new WeakMap,
            c = {
                premultipliedAlpha: !1,
                preserveDrawingBuffer: !0,
                antialias: !1,
                depth: !1
            };

        function u(Z, U) {
            var j = Z.getContext ? Z.getContext("webgl", c) : Z,
                te = l.get(j);
            if (!te) {
                let Oe = function(De) {
                        var Ce = $[De];
                        if (!Ce && (Ce = $[De] = j.getExtension(De), !Ce)) throw new Error(De + " not supported");
                        return Ce
                    },
                    ke = function(De, Ce) {
                        var se = j.createShader(Ce);
                        return j.shaderSource(se, De), j.compileShader(se), se
                    },
                    Ee = function(De, Ce, se, Se) {
                        if (!ne[De]) {
                            var Xe = {},
                                Le = {},
                                k = j.createProgram();
                            j.attachShader(k, ke(Ce, j.VERTEX_SHADER)), j.attachShader(k, ke(se, j.FRAGMENT_SHADER)), j.linkProgram(k), ne[De] = {
                                program: k,
                                transaction: function(ue) {
                                    j.useProgram(k), ue({
                                        setUniform: function(ge, Re) {
                                            for (var Be = [], Fe = arguments.length - 2; Fe-- > 0;) Be[Fe] = arguments[Fe + 2];
                                            var Ne = Le[Re] || (Le[Re] = j.getUniformLocation(k, Re));
                                            j["uniform" + ge].apply(j, [Ne].concat(Be))
                                        },
                                        setAttribute: function(ge, Re, Be, Fe, Ne) {
                                            var ot = Xe[ge];
                                            ot || (ot = Xe[ge] = {
                                                buf: j.createBuffer(),
                                                loc: j.getAttribLocation(k, ge),
                                                data: null
                                            }), j.bindBuffer(j.ARRAY_BUFFER, ot.buf), j.vertexAttribPointer(ot.loc, Re, j.FLOAT, !1, 0, 0), j.enableVertexAttribArray(ot.loc), he ? j.vertexAttribDivisor(ot.loc, Fe) : Oe("ANGLE_instanced_arrays").vertexAttribDivisorANGLE(ot.loc, Fe), Ne !== ot.data && (j.bufferData(j.ARRAY_BUFFER, Ne, Be), ot.data = Ne)
                                        }
                                    })
                                }
                            }
                        }
                        ne[De].transaction(Se)
                    },
                    pe = function(De, Ce) {
                        ce++;
                        try {
                            j.activeTexture(j.TEXTURE0 + ce);
                            var se = me[De];
                            se || (se = me[De] = j.createTexture(), j.bindTexture(j.TEXTURE_2D, se), j.texParameteri(j.TEXTURE_2D, j.TEXTURE_MIN_FILTER, j.NEAREST), j.texParameteri(j.TEXTURE_2D, j.TEXTURE_MAG_FILTER, j.NEAREST)), j.bindTexture(j.TEXTURE_2D, se), Ce(se, ce)
                        } finally {
                            ce--
                        }
                    },
                    xe = function(De, Ce, se) {
                        var Se = j.createFramebuffer();
                        _e.push(Se), j.bindFramebuffer(j.FRAMEBUFFER, Se), j.activeTexture(j.TEXTURE0 + Ce), j.bindTexture(j.TEXTURE_2D, De), j.framebufferTexture2D(j.FRAMEBUFFER, j.COLOR_ATTACHMENT0, j.TEXTURE_2D, De, 0);
                        try {
                            se(Se)
                        } finally {
                            j.deleteFramebuffer(Se), j.bindFramebuffer(j.FRAMEBUFFER, _e[--_e.length - 1] || null)
                        }
                    },
                    J = function() {
                        $ = {}, ne = {}, me = {}, ce = -1, _e.length = 0
                    };
                var he = typeof WebGL2RenderingContext < "u" && j instanceof WebGL2RenderingContext,
                    $ = {},
                    ne = {},
                    me = {},
                    ce = -1,
                    _e = [];
                j.canvas.addEventListener("webglcontextlost", function(De) {
                    J(), De.preventDefault()
                }, !1), l.set(j, te = {
                    gl: j,
                    isWebGL2: he,
                    getExtension: Oe,
                    withProgram: Ee,
                    withTexture: pe,
                    withTextureFramebuffer: xe,
                    handleContextLoss: J
                })
            }
            U(te)
        }

        function f(Z, U, j, te, he, $, ne, me) {
            ne === void 0 && (ne = 15), me === void 0 && (me = null), u(Z, function(ce) {
                var _e = ce.gl,
                    Oe = ce.withProgram,
                    ke = ce.withTexture;
                ke("copy", function(Ee, pe) {
                    _e.texImage2D(_e.TEXTURE_2D, 0, _e.RGBA, he, $, 0, _e.RGBA, _e.UNSIGNED_BYTE, U), Oe("copy", o, a, function(xe) {
                        var J = xe.setUniform,
                            De = xe.setAttribute;
                        De("aUV", 2, _e.STATIC_DRAW, 0, new Float32Array([0, 0, 2, 0, 0, 2])), J("1i", "image", pe), _e.bindFramebuffer(_e.FRAMEBUFFER, me || null), _e.disable(_e.BLEND), _e.colorMask(ne & 8, ne & 4, ne & 2, ne & 1), _e.viewport(j, te, he, $), _e.scissor(j, te, he, $), _e.drawArrays(_e.TRIANGLES, 0, 3)
                    })
                })
            })
        }

        function d(Z, U, j) {
            var te = Z.width,
                he = Z.height;
            u(Z, function($) {
                var ne = $.gl,
                    me = new Uint8Array(te * he * 4);
                ne.readPixels(0, 0, te, he, ne.RGBA, ne.UNSIGNED_BYTE, me), Z.width = U, Z.height = j, f(ne, me, 0, 0, te, he)
            })
        }
        var m = Object.freeze({
            __proto__: null,
            withWebGLContext: u,
            renderImageData: f,
            resizeWebGLCanvasWithoutClearing: d
        });

        function g(Z, U, j, te, he, $) {
            $ === void 0 && ($ = 1);
            var ne = new Uint8Array(Z * U),
                me = te[2] - te[0],
                ce = te[3] - te[1],
                _e = [];
            s(j, function(De, Ce, se, Se) {
                _e.push({
                    x1: De,
                    y1: Ce,
                    x2: se,
                    y2: Se,
                    minX: Math.min(De, se),
                    minY: Math.min(Ce, Se),
                    maxX: Math.max(De, se),
                    maxY: Math.max(Ce, Se)
                })
            }), _e.sort(function(De, Ce) {
                return De.maxX - Ce.maxX
            });
            for (var Oe = 0; Oe < Z; Oe++)
                for (var ke = 0; ke < U; ke++) {
                    var Ee = xe(te[0] + me * (Oe + .5) / Z, te[1] + ce * (ke + .5) / U),
                        pe = Math.pow(1 - Math.abs(Ee) / he, $) / 2;
                    Ee < 0 && (pe = 1 - pe), pe = Math.max(0, Math.min(255, Math.round(pe * 255))), ne[ke * Z + Oe] = pe
                }
            return ne;

            function xe(De, Ce) {
                for (var se = 1 / 0, Se = 1 / 0, Xe = _e.length; Xe--;) {
                    var Le = _e[Xe];
                    if (Le.maxX + Se <= De) break;
                    if (De + Se > Le.minX && Ce - Se < Le.maxY && Ce + Se > Le.minY) {
                        var k = _(De, Ce, Le.x1, Le.y1, Le.x2, Le.y2);
                        k < se && (se = k, Se = Math.sqrt(se))
                    }
                }
                return J(De, Ce) && (Se = -Se), Se
            }

            function J(De, Ce) {
                for (var se = 0, Se = _e.length; Se--;) {
                    var Xe = _e[Se];
                    if (Xe.maxX <= De) break;
                    var Le = Xe.y1 > Ce != Xe.y2 > Ce && De < (Xe.x2 - Xe.x1) * (Ce - Xe.y1) / (Xe.y2 - Xe.y1) + Xe.x1;
                    Le && (se += Xe.y1 < Xe.y2 ? 1 : -1)
                }
                return se !== 0
            }
        }

        function y(Z, U, j, te, he, $, ne, me, ce, _e) {
            $ === void 0 && ($ = 1), me === void 0 && (me = 0), ce === void 0 && (ce = 0), _e === void 0 && (_e = 0), v(Z, U, j, te, he, $, ne, null, me, ce, _e)
        }

        function v(Z, U, j, te, he, $, ne, me, ce, _e, Oe) {
            $ === void 0 && ($ = 1), ce === void 0 && (ce = 0), _e === void 0 && (_e = 0), Oe === void 0 && (Oe = 0);
            for (var ke = g(Z, U, j, te, he, $), Ee = new Uint8Array(ke.length * 4), pe = 0; pe < ke.length; pe++) Ee[pe * 4 + Oe] = ke[pe];
            f(ne, Ee, ce, _e, Z, U, 1 << 3 - Oe, me)
        }

        function _(Z, U, j, te, he, $) {
            var ne = he - j,
                me = $ - te,
                ce = ne * ne + me * me,
                _e = ce ? Math.max(0, Math.min(1, ((Z - j) * ne + (U - te) * me) / ce)) : 0,
                Oe = Z - (j + _e * ne),
                ke = U - (te + _e * me);
            return Oe * Oe + ke * ke
        }
        var A = Object.freeze({
                __proto__: null,
                generate: g,
                generateIntoCanvas: y,
                generateIntoFramebuffer: v
            }),
            S = "precision highp float;uniform vec4 uGlyphBounds;attribute vec2 aUV;attribute vec4 aLineSegment;varying vec4 vLineSegment;varying vec2 vGlyphXY;void main(){vLineSegment=aLineSegment;vGlyphXY=mix(uGlyphBounds.xy,uGlyphBounds.zw,aUV);gl_Position=vec4(mix(vec2(-1.0),vec2(1.0),aUV),0.0,1.0);}",
            M = "precision highp float;uniform vec4 uGlyphBounds;uniform float uMaxDistance;uniform float uExponent;varying vec4 vLineSegment;varying vec2 vGlyphXY;float absDistToSegment(vec2 point,vec2 lineA,vec2 lineB){vec2 lineDir=lineB-lineA;float lenSq=dot(lineDir,lineDir);float t=lenSq==0.0 ? 0.0 : clamp(dot(point-lineA,lineDir)/lenSq,0.0,1.0);vec2 linePt=lineA+t*lineDir;return distance(point,linePt);}void main(){vec4 seg=vLineSegment;vec2 p=vGlyphXY;float dist=absDistToSegment(p,seg.xy,seg.zw);float val=pow(1.0-clamp(dist/uMaxDistance,0.0,1.0),uExponent)*0.5;bool crossing=(seg.y>p.y!=seg.w>p.y)&&(p.x<(seg.z-seg.x)*(p.y-seg.y)/(seg.w-seg.y)+seg.x);bool crossingUp=crossing&&vLineSegment.y<vLineSegment.w;gl_FragColor=vec4(crossingUp ? 1.0/255.0 : 0.0,crossing&&!crossingUp ? 1.0/255.0 : 0.0,0.0,val);}",
            C = "precision highp float;uniform sampler2D tex;varying vec2 vUV;void main(){vec4 color=texture2D(tex,vUV);bool inside=color.r!=color.g;float val=inside ? 1.0-color.a : color.a;gl_FragColor=vec4(val);}",
            E = new Float32Array([0, 0, 2, 0, 0, 2]),
            R = null,
            P = !1,
            b = {},
            T = new WeakMap;

        function L(Z) {
            if (!P && !q(Z)) throw new Error("WebGL generation not supported")
        }

        function D(Z, U, j, te, he, $, ne) {
            if ($ === void 0 && ($ = 1), ne === void 0 && (ne = null), !ne && (ne = R, !ne)) {
                var me = typeof OffscreenCanvas == "function" ? new OffscreenCanvas(1, 1) : typeof document < "u" ? document.createElement("canvas") : null;
                if (!me) throw new Error("OffscreenCanvas or DOM canvas not supported");
                ne = R = me.getContext("webgl", {
                    depth: !1
                })
            }
            L(ne);
            var ce = new Uint8Array(Z * U * 4);
            u(ne, function(Ee) {
                var pe = Ee.gl,
                    xe = Ee.withTexture,
                    J = Ee.withTextureFramebuffer;
                xe("readable", function(De, Ce) {
                    pe.texImage2D(pe.TEXTURE_2D, 0, pe.RGBA, Z, U, 0, pe.RGBA, pe.UNSIGNED_BYTE, null), J(De, Ce, function(se) {
                        H(Z, U, j, te, he, $, pe, se, 0, 0, 0), pe.readPixels(0, 0, Z, U, pe.RGBA, pe.UNSIGNED_BYTE, ce)
                    })
                })
            });
            for (var _e = new Uint8Array(Z * U), Oe = 0, ke = 0; Oe < ce.length; Oe += 4) _e[ke++] = ce[Oe];
            return _e
        }

        function V(Z, U, j, te, he, $, ne, me, ce, _e) {
            $ === void 0 && ($ = 1), me === void 0 && (me = 0), ce === void 0 && (ce = 0), _e === void 0 && (_e = 0), H(Z, U, j, te, he, $, ne, null, me, ce, _e)
        }

        function H(Z, U, j, te, he, $, ne, me, ce, _e, Oe) {
            $ === void 0 && ($ = 1), ce === void 0 && (ce = 0), _e === void 0 && (_e = 0), Oe === void 0 && (Oe = 0), L(ne);
            var ke = [];
            s(j, function(Ee, pe, xe, J) {
                ke.push(Ee, pe, xe, J)
            }), ke = new Float32Array(ke), u(ne, function(Ee) {
                var pe = Ee.gl,
                    xe = Ee.isWebGL2,
                    J = Ee.getExtension,
                    De = Ee.withProgram,
                    Ce = Ee.withTexture,
                    se = Ee.withTextureFramebuffer,
                    Se = Ee.handleContextLoss;
                if (Ce("rawDistances", function(Xe, Le) {
                        (Z !== Xe._lastWidth || U !== Xe._lastHeight) && pe.texImage2D(pe.TEXTURE_2D, 0, pe.RGBA, Xe._lastWidth = Z, Xe._lastHeight = U, 0, pe.RGBA, pe.UNSIGNED_BYTE, null), De("main", S, M, function(k) {
                            var z = k.setAttribute,
                                ue = k.setUniform,
                                ye = !xe && J("ANGLE_instanced_arrays"),
                                ge = !xe && J("EXT_blend_minmax");
                            z("aUV", 2, pe.STATIC_DRAW, 0, E), z("aLineSegment", 4, pe.DYNAMIC_DRAW, 1, ke), ue.apply(void 0, ["4f", "uGlyphBounds"].concat(te)), ue("1f", "uMaxDistance", he), ue("1f", "uExponent", $), se(Xe, Le, function(Re) {
                                pe.enable(pe.BLEND), pe.colorMask(!0, !0, !0, !0), pe.viewport(0, 0, Z, U), pe.scissor(0, 0, Z, U), pe.blendFunc(pe.ONE, pe.ONE), pe.blendEquationSeparate(pe.FUNC_ADD, xe ? pe.MAX : ge.MAX_EXT), pe.clear(pe.COLOR_BUFFER_BIT), xe ? pe.drawArraysInstanced(pe.TRIANGLES, 0, 3, ke.length / 4) : ye.drawArraysInstancedANGLE(pe.TRIANGLES, 0, 3, ke.length / 4)
                            })
                        }), De("post", o, C, function(k) {
                            k.setAttribute("aUV", 2, pe.STATIC_DRAW, 0, E), k.setUniform("1i", "tex", Le), pe.bindFramebuffer(pe.FRAMEBUFFER, me), pe.disable(pe.BLEND), pe.colorMask(Oe === 0, Oe === 1, Oe === 2, Oe === 3), pe.viewport(ce, _e, Z, U), pe.scissor(ce, _e, Z, U), pe.drawArrays(pe.TRIANGLES, 0, 3)
                        })
                    }), pe.isContextLost()) throw Se(), new Error("webgl context lost")
            })
        }

        function q(Z) {
            var U = !Z || Z === R ? b : Z.canvas || Z,
                j = T.get(U);
            if (j === void 0) {
                P = !0;
                var te = null;
                try {
                    var he = [97, 106, 97, 61, 99, 137, 118, 80, 80, 118, 137, 99, 61, 97, 106, 97],
                        $ = D(4, 4, "M8,8L16,8L24,24L16,24Z", [0, 0, 32, 32], 24, 1, Z);
                    j = $ && he.length === $.length && $.every(function(ne, me) {
                        return ne === he[me]
                    }), j || (te = "bad trial run results", console.info(he, $))
                } catch (ne) {
                    j = !1, te = ne.message
                }
                te && console.warn("WebGL SDF generation not supported:", te), P = !1, T.set(U, j)
            }
            return j
        }
        var X = Object.freeze({
            __proto__: null,
            generate: D,
            generateIntoCanvas: V,
            generateIntoFramebuffer: H,
            isSupported: q
        });

        function oe(Z, U, j, te, he, $) {
            he === void 0 && (he = Math.max(te[2] - te[0], te[3] - te[1]) / 2), $ === void 0 && ($ = 1);
            try {
                return D.apply(X, arguments)
            } catch (ne) {
                return console.info("WebGL SDF generation failed, falling back to JS", ne), g.apply(A, arguments)
            }
        }

        function Y(Z, U, j, te, he, $, ne, me, ce, _e) {
            he === void 0 && (he = Math.max(te[2] - te[0], te[3] - te[1]) / 2), $ === void 0 && ($ = 1), me === void 0 && (me = 0), ce === void 0 && (ce = 0), _e === void 0 && (_e = 0);
            try {
                return V.apply(X, arguments)
            } catch (Oe) {
                return console.info("WebGL SDF generation failed, falling back to JS", Oe), y.apply(A, arguments)
            }
        }
        return e.forEachPathCommand = i, e.generate = oe, e.generateIntoCanvas = Y, e.javascript = A, e.pathToLineSegments = s, e.webgl = X, e.webglUtils = m, Object.defineProperty(e, "__esModule", {
            value: !0
        }), e
    }({});
    return r
}

function M9() {
    var r = function(e) {
        var t = {
                R: "13k,1a,2,3,3,2+1j,ch+16,a+1,5+2,2+n,5,a,4,6+16,4+3,h+1b,4mo,179q,2+9,2+11,2i9+7y,2+68,4,3+4,5+13,4+3,2+4k,3+29,8+cf,1t+7z,w+17,3+3m,1t+3z,16o1+5r,8+30,8+mc,29+1r,29+4v,75+73",
                EN: "1c+9,3d+1,6,187+9,513,4+5,7+9,sf+j,175h+9,qw+q,161f+1d,4xt+a,25i+9",
                ES: "17,2,6dp+1,f+1,av,16vr,mx+1,4o,2",
                ET: "z+2,3h+3,b+1,ym,3e+1,2o,p4+1,8,6u,7c,g6,1wc,1n9+4,30+1b,2n,6d,qhx+1,h0m,a+1,49+2,63+1,4+1,6bb+3,12jj",
                AN: "16o+5,2j+9,2+1,35,ed,1ff2+9,87+u",
                CS: "18,2+1,b,2u,12k,55v,l,17v0,2,3,53,2+1,b",
                B: "a,3,f+2,2v,690",
                S: "9,2,k",
                WS: "c,k,4f4,1vk+a,u,1j,335",
                ON: "x+1,4+4,h+5,r+5,r+3,z,5+3,2+1,2+1,5,2+2,3+4,o,w,ci+1,8+d,3+d,6+8,2+g,39+1,9,6+1,2,33,b8,3+1,3c+1,7+1,5r,b,7h+3,sa+5,2,3i+6,jg+3,ur+9,2v,ij+1,9g+9,7+a,8m,4+1,49+x,14u,2+2,c+2,e+2,e+2,e+1,i+n,e+e,2+p,u+2,e+2,36+1,2+3,2+1,b,2+2,6+5,2,2,2,h+1,5+4,6+3,3+f,16+2,5+3l,3+81,1y+p,2+40,q+a,m+13,2r+ch,2+9e,75+hf,3+v,2+2w,6e+5,f+6,75+2a,1a+p,2+2g,d+5x,r+b,6+3,4+o,g,6+1,6+2,2k+1,4,2j,5h+z,1m+1,1e+f,t+2,1f+e,d+3,4o+3,2s+1,w,535+1r,h3l+1i,93+2,2s,b+1,3l+x,2v,4g+3,21+3,kz+1,g5v+1,5a,j+9,n+v,2,3,2+8,2+1,3+2,2,3,46+1,4+4,h+5,r+5,r+a,3h+2,4+6,b+4,78,1r+24,4+c,4,1hb,ey+6,103+j,16j+c,1ux+7,5+g,fsh,jdq+1t,4,57+2e,p1,1m,1m,1m,1m,4kt+1,7j+17,5+2r,d+e,3+e,2+e,2+10,m+4,w,1n+5,1q,4z+5,4b+rb,9+c,4+c,4+37,d+2g,8+b,l+b,5+1j,9+9,7+13,9+t,3+1,27+3c,2+29,2+3q,d+d,3+4,4+2,6+6,a+o,8+6,a+2,e+6,16+42,2+1i",
                BN: "0+8,6+d,2s+5,2+p,e,4m9,1kt+2,2b+5,5+5,17q9+v,7k,6p+8,6+1,119d+3,440+7,96s+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+1,1ekf+75,6p+2rz,1ben+1,1ekf+1,1ekf+1",
                NSM: "lc+33,7o+6,7c+18,2,2+1,2+1,2,21+a,1d+k,h,2u+6,3+5,3+1,2+3,10,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,g+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+g,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,k1+w,2db+2,3y,2p+v,ff+3,30+1,n9x+3,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,r2,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+5,3+1,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2d+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,f0c+4,1o+6,t5,1s+3,2a,f5l+1,43t+2,i+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,gzhy+6n",
                AL: "16w,3,2,e+1b,z+2,2+2s,g+1,8+1,b+m,2+t,s+2i,c+e,4h+f,1d+1e,1bwe+dp,3+3z,x+c,2+1,35+3y,2rm+z,5+7,b+5,dt+l,c+u,17nl+27,1t+27,4x+6n,3+d",
                LRO: "6ct",
                RLO: "6cu",
                LRE: "6cq",
                RLE: "6cr",
                PDF: "6cs",
                LRI: "6ee",
                RLI: "6ef",
                FSI: "6eg",
                PDI: "6eh"
            },
            n = {},
            i = {};
        n.L = 1, i[1] = "L", Object.keys(t).forEach(function(Se, Xe) {
            n[Se] = 1 << Xe + 1, i[n[Se]] = Se
        }), Object.freeze(n);
        var s = n.LRI | n.RLI | n.FSI,
            o = n.L | n.R | n.AL,
            a = n.B | n.S | n.WS | n.ON | n.FSI | n.LRI | n.RLI | n.PDI,
            l = n.BN | n.RLE | n.LRE | n.RLO | n.LRO | n.PDF,
            c = n.S | n.WS | n.B | s | n.PDI | l,
            u = null;

        function f() {
            if (!u) {
                u = new Map;
                var Se = function(Le) {
                    if (t.hasOwnProperty(Le)) {
                        var k = 0;
                        t[Le].split(",").forEach(function(z) {
                            var ue = z.split("+"),
                                ye = ue[0],
                                ge = ue[1];
                            ye = parseInt(ye, 36), ge = ge ? parseInt(ge, 36) : 0, u.set(k += ye, n[Le]);
                            for (var Re = 0; Re < ge; Re++) u.set(++k, n[Le])
                        })
                    }
                };
                for (var Xe in t) Se(Xe)
            }
        }

        function d(Se) {
            return f(), u.get(Se.codePointAt(0)) || n.L
        }

        function m(Se) {
            return i[d(Se)]
        }
        var g = {
            pairs: "14>1,1e>2,u>2,2wt>1,1>1,1ge>1,1wp>1,1j>1,f>1,hm>1,1>1,u>1,u6>1,1>1,+5,28>1,w>1,1>1,+3,b8>1,1>1,+3,1>3,-1>-1,3>1,1>1,+2,1s>1,1>1,x>1,th>1,1>1,+2,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,4q>1,1e>2,u>2,2>1,+1",
            canonical: "6f1>-6dx,6dy>-6dx,6ec>-6ed,6ee>-6ed,6ww>2jj,-2ji>2jj,14r4>-1e7l,1e7m>-1e7l,1e7m>-1e5c,1e5d>-1e5b,1e5c>-14qx,14qy>-14qx,14vn>-1ecg,1ech>-1ecg,1edu>-1ecg,1eci>-1ecg,1eda>-1ecg,1eci>-1ecg,1eci>-168q,168r>-168q,168s>-14ye,14yf>-14ye"
        };

        function y(Se, Xe) {
            var Le = 36,
                k = 0,
                z = new Map,
                ue = Xe && new Map,
                ye;
            return Se.split(",").forEach(function ge(Re) {
                if (Re.indexOf("+") !== -1)
                    for (var Be = +Re; Be--;) ge(ye);
                else {
                    ye = Re;
                    var Fe = Re.split(">"),
                        Ne = Fe[0],
                        ot = Fe[1];
                    Ne = String.fromCodePoint(k += parseInt(Ne, Le)), ot = String.fromCodePoint(k += parseInt(ot, Le)), z.set(Ne, ot), Xe && ue.set(ot, Ne)
                }
            }), {
                map: z,
                reverseMap: ue
            }
        }
        var v, _, A;

        function S() {
            if (!v) {
                var Se = y(g.pairs, !0),
                    Xe = Se.map,
                    Le = Se.reverseMap;
                v = Xe, _ = Le, A = y(g.canonical, !1).map
            }
        }

        function M(Se) {
            return S(), v.get(Se) || null
        }

        function C(Se) {
            return S(), _.get(Se) || null
        }

        function E(Se) {
            return S(), A.get(Se) || null
        }
        var R = n.L,
            P = n.R,
            b = n.EN,
            T = n.ES,
            L = n.ET,
            D = n.AN,
            V = n.CS,
            H = n.B,
            q = n.S,
            X = n.ON,
            oe = n.BN,
            Y = n.NSM,
            Z = n.AL,
            U = n.LRO,
            j = n.RLO,
            te = n.LRE,
            he = n.RLE,
            $ = n.PDF,
            ne = n.LRI,
            me = n.RLI,
            ce = n.FSI,
            _e = n.PDI;

        function Oe(Se, Xe) {
            for (var Le = 125, k = new Uint32Array(Se.length), z = 0; z < Se.length; z++) k[z] = d(Se[z]);
            var ue = new Map;

            function ye(Oi, Sr) {
                var gi = k[Oi];
                k[Oi] = Sr, ue.set(gi, ue.get(gi) - 1), gi & a && ue.set(a, ue.get(a) - 1), ue.set(Sr, (ue.get(Sr) || 0) + 1), Sr & a && ue.set(a, (ue.get(a) || 0) + 1)
            }
            for (var ge = new Uint8Array(Se.length), Re = new Map, Be = [], Fe = null, Ne = 0; Ne < Se.length; Ne++) Fe || Be.push(Fe = {
                start: Ne,
                end: Se.length - 1,
                level: Xe === "rtl" ? 1 : Xe === "ltr" ? 0 : wu(Ne, !1)
            }), k[Ne] & H && (Fe.end = Ne, Fe = null);
            for (var ot = he | te | j | U | s | _e | $ | H, je = function(Oi) {
                    return Oi + (Oi & 1 ? 1 : 2)
                }, Ze = function(Oi) {
                    return Oi + (Oi & 1 ? 2 : 1)
                }, it = 0; it < Be.length; it++) {
                Fe = Be[it];
                var $e = [{
                        _level: Fe.level,
                        _override: 0,
                        _isolate: 0
                    }],
                    We = void 0,
                    yt = 0,
                    at = 0,
                    Mt = 0;
                ue.clear();
                for (var ae = Fe.start; ae <= Fe.end; ae++) {
                    var ve = k[ae];
                    if (We = $e[$e.length - 1], ue.set(ve, (ue.get(ve) || 0) + 1), ve & a && ue.set(a, (ue.get(a) || 0) + 1), ve & ot)
                        if (ve & (he | te)) {
                            ge[ae] = We._level;
                            var we = (ve === he ? Ze : je)(We._level);
                            we <= Le && !yt && !at ? $e.push({
                                _level: we,
                                _override: 0,
                                _isolate: 0
                            }) : yt || at++
                        } else if (ve & (j | U)) {
                        ge[ae] = We._level;
                        var He = (ve === j ? Ze : je)(We._level);
                        He <= Le && !yt && !at ? $e.push({
                            _level: He,
                            _override: ve & j ? P : R,
                            _isolate: 0
                        }) : yt || at++
                    } else if (ve & s) {
                        ve & ce && (ve = wu(ae + 1, !0) === 1 ? me : ne), ge[ae] = We._level, We._override && ye(ae, We._override);
                        var Je = (ve === me ? Ze : je)(We._level);
                        Je <= Le && yt === 0 && at === 0 ? (Mt++, $e.push({
                            _level: Je,
                            _override: 0,
                            _isolate: 1,
                            _isolInitIndex: ae
                        })) : yt++
                    } else if (ve & _e) {
                        if (yt > 0) yt--;
                        else if (Mt > 0) {
                            for (at = 0; !$e[$e.length - 1]._isolate;) $e.pop();
                            var Ye = $e[$e.length - 1]._isolInitIndex;
                            Ye != null && (Re.set(Ye, ae), Re.set(ae, Ye)), $e.pop(), Mt--
                        }
                        We = $e[$e.length - 1], ge[ae] = We._level, We._override && ye(ae, We._override)
                    } else ve & $ ? (yt === 0 && (at > 0 ? at-- : !We._isolate && $e.length > 1 && ($e.pop(), We = $e[$e.length - 1])), ge[ae] = We._level) : ve & H && (ge[ae] = Fe.level);
                    else ge[ae] = We._level, We._override && ve !== oe && ye(ae, We._override)
                }
                for (var mt = [], Pt = null, St = Fe.start; St <= Fe.end; St++) {
                    var tt = k[St];
                    if (!(tt & l)) {
                        var ut = ge[St],
                            Rt = tt & s,
                            nt = tt === _e;
                        Pt && ut === Pt._level ? (Pt._end = St, Pt._endsWithIsolInit = Rt) : mt.push(Pt = {
                            _start: St,
                            _end: St,
                            _level: ut,
                            _startsWithPDI: nt,
                            _endsWithIsolInit: Rt
                        })
                    }
                }
                for (var It = [], pt = 0; pt < mt.length; pt++) {
                    var Ct = mt[pt];
                    if (!Ct._startsWithPDI || Ct._startsWithPDI && !Re.has(Ct._start)) {
                        for (var ln = [Pt = Ct], Dt = void 0; Pt && Pt._endsWithIsolInit && (Dt = Re.get(Pt._end)) != null;)
                            for (var gt = pt + 1; gt < mt.length; gt++)
                                if (mt[gt]._start === Dt) {
                                    ln.push(Pt = mt[gt]);
                                    break
                                }
                        for (var $t = [], rn = 0; rn < ln.length; rn++)
                            for (var O = ln[rn], W = O._start; W <= O._end; W++) $t.push(W);
                        for (var de = ge[$t[0]], be = Fe.level, Pe = $t[0] - 1; Pe >= 0; Pe--)
                            if (!(k[Pe] & l)) {
                                be = ge[Pe];
                                break
                            }
                        var F = $t[$t.length - 1],
                            Q = ge[F],
                            re = Fe.level;
                        if (!(k[F] & s)) {
                            for (var le = F + 1; le <= Fe.end; le++)
                                if (!(k[le] & l)) {
                                    re = ge[le];
                                    break
                                }
                        }
                        It.push({
                            _seqIndices: $t,
                            _sosType: Math.max(be, de) % 2 ? P : R,
                            _eosType: Math.max(re, Q) % 2 ? P : R
                        })
                    }
                }
                for (var ee = 0; ee < It.length; ee++) {
                    var Te = It[ee],
                        fe = Te._seqIndices,
                        Ke = Te._sosType,
                        Ge = Te._eosType,
                        qe = ge[fe[0]] & 1 ? P : R;
                    if (ue.get(Y))
                        for (var st = 0; st < fe.length; st++) {
                            var Qe = fe[st];
                            if (k[Qe] & Y) {
                                for (var ft = Ke, _t = st - 1; _t >= 0; _t--)
                                    if (!(k[fe[_t]] & l)) {
                                        ft = k[fe[_t]];
                                        break
                                    }
                                ye(Qe, ft & (s | _e) ? X : ft)
                            }
                        }
                    if (ue.get(b))
                        for (var ht = 0; ht < fe.length; ht++) {
                            var wt = fe[ht];
                            if (k[wt] & b)
                                for (var At = ht - 1; At >= -1; At--) {
                                    var ct = At === -1 ? Ke : k[fe[At]];
                                    if (ct & o) {
                                        ct === Z && ye(wt, D);
                                        break
                                    }
                                }
                        }
                    if (ue.get(Z))
                        for (var Ut = 0; Ut < fe.length; Ut++) {
                            var Bt = fe[Ut];
                            k[Bt] & Z && ye(Bt, P)
                        }
                    if (ue.get(T) || ue.get(V))
                        for (var Mn = 1; Mn < fe.length - 1; Mn++) {
                            var In = fe[Mn];
                            if (k[In] & (T | V)) {
                                for (var cn = 0, en = 0, Gt = Mn - 1; Gt >= 0 && (cn = k[fe[Gt]], !!(cn & l)); Gt--);
                                for (var Wt = Mn + 1; Wt < fe.length && (en = k[fe[Wt]], !!(en & l)); Wt++);
                                cn === en && (k[In] === T ? cn === b : cn & (b | D)) && ye(In, cn)
                            }
                        }
                    if (ue.get(b))
                        for (var Ht = 0; Ht < fe.length; Ht++) {
                            var sn = fe[Ht];
                            if (k[sn] & b) {
                                for (var Qn = Ht - 1; Qn >= 0 && k[fe[Qn]] & (L | l); Qn--) ye(fe[Qn], b);
                                for (Ht++; Ht < fe.length && k[fe[Ht]] & (L | l | b); Ht++) k[fe[Ht]] !== b && ye(fe[Ht], b)
                            }
                        }
                    if (ue.get(L) || ue.get(T) || ue.get(V))
                        for (var Dn = 0; Dn < fe.length; Dn++) {
                            var tr = fe[Dn];
                            if (k[tr] & (L | T | V)) {
                                ye(tr, X);
                                for (var Go = Dn - 1; Go >= 0 && k[fe[Go]] & l; Go--) ye(fe[Go], X);
                                for (var Ho = Dn + 1; Ho < fe.length && k[fe[Ho]] & l; Ho++) ye(fe[Ho], X)
                            }
                        }
                    if (ue.get(b))
                        for (var Vo = 0, zl = Ke; Vo < fe.length; Vo++) {
                            var dm = fe[Vo],
                                yh = k[dm];
                            yh & b ? zl === R && ye(dm, R) : yh & o && (zl = yh)
                        }
                    if (ue.get(a)) {
                        var Wo = P | b | D,
                            Au = Wo | R,
                            yo = []; {
                            for (var Ra = [], _o = 0; _o < fe.length; _o++)
                                if (k[fe[_o]] & a) {
                                    var un = Se[fe[_o]],
                                        _h = void 0;
                                    if (M(un) !== null)
                                        if (Ra.length < 63) Ra.push({
                                            char: un,
                                            seqIndex: _o
                                        });
                                        else break;
                                    else if ((_h = C(un)) !== null)
                                        for (var jo = Ra.length - 1; jo >= 0; jo--) {
                                            var Su = Ra[jo].char;
                                            if (Su === _h || Su === C(E(un)) || M(E(Su)) === un) {
                                                yo.push([Ra[jo].seqIndex, _o]), Ra.length = jo;
                                                break
                                            }
                                        }
                                }
                            yo.sort(function(Oi, Sr) {
                                return Oi[0] - Sr[0]
                            })
                        }
                        for (var xh = 0; xh < yo.length; xh++) {
                            for (var pm = yo[xh], $n = pm[0], Gl = pm[1], mm = !1, _r = 0, Ah = $n + 1; Ah < Gl; Ah++) {
                                var Hl = fe[Ah];
                                if (k[Hl] & Au) {
                                    mm = !0;
                                    var Qr = k[Hl] & Wo ? P : R;
                                    if (Qr === qe) {
                                        _r = Qr;
                                        break
                                    }
                                }
                            }
                            if (mm && !_r) {
                                _r = Ke;
                                for (var Sh = $n - 1; Sh >= 0; Sh--) {
                                    var gm = fe[Sh];
                                    if (k[gm] & Au) {
                                        var $r = k[gm] & Wo ? P : R;
                                        $r !== qe ? _r = $r : _r = qe;
                                        break
                                    }
                                }
                            }
                            if (_r) {
                                if (k[fe[$n]] = k[fe[Gl]] = _r, _r !== qe) {
                                    for (var xr = $n + 1; xr < fe.length; xr++)
                                        if (!(k[fe[xr]] & l)) {
                                            d(Se[fe[xr]]) & Y && (k[fe[xr]] = _r);
                                            break
                                        }
                                }
                                if (_r !== qe) {
                                    for (var xo = Gl + 1; xo < fe.length; xo++)
                                        if (!(k[fe[xo]] & l)) {
                                            d(Se[fe[xo]]) & Y && (k[fe[xo]] = _r);
                                            break
                                        }
                                }
                            }
                        }
                        for (var Cs = 0; Cs < fe.length; Cs++)
                            if (k[fe[Cs]] & a) {
                                for (var Mh = Cs, wh = Cs, kr = Ke, Vl = Cs - 1; Vl >= 0; Vl--)
                                    if (k[fe[Vl]] & l) Mh = Vl;
                                    else {
                                        kr = k[fe[Vl]] & Wo ? P : R;
                                        break
                                    }
                                for (var Wl = Ge, jl = Cs + 1; jl < fe.length; jl++)
                                    if (k[fe[jl]] & (a | l)) wh = jl;
                                    else {
                                        Wl = k[fe[jl]] & Wo ? P : R;
                                        break
                                    }
                                for (var Ar = Mh; Ar <= wh; Ar++) k[fe[Ar]] = kr === Wl ? kr : qe;
                                Cs = wh
                            }
                    }
                }
                for (var Ui = Fe.start; Ui <= Fe.end; Ui++) {
                    var Mu = ge[Ui],
                        eo = k[Ui];
                    if (Mu & 1 ? eo & (R | b | D) && ge[Ui]++ : eo & P ? ge[Ui]++ : eo & (D | b) && (ge[Ui] += 2), eo & l && (ge[Ui] = Ui === 0 ? Fe.level : ge[Ui - 1]), Ui === Fe.end || d(Se[Ui]) & (q | H))
                        for (var Pa = Ui; Pa >= 0 && d(Se[Pa]) & c; Pa--) ge[Pa] = Fe.level
                }
            }
            return {
                levels: ge,
                paragraphs: Be
            };

            function wu(Oi, Sr) {
                for (var gi = Oi; gi < Se.length; gi++) {
                    var vi = k[gi];
                    if (vi & (P | Z)) return 1;
                    if (vi & (H | R) || Sr && vi === _e) return 0;
                    if (vi & s) {
                        var es = vm(gi);
                        gi = es === -1 ? Se.length : es
                    }
                }
                return 0
            }

            function vm(Oi) {
                for (var Sr = 1, gi = Oi + 1; gi < Se.length; gi++) {
                    var vi = k[gi];
                    if (vi & H) break;
                    if (vi & _e) {
                        if (--Sr === 0) return gi
                    } else vi & s && Sr++
                }
                return -1
            }
        }
        var ke = "14>1,j>2,t>2,u>2,1a>g,2v3>1,1>1,1ge>1,1wd>1,b>1,1j>1,f>1,ai>3,-2>3,+1,8>1k0,-1jq>1y7,-1y6>1hf,-1he>1h6,-1h5>1ha,-1h8>1qi,-1pu>1,6>3u,-3s>7,6>1,1>1,f>1,1>1,+2,3>1,1>1,+13,4>1,1>1,6>1eo,-1ee>1,3>1mg,-1me>1mk,-1mj>1mi,-1mg>1mi,-1md>1,1>1,+2,1>10k,-103>1,1>1,4>1,5>1,1>1,+10,3>1,1>8,-7>8,+1,-6>7,+1,a>1,1>1,u>1,u6>1,1>1,+5,26>1,1>1,2>1,2>2,8>1,7>1,4>1,1>1,+5,b8>1,1>1,+3,1>3,-2>1,2>1,1>1,+2,c>1,3>1,1>1,+2,h>1,3>1,a>1,1>1,2>1,3>1,1>1,d>1,f>1,3>1,1a>1,1>1,6>1,7>1,13>1,k>1,1>1,+19,4>1,1>1,+2,2>1,1>1,+18,m>1,a>1,1>1,lk>1,1>1,4>1,2>1,f>1,3>1,1>1,+3,db>1,1>1,+3,3>1,1>1,+2,14qm>1,1>1,+1,6>1,4j>1,j>2,t>2,u>2,2>1,+1",
            Ee;

        function pe() {
            if (!Ee) {
                var Se = y(ke, !0),
                    Xe = Se.map,
                    Le = Se.reverseMap;
                Le.forEach(function(k, z) {
                    Xe.set(z, k)
                }), Ee = Xe
            }
        }

        function xe(Se) {
            return pe(), Ee.get(Se) || null
        }

        function J(Se, Xe, Le, k) {
            var z = Se.length;
            Le = Math.max(0, Le == null ? 0 : +Le), k = Math.min(z - 1, k == null ? z - 1 : +k);
            for (var ue = new Map, ye = Le; ye <= k; ye++)
                if (Xe[ye] & 1) {
                    var ge = xe(Se[ye]);
                    ge !== null && ue.set(ye, ge)
                }
            return ue
        }

        function De(Se, Xe, Le, k) {
            var z = Se.length;
            Le = Math.max(0, Le == null ? 0 : +Le), k = Math.min(z - 1, k == null ? z - 1 : +k);
            var ue = [];
            return Xe.paragraphs.forEach(function(ye) {
                var ge = Math.max(Le, ye.start),
                    Re = Math.min(k, ye.end);
                if (ge < Re) {
                    for (var Be = Xe.levels.slice(ge, Re + 1), Fe = Re; Fe >= ge && d(Se[Fe]) & c; Fe--) Be[Fe] = ye.level;
                    for (var Ne = ye.level, ot = 1 / 0, je = 0; je < Be.length; je++) {
                        var Ze = Be[je];
                        Ze > Ne && (Ne = Ze), Ze < ot && (ot = Ze | 1)
                    }
                    for (var it = Ne; it >= ot; it--)
                        for (var $e = 0; $e < Be.length; $e++)
                            if (Be[$e] >= it) {
                                for (var We = $e; $e + 1 < Be.length && Be[$e + 1] >= it;) $e++;
                                $e > We && ue.push([We + ge, $e + ge])
                            }
                }
            }), ue
        }

        function Ce(Se, Xe, Le, k) {
            var z = se(Se, Xe, Le, k),
                ue = [].concat(Se);
            return z.forEach(function(ye, ge) {
                ue[ge] = (Xe.levels[ye] & 1 ? xe(Se[ye]) : null) || Se[ye]
            }), ue.join("")
        }

        function se(Se, Xe, Le, k) {
            for (var z = De(Se, Xe, Le, k), ue = [], ye = 0; ye < Se.length; ye++) ue[ye] = ye;
            return z.forEach(function(ge) {
                for (var Re = ge[0], Be = ge[1], Fe = ue.slice(Re, Be + 1), Ne = Fe.length; Ne--;) ue[Be - Ne] = Fe[Ne]
            }), ue
        }
        return e.closingToOpeningBracket = C, e.getBidiCharType = d, e.getBidiCharTypeName = m, e.getCanonicalBracket = E, e.getEmbeddingLevels = Oe, e.getMirroredCharacter = xe, e.getMirroredCharactersMap = J, e.getReorderSegments = De, e.getReorderedIndices = se, e.getReorderedString = Ce, e.openingToClosingBracket = M, Object.defineProperty(e, "__esModule", {
            value: !0
        }), e
    }({});
    return r
}
const zD = /\bvoid\s+main\s*\(\s*\)\s*{/g;

function DA(r) {
    const e = /^[ \t]*#include +<([\w\d./]+)>/gm;

    function t(n, i) {
        let s = Jt[i];
        return s ? DA(s) : n
    }
    return r.replace(e, t)
}
const Ki = [];
for (let r = 0; r < 256; r++) Ki[r] = (r < 16 ? "0" : "") + r.toString(16);

function w9() {
    const r = Math.random() * 4294967295 | 0,
        e = Math.random() * 4294967295 | 0,
        t = Math.random() * 4294967295 | 0,
        n = Math.random() * 4294967295 | 0;
    return (Ki[r & 255] + Ki[r >> 8 & 255] + Ki[r >> 16 & 255] + Ki[r >> 24 & 255] + "-" + Ki[e & 255] + Ki[e >> 8 & 255] + "-" + Ki[e >> 16 & 15 | 64] + Ki[e >> 24 & 255] + "-" + Ki[t & 63 | 128] + Ki[t >> 8 & 255] + "-" + Ki[t >> 16 & 255] + Ki[t >> 24 & 255] + Ki[n & 255] + Ki[n >> 8 & 255] + Ki[n >> 16 & 255] + Ki[n >> 24 & 255]).toUpperCase()
}
const vc = Object.assign || function() {
        let r = arguments[0];
        for (let e = 1, t = arguments.length; e < t; e++) {
            let n = arguments[e];
            if (n)
                for (let i in n) Object.prototype.hasOwnProperty.call(n, i) && (r[i] = n[i])
        }
        return r
    },
    b9 = Date.now(),
    YC = new WeakMap,
    JC = new Map;
let T9 = 1e10;

function LA(r, e) {
    const t = P9(e);
    let n = YC.get(r);
    if (n || YC.set(r, n = Object.create(null)), n[t]) return new n[t];
    const i = `_onBeforeCompile${t}`,
        s = function(c, u) {
            r.onBeforeCompile.call(this, c, u);
            const f = this.customProgramCacheKey() + "|" + c.vertexShader + "|" + c.fragmentShader;
            let d = JC[f];
            if (!d) {
                const m = E9(this, c, e, t);
                d = JC[f] = m
            }
            c.vertexShader = d.vertexShader, c.fragmentShader = d.fragmentShader, vc(c.uniforms, this.uniforms), e.timeUniform && (c.uniforms[e.timeUniform] = {
                get value() {
                    return Date.now() - b9
                }
            }), this[i] && this[i](c)
        },
        o = function() {
            return a(e.chained ? r : r.clone())
        },
        a = function(c) {
            const u = Object.create(c, l);
            return Object.defineProperty(u, "baseMaterial", {
                value: r
            }), Object.defineProperty(u, "id", {
                value: T9++
            }), u.uuid = w9(), u.uniforms = vc({}, c.uniforms, e.uniforms), u.defines = vc({}, c.defines, e.defines), u.defines[`TROIKA_DERIVED_MATERIAL_${t}`] = "", u.extensions = vc({}, c.extensions, e.extensions), u._listeners = void 0, u
        },
        l = {
            constructor: {
                value: o
            },
            isDerivedMaterial: {
                value: !0
            },
            type: {
                get: () => r.type,
                set: c => {
                    r.type = c
                }
            },
            isDerivedFrom: {
                writable: !0,
                configurable: !0,
                value: function(c) {
                    const u = this.baseMaterial;
                    return c === u || u.isDerivedMaterial && u.isDerivedFrom(c) || !1
                }
            },
            customProgramCacheKey: {
                writable: !0,
                configurable: !0,
                value: function() {
                    return r.customProgramCacheKey() + "|" + t
                }
            },
            onBeforeCompile: {
                get() {
                    return s
                },
                set(c) {
                    this[i] = c
                }
            },
            copy: {
                writable: !0,
                configurable: !0,
                value: function(c) {
                    return r.copy.call(this, c), !r.isShaderMaterial && !r.isDerivedMaterial && (vc(this.extensions, c.extensions), vc(this.defines, c.defines), vc(this.uniforms, bl.clone(c.uniforms))), this
                }
            },
            clone: {
                writable: !0,
                configurable: !0,
                value: function() {
                    const c = new r.constructor;
                    return a(c).copy(this)
                }
            },
            getDepthMaterial: {
                writable: !0,
                configurable: !0,
                value: function() {
                    let c = this._depthMaterial;
                    return c || (c = this._depthMaterial = LA(r.isDerivedMaterial ? r.getDepthMaterial() : new gy({
                        depthPacking: GS
                    }), e), c.defines.IS_DEPTH_MATERIAL = "", c.uniforms = this.uniforms), c
                }
            },
            getDistanceMaterial: {
                writable: !0,
                configurable: !0,
                value: function() {
                    let c = this._distanceMaterial;
                    return c || (c = this._distanceMaterial = LA(r.isDerivedMaterial ? r.getDistanceMaterial() : new vy, e), c.defines.IS_DISTANCE_MATERIAL = "", c.uniforms = this.uniforms), c
                }
            },
            dispose: {
                writable: !0,
                configurable: !0,
                value() {
                    const {
                        _depthMaterial: c,
                        _distanceMaterial: u
                    } = this;
                    c && c.dispose(), u && u.dispose(), r.dispose.call(this)
                }
            }
        };
    return n[t] = o, new o
}

function E9(r, {
    vertexShader: e,
    fragmentShader: t
}, n, i) {
    let {
        vertexDefs: s,
        vertexMainIntro: o,
        vertexMainOutro: a,
        vertexTransform: l,
        fragmentDefs: c,
        fragmentMainIntro: u,
        fragmentMainOutro: f,
        fragmentColorTransform: d,
        customRewriter: m,
        timeUniform: g
    } = n;
    if (s = s || "", o = o || "", a = a || "", c = c || "", u = u || "", f = f || "", (l || m) && (e = DA(e)), (d || m) && (t = t.replace(/^[ \t]*#include <((?:tonemapping|encodings|colorspace|fog|premultiplied_alpha|dithering)_fragment)>/gm, `
//!BEGIN_POST_CHUNK $1
$&
//!END_POST_CHUNK
`), t = DA(t)), m) {
        let y = m({
            vertexShader: e,
            fragmentShader: t
        });
        e = y.vertexShader, t = y.fragmentShader
    }
    if (d) {
        let y = [];
        t = t.replace(/^\/\/!BEGIN_POST_CHUNK[^]+?^\/\/!END_POST_CHUNK/gm, v => (y.push(v), "")), f = `${d}
${y.join(`
`)}
${f}`
    }
    if (g) {
        const y = `
uniform float ${g};
`;
        s = y + s, c = y + c
    }
    return l && (e = `vec3 troika_position_${i};
vec3 troika_normal_${i};
vec2 troika_uv_${i};
${e}
`, s = `${s}
void troikaVertexTransform${i}(inout vec3 position, inout vec3 normal, inout vec2 uv) {
  ${l}
}
`, o = `
troika_position_${i} = vec3(position);
troika_normal_${i} = vec3(normal);
troika_uv_${i} = vec2(uv);
troikaVertexTransform${i}(troika_position_${i}, troika_normal_${i}, troika_uv_${i});
${o}
`, e = e.replace(/\b(position|normal|uv)\b/g, (y, v, _, A) => /\battribute\s+vec[23]\s+$/.test(A.substr(0, _)) ? v : `troika_${v}_${i}`), r.map && r.map.channel > 0 || (e = e.replace(/\bMAP_UV\b/g, `troika_uv_${i}`))), e = KC(e, i, s, o, a), t = KC(t, i, c, u, f), {
        vertexShader: e,
        fragmentShader: t
    }
}

function KC(r, e, t, n, i) {
    return (n || i || t) && (r = r.replace(zD, `
${t}
void troikaOrigMain${e}() {`), r += `
void main() {
  ${n}
  troikaOrigMain${e}();
  ${i}
}`), r
}

function C9(r, e) {
    return r === "uniforms" ? void 0 : typeof e == "function" ? e.toString() : e
}
let R9 = 0;
const qC = new Map;

function P9(r) {
    const e = JSON.stringify(r, C9);
    let t = qC.get(e);
    return t == null && qC.set(e, t = ++R9), t
}
/*!
Custom build of Typr.ts (https://github.com/fredli74/Typr.ts) for use in Troika text rendering.
Original MIT license applies: https://github.com/fredli74/Typr.ts/blob/master/LICENSE
*/
function I9() {
    return typeof window > "u" && (self.window = self),
        function(r) {
            var e = {
                parse: function(i) {
                    var s = e._bin,
                        o = new Uint8Array(i);
                    if (s.readASCII(o, 0, 4) == "ttcf") {
                        var a = 4;
                        s.readUshort(o, a), a += 2, s.readUshort(o, a), a += 2;
                        var l = s.readUint(o, a);
                        a += 4;
                        for (var c = [], u = 0; u < l; u++) {
                            var f = s.readUint(o, a);
                            a += 4, c.push(e._readFont(o, f))
                        }
                        return c
                    }
                    return [e._readFont(o, 0)]
                },
                _readFont: function(i, s) {
                    var o = e._bin,
                        a = s;
                    o.readFixed(i, s), s += 4;
                    var l = o.readUshort(i, s);
                    s += 2, o.readUshort(i, s), s += 2, o.readUshort(i, s), s += 2, o.readUshort(i, s), s += 2;
                    for (var c = ["cmap", "head", "hhea", "maxp", "hmtx", "name", "OS/2", "post", "loca", "glyf", "kern", "CFF ", "GDEF", "GPOS", "GSUB", "SVG "], u = {
                            _data: i,
                            _offset: a
                        }, f = {}, d = 0; d < l; d++) {
                        var m = o.readASCII(i, s, 4);
                        s += 4, o.readUint(i, s), s += 4;
                        var g = o.readUint(i, s);
                        s += 4;
                        var y = o.readUint(i, s);
                        s += 4, f[m] = {
                            offset: g,
                            length: y
                        }
                    }
                    for (d = 0; d < c.length; d++) {
                        var v = c[d];
                        f[v] && (u[v.trim()] = e[v.trim()].parse(i, f[v].offset, f[v].length, u))
                    }
                    return u
                },
                _tabOffset: function(i, s, o) {
                    for (var a = e._bin, l = a.readUshort(i, o + 4), c = o + 12, u = 0; u < l; u++) {
                        var f = a.readASCII(i, c, 4);
                        c += 4, a.readUint(i, c), c += 4;
                        var d = a.readUint(i, c);
                        if (c += 4, a.readUint(i, c), c += 4, f == s) return d
                    }
                    return 0
                }
            };
            e._bin = {
                readFixed: function(i, s) {
                    return (i[s] << 8 | i[s + 1]) + (i[s + 2] << 8 | i[s + 3]) / 65540
                },
                readF2dot14: function(i, s) {
                    return e._bin.readShort(i, s) / 16384
                },
                readInt: function(i, s) {
                    return e._bin._view(i).getInt32(s)
                },
                readInt8: function(i, s) {
                    return e._bin._view(i).getInt8(s)
                },
                readShort: function(i, s) {
                    return e._bin._view(i).getInt16(s)
                },
                readUshort: function(i, s) {
                    return e._bin._view(i).getUint16(s)
                },
                readUshorts: function(i, s, o) {
                    for (var a = [], l = 0; l < o; l++) a.push(e._bin.readUshort(i, s + 2 * l));
                    return a
                },
                readUint: function(i, s) {
                    return e._bin._view(i).getUint32(s)
                },
                readUint64: function(i, s) {
                    return 4294967296 * e._bin.readUint(i, s) + e._bin.readUint(i, s + 4)
                },
                readASCII: function(i, s, o) {
                    for (var a = "", l = 0; l < o; l++) a += String.fromCharCode(i[s + l]);
                    return a
                },
                readUnicode: function(i, s, o) {
                    for (var a = "", l = 0; l < o; l++) {
                        var c = i[s++] << 8 | i[s++];
                        a += String.fromCharCode(c)
                    }
                    return a
                },
                _tdec: typeof window < "u" && window.TextDecoder ? new window.TextDecoder : null,
                readUTF8: function(i, s, o) {
                    var a = e._bin._tdec;
                    return a && s == 0 && o == i.length ? a.decode(i) : e._bin.readASCII(i, s, o)
                },
                readBytes: function(i, s, o) {
                    for (var a = [], l = 0; l < o; l++) a.push(i[s + l]);
                    return a
                },
                readASCIIArray: function(i, s, o) {
                    for (var a = [], l = 0; l < o; l++) a.push(String.fromCharCode(i[s + l]));
                    return a
                },
                _view: function(i) {
                    return i._dataView || (i._dataView = i.buffer ? new DataView(i.buffer, i.byteOffset, i.byteLength) : new DataView(new Uint8Array(i).buffer))
                }
            }, e._lctf = {}, e._lctf.parse = function(i, s, o, a, l) {
                var c = e._bin,
                    u = {},
                    f = s;
                c.readFixed(i, s), s += 4;
                var d = c.readUshort(i, s);
                s += 2;
                var m = c.readUshort(i, s);
                s += 2;
                var g = c.readUshort(i, s);
                return s += 2, u.scriptList = e._lctf.readScriptList(i, f + d), u.featureList = e._lctf.readFeatureList(i, f + m), u.lookupList = e._lctf.readLookupList(i, f + g, l), u
            }, e._lctf.readLookupList = function(i, s, o) {
                var a = e._bin,
                    l = s,
                    c = [],
                    u = a.readUshort(i, s);
                s += 2;
                for (var f = 0; f < u; f++) {
                    var d = a.readUshort(i, s);
                    s += 2;
                    var m = e._lctf.readLookupTable(i, l + d, o);
                    c.push(m)
                }
                return c
            }, e._lctf.readLookupTable = function(i, s, o) {
                var a = e._bin,
                    l = s,
                    c = {
                        tabs: []
                    };
                c.ltype = a.readUshort(i, s), s += 2, c.flag = a.readUshort(i, s), s += 2;
                var u = a.readUshort(i, s);
                s += 2;
                for (var f = c.ltype, d = 0; d < u; d++) {
                    var m = a.readUshort(i, s);
                    s += 2;
                    var g = o(i, f, l + m, c);
                    c.tabs.push(g)
                }
                return c
            }, e._lctf.numOfOnes = function(i) {
                for (var s = 0, o = 0; o < 32; o++) i >>> o & 1 && s++;
                return s
            }, e._lctf.readClassDef = function(i, s) {
                var o = e._bin,
                    a = [],
                    l = o.readUshort(i, s);
                if (s += 2, l == 1) {
                    var c = o.readUshort(i, s);
                    s += 2;
                    var u = o.readUshort(i, s);
                    s += 2;
                    for (var f = 0; f < u; f++) a.push(c + f), a.push(c + f), a.push(o.readUshort(i, s)), s += 2
                }
                if (l == 2) {
                    var d = o.readUshort(i, s);
                    for (s += 2, f = 0; f < d; f++) a.push(o.readUshort(i, s)), s += 2, a.push(o.readUshort(i, s)), s += 2, a.push(o.readUshort(i, s)), s += 2
                }
                return a
            }, e._lctf.getInterval = function(i, s) {
                for (var o = 0; o < i.length; o += 3) {
                    var a = i[o],
                        l = i[o + 1];
                    if (i[o + 2], a <= s && s <= l) return o
                }
                return -1
            }, e._lctf.readCoverage = function(i, s) {
                var o = e._bin,
                    a = {};
                a.fmt = o.readUshort(i, s), s += 2;
                var l = o.readUshort(i, s);
                return s += 2, a.fmt == 1 && (a.tab = o.readUshorts(i, s, l)), a.fmt == 2 && (a.tab = o.readUshorts(i, s, 3 * l)), a
            }, e._lctf.coverageIndex = function(i, s) {
                var o = i.tab;
                if (i.fmt == 1) return o.indexOf(s);
                if (i.fmt == 2) {
                    var a = e._lctf.getInterval(o, s);
                    if (a != -1) return o[a + 2] + (s - o[a])
                }
                return -1
            }, e._lctf.readFeatureList = function(i, s) {
                var o = e._bin,
                    a = s,
                    l = [],
                    c = o.readUshort(i, s);
                s += 2;
                for (var u = 0; u < c; u++) {
                    var f = o.readASCII(i, s, 4);
                    s += 4;
                    var d = o.readUshort(i, s);
                    s += 2;
                    var m = e._lctf.readFeatureTable(i, a + d);
                    m.tag = f.trim(), l.push(m)
                }
                return l
            }, e._lctf.readFeatureTable = function(i, s) {
                var o = e._bin,
                    a = s,
                    l = {},
                    c = o.readUshort(i, s);
                s += 2, c > 0 && (l.featureParams = a + c);
                var u = o.readUshort(i, s);
                s += 2, l.tab = [];
                for (var f = 0; f < u; f++) l.tab.push(o.readUshort(i, s + 2 * f));
                return l
            }, e._lctf.readScriptList = function(i, s) {
                var o = e._bin,
                    a = s,
                    l = {},
                    c = o.readUshort(i, s);
                s += 2;
                for (var u = 0; u < c; u++) {
                    var f = o.readASCII(i, s, 4);
                    s += 4;
                    var d = o.readUshort(i, s);
                    s += 2, l[f.trim()] = e._lctf.readScriptTable(i, a + d)
                }
                return l
            }, e._lctf.readScriptTable = function(i, s) {
                var o = e._bin,
                    a = s,
                    l = {},
                    c = o.readUshort(i, s);
                s += 2, c > 0 && (l.default = e._lctf.readLangSysTable(i, a + c));
                var u = o.readUshort(i, s);
                s += 2;
                for (var f = 0; f < u; f++) {
                    var d = o.readASCII(i, s, 4);
                    s += 4;
                    var m = o.readUshort(i, s);
                    s += 2, l[d.trim()] = e._lctf.readLangSysTable(i, a + m)
                }
                return l
            }, e._lctf.readLangSysTable = function(i, s) {
                var o = e._bin,
                    a = {};
                o.readUshort(i, s), s += 2, a.reqFeature = o.readUshort(i, s), s += 2;
                var l = o.readUshort(i, s);
                return s += 2, a.features = o.readUshorts(i, s, l), a
            }, e.CFF = {}, e.CFF.parse = function(i, s, o) {
                var a = e._bin;
                (i = new Uint8Array(i.buffer, s, o))[s = 0], i[++s], i[++s], i[++s], s++;
                var l = [];
                s = e.CFF.readIndex(i, s, l);
                for (var c = [], u = 0; u < l.length - 1; u++) c.push(a.readASCII(i, s + l[u], l[u + 1] - l[u]));
                s += l[l.length - 1];
                var f = [];
                s = e.CFF.readIndex(i, s, f);
                var d = [];
                for (u = 0; u < f.length - 1; u++) d.push(e.CFF.readDict(i, s + f[u], s + f[u + 1]));
                s += f[f.length - 1];
                var m = d[0],
                    g = [];
                s = e.CFF.readIndex(i, s, g);
                var y = [];
                for (u = 0; u < g.length - 1; u++) y.push(a.readASCII(i, s + g[u], g[u + 1] - g[u]));
                if (s += g[g.length - 1], e.CFF.readSubrs(i, s, m), m.CharStrings) {
                    s = m.CharStrings, g = [], s = e.CFF.readIndex(i, s, g);
                    var v = [];
                    for (u = 0; u < g.length - 1; u++) v.push(a.readBytes(i, s + g[u], g[u + 1] - g[u]));
                    m.CharStrings = v
                }
                if (m.ROS) {
                    s = m.FDArray;
                    var _ = [];
                    for (s = e.CFF.readIndex(i, s, _), m.FDArray = [], u = 0; u < _.length - 1; u++) {
                        var A = e.CFF.readDict(i, s + _[u], s + _[u + 1]);
                        e.CFF._readFDict(i, A, y), m.FDArray.push(A)
                    }
                    s += _[_.length - 1], s = m.FDSelect, m.FDSelect = [];
                    var S = i[s];
                    if (s++, S != 3) throw S;
                    var M = a.readUshort(i, s);
                    for (s += 2, u = 0; u < M + 1; u++) m.FDSelect.push(a.readUshort(i, s), i[s + 2]), s += 3
                }
                return m.Encoding && (m.Encoding = e.CFF.readEncoding(i, m.Encoding, m.CharStrings.length)), m.charset && (m.charset = e.CFF.readCharset(i, m.charset, m.CharStrings.length)), e.CFF._readFDict(i, m, y), m
            }, e.CFF._readFDict = function(i, s, o) {
                var a;
                for (var l in s.Private && (a = s.Private[1], s.Private = e.CFF.readDict(i, a, a + s.Private[0]), s.Private.Subrs && e.CFF.readSubrs(i, a + s.Private.Subrs, s.Private)), s)["FamilyName", "FontName", "FullName", "Notice", "version", "Copyright"].indexOf(l) != -1 && (s[l] = o[s[l] - 426 + 35])
            }, e.CFF.readSubrs = function(i, s, o) {
                var a = e._bin,
                    l = [];
                s = e.CFF.readIndex(i, s, l);
                var c, u = l.length;
                c = u < 1240 ? 107 : u < 33900 ? 1131 : 32768, o.Bias = c, o.Subrs = [];
                for (var f = 0; f < l.length - 1; f++) o.Subrs.push(a.readBytes(i, s + l[f], l[f + 1] - l[f]))
            }, e.CFF.tableSE = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 106, 107, 108, 109, 110, 0, 111, 112, 113, 114, 0, 115, 116, 117, 118, 119, 120, 121, 122, 0, 123, 0, 124, 125, 126, 127, 128, 129, 130, 131, 0, 132, 133, 0, 134, 135, 136, 137, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 138, 0, 139, 0, 0, 0, 0, 140, 141, 142, 143, 0, 0, 0, 0, 0, 144, 0, 0, 0, 145, 0, 0, 146, 147, 148, 149, 0, 0, 0, 0], e.CFF.glyphByUnicode = function(i, s) {
                for (var o = 0; o < i.charset.length; o++)
                    if (i.charset[o] == s) return o;
                return -1
            }, e.CFF.glyphBySE = function(i, s) {
                return s < 0 || s > 255 ? -1 : e.CFF.glyphByUnicode(i, e.CFF.tableSE[s])
            }, e.CFF.readEncoding = function(i, s, o) {
                e._bin;
                var a = [".notdef"],
                    l = i[s];
                if (s++, l != 0) throw "error: unknown encoding format: " + l;
                var c = i[s];
                s++;
                for (var u = 0; u < c; u++) a.push(i[s + u]);
                return a
            }, e.CFF.readCharset = function(i, s, o) {
                var a = e._bin,
                    l = [".notdef"],
                    c = i[s];
                if (s++, c == 0)
                    for (var u = 0; u < o; u++) {
                        var f = a.readUshort(i, s);
                        s += 2, l.push(f)
                    } else {
                        if (c != 1 && c != 2) throw "error: format: " + c;
                        for (; l.length < o;) {
                            f = a.readUshort(i, s), s += 2;
                            var d = 0;
                            for (c == 1 ? (d = i[s], s++) : (d = a.readUshort(i, s), s += 2), u = 0; u <= d; u++) l.push(f), f++
                        }
                    }
                return l
            }, e.CFF.readIndex = function(i, s, o) {
                var a = e._bin,
                    l = a.readUshort(i, s) + 1,
                    c = i[s += 2];
                if (s++, c == 1)
                    for (var u = 0; u < l; u++) o.push(i[s + u]);
                else if (c == 2)
                    for (u = 0; u < l; u++) o.push(a.readUshort(i, s + 2 * u));
                else if (c == 3)
                    for (u = 0; u < l; u++) o.push(16777215 & a.readUint(i, s + 3 * u - 1));
                else if (l != 1) throw "unsupported offset size: " + c + ", count: " + l;
                return (s += l * c) - 1
            }, e.CFF.getCharString = function(i, s, o) {
                var a = e._bin,
                    l = i[s],
                    c = i[s + 1];
                i[s + 2], i[s + 3], i[s + 4];
                var u = 1,
                    f = null,
                    d = null;
                l <= 20 && (f = l, u = 1), l == 12 && (f = 100 * l + c, u = 2), 21 <= l && l <= 27 && (f = l, u = 1), l == 28 && (d = a.readShort(i, s + 1), u = 3), 29 <= l && l <= 31 && (f = l, u = 1), 32 <= l && l <= 246 && (d = l - 139, u = 1), 247 <= l && l <= 250 && (d = 256 * (l - 247) + c + 108, u = 2), 251 <= l && l <= 254 && (d = 256 * -(l - 251) - c - 108, u = 2), l == 255 && (d = a.readInt(i, s + 1) / 65535, u = 5), o.val = d ? ? "o" + f, o.size = u
            }, e.CFF.readCharString = function(i, s, o) {
                for (var a = s + o, l = e._bin, c = []; s < a;) {
                    var u = i[s],
                        f = i[s + 1];
                    i[s + 2], i[s + 3], i[s + 4];
                    var d = 1,
                        m = null,
                        g = null;
                    u <= 20 && (m = u, d = 1), u == 12 && (m = 100 * u + f, d = 2), u != 19 && u != 20 || (m = u, d = 2), 21 <= u && u <= 27 && (m = u, d = 1), u == 28 && (g = l.readShort(i, s + 1), d = 3), 29 <= u && u <= 31 && (m = u, d = 1), 32 <= u && u <= 246 && (g = u - 139, d = 1), 247 <= u && u <= 250 && (g = 256 * (u - 247) + f + 108, d = 2), 251 <= u && u <= 254 && (g = 256 * -(u - 251) - f - 108, d = 2), u == 255 && (g = l.readInt(i, s + 1) / 65535, d = 5), c.push(g ? ? "o" + m), s += d
                }
                return c
            }, e.CFF.readDict = function(i, s, o) {
                for (var a = e._bin, l = {}, c = []; s < o;) {
                    var u = i[s],
                        f = i[s + 1];
                    i[s + 2], i[s + 3], i[s + 4];
                    var d = 1,
                        m = null,
                        g = null;
                    if (u == 28 && (g = a.readShort(i, s + 1), d = 3), u == 29 && (g = a.readInt(i, s + 1), d = 5), 32 <= u && u <= 246 && (g = u - 139, d = 1), 247 <= u && u <= 250 && (g = 256 * (u - 247) + f + 108, d = 2), 251 <= u && u <= 254 && (g = 256 * -(u - 251) - f - 108, d = 2), u == 255) throw g = a.readInt(i, s + 1) / 65535, d = 5, "unknown number";
                    if (u == 30) {
                        var y = [];
                        for (d = 1;;) {
                            var v = i[s + d];
                            d++;
                            var _ = v >> 4,
                                A = 15 & v;
                            if (_ != 15 && y.push(_), A != 15 && y.push(A), A == 15) break
                        }
                        for (var S = "", M = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, ".", "e", "e-", "reserved", "-", "endOfNumber"], C = 0; C < y.length; C++) S += M[y[C]];
                        g = parseFloat(S)
                    }
                    u <= 21 && (m = ["version", "Notice", "FullName", "FamilyName", "Weight", "FontBBox", "BlueValues", "OtherBlues", "FamilyBlues", "FamilyOtherBlues", "StdHW", "StdVW", "escape", "UniqueID", "XUID", "charset", "Encoding", "CharStrings", "Private", "Subrs", "defaultWidthX", "nominalWidthX"][u], d = 1, u == 12 && (m = ["Copyright", "isFixedPitch", "ItalicAngle", "UnderlinePosition", "UnderlineThickness", "PaintType", "CharstringType", "FontMatrix", "StrokeWidth", "BlueScale", "BlueShift", "BlueFuzz", "StemSnapH", "StemSnapV", "ForceBold", 0, 0, "LanguageGroup", "ExpansionFactor", "initialRandomSeed", "SyntheticBase", "PostScript", "BaseFontName", "BaseFontBlend", 0, 0, 0, 0, 0, 0, "ROS", "CIDFontVersion", "CIDFontRevision", "CIDFontType", "CIDCount", "UIDBase", "FDArray", "FDSelect", "FontName"][f], d = 2)), m != null ? (l[m] = c.length == 1 ? c[0] : c, c = []) : c.push(g), s += d
                }
                return l
            }, e.cmap = {}, e.cmap.parse = function(i, s, o) {
                i = new Uint8Array(i.buffer, s, o), s = 0;
                var a = e._bin,
                    l = {};
                a.readUshort(i, s), s += 2;
                var c = a.readUshort(i, s);
                s += 2;
                var u = [];
                l.tables = [];
                for (var f = 0; f < c; f++) {
                    var d = a.readUshort(i, s);
                    s += 2;
                    var m = a.readUshort(i, s);
                    s += 2;
                    var g = a.readUint(i, s);
                    s += 4;
                    var y = "p" + d + "e" + m,
                        v = u.indexOf(g);
                    if (v == -1) {
                        var _;
                        v = l.tables.length, u.push(g);
                        var A = a.readUshort(i, g);
                        A == 0 ? _ = e.cmap.parse0(i, g) : A == 4 ? _ = e.cmap.parse4(i, g) : A == 6 ? _ = e.cmap.parse6(i, g) : A == 12 ? _ = e.cmap.parse12(i, g) : console.debug("unknown format: " + A, d, m, g), l.tables.push(_)
                    }
                    if (l[y] != null) throw "multiple tables for one platform+encoding";
                    l[y] = v
                }
                return l
            }, e.cmap.parse0 = function(i, s) {
                var o = e._bin,
                    a = {};
                a.format = o.readUshort(i, s), s += 2;
                var l = o.readUshort(i, s);
                s += 2, o.readUshort(i, s), s += 2, a.map = [];
                for (var c = 0; c < l - 6; c++) a.map.push(i[s + c]);
                return a
            }, e.cmap.parse4 = function(i, s) {
                var o = e._bin,
                    a = s,
                    l = {};
                l.format = o.readUshort(i, s), s += 2;
                var c = o.readUshort(i, s);
                s += 2, o.readUshort(i, s), s += 2;
                var u = o.readUshort(i, s);
                s += 2;
                var f = u / 2;
                l.searchRange = o.readUshort(i, s), s += 2, l.entrySelector = o.readUshort(i, s), s += 2, l.rangeShift = o.readUshort(i, s), s += 2, l.endCount = o.readUshorts(i, s, f), s += 2 * f, s += 2, l.startCount = o.readUshorts(i, s, f), s += 2 * f, l.idDelta = [];
                for (var d = 0; d < f; d++) l.idDelta.push(o.readShort(i, s)), s += 2;
                for (l.idRangeOffset = o.readUshorts(i, s, f), s += 2 * f, l.glyphIdArray = []; s < a + c;) l.glyphIdArray.push(o.readUshort(i, s)), s += 2;
                return l
            }, e.cmap.parse6 = function(i, s) {
                var o = e._bin,
                    a = {};
                a.format = o.readUshort(i, s), s += 2, o.readUshort(i, s), s += 2, o.readUshort(i, s), s += 2, a.firstCode = o.readUshort(i, s), s += 2;
                var l = o.readUshort(i, s);
                s += 2, a.glyphIdArray = [];
                for (var c = 0; c < l; c++) a.glyphIdArray.push(o.readUshort(i, s)), s += 2;
                return a
            }, e.cmap.parse12 = function(i, s) {
                var o = e._bin,
                    a = {};
                a.format = o.readUshort(i, s), s += 2, s += 2, o.readUint(i, s), s += 4, o.readUint(i, s), s += 4;
                var l = o.readUint(i, s);
                s += 4, a.groups = [];
                for (var c = 0; c < l; c++) {
                    var u = s + 12 * c,
                        f = o.readUint(i, u + 0),
                        d = o.readUint(i, u + 4),
                        m = o.readUint(i, u + 8);
                    a.groups.push([f, d, m])
                }
                return a
            }, e.glyf = {}, e.glyf.parse = function(i, s, o, a) {
                for (var l = [], c = 0; c < a.maxp.numGlyphs; c++) l.push(null);
                return l
            }, e.glyf._parseGlyf = function(i, s) {
                var o = e._bin,
                    a = i._data,
                    l = e._tabOffset(a, "glyf", i._offset) + i.loca[s];
                if (i.loca[s] == i.loca[s + 1]) return null;
                var c = {};
                if (c.noc = o.readShort(a, l), l += 2, c.xMin = o.readShort(a, l), l += 2, c.yMin = o.readShort(a, l), l += 2, c.xMax = o.readShort(a, l), l += 2, c.yMax = o.readShort(a, l), l += 2, c.xMin >= c.xMax || c.yMin >= c.yMax) return null;
                if (c.noc > 0) {
                    c.endPts = [];
                    for (var u = 0; u < c.noc; u++) c.endPts.push(o.readUshort(a, l)), l += 2;
                    var f = o.readUshort(a, l);
                    if (l += 2, a.length - l < f) return null;
                    c.instructions = o.readBytes(a, l, f), l += f;
                    var d = c.endPts[c.noc - 1] + 1;
                    for (c.flags = [], u = 0; u < d; u++) {
                        var m = a[l];
                        if (l++, c.flags.push(m), (8 & m) != 0) {
                            var g = a[l];
                            l++;
                            for (var y = 0; y < g; y++) c.flags.push(m), u++
                        }
                    }
                    for (c.xs = [], u = 0; u < d; u++) {
                        var v = (2 & c.flags[u]) != 0,
                            _ = (16 & c.flags[u]) != 0;
                        v ? (c.xs.push(_ ? a[l] : -a[l]), l++) : _ ? c.xs.push(0) : (c.xs.push(o.readShort(a, l)), l += 2)
                    }
                    for (c.ys = [], u = 0; u < d; u++) v = (4 & c.flags[u]) != 0, _ = (32 & c.flags[u]) != 0, v ? (c.ys.push(_ ? a[l] : -a[l]), l++) : _ ? c.ys.push(0) : (c.ys.push(o.readShort(a, l)), l += 2);
                    var A = 0,
                        S = 0;
                    for (u = 0; u < d; u++) A += c.xs[u], S += c.ys[u], c.xs[u] = A, c.ys[u] = S
                } else {
                    var M;
                    c.parts = [];
                    do {
                        M = o.readUshort(a, l), l += 2;
                        var C = {
                            m: {
                                a: 1,
                                b: 0,
                                c: 0,
                                d: 1,
                                tx: 0,
                                ty: 0
                            },
                            p1: -1,
                            p2: -1
                        };
                        if (c.parts.push(C), C.glyphIndex = o.readUshort(a, l), l += 2, 1 & M) {
                            var E = o.readShort(a, l);
                            l += 2;
                            var R = o.readShort(a, l);
                            l += 2
                        } else E = o.readInt8(a, l), l++, R = o.readInt8(a, l), l++;
                        2 & M ? (C.m.tx = E, C.m.ty = R) : (C.p1 = E, C.p2 = R), 8 & M ? (C.m.a = C.m.d = o.readF2dot14(a, l), l += 2) : 64 & M ? (C.m.a = o.readF2dot14(a, l), l += 2, C.m.d = o.readF2dot14(a, l), l += 2) : 128 & M && (C.m.a = o.readF2dot14(a, l), l += 2, C.m.b = o.readF2dot14(a, l), l += 2, C.m.c = o.readF2dot14(a, l), l += 2, C.m.d = o.readF2dot14(a, l), l += 2)
                    } while (32 & M);
                    if (256 & M) {
                        var P = o.readUshort(a, l);
                        for (l += 2, c.instr = [], u = 0; u < P; u++) c.instr.push(a[l]), l++
                    }
                }
                return c
            }, e.GDEF = {}, e.GDEF.parse = function(i, s, o, a) {
                var l = s;
                s += 4;
                var c = e._bin.readUshort(i, s);
                return {
                    glyphClassDef: c === 0 ? null : e._lctf.readClassDef(i, l + c)
                }
            }, e.GPOS = {}, e.GPOS.parse = function(i, s, o, a) {
                return e._lctf.parse(i, s, o, a, e.GPOS.subt)
            }, e.GPOS.subt = function(i, s, o, a) {
                var l = e._bin,
                    c = o,
                    u = {};
                if (u.fmt = l.readUshort(i, o), o += 2, s == 1 || s == 2 || s == 3 || s == 7 || s == 8 && u.fmt <= 2) {
                    var f = l.readUshort(i, o);
                    o += 2, u.coverage = e._lctf.readCoverage(i, f + c)
                }
                if (s == 1 && u.fmt == 1) {
                    var d = l.readUshort(i, o);
                    o += 2, d != 0 && (u.pos = e.GPOS.readValueRecord(i, o, d))
                } else if (s == 2 && u.fmt >= 1 && u.fmt <= 2) {
                    d = l.readUshort(i, o), o += 2;
                    var m = l.readUshort(i, o);
                    o += 2;
                    var g = e._lctf.numOfOnes(d),
                        y = e._lctf.numOfOnes(m);
                    if (u.fmt == 1) {
                        u.pairsets = [];
                        var v = l.readUshort(i, o);
                        o += 2;
                        for (var _ = 0; _ < v; _++) {
                            var A = c + l.readUshort(i, o);
                            o += 2;
                            var S = l.readUshort(i, A);
                            A += 2;
                            for (var M = [], C = 0; C < S; C++) {
                                var E = l.readUshort(i, A);
                                A += 2, d != 0 && (D = e.GPOS.readValueRecord(i, A, d), A += 2 * g), m != 0 && (V = e.GPOS.readValueRecord(i, A, m), A += 2 * y), M.push({
                                    gid2: E,
                                    val1: D,
                                    val2: V
                                })
                            }
                            u.pairsets.push(M)
                        }
                    }
                    if (u.fmt == 2) {
                        var R = l.readUshort(i, o);
                        o += 2;
                        var P = l.readUshort(i, o);
                        o += 2;
                        var b = l.readUshort(i, o);
                        o += 2;
                        var T = l.readUshort(i, o);
                        for (o += 2, u.classDef1 = e._lctf.readClassDef(i, c + R), u.classDef2 = e._lctf.readClassDef(i, c + P), u.matrix = [], _ = 0; _ < b; _++) {
                            var L = [];
                            for (C = 0; C < T; C++) {
                                var D = null,
                                    V = null;
                                d != 0 && (D = e.GPOS.readValueRecord(i, o, d), o += 2 * g), m != 0 && (V = e.GPOS.readValueRecord(i, o, m), o += 2 * y), L.push({
                                    val1: D,
                                    val2: V
                                })
                            }
                            u.matrix.push(L)
                        }
                    }
                } else if (s == 4 && u.fmt == 1) u.markCoverage = e._lctf.readCoverage(i, l.readUshort(i, o) + c), u.baseCoverage = e._lctf.readCoverage(i, l.readUshort(i, o + 2) + c), u.markClassCount = l.readUshort(i, o + 4), u.markArray = e.GPOS.readMarkArray(i, l.readUshort(i, o + 6) + c), u.baseArray = e.GPOS.readBaseArray(i, l.readUshort(i, o + 8) + c, u.markClassCount);
                else if (s == 6 && u.fmt == 1) u.mark1Coverage = e._lctf.readCoverage(i, l.readUshort(i, o) + c), u.mark2Coverage = e._lctf.readCoverage(i, l.readUshort(i, o + 2) + c), u.markClassCount = l.readUshort(i, o + 4), u.mark1Array = e.GPOS.readMarkArray(i, l.readUshort(i, o + 6) + c), u.mark2Array = e.GPOS.readBaseArray(i, l.readUshort(i, o + 8) + c, u.markClassCount);
                else {
                    if (s == 9 && u.fmt == 1) {
                        var H = l.readUshort(i, o);
                        o += 2;
                        var q = l.readUint(i, o);
                        if (o += 4, a.ltype == 9) a.ltype = H;
                        else if (a.ltype != H) throw "invalid extension substitution";
                        return e.GPOS.subt(i, a.ltype, c + q)
                    }
                    console.debug("unsupported GPOS table LookupType", s, "format", u.fmt)
                }
                return u
            }, e.GPOS.readValueRecord = function(i, s, o) {
                var a = e._bin,
                    l = [];
                return l.push(1 & o ? a.readShort(i, s) : 0), s += 1 & o ? 2 : 0, l.push(2 & o ? a.readShort(i, s) : 0), s += 2 & o ? 2 : 0, l.push(4 & o ? a.readShort(i, s) : 0), s += 4 & o ? 2 : 0, l.push(8 & o ? a.readShort(i, s) : 0), s += 8 & o ? 2 : 0, l
            }, e.GPOS.readBaseArray = function(i, s, o) {
                var a = e._bin,
                    l = [],
                    c = s,
                    u = a.readUshort(i, s);
                s += 2;
                for (var f = 0; f < u; f++) {
                    for (var d = [], m = 0; m < o; m++) d.push(e.GPOS.readAnchorRecord(i, c + a.readUshort(i, s))), s += 2;
                    l.push(d)
                }
                return l
            }, e.GPOS.readMarkArray = function(i, s) {
                var o = e._bin,
                    a = [],
                    l = s,
                    c = o.readUshort(i, s);
                s += 2;
                for (var u = 0; u < c; u++) {
                    var f = e.GPOS.readAnchorRecord(i, o.readUshort(i, s + 2) + l);
                    f.markClass = o.readUshort(i, s), a.push(f), s += 4
                }
                return a
            }, e.GPOS.readAnchorRecord = function(i, s) {
                var o = e._bin,
                    a = {};
                return a.fmt = o.readUshort(i, s), a.x = o.readShort(i, s + 2), a.y = o.readShort(i, s + 4), a
            }, e.GSUB = {}, e.GSUB.parse = function(i, s, o, a) {
                return e._lctf.parse(i, s, o, a, e.GSUB.subt)
            }, e.GSUB.subt = function(i, s, o, a) {
                var l = e._bin,
                    c = o,
                    u = {};
                if (u.fmt = l.readUshort(i, o), o += 2, s != 1 && s != 2 && s != 4 && s != 5 && s != 6) return null;
                if (s == 1 || s == 2 || s == 4 || s == 5 && u.fmt <= 2 || s == 6 && u.fmt <= 2) {
                    var f = l.readUshort(i, o);
                    o += 2, u.coverage = e._lctf.readCoverage(i, c + f)
                }
                if (s == 1 && u.fmt >= 1 && u.fmt <= 2) {
                    if (u.fmt == 1) u.delta = l.readShort(i, o), o += 2;
                    else if (u.fmt == 2) {
                        var d = l.readUshort(i, o);
                        o += 2, u.newg = l.readUshorts(i, o, d), o += 2 * u.newg.length
                    }
                } else if (s == 2 && u.fmt == 1) {
                    d = l.readUshort(i, o), o += 2, u.seqs = [];
                    for (var m = 0; m < d; m++) {
                        var g = l.readUshort(i, o) + c;
                        o += 2;
                        var y = l.readUshort(i, g);
                        u.seqs.push(l.readUshorts(i, g + 2, y))
                    }
                } else if (s == 4)
                    for (u.vals = [], d = l.readUshort(i, o), o += 2, m = 0; m < d; m++) {
                        var v = l.readUshort(i, o);
                        o += 2, u.vals.push(e.GSUB.readLigatureSet(i, c + v))
                    } else if (s == 5 && u.fmt == 2) {
                        if (u.fmt == 2) {
                            var _ = l.readUshort(i, o);
                            o += 2, u.cDef = e._lctf.readClassDef(i, c + _), u.scset = [];
                            var A = l.readUshort(i, o);
                            for (o += 2, m = 0; m < A; m++) {
                                var S = l.readUshort(i, o);
                                o += 2, u.scset.push(S == 0 ? null : e.GSUB.readSubClassSet(i, c + S))
                            }
                        }
                    } else if (s == 6 && u.fmt == 3) {
                    if (u.fmt == 3) {
                        for (m = 0; m < 3; m++) {
                            d = l.readUshort(i, o), o += 2;
                            for (var M = [], C = 0; C < d; C++) M.push(e._lctf.readCoverage(i, c + l.readUshort(i, o + 2 * C)));
                            o += 2 * d, m == 0 && (u.backCvg = M), m == 1 && (u.inptCvg = M), m == 2 && (u.ahedCvg = M)
                        }
                        d = l.readUshort(i, o), o += 2, u.lookupRec = e.GSUB.readSubstLookupRecords(i, o, d)
                    }
                } else {
                    if (s == 7 && u.fmt == 1) {
                        var E = l.readUshort(i, o);
                        o += 2;
                        var R = l.readUint(i, o);
                        if (o += 4, a.ltype == 9) a.ltype = E;
                        else if (a.ltype != E) throw "invalid extension substitution";
                        return e.GSUB.subt(i, a.ltype, c + R)
                    }
                    console.debug("unsupported GSUB table LookupType", s, "format", u.fmt)
                }
                return u
            }, e.GSUB.readSubClassSet = function(i, s) {
                var o = e._bin.readUshort,
                    a = s,
                    l = [],
                    c = o(i, s);
                s += 2;
                for (var u = 0; u < c; u++) {
                    var f = o(i, s);
                    s += 2, l.push(e.GSUB.readSubClassRule(i, a + f))
                }
                return l
            }, e.GSUB.readSubClassRule = function(i, s) {
                var o = e._bin.readUshort,
                    a = {},
                    l = o(i, s),
                    c = o(i, s += 2);
                s += 2, a.input = [];
                for (var u = 0; u < l - 1; u++) a.input.push(o(i, s)), s += 2;
                return a.substLookupRecords = e.GSUB.readSubstLookupRecords(i, s, c), a
            }, e.GSUB.readSubstLookupRecords = function(i, s, o) {
                for (var a = e._bin.readUshort, l = [], c = 0; c < o; c++) l.push(a(i, s), a(i, s + 2)), s += 4;
                return l
            }, e.GSUB.readChainSubClassSet = function(i, s) {
                var o = e._bin,
                    a = s,
                    l = [],
                    c = o.readUshort(i, s);
                s += 2;
                for (var u = 0; u < c; u++) {
                    var f = o.readUshort(i, s);
                    s += 2, l.push(e.GSUB.readChainSubClassRule(i, a + f))
                }
                return l
            }, e.GSUB.readChainSubClassRule = function(i, s) {
                for (var o = e._bin, a = {}, l = ["backtrack", "input", "lookahead"], c = 0; c < l.length; c++) {
                    var u = o.readUshort(i, s);
                    s += 2, c == 1 && u--, a[l[c]] = o.readUshorts(i, s, u), s += 2 * a[l[c]].length
                }
                return u = o.readUshort(i, s), s += 2, a.subst = o.readUshorts(i, s, 2 * u), s += 2 * a.subst.length, a
            }, e.GSUB.readLigatureSet = function(i, s) {
                var o = e._bin,
                    a = s,
                    l = [],
                    c = o.readUshort(i, s);
                s += 2;
                for (var u = 0; u < c; u++) {
                    var f = o.readUshort(i, s);
                    s += 2, l.push(e.GSUB.readLigature(i, a + f))
                }
                return l
            }, e.GSUB.readLigature = function(i, s) {
                var o = e._bin,
                    a = {
                        chain: []
                    };
                a.nglyph = o.readUshort(i, s), s += 2;
                var l = o.readUshort(i, s);
                s += 2;
                for (var c = 0; c < l - 1; c++) a.chain.push(o.readUshort(i, s)), s += 2;
                return a
            }, e.head = {}, e.head.parse = function(i, s, o) {
                var a = e._bin,
                    l = {};
                return a.readFixed(i, s), s += 4, l.fontRevision = a.readFixed(i, s), s += 4, a.readUint(i, s), s += 4, a.readUint(i, s), s += 4, l.flags = a.readUshort(i, s), s += 2, l.unitsPerEm = a.readUshort(i, s), s += 2, l.created = a.readUint64(i, s), s += 8, l.modified = a.readUint64(i, s), s += 8, l.xMin = a.readShort(i, s), s += 2, l.yMin = a.readShort(i, s), s += 2, l.xMax = a.readShort(i, s), s += 2, l.yMax = a.readShort(i, s), s += 2, l.macStyle = a.readUshort(i, s), s += 2, l.lowestRecPPEM = a.readUshort(i, s), s += 2, l.fontDirectionHint = a.readShort(i, s), s += 2, l.indexToLocFormat = a.readShort(i, s), s += 2, l.glyphDataFormat = a.readShort(i, s), s += 2, l
            }, e.hhea = {}, e.hhea.parse = function(i, s, o) {
                var a = e._bin,
                    l = {};
                return a.readFixed(i, s), s += 4, l.ascender = a.readShort(i, s), s += 2, l.descender = a.readShort(i, s), s += 2, l.lineGap = a.readShort(i, s), s += 2, l.advanceWidthMax = a.readUshort(i, s), s += 2, l.minLeftSideBearing = a.readShort(i, s), s += 2, l.minRightSideBearing = a.readShort(i, s), s += 2, l.xMaxExtent = a.readShort(i, s), s += 2, l.caretSlopeRise = a.readShort(i, s), s += 2, l.caretSlopeRun = a.readShort(i, s), s += 2, l.caretOffset = a.readShort(i, s), s += 2, s += 8, l.metricDataFormat = a.readShort(i, s), s += 2, l.numberOfHMetrics = a.readUshort(i, s), s += 2, l
            }, e.hmtx = {}, e.hmtx.parse = function(i, s, o, a) {
                for (var l = e._bin, c = {
                        aWidth: [],
                        lsBearing: []
                    }, u = 0, f = 0, d = 0; d < a.maxp.numGlyphs; d++) d < a.hhea.numberOfHMetrics && (u = l.readUshort(i, s), s += 2, f = l.readShort(i, s), s += 2), c.aWidth.push(u), c.lsBearing.push(f);
                return c
            }, e.kern = {}, e.kern.parse = function(i, s, o, a) {
                var l = e._bin,
                    c = l.readUshort(i, s);
                if (s += 2, c == 1) return e.kern.parseV1(i, s - 2, o, a);
                var u = l.readUshort(i, s);
                s += 2;
                for (var f = {
                        glyph1: [],
                        rval: []
                    }, d = 0; d < u; d++) {
                    s += 2, o = l.readUshort(i, s), s += 2;
                    var m = l.readUshort(i, s);
                    s += 2;
                    var g = m >>> 8;
                    if ((g &= 15) != 0) throw "unknown kern table format: " + g;
                    s = e.kern.readFormat0(i, s, f)
                }
                return f
            }, e.kern.parseV1 = function(i, s, o, a) {
                var l = e._bin;
                l.readFixed(i, s), s += 4;
                var c = l.readUint(i, s);
                s += 4;
                for (var u = {
                        glyph1: [],
                        rval: []
                    }, f = 0; f < c; f++) {
                    l.readUint(i, s), s += 4;
                    var d = l.readUshort(i, s);
                    s += 2, l.readUshort(i, s), s += 2;
                    var m = d >>> 8;
                    if ((m &= 15) != 0) throw "unknown kern table format: " + m;
                    s = e.kern.readFormat0(i, s, u)
                }
                return u
            }, e.kern.readFormat0 = function(i, s, o) {
                var a = e._bin,
                    l = -1,
                    c = a.readUshort(i, s);
                s += 2, a.readUshort(i, s), s += 2, a.readUshort(i, s), s += 2, a.readUshort(i, s), s += 2;
                for (var u = 0; u < c; u++) {
                    var f = a.readUshort(i, s);
                    s += 2;
                    var d = a.readUshort(i, s);
                    s += 2;
                    var m = a.readShort(i, s);
                    s += 2, f != l && (o.glyph1.push(f), o.rval.push({
                        glyph2: [],
                        vals: []
                    }));
                    var g = o.rval[o.rval.length - 1];
                    g.glyph2.push(d), g.vals.push(m), l = f
                }
                return s
            }, e.loca = {}, e.loca.parse = function(i, s, o, a) {
                var l = e._bin,
                    c = [],
                    u = a.head.indexToLocFormat,
                    f = a.maxp.numGlyphs + 1;
                if (u == 0)
                    for (var d = 0; d < f; d++) c.push(l.readUshort(i, s + (d << 1)) << 1);
                if (u == 1)
                    for (d = 0; d < f; d++) c.push(l.readUint(i, s + (d << 2)));
                return c
            }, e.maxp = {}, e.maxp.parse = function(i, s, o) {
                var a = e._bin,
                    l = {},
                    c = a.readUint(i, s);
                return s += 4, l.numGlyphs = a.readUshort(i, s), s += 2, c == 65536 && (l.maxPoints = a.readUshort(i, s), s += 2, l.maxContours = a.readUshort(i, s), s += 2, l.maxCompositePoints = a.readUshort(i, s), s += 2, l.maxCompositeContours = a.readUshort(i, s), s += 2, l.maxZones = a.readUshort(i, s), s += 2, l.maxTwilightPoints = a.readUshort(i, s), s += 2, l.maxStorage = a.readUshort(i, s), s += 2, l.maxFunctionDefs = a.readUshort(i, s), s += 2, l.maxInstructionDefs = a.readUshort(i, s), s += 2, l.maxStackElements = a.readUshort(i, s), s += 2, l.maxSizeOfInstructions = a.readUshort(i, s), s += 2, l.maxComponentElements = a.readUshort(i, s), s += 2, l.maxComponentDepth = a.readUshort(i, s), s += 2), l
            }, e.name = {}, e.name.parse = function(i, s, o) {
                var a = e._bin,
                    l = {};
                a.readUshort(i, s), s += 2;
                var c = a.readUshort(i, s);
                s += 2, a.readUshort(i, s);
                for (var u, f = ["copyright", "fontFamily", "fontSubfamily", "ID", "fullName", "version", "postScriptName", "trademark", "manufacturer", "designer", "description", "urlVendor", "urlDesigner", "licence", "licenceURL", "---", "typoFamilyName", "typoSubfamilyName", "compatibleFull", "sampleText", "postScriptCID", "wwsFamilyName", "wwsSubfamilyName", "lightPalette", "darkPalette"], d = s += 2, m = 0; m < c; m++) {
                    var g = a.readUshort(i, s);
                    s += 2;
                    var y = a.readUshort(i, s);
                    s += 2;
                    var v = a.readUshort(i, s);
                    s += 2;
                    var _ = a.readUshort(i, s);
                    s += 2;
                    var A = a.readUshort(i, s);
                    s += 2;
                    var S = a.readUshort(i, s);
                    s += 2;
                    var M, C = f[_],
                        E = d + 12 * c + S;
                    if (g == 0) M = a.readUnicode(i, E, A / 2);
                    else if (g == 3 && y == 0) M = a.readUnicode(i, E, A / 2);
                    else if (y == 0) M = a.readASCII(i, E, A);
                    else if (y == 1) M = a.readUnicode(i, E, A / 2);
                    else if (y == 3) M = a.readUnicode(i, E, A / 2);
                    else {
                        if (g != 1) throw "unknown encoding " + y + ", platformID: " + g;
                        M = a.readASCII(i, E, A), console.debug("reading unknown MAC encoding " + y + " as ASCII")
                    }
                    var R = "p" + g + "," + v.toString(16);
                    l[R] == null && (l[R] = {}), l[R][C !== void 0 ? C : _] = M, l[R]._lang = v
                }
                for (var P in l)
                    if (l[P].postScriptName != null && l[P]._lang == 1033) return l[P];
                for (var P in l)
                    if (l[P].postScriptName != null && l[P]._lang == 0) return l[P];
                for (var P in l)
                    if (l[P].postScriptName != null && l[P]._lang == 3084) return l[P];
                for (var P in l)
                    if (l[P].postScriptName != null) return l[P];
                for (var P in l) {
                    u = P;
                    break
                }
                return console.debug("returning name table with languageID " + l[u]._lang), l[u]
            }, e["OS/2"] = {}, e["OS/2"].parse = function(i, s, o) {
                var a = e._bin.readUshort(i, s);
                s += 2;
                var l = {};
                if (a == 0) e["OS/2"].version0(i, s, l);
                else if (a == 1) e["OS/2"].version1(i, s, l);
                else if (a == 2 || a == 3 || a == 4) e["OS/2"].version2(i, s, l);
                else {
                    if (a != 5) throw "unknown OS/2 table version: " + a;
                    e["OS/2"].version5(i, s, l)
                }
                return l
            }, e["OS/2"].version0 = function(i, s, o) {
                var a = e._bin;
                return o.xAvgCharWidth = a.readShort(i, s), s += 2, o.usWeightClass = a.readUshort(i, s), s += 2, o.usWidthClass = a.readUshort(i, s), s += 2, o.fsType = a.readUshort(i, s), s += 2, o.ySubscriptXSize = a.readShort(i, s), s += 2, o.ySubscriptYSize = a.readShort(i, s), s += 2, o.ySubscriptXOffset = a.readShort(i, s), s += 2, o.ySubscriptYOffset = a.readShort(i, s), s += 2, o.ySuperscriptXSize = a.readShort(i, s), s += 2, o.ySuperscriptYSize = a.readShort(i, s), s += 2, o.ySuperscriptXOffset = a.readShort(i, s), s += 2, o.ySuperscriptYOffset = a.readShort(i, s), s += 2, o.yStrikeoutSize = a.readShort(i, s), s += 2, o.yStrikeoutPosition = a.readShort(i, s), s += 2, o.sFamilyClass = a.readShort(i, s), s += 2, o.panose = a.readBytes(i, s, 10), s += 10, o.ulUnicodeRange1 = a.readUint(i, s), s += 4, o.ulUnicodeRange2 = a.readUint(i, s), s += 4, o.ulUnicodeRange3 = a.readUint(i, s), s += 4, o.ulUnicodeRange4 = a.readUint(i, s), s += 4, o.achVendID = [a.readInt8(i, s), a.readInt8(i, s + 1), a.readInt8(i, s + 2), a.readInt8(i, s + 3)], s += 4, o.fsSelection = a.readUshort(i, s), s += 2, o.usFirstCharIndex = a.readUshort(i, s), s += 2, o.usLastCharIndex = a.readUshort(i, s), s += 2, o.sTypoAscender = a.readShort(i, s), s += 2, o.sTypoDescender = a.readShort(i, s), s += 2, o.sTypoLineGap = a.readShort(i, s), s += 2, o.usWinAscent = a.readUshort(i, s), s += 2, o.usWinDescent = a.readUshort(i, s), s += 2
            }, e["OS/2"].version1 = function(i, s, o) {
                var a = e._bin;
                return s = e["OS/2"].version0(i, s, o), o.ulCodePageRange1 = a.readUint(i, s), s += 4, o.ulCodePageRange2 = a.readUint(i, s), s += 4
            }, e["OS/2"].version2 = function(i, s, o) {
                var a = e._bin;
                return s = e["OS/2"].version1(i, s, o), o.sxHeight = a.readShort(i, s), s += 2, o.sCapHeight = a.readShort(i, s), s += 2, o.usDefault = a.readUshort(i, s), s += 2, o.usBreak = a.readUshort(i, s), s += 2, o.usMaxContext = a.readUshort(i, s), s += 2
            }, e["OS/2"].version5 = function(i, s, o) {
                var a = e._bin;
                return s = e["OS/2"].version2(i, s, o), o.usLowerOpticalPointSize = a.readUshort(i, s), s += 2, o.usUpperOpticalPointSize = a.readUshort(i, s), s += 2
            }, e.post = {}, e.post.parse = function(i, s, o) {
                var a = e._bin,
                    l = {};
                return l.version = a.readFixed(i, s), s += 4, l.italicAngle = a.readFixed(i, s), s += 4, l.underlinePosition = a.readShort(i, s), s += 2, l.underlineThickness = a.readShort(i, s), s += 2, l
            }, e == null && (e = {}), e.U == null && (e.U = {}), e.U.codeToGlyph = function(i, s) {
                var o = i.cmap,
                    a = -1;
                if (o.p0e4 != null ? a = o.p0e4 : o.p3e1 != null ? a = o.p3e1 : o.p1e0 != null ? a = o.p1e0 : o.p0e3 != null && (a = o.p0e3), a == -1) throw "no familiar platform and encoding!";
                var l = o.tables[a];
                if (l.format == 0) return s >= l.map.length ? 0 : l.map[s];
                if (l.format == 4) {
                    for (var c = -1, u = 0; u < l.endCount.length; u++)
                        if (s <= l.endCount[u]) {
                            c = u;
                            break
                        }
                    return c == -1 || l.startCount[c] > s ? 0 : 65535 & (l.idRangeOffset[c] != 0 ? l.glyphIdArray[s - l.startCount[c] + (l.idRangeOffset[c] >> 1) - (l.idRangeOffset.length - c)] : s + l.idDelta[c])
                }
                if (l.format == 12) {
                    if (s > l.groups[l.groups.length - 1][1]) return 0;
                    for (u = 0; u < l.groups.length; u++) {
                        var f = l.groups[u];
                        if (f[0] <= s && s <= f[1]) return f[2] + (s - f[0])
                    }
                    return 0
                }
                throw "unknown cmap table format " + l.format
            }, e.U.glyphToPath = function(i, s) {
                var o = {
                    cmds: [],
                    crds: []
                };
                if (i.SVG && i.SVG.entries[s]) {
                    var a = i.SVG.entries[s];
                    return a == null ? o : (typeof a == "string" && (a = e.SVG.toPath(a), i.SVG.entries[s] = a), a)
                }
                if (i.CFF) {
                    var l = {
                            x: 0,
                            y: 0,
                            stack: [],
                            nStems: 0,
                            haveWidth: !1,
                            width: i.CFF.Private ? i.CFF.Private.defaultWidthX : 0,
                            open: !1
                        },
                        c = i.CFF,
                        u = i.CFF.Private;
                    if (c.ROS) {
                        for (var f = 0; c.FDSelect[f + 2] <= s;) f += 2;
                        u = c.FDArray[c.FDSelect[f + 1]].Private
                    }
                    e.U._drawCFF(i.CFF.CharStrings[s], l, c, u, o)
                } else i.glyf && e.U._drawGlyf(s, i, o);
                return o
            }, e.U._drawGlyf = function(i, s, o) {
                var a = s.glyf[i];
                a == null && (a = s.glyf[i] = e.glyf._parseGlyf(s, i)), a != null && (a.noc > -1 ? e.U._simpleGlyph(a, o) : e.U._compoGlyph(a, s, o))
            }, e.U._simpleGlyph = function(i, s) {
                for (var o = 0; o < i.noc; o++) {
                    for (var a = o == 0 ? 0 : i.endPts[o - 1] + 1, l = i.endPts[o], c = a; c <= l; c++) {
                        var u = c == a ? l : c - 1,
                            f = c == l ? a : c + 1,
                            d = 1 & i.flags[c],
                            m = 1 & i.flags[u],
                            g = 1 & i.flags[f],
                            y = i.xs[c],
                            v = i.ys[c];
                        if (c == a)
                            if (d) {
                                if (!m) {
                                    e.U.P.moveTo(s, y, v);
                                    continue
                                }
                                e.U.P.moveTo(s, i.xs[u], i.ys[u])
                            } else m ? e.U.P.moveTo(s, i.xs[u], i.ys[u]) : e.U.P.moveTo(s, (i.xs[u] + y) / 2, (i.ys[u] + v) / 2);
                        d ? m && e.U.P.lineTo(s, y, v) : g ? e.U.P.qcurveTo(s, y, v, i.xs[f], i.ys[f]) : e.U.P.qcurveTo(s, y, v, (y + i.xs[f]) / 2, (v + i.ys[f]) / 2)
                    }
                    e.U.P.closePath(s)
                }
            }, e.U._compoGlyph = function(i, s, o) {
                for (var a = 0; a < i.parts.length; a++) {
                    var l = {
                            cmds: [],
                            crds: []
                        },
                        c = i.parts[a];
                    e.U._drawGlyf(c.glyphIndex, s, l);
                    for (var u = c.m, f = 0; f < l.crds.length; f += 2) {
                        var d = l.crds[f],
                            m = l.crds[f + 1];
                        o.crds.push(d * u.a + m * u.b + u.tx), o.crds.push(d * u.c + m * u.d + u.ty)
                    }
                    for (f = 0; f < l.cmds.length; f++) o.cmds.push(l.cmds[f])
                }
            }, e.U._getGlyphClass = function(i, s) {
                var o = e._lctf.getInterval(s, i);
                return o == -1 ? 0 : s[o + 2]
            }, e.U._applySubs = function(i, s, o, a) {
                for (var l = i.length - s - 1, c = 0; c < o.tabs.length; c++)
                    if (o.tabs[c] != null) {
                        var u, f = o.tabs[c];
                        if (!f.coverage || (u = e._lctf.coverageIndex(f.coverage, i[s])) != -1) {
                            if (o.ltype == 1) i[s], f.fmt == 1 ? i[s] = i[s] + f.delta : i[s] = f.newg[u];
                            else if (o.ltype == 4)
                                for (var d = f.vals[u], m = 0; m < d.length; m++) {
                                    var g = d[m],
                                        y = g.chain.length;
                                    if (!(y > l)) {
                                        for (var v = !0, _ = 0, A = 0; A < y; A++) {
                                            for (; i[s + _ + (1 + A)] == -1;) _++;
                                            g.chain[A] != i[s + _ + (1 + A)] && (v = !1)
                                        }
                                        if (v) {
                                            for (i[s] = g.nglyph, A = 0; A < y + _; A++) i[s + A + 1] = -1;
                                            break
                                        }
                                    }
                                } else if (o.ltype == 5 && f.fmt == 2)
                                    for (var S = e._lctf.getInterval(f.cDef, i[s]), M = f.cDef[S + 2], C = f.scset[M], E = 0; E < C.length; E++) {
                                        var R = C[E],
                                            P = R.input;
                                        if (!(P.length > l)) {
                                            for (v = !0, A = 0; A < P.length; A++) {
                                                var b = e._lctf.getInterval(f.cDef, i[s + 1 + A]);
                                                if (S == -1 && f.cDef[b + 2] != P[A]) {
                                                    v = !1;
                                                    break
                                                }
                                            }
                                            if (v) {
                                                var T = R.substLookupRecords;
                                                for (m = 0; m < T.length; m += 2) T[m], T[m + 1]
                                            }
                                        }
                                    } else if (o.ltype == 6 && f.fmt == 3) {
                                        if (!e.U._glsCovered(i, f.backCvg, s - f.backCvg.length) || !e.U._glsCovered(i, f.inptCvg, s) || !e.U._glsCovered(i, f.ahedCvg, s + f.inptCvg.length)) continue;
                                        var L = f.lookupRec;
                                        for (E = 0; E < L.length; E += 2) {
                                            S = L[E];
                                            var D = a[L[E + 1]];
                                            e.U._applySubs(i, s + S, D, a)
                                        }
                                    }
                        }
                    }
            }, e.U._glsCovered = function(i, s, o) {
                for (var a = 0; a < s.length; a++)
                    if (e._lctf.coverageIndex(s[a], i[o + a]) == -1) return !1;
                return !0
            }, e.U.glyphsToPath = function(i, s, o) {
                for (var a = {
                        cmds: [],
                        crds: []
                    }, l = 0, c = 0; c < s.length; c++) {
                    var u = s[c];
                    if (u != -1) {
                        for (var f = c < s.length - 1 && s[c + 1] != -1 ? s[c + 1] : 0, d = e.U.glyphToPath(i, u), m = 0; m < d.crds.length; m += 2) a.crds.push(d.crds[m] + l), a.crds.push(d.crds[m + 1]);
                        for (o && a.cmds.push(o), m = 0; m < d.cmds.length; m++) a.cmds.push(d.cmds[m]);
                        o && a.cmds.push("X"), l += i.hmtx.aWidth[u], c < s.length - 1 && (l += e.U.getPairAdjustment(i, u, f))
                    }
                }
                return a
            }, e.U.P = {}, e.U.P.moveTo = function(i, s, o) {
                i.cmds.push("M"), i.crds.push(s, o)
            }, e.U.P.lineTo = function(i, s, o) {
                i.cmds.push("L"), i.crds.push(s, o)
            }, e.U.P.curveTo = function(i, s, o, a, l, c, u) {
                i.cmds.push("C"), i.crds.push(s, o, a, l, c, u)
            }, e.U.P.qcurveTo = function(i, s, o, a, l) {
                i.cmds.push("Q"), i.crds.push(s, o, a, l)
            }, e.U.P.closePath = function(i) {
                i.cmds.push("Z")
            }, e.U._drawCFF = function(i, s, o, a, l) {
                for (var c = s.stack, u = s.nStems, f = s.haveWidth, d = s.width, m = s.open, g = 0, y = s.x, v = s.y, _ = 0, A = 0, S = 0, M = 0, C = 0, E = 0, R = 0, P = 0, b = 0, T = 0, L = {
                        val: 0,
                        size: 0
                    }; g < i.length;) {
                    e.CFF.getCharString(i, g, L);
                    var D = L.val;
                    if (g += L.size, D == "o1" || D == "o18") c.length % 2 != 0 && !f && (d = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, f = !0;
                    else if (D == "o3" || D == "o23") c.length % 2 != 0 && !f && (d = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, f = !0;
                    else if (D == "o4") c.length > 1 && !f && (d = c.shift() + a.nominalWidthX, f = !0), m && e.U.P.closePath(l), v += c.pop(), e.U.P.moveTo(l, y, v), m = !0;
                    else if (D == "o5")
                        for (; c.length > 0;) y += c.shift(), v += c.shift(), e.U.P.lineTo(l, y, v);
                    else if (D == "o6" || D == "o7")
                        for (var V = c.length, H = D == "o6", q = 0; q < V; q++) {
                            var X = c.shift();
                            H ? y += X : v += X, H = !H, e.U.P.lineTo(l, y, v)
                        } else if (D == "o8" || D == "o24") {
                            V = c.length;
                            for (var oe = 0; oe + 6 <= V;) _ = y + c.shift(), A = v + c.shift(), S = _ + c.shift(), M = A + c.shift(), y = S + c.shift(), v = M + c.shift(), e.U.P.curveTo(l, _, A, S, M, y, v), oe += 6;
                            D == "o24" && (y += c.shift(), v += c.shift(), e.U.P.lineTo(l, y, v))
                        } else {
                            if (D == "o11") break;
                            if (D == "o1234" || D == "o1235" || D == "o1236" || D == "o1237") D == "o1234" && (A = v, S = (_ = y + c.shift()) + c.shift(), T = M = A + c.shift(), E = M, P = v, y = (R = (C = (b = S + c.shift()) + c.shift()) + c.shift()) + c.shift(), e.U.P.curveTo(l, _, A, S, M, b, T), e.U.P.curveTo(l, C, E, R, P, y, v)), D == "o1235" && (_ = y + c.shift(), A = v + c.shift(), S = _ + c.shift(), M = A + c.shift(), b = S + c.shift(), T = M + c.shift(), C = b + c.shift(), E = T + c.shift(), R = C + c.shift(), P = E + c.shift(), y = R + c.shift(), v = P + c.shift(), c.shift(), e.U.P.curveTo(l, _, A, S, M, b, T), e.U.P.curveTo(l, C, E, R, P, y, v)), D == "o1236" && (_ = y + c.shift(), A = v + c.shift(), S = _ + c.shift(), T = M = A + c.shift(), E = M, R = (C = (b = S + c.shift()) + c.shift()) + c.shift(), P = E + c.shift(), y = R + c.shift(), e.U.P.curveTo(l, _, A, S, M, b, T), e.U.P.curveTo(l, C, E, R, P, y, v)), D == "o1237" && (_ = y + c.shift(), A = v + c.shift(), S = _ + c.shift(), M = A + c.shift(), b = S + c.shift(), T = M + c.shift(), C = b + c.shift(), E = T + c.shift(), R = C + c.shift(), P = E + c.shift(), Math.abs(R - y) > Math.abs(P - v) ? y = R + c.shift() : v = P + c.shift(), e.U.P.curveTo(l, _, A, S, M, b, T), e.U.P.curveTo(l, C, E, R, P, y, v));
                            else if (D == "o14") {
                                if (c.length > 0 && !f && (d = c.shift() + o.nominalWidthX, f = !0), c.length == 4) {
                                    var Y = c.shift(),
                                        Z = c.shift(),
                                        U = c.shift(),
                                        j = c.shift(),
                                        te = e.CFF.glyphBySE(o, U),
                                        he = e.CFF.glyphBySE(o, j);
                                    e.U._drawCFF(o.CharStrings[te], s, o, a, l), s.x = Y, s.y = Z, e.U._drawCFF(o.CharStrings[he], s, o, a, l)
                                }
                                m && (e.U.P.closePath(l), m = !1)
                            } else if (D == "o19" || D == "o20") c.length % 2 != 0 && !f && (d = c.shift() + a.nominalWidthX), u += c.length >> 1, c.length = 0, f = !0, g += u + 7 >> 3;
                            else if (D == "o21") c.length > 2 && !f && (d = c.shift() + a.nominalWidthX, f = !0), v += c.pop(), y += c.pop(), m && e.U.P.closePath(l), e.U.P.moveTo(l, y, v), m = !0;
                            else if (D == "o22") c.length > 1 && !f && (d = c.shift() + a.nominalWidthX, f = !0), y += c.pop(), m && e.U.P.closePath(l), e.U.P.moveTo(l, y, v), m = !0;
                            else if (D == "o25") {
                                for (; c.length > 6;) y += c.shift(), v += c.shift(), e.U.P.lineTo(l, y, v);
                                _ = y + c.shift(), A = v + c.shift(), S = _ + c.shift(), M = A + c.shift(), y = S + c.shift(), v = M + c.shift(), e.U.P.curveTo(l, _, A, S, M, y, v)
                            } else if (D == "o26")
                                for (c.length % 2 && (y += c.shift()); c.length > 0;) _ = y, A = v + c.shift(), y = S = _ + c.shift(), v = (M = A + c.shift()) + c.shift(), e.U.P.curveTo(l, _, A, S, M, y, v);
                            else if (D == "o27")
                                for (c.length % 2 && (v += c.shift()); c.length > 0;) A = v, S = (_ = y + c.shift()) + c.shift(), M = A + c.shift(), y = S + c.shift(), v = M, e.U.P.curveTo(l, _, A, S, M, y, v);
                            else if (D == "o10" || D == "o29") {
                                var $ = D == "o10" ? a : o;
                                if (c.length == 0) console.debug("error: empty stack");
                                else {
                                    var ne = c.pop(),
                                        me = $.Subrs[ne + $.Bias];
                                    s.x = y, s.y = v, s.nStems = u, s.haveWidth = f, s.width = d, s.open = m, e.U._drawCFF(me, s, o, a, l), y = s.x, v = s.y, u = s.nStems, f = s.haveWidth, d = s.width, m = s.open
                                }
                            } else if (D == "o30" || D == "o31") {
                                var ce = c.length,
                                    _e = (oe = 0, D == "o31");
                                for (oe += ce - (V = -3 & ce); oe < V;) _e ? (A = v, S = (_ = y + c.shift()) + c.shift(), v = (M = A + c.shift()) + c.shift(), V - oe == 5 ? (y = S + c.shift(), oe++) : y = S, _e = !1) : (_ = y, A = v + c.shift(), S = _ + c.shift(), M = A + c.shift(), y = S + c.shift(), V - oe == 5 ? (v = M + c.shift(), oe++) : v = M, _e = !0), e.U.P.curveTo(l, _, A, S, M, y, v), oe += 4
                            } else {
                                if ((D + "").charAt(0) == "o") throw console.debug("Unknown operation: " + D, i), D;
                                c.push(D)
                            }
                        }
                }
                s.x = y, s.y = v, s.nStems = u, s.haveWidth = f, s.width = d, s.open = m
            };
            var t = e,
                n = {
                    Typr: t
                };
            return r.Typr = t, r.default = n, Object.defineProperty(r, "__esModule", {
                value: !0
            }), r
        }({}).Typr
}
/*!
Custom bundle of woff2otf (https://github.com/arty-name/woff2otf) with fflate
(https://github.com/101arrowz/fflate) for use in Troika text rendering. 
Original licenses apply: 
- fflate: https://github.com/101arrowz/fflate/blob/master/LICENSE (MIT)
- woff2otf.js: https://github.com/arty-name/woff2otf/blob/master/woff2otf.js (Apache2)
*/
function B9() {
    return function(r) {
        var e = Uint8Array,
            t = Uint16Array,
            n = Uint32Array,
            i = new e([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 0, 0, 0]),
            s = new e([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13, 0, 0]),
            o = new e([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]),
            a = function(D, V) {
                for (var H = new t(31), q = 0; q < 31; ++q) H[q] = V += 1 << D[q - 1];
                var X = new n(H[30]);
                for (q = 1; q < 30; ++q)
                    for (var oe = H[q]; oe < H[q + 1]; ++oe) X[oe] = oe - H[q] << 5 | q;
                return [H, X]
            },
            l = a(i, 2),
            c = l[0],
            u = l[1];
        c[28] = 258, u[258] = 28;
        for (var f = a(s, 0)[0], d = new t(32768), m = 0; m < 32768; ++m) {
            var g = (43690 & m) >>> 1 | (21845 & m) << 1;
            g = (61680 & (g = (52428 & g) >>> 2 | (13107 & g) << 2)) >>> 4 | (3855 & g) << 4, d[m] = ((65280 & g) >>> 8 | (255 & g) << 8) >>> 1
        }
        var y = function(D, V, H) {
                for (var q = D.length, X = 0, oe = new t(V); X < q; ++X) ++oe[D[X] - 1];
                var Y, Z = new t(V);
                for (X = 0; X < V; ++X) Z[X] = Z[X - 1] + oe[X - 1] << 1; {
                    Y = new t(1 << V);
                    var U = 15 - V;
                    for (X = 0; X < q; ++X)
                        if (D[X])
                            for (var j = X << 4 | D[X], te = V - D[X], he = Z[D[X] - 1]++ << te, $ = he | (1 << te) - 1; he <= $; ++he) Y[d[he] >>> U] = j
                }
                return Y
            },
            v = new e(288);
        for (m = 0; m < 144; ++m) v[m] = 8;
        for (m = 144; m < 256; ++m) v[m] = 9;
        for (m = 256; m < 280; ++m) v[m] = 7;
        for (m = 280; m < 288; ++m) v[m] = 8;
        var _ = new e(32);
        for (m = 0; m < 32; ++m) _[m] = 5;
        var A = y(v, 9),
            S = y(_, 5),
            M = function(D) {
                for (var V = D[0], H = 1; H < D.length; ++H) D[H] > V && (V = D[H]);
                return V
            },
            C = function(D, V, H) {
                var q = V / 8 | 0;
                return (D[q] | D[q + 1] << 8) >> (7 & V) & H
            },
            E = function(D, V) {
                var H = V / 8 | 0;
                return (D[H] | D[H + 1] << 8 | D[H + 2] << 16) >> (7 & V)
            },
            R = ["unexpected EOF", "invalid block type", "invalid length/literal", "invalid distance", "stream finished", "no stream handler", , "no callback", "invalid UTF-8 data", "extra field too long", "date not in range 1980-2099", "filename too long", "stream finishing", "invalid zip data"],
            P = function(D, V, H) {
                var q = new Error(V || R[D]);
                if (q.code = D, Error.captureStackTrace && Error.captureStackTrace(q, P), !H) throw q;
                return q
            },
            b = function(D, V, H) {
                var q = D.length;
                if (!q || H && !H.l && q < 5) return V || new e(0);
                var X = !V || H,
                    oe = !H || H.i;
                H || (H = {}), V || (V = new e(3 * q));
                var Y, Z = function(We) {
                        var yt = V.length;
                        if (We > yt) {
                            var at = new e(Math.max(2 * yt, We));
                            at.set(V), V = at
                        }
                    },
                    U = H.f || 0,
                    j = H.p || 0,
                    te = H.b || 0,
                    he = H.l,
                    $ = H.d,
                    ne = H.m,
                    me = H.n,
                    ce = 8 * q;
                do {
                    if (!he) {
                        H.f = U = C(D, j, 1);
                        var _e = C(D, j + 1, 3);
                        if (j += 3, !_e) {
                            var Oe = D[(Le = ((Y = j) / 8 | 0) + (7 & Y && 1) + 4) - 4] | D[Le - 3] << 8,
                                ke = Le + Oe;
                            if (ke > q) {
                                oe && P(0);
                                break
                            }
                            X && Z(te + Oe), V.set(D.subarray(Le, ke), te), H.b = te += Oe, H.p = j = 8 * ke;
                            continue
                        }
                        if (_e == 1) he = A, $ = S, ne = 9, me = 5;
                        else if (_e == 2) {
                            var Ee = C(D, j, 31) + 257,
                                pe = C(D, j + 10, 15) + 4,
                                xe = Ee + C(D, j + 5, 31) + 1;
                            j += 14;
                            for (var J = new e(xe), De = new e(19), Ce = 0; Ce < pe; ++Ce) De[o[Ce]] = C(D, j + 3 * Ce, 7);
                            j += 3 * pe;
                            var se = M(De),
                                Se = (1 << se) - 1,
                                Xe = y(De, se);
                            for (Ce = 0; Ce < xe;) {
                                var Le, k = Xe[C(D, j, Se)];
                                if (j += 15 & k, (Le = k >>> 4) < 16) J[Ce++] = Le;
                                else {
                                    var z = 0,
                                        ue = 0;
                                    for (Le == 16 ? (ue = 3 + C(D, j, 3), j += 2, z = J[Ce - 1]) : Le == 17 ? (ue = 3 + C(D, j, 7), j += 3) : Le == 18 && (ue = 11 + C(D, j, 127), j += 7); ue--;) J[Ce++] = z
                                }
                            }
                            var ye = J.subarray(0, Ee),
                                ge = J.subarray(Ee);
                            ne = M(ye), me = M(ge), he = y(ye, ne), $ = y(ge, me)
                        } else P(1);
                        if (j > ce) {
                            oe && P(0);
                            break
                        }
                    }
                    X && Z(te + 131072);
                    for (var Re = (1 << ne) - 1, Be = (1 << me) - 1, Fe = j;; Fe = j) {
                        var Ne = (z = he[E(D, j) & Re]) >>> 4;
                        if ((j += 15 & z) > ce) {
                            oe && P(0);
                            break
                        }
                        if (z || P(2), Ne < 256) V[te++] = Ne;
                        else {
                            if (Ne == 256) {
                                Fe = j, he = null;
                                break
                            }
                            var ot = Ne - 254;
                            if (Ne > 264) {
                                var je = i[Ce = Ne - 257];
                                ot = C(D, j, (1 << je) - 1) + c[Ce], j += je
                            }
                            var Ze = $[E(D, j) & Be],
                                it = Ze >>> 4;
                            if (Ze || P(3), j += 15 & Ze, ge = f[it], it > 3 && (je = s[it], ge += E(D, j) & (1 << je) - 1, j += je), j > ce) {
                                oe && P(0);
                                break
                            }
                            X && Z(te + 131072);
                            for (var $e = te + ot; te < $e; te += 4) V[te] = V[te - ge], V[te + 1] = V[te + 1 - ge], V[te + 2] = V[te + 2 - ge], V[te + 3] = V[te + 3 - ge];
                            te = $e
                        }
                    }
                    H.l = he, H.p = Fe, H.b = te, he && (U = 1, H.m = ne, H.d = $, H.n = me)
                } while (!U);
                return te == V.length ? V : function(We, yt, at) {
                    (at == null || at > We.length) && (at = We.length);
                    var Mt = new(We instanceof t ? t : We instanceof n ? n : e)(at - yt);
                    return Mt.set(We.subarray(yt, at)), Mt
                }(V, 0, te)
            },
            T = new e(0),
            L = typeof TextDecoder < "u" && new TextDecoder;
        try {
            L.decode(T, {
                stream: !0
            })
        } catch {}
        return r.convert_streams = function(D) {
            var V = new DataView(D),
                H = 0;

            function q() {
                var Ee = V.getUint16(H);
                return H += 2, Ee
            }

            function X() {
                var Ee = V.getUint32(H);
                return H += 4, Ee
            }

            function oe(Ee) {
                Oe.setUint16(ke, Ee), ke += 2
            }

            function Y(Ee) {
                Oe.setUint32(ke, Ee), ke += 4
            }
            for (var Z = {
                    signature: X(),
                    flavor: X(),
                    length: X(),
                    numTables: q(),
                    reserved: q(),
                    totalSfntSize: X(),
                    majorVersion: q(),
                    minorVersion: q(),
                    metaOffset: X(),
                    metaLength: X(),
                    metaOrigLength: X(),
                    privOffset: X(),
                    privLength: X()
                }, U = 0; Math.pow(2, U) <= Z.numTables;) U++;
            U--;
            for (var j = 16 * Math.pow(2, U), te = 16 * Z.numTables - j, he = 12, $ = [], ne = 0; ne < Z.numTables; ne++) $.push({
                tag: X(),
                offset: X(),
                compLength: X(),
                origLength: X(),
                origChecksum: X()
            }), he += 16;
            var me, ce = new Uint8Array(12 + 16 * $.length + $.reduce(function(Ee, pe) {
                    return Ee + pe.origLength + 4
                }, 0)),
                _e = ce.buffer,
                Oe = new DataView(_e),
                ke = 0;
            return Y(Z.flavor), oe(Z.numTables), oe(j), oe(U), oe(te), $.forEach(function(Ee) {
                Y(Ee.tag), Y(Ee.origChecksum), Y(he), Y(Ee.origLength), Ee.outOffset = he, (he += Ee.origLength) % 4 != 0 && (he += 4 - he % 4)
            }), $.forEach(function(Ee) {
                var pe, xe = D.slice(Ee.offset, Ee.offset + Ee.compLength);
                if (Ee.compLength != Ee.origLength) {
                    var J = new Uint8Array(Ee.origLength);
                    pe = new Uint8Array(xe, 2), b(pe, J)
                } else J = new Uint8Array(xe);
                ce.set(J, Ee.outOffset);
                var De = 0;
                (he = Ee.outOffset + Ee.origLength) % 4 != 0 && (De = 4 - he % 4), ce.set(new Uint8Array(De).buffer, Ee.outOffset + Ee.origLength), me = he + De
            }), _e.slice(0, me)
        }, Object.defineProperty(r, "__esModule", {
            value: !0
        }), r
    }({}).convert_streams
}

function D9(r, e) {
    const t = {
            M: 2,
            L: 2,
            Q: 4,
            C: 6,
            Z: 0
        },
        n = {
            C: "18g,ca,368,1kz",
            D: "17k,6,2,2+4,5+c,2+6,2+1,10+1,9+f,j+11,2+1,a,2,2+1,15+2,3,j+2,6+3,2+8,2,2,2+1,w+a,4+e,3+3,2,3+2,3+5,23+w,2f+4,3,2+9,2,b,2+3,3,1k+9,6+1,3+1,2+2,2+d,30g,p+y,1,1+1g,f+x,2,sd2+1d,jf3+4,f+3,2+4,2+2,b+3,42,2,4+2,2+1,2,3,t+1,9f+w,2,el+2,2+g,d+2,2l,2+1,5,3+1,2+1,2,3,6,16wm+1v",
            R: "17m+3,2,2,6+3,m,15+2,2+2,h+h,13,3+8,2,2,3+1,2,p+1,x,5+4,5,a,2,2,3,u,c+2,g+1,5,2+1,4+1,5j,6+1,2,b,2+2,f,2+1,1s+2,2,3+1,7,1ez0,2,2+1,4+4,b,4,3,b,42,2+2,4,3,2+1,2,o+3,ae,ep,x,2o+2,3+1,3,5+1,6",
            L: "x9u,jff,a,fd,jv",
            T: "4t,gj+33,7o+4,1+1,7c+18,2,2+1,2+1,2,21+a,2,1b+k,h,2u+6,3+5,3+1,2+3,y,2,v+q,2k+a,1n+8,a,p+3,2+8,2+2,2+4,18+2,3c+e,2+v,1k,2,5+7,5,4+6,b+1,u,1n,5+3,9,l+1,r,3+1,1m,5+1,5+1,3+2,4,v+1,4,c+1,1m,5+4,2+1,5,l+1,n+5,2,1n,3,2+3,9,8+1,c+1,v,1q,d,1f,4,1m+2,6+2,2+3,8+1,c+1,u,1n,3,7,6+1,l+1,t+1,1m+1,5+3,9,l+1,u,21,8+2,2,2j,3+6,d+7,2r,3+8,c+5,23+1,s,2,2,1k+d,2+4,2+1,6+a,2+z,a,2v+3,2+5,2+1,3+1,q+1,5+2,h+3,e,3+1,7,g,jk+2,qb+2,u+2,u+1,v+1,1t+1,2+6,9,3+a,a,1a+2,3c+1,z,3b+2,5+1,a,7+2,64+1,3,1n,2+6,2,2,3+7,7+9,3,1d+d,1,1+1,1s+3,1d,2+4,2,6,15+8,d+1,x+3,3+1,2+2,1l,2+1,4,2+2,1n+7,3+1,49+2,2+c,2+6,5,7,4+1,5j+1l,2+4,ek,3+1,r+4,1e+4,6+5,2p+c,1+3,1,1+2,1+b,2db+2,3y,2p+v,ff+3,30+1,n9x,1+2,2+9,x+1,29+1,7l,4,5,q+1,6,48+1,r+h,e,13+7,q+a,1b+2,1d,3+3,3+1,14,1w+5,3+1,3+1,d,9,1c,1g,2+2,3+1,6+1,2,17+1,9,6n,3,5,fn5,ki+f,h+f,5s,6y+2,ea,6b,46+4,1af+2,2+1,6+3,15+2,5,4m+1,fy+3,as+1,4a+a,4x,1j+e,1l+2,1e+3,3+1,1y+2,11+4,2+7,1r,d+1,1h+8,b+3,3,2o+2,3,2+1,7,4h,4+7,m+1,1m+1,4,12+6,4+4,5g+7,3+2,2,o,2d+5,2,5+1,2+1,6n+3,7+1,2+1,s+1,2e+7,3,2+1,2z,2,3+5,2,2u+2,3+3,2+4,78+8,2+1,75+1,2,5,41+3,3+1,5,x+9,15+5,3+3,9,a+5,3+2,1b+c,2+1,bb+6,2+5,2,2b+l,3+6,2+1,2+1,3f+5,4,2+1,2+6,2,21+1,4,2,9o+1,470+8,at4+4,1o+6,t5,1s+3,2a,f5l+1,2+3,43o+2,a+7,1+7,3+6,v+3,45+2,1j0+1i,5+1d,9,f,n+4,2+e,11t+6,2+g,3+6,2+1,2+4,7a+6,c6+3,15t+6,32+6,1,gzau,v+2n,3l+6n"
        },
        i = 1,
        s = 2,
        o = 4,
        a = 8,
        l = 16,
        c = 32;
    let u;

    function f(R) {
        if (!u) {
            const P = {
                R: s,
                L: i,
                D: o,
                C: l,
                U: c,
                T: a
            };
            u = new Map;
            for (let b in n) {
                let T = 0;
                n[b].split(",").forEach(L => {
                    let [D, V] = L.split("+");
                    D = parseInt(D, 36), V = V ? parseInt(V, 36) : 0, u.set(T += D, P[b]);
                    for (let H = V; H--;) u.set(++T, P[b])
                })
            }
        }
        return u.get(R) || c
    }
    const d = 1,
        m = 2,
        g = 3,
        y = 4,
        v = [null, "isol", "init", "fina", "medi"];

    function _(R) {
        const P = new Uint8Array(R.length);
        let b = c,
            T = d,
            L = -1;
        for (let D = 0; D < R.length; D++) {
            const V = R.codePointAt(D);
            let H = f(V) | 0,
                q = d;
            H & a || (b & (i | o | l) ? H & (s | o | l) ? (q = g, (T === d || T === g) && P[L]++) : H & (i | c) && (T === m || T === y) && P[L]-- : b & (s | c) && (T === m || T === y) && P[L]--, T = P[D] = q, b = H, L = D, V > 65535 && D++)
        }
        return P
    }

    function A(R, P) {
        const b = [];
        for (let L = 0; L < P.length; L++) {
            const D = P.codePointAt(L);
            D > 65535 && L++, b.push(r.U.codeToGlyph(R, D))
        }
        const T = R.GSUB;
        if (T) {
            const {
                lookupList: L,
                featureList: D
            } = T;
            let V;
            const H = /^(rlig|liga|mset|isol|init|fina|medi|half|pres|blws|ccmp)$/,
                q = [];
            D.forEach(X => {
                if (H.test(X.tag))
                    for (let oe = 0; oe < X.tab.length; oe++) {
                        if (q[X.tab[oe]]) continue;
                        q[X.tab[oe]] = !0;
                        const Y = L[X.tab[oe]],
                            Z = /^(isol|init|fina|medi)$/.test(X.tag);
                        Z && !V && (V = _(P));
                        for (let U = 0; U < b.length; U++)(!V || !Z || v[V[U]] === X.tag) && r.U._applySubs(b, U, Y, L)
                    }
            })
        }
        return b
    }

    function S(R, P) {
        const b = new Int16Array(P.length * 3);
        let T = 0;
        for (; T < P.length; T++) {
            const H = P[T];
            if (H === -1) continue;
            b[T * 3 + 2] = R.hmtx.aWidth[H];
            const q = R.GPOS;
            if (q) {
                const X = q.lookupList;
                for (let oe = 0; oe < X.length; oe++) {
                    const Y = X[oe];
                    for (let Z = 0; Z < Y.tabs.length; Z++) {
                        const U = Y.tabs[Z];
                        if (Y.ltype === 1) {
                            if (r._lctf.coverageIndex(U.coverage, H) !== -1 && U.pos) {
                                V(U.pos, T);
                                break
                            }
                        } else if (Y.ltype === 2) {
                            let j = null,
                                te = L();
                            if (te !== -1) {
                                const he = r._lctf.coverageIndex(U.coverage, P[te]);
                                if (he !== -1) {
                                    if (U.fmt === 1) {
                                        const $ = U.pairsets[he];
                                        for (let ne = 0; ne < $.length; ne++) $[ne].gid2 === H && (j = $[ne])
                                    } else if (U.fmt === 2) {
                                        const $ = r.U._getGlyphClass(P[te], U.classDef1),
                                            ne = r.U._getGlyphClass(H, U.classDef2);
                                        j = U.matrix[$][ne]
                                    }
                                    if (j) {
                                        j.val1 && V(j.val1, te), j.val2 && V(j.val2, T);
                                        break
                                    }
                                }
                            }
                        } else if (Y.ltype === 4) {
                            const j = r._lctf.coverageIndex(U.markCoverage, H);
                            if (j !== -1) {
                                const te = L(D),
                                    he = te === -1 ? -1 : r._lctf.coverageIndex(U.baseCoverage, P[te]);
                                if (he !== -1) {
                                    const $ = U.markArray[j],
                                        ne = U.baseArray[he][$.markClass];
                                    b[T * 3] = ne.x - $.x + b[te * 3] - b[te * 3 + 2], b[T * 3 + 1] = ne.y - $.y + b[te * 3 + 1];
                                    break
                                }
                            }
                        } else if (Y.ltype === 6) {
                            const j = r._lctf.coverageIndex(U.mark1Coverage, H);
                            if (j !== -1) {
                                const te = L();
                                if (te !== -1) {
                                    const he = P[te];
                                    if (M(R, he) === 3) {
                                        const $ = r._lctf.coverageIndex(U.mark2Coverage, he);
                                        if ($ !== -1) {
                                            const ne = U.mark1Array[j],
                                                me = U.mark2Array[$][ne.markClass];
                                            b[T * 3] = me.x - ne.x + b[te * 3] - b[te * 3 + 2], b[T * 3 + 1] = me.y - ne.y + b[te * 3 + 1];
                                            break
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            } else if (R.kern && !R.cff) {
                const X = L();
                if (X !== -1) {
                    const oe = R.kern.glyph1.indexOf(P[X]);
                    if (oe !== -1) {
                        const Y = R.kern.rval[oe].glyph2.indexOf(H);
                        Y !== -1 && (b[X * 3 + 2] += R.kern.rval[oe].vals[Y])
                    }
                }
            }
        }
        return b;

        function L(H) {
            for (let q = T - 1; q >= 0; q--)
                if (P[q] !== -1 && (!H || H(P[q]))) return q;
            return -1
        }

        function D(H) {
            return M(R, H) === 1
        }

        function V(H, q) {
            for (let X = 0; X < 3; X++) b[q * 3 + X] += H[X] || 0
        }
    }

    function M(R, P) {
        const b = R.GDEF && R.GDEF.glyphClassDef;
        return b ? r.U._getGlyphClass(P, b) : 0
    }

    function C(...R) {
        for (let P = 0; P < R.length; P++)
            if (typeof R[P] == "number") return R[P]
    }

    function E(R) {
        const P = Object.create(null),
            b = R["OS/2"],
            T = R.hhea,
            L = R.head.unitsPerEm,
            D = C(b && b.sTypoAscender, T && T.ascender, L),
            V = {
                unitsPerEm: L,
                ascender: D,
                descender: C(b && b.sTypoDescender, T && T.descender, 0),
                capHeight: C(b && b.sCapHeight, D),
                xHeight: C(b && b.sxHeight, D),
                lineGap: C(b && b.sTypoLineGap, T && T.lineGap),
                supportsCodePoint(H) {
                    return r.U.codeToGlyph(R, H) > 0
                },
                forEachGlyph(H, q, X, oe) {
                    let Y = 0;
                    const Z = 1 / V.unitsPerEm * q,
                        U = A(R, H);
                    let j = 0;
                    const te = S(R, U);
                    return U.forEach((he, $) => {
                        if (he !== -1) {
                            let ne = P[he];
                            if (!ne) {
                                const {
                                    cmds: me,
                                    crds: ce
                                } = r.U.glyphToPath(R, he);
                                let _e = "",
                                    Oe = 0;
                                for (let J = 0, De = me.length; J < De; J++) {
                                    const Ce = t[me[J]];
                                    _e += me[J];
                                    for (let se = 1; se <= Ce; se++) _e += (se > 1 ? "," : "") + ce[Oe++]
                                }
                                let ke, Ee, pe, xe;
                                if (ce.length) {
                                    ke = Ee = 1 / 0, pe = xe = -1 / 0;
                                    for (let J = 0, De = ce.length; J < De; J += 2) {
                                        let Ce = ce[J],
                                            se = ce[J + 1];
                                        Ce < ke && (ke = Ce), se < Ee && (Ee = se), Ce > pe && (pe = Ce), se > xe && (xe = se)
                                    }
                                } else ke = pe = Ee = xe = 0;
                                ne = P[he] = {
                                    index: he,
                                    advanceWidth: R.hmtx.aWidth[he],
                                    xMin: ke,
                                    yMin: Ee,
                                    xMax: pe,
                                    yMax: xe,
                                    path: _e
                                }
                            }
                            oe.call(null, ne, Y + te[$ * 3] * Z, te[$ * 3 + 1] * Z, j), Y += te[$ * 3 + 2] * Z, X && (Y += X * q)
                        }
                        j += H.codePointAt(j) > 65535 ? 2 : 1
                    }), Y
                }
            };
        return V
    }
    return function(P) {
        const b = new Uint8Array(P, 0, 4),
            T = r._bin.readASCII(b, 0, 4);
        if (T === "wOFF") P = e(P);
        else if (T === "wOF2") throw new Error("woff2 fonts not supported");
        return E(r.parse(P)[0])
    }
}
const L9 = hh({
    name: "Typr Font Parser",
    dependencies: [I9, B9, D9],
    init(r, e, t) {
        const n = r(),
            i = e();
        return t(n, i)
    }
});
/*!
Custom bundle of @unicode-font-resolver/client v1.0.2 (https://github.com/lojjic/unicode-font-resolver)
for use in Troika text rendering. 
Original MIT license applies
*/
function F9() {
    return function(r) {
        var e = function() {
            this.buckets = new Map
        };
        e.prototype.add = function(S) {
            var M = S >> 5;
            this.buckets.set(M, (this.buckets.get(M) || 0) | 1 << (31 & S))
        }, e.prototype.has = function(S) {
            var M = this.buckets.get(S >> 5);
            return M !== void 0 && (M & 1 << (31 & S)) != 0
        }, e.prototype.serialize = function() {
            var S = [];
            return this.buckets.forEach(function(M, C) {
                S.push((+C).toString(36) + ":" + M.toString(36))
            }), S.join(",")
        }, e.prototype.deserialize = function(S) {
            var M = this;
            this.buckets.clear(), S.split(",").forEach(function(C) {
                var E = C.split(":");
                M.buckets.set(parseInt(E[0], 36), parseInt(E[1], 36))
            })
        };
        var t = Math.pow(2, 8),
            n = t - 1,
            i = ~n;

        function s(S) {
            var M = function(E) {
                    return E & i
                }(S).toString(16),
                C = function(E) {
                    return (E & i) + t - 1
                }(S).toString(16);
            return "codepoint-index/plane" + (S >> 16) + "/" + M + "-" + C + ".json"
        }

        function o(S, M) {
            var C = S & n,
                E = M.codePointAt(C / 6 | 0);
            return ((E = (E || 48) - 48) & 1 << C % 6) != 0
        }

        function a(S, M) {
            var C;
            (C = S, C.replace(/U\+/gi, "").replace(/^,+|,+$/g, "").split(/,+/).map(function(E) {
                return E.split("-").map(function(R) {
                    return parseInt(R.trim(), 16)
                })
            })).forEach(function(E) {
                var R = E[0],
                    P = E[1];
                P === void 0 && (P = R), M(R, P)
            })
        }

        function l(S, M) {
            a(S, function(C, E) {
                for (var R = C; R <= E; R++) M(R)
            })
        }
        var c = {},
            u = {},
            f = new WeakMap,
            d = "https://cdn.jsdelivr.net/gh/lojjic/unicode-font-resolver@v1.0.1/packages/data";

        function m(S) {
            var M = f.get(S);
            return M || (M = new e, l(S.ranges, function(C) {
                return M.add(C)
            }), f.set(S, M)), M
        }
        var g, y = new Map;

        function v(S, M, C) {
            return S[M] ? M : S[C] ? C : function(E) {
                for (var R in E) return R
            }(S)
        }

        function _(S, M) {
            var C = M;
            if (!S.includes(C)) {
                C = 1 / 0;
                for (var E = 0; E < S.length; E++) Math.abs(S[E] - M) < Math.abs(C - M) && (C = S[E])
            }
            return C
        }

        function A(S) {
            return g || (g = new Set, l("9-D,20,85,A0,1680,2000-200A,2028-202F,205F,3000", function(M) {
                g.add(M)
            })), g.has(S)
        }
        return r.CodePointSet = e, r.clearCache = function() {
            c = {}, u = {}
        }, r.getFontsForString = function(S, M) {
            M === void 0 && (M = {});
            var C, E = M.lang;
            E === void 0 && (E = new RegExp("\\p{Script=Hangul}", "u").test(C = S) ? "ko" : new RegExp("\\p{Script=Hiragana}|\\p{Script=Katakana}", "u").test(C) ? "ja" : "en");
            var R = M.category;
            R === void 0 && (R = "sans-serif");
            var P = M.style;
            P === void 0 && (P = "normal");
            var b = M.weight;
            b === void 0 && (b = 400);
            var T = (M.dataUrl || d).replace(/\/$/g, ""),
                L = new Map,
                D = new Uint8Array(S.length),
                V = {},
                H = {},
                q = new Array(S.length),
                X = new Map,
                oe = !1;

            function Y(j) {
                var te = y.get(j);
                return te || (te = fetch(T + "/" + j).then(function(he) {
                    if (!he.ok) throw new Error(he.statusText);
                    return he.json().then(function($) {
                        if (!Array.isArray($) || $[0] !== 1) throw new Error("Incorrect schema version; need 1, got " + $[0]);
                        return $[1]
                    })
                }).catch(function(he) {
                    if (T !== d) return oe || (console.error('unicode-font-resolver: Failed loading from dataUrl "' + T + '", trying default CDN. ' + he.message), oe = !0), T = d, y.delete(j), Y(j);
                    throw he
                }), y.set(j, te)), te
            }
            for (var Z = function(j) {
                    var te = S.codePointAt(j),
                        he = s(te);
                    q[j] = he, c[he] || X.has(he) || X.set(he, Y(he).then(function($) {
                        c[he] = $
                    })), te > 65535 && (j++, U = j)
                }, U = 0; U < S.length; U++) Z(U);
            return Promise.all(X.values()).then(function() {
                X.clear();
                for (var j = function(he) {
                        var $ = S.codePointAt(he),
                            ne = null,
                            me = c[q[he]],
                            ce = void 0;
                        for (var _e in me) {
                            var Oe = H[_e];
                            if (Oe === void 0 && (Oe = H[_e] = new RegExp(_e).test(E || "en")), Oe) {
                                for (var ke in ce = _e, me[_e])
                                    if (o($, me[_e][ke])) {
                                        ne = ke;
                                        break
                                    }
                                break
                            }
                        }
                        if (!ne) {
                            e: for (var Ee in me)
                                if (Ee !== ce) {
                                    for (var pe in me[Ee])
                                        if (o($, me[Ee][pe])) {
                                            ne = pe;
                                            break e
                                        }
                                }
                        }
                        ne || (console.debug("No font coverage for U+" + $.toString(16)), ne = "latin"), q[he] = ne, u[ne] || X.has(ne) || X.set(ne, Y("font-meta/" + ne + ".json").then(function(xe) {
                            u[ne] = xe
                        })), $ > 65535 && (he++, te = he)
                    }, te = 0; te < S.length; te++) j(te);
                return Promise.all(X.values())
            }).then(function() {
                for (var j, te = null, he = 0; he < S.length; he++) {
                    var $ = S.codePointAt(he);
                    if (te && (A($) || m(te).has($))) D[he] = D[he - 1];
                    else {
                        te = u[q[he]];
                        var ne = V[te.id];
                        if (!ne) {
                            var me = te.typeforms,
                                ce = v(me, R, "sans-serif"),
                                _e = v(me[ce], P, "normal"),
                                Oe = _((j = me[ce]) === null || j === void 0 ? void 0 : j[_e], b);
                            ne = V[te.id] = T + "/font-files/" + te.id + "/" + ce + "." + _e + "." + Oe + ".woff"
                        }
                        var ke = L.get(ne);
                        ke == null && (ke = L.size, L.set(ne, ke)), D[he] = ke
                    }
                    $ > 65535 && (he++, D[he] = D[he - 1])
                }
                return {
                    fontUrls: Array.from(L.keys()),
                    chars: D
                }
            })
        }, Object.defineProperty(r, "__esModule", {
            value: !0
        }), r
    }({})
}

function U9(r, e) {
    const t = Object.create(null),
        n = Object.create(null);

    function i(o, a) {
        const l = c => {
            console.error(`Failure loading font ${o}`, c)
        };
        try {
            const c = new XMLHttpRequest;
            c.open("get", o, !0), c.responseType = "arraybuffer", c.onload = function() {
                if (c.status >= 400) l(new Error(c.statusText));
                else if (c.status > 0) try {
                    const u = r(c.response);
                    u.src = o, a(u)
                } catch (u) {
                    l(u)
                }
            }, c.onerror = l, c.send()
        } catch (c) {
            l(c)
        }
    }

    function s(o, a) {
        let l = t[o];
        l ? a(l) : n[o] ? n[o].push(a) : (n[o] = [a], i(o, c => {
            c.src = o, t[o] = c, n[o].forEach(u => u(c)), delete n[o]
        }))
    }
    return function(o, a, {
        lang: l,
        fonts: c = [],
        style: u = "normal",
        weight: f = "normal",
        unicodeFontsURL: d
    } = {}) {
        const m = new Uint8Array(o.length),
            g = [];
        o.length || A();
        const y = new Map,
            v = [];
        if (u !== "italic" && (u = "normal"), typeof f != "number" && (f = f === "bold" ? 700 : 400), c && !Array.isArray(c) && (c = [c]), c = c.slice().filter(M => !M.lang || M.lang.test(l)).reverse(), c.length) {
            let R = 0;
            (function P(b = 0) {
                for (let T = b, L = o.length; T < L; T++) {
                    const D = o.codePointAt(T);
                    if (R === 1 && g[m[T - 1]].supportsCodePoint(D) || T > 0 && /\s/.test(o[T])) m[T] = m[T - 1], R === 2 && (v[v.length - 1][1] = T);
                    else
                        for (let V = m[T], H = c.length; V <= H; V++)
                            if (V === H) {
                                const q = R === 2 ? v[v.length - 1] : v[v.length] = [T, T];
                                q[1] = T, R = 2
                            } else {
                                m[T] = V;
                                const {
                                    src: q,
                                    unicodeRange: X
                                } = c[V];
                                if (!X || S(D, X)) {
                                    const oe = t[q];
                                    if (!oe) {
                                        s(q, () => {
                                            P(T)
                                        });
                                        return
                                    }
                                    if (oe.supportsCodePoint(D)) {
                                        let Y = y.get(oe);
                                        typeof Y != "number" && (Y = g.length, g.push(oe), y.set(oe, Y)), m[T] = Y, R = 1;
                                        break
                                    }
                                }
                            }
                    D > 65535 && T + 1 < L && (m[T + 1] = m[T], T++, R === 2 && (v[v.length - 1][1] = T))
                }
                _()
            })()
        } else v.push([0, o.length - 1]), _();

        function _() {
            if (v.length) {
                const M = v.map(C => o.substring(C[0], C[1] + 1)).join(`
`);
                e.getFontsForString(M, {
                    lang: l || void 0,
                    style: u,
                    weight: f,
                    dataUrl: d
                }).then(({
                    fontUrls: C,
                    chars: E
                }) => {
                    const R = g.length;
                    let P = 0;
                    v.forEach(T => {
                        for (let L = 0, D = T[1] - T[0]; L <= D; L++) m[T[0] + L] = E[P++] + R;
                        P++
                    });
                    let b = 0;
                    C.forEach((T, L) => {
                        s(T, D => {
                            g[L + R] = D, ++b === C.length && A()
                        })
                    })
                })
            } else A()
        }

        function A() {
            a({
                chars: m,
                fonts: g
            })
        }

        function S(M, C) {
            for (let E = 0; E < C.length; E++) {
                const [R, P = R] = C[E];
                if (R <= M && M <= P) return !0
            }
            return !1
        }
    }
}
const O9 = hh({
    name: "FontResolver",
    dependencies: [U9, L9, F9],
    init(r, e, t) {
        return r(e, t())
    }
});

function N9(r, e) {
    const n = /[\u00AD\u034F\u061C\u115F-\u1160\u17B4-\u17B5\u180B-\u180E\u200B-\u200F\u202A-\u202E\u2060-\u206F\u3164\uFE00-\uFE0F\uFEFF\uFFA0\uFFF0-\uFFF8]/,
        i = "[^\\S\\u00A0]",
        s = new RegExp(`${i}|[\\-\\u007C\\u00AD\\u2010\\u2012-\\u2014\\u2027\\u2056\\u2E17\\u2E40]`);

    function o({
        text: g,
        lang: y,
        fonts: v,
        style: _,
        weight: A,
        preResolvedFonts: S,
        unicodeFontsURL: M
    }, C) {
        const E = ({
            chars: R,
            fonts: P
        }) => {
            let b, T;
            const L = [];
            for (let D = 0; D < R.length; D++) R[D] !== T ? (T = R[D], L.push(b = {
                start: D,
                end: D,
                fontObj: P[R[D]]
            })) : b.end = D;
            C(L)
        };
        S ? E(S) : r(g, E, {
            lang: y,
            fonts: v,
            style: _,
            weight: A,
            unicodeFontsURL: M
        })
    }

    function a({
        text: g = "",
        font: y,
        lang: v,
        sdfGlyphSize: _ = 64,
        fontSize: A = 400,
        fontWeight: S = 1,
        fontStyle: M = "normal",
        letterSpacing: C = 0,
        lineHeight: E = "normal",
        maxWidth: R = 1 / 0,
        direction: P,
        textAlign: b = "left",
        textIndent: T = 0,
        whiteSpace: L = "normal",
        overflowWrap: D = "normal",
        anchorX: V = 0,
        anchorY: H = 0,
        metricsOnly: q = !1,
        unicodeFontsURL: X,
        preResolvedFonts: oe = null,
        includeCaretPositions: Y = !1,
        chunkedBoundsSize: Z = 8192,
        colorRanges: U = null
    }, j) {
        const te = f(),
            he = {
                fontLoad: 0,
                typesetting: 0
            };
        g.indexOf("\r") > -1 && (console.info("Typesetter: got text with \\r chars; normalizing to \\n"), g = g.replace(/\r\n/g, `
`).replace(/\r/g, `
`)), A = +A, C = +C, R = +R, E = E || "normal", T = +T, o({
            text: g,
            lang: v,
            style: M,
            weight: S,
            fonts: typeof y == "string" ? [{
                src: y
            }] : y,
            unicodeFontsURL: X,
            preResolvedFonts: oe
        }, $ => {
            he.fontLoad = f() - te;
            const ne = isFinite(R);
            let me = null,
                ce = null,
                _e = null,
                Oe = null,
                ke = null,
                Ee = null,
                pe = null,
                xe = null,
                J = 0,
                De = 0,
                Ce = L !== "nowrap";
            const se = new Map,
                Se = f();
            let Xe = T,
                Le = 0,
                k = new d;
            const z = [k];
            $.forEach(Be => {
                const {
                    fontObj: Fe
                } = Be, {
                    ascender: Ne,
                    descender: ot,
                    unitsPerEm: je,
                    lineGap: Ze,
                    capHeight: it,
                    xHeight: $e
                } = Fe;
                let We = se.get(Fe);
                if (!We) {
                    const ve = A / je,
                        we = E === "normal" ? (Ne - ot + Ze) * ve : E * A,
                        He = (we - (Ne - ot) * ve) / 2,
                        Je = Math.min(we, (Ne - ot) * ve),
                        Ye = (Ne + ot) / 2 * ve + Je / 2;
                    We = {
                        index: se.size,
                        src: Fe.src,
                        fontObj: Fe,
                        fontSizeMult: ve,
                        unitsPerEm: je,
                        ascender: Ne * ve,
                        descender: ot * ve,
                        capHeight: it * ve,
                        xHeight: $e * ve,
                        lineHeight: we,
                        baseline: -He - Ne * ve,
                        caretTop: Ye,
                        caretBottom: Ye - Je
                    }, se.set(Fe, We)
                }
                const {
                    fontSizeMult: yt
                } = We, at = g.slice(Be.start, Be.end + 1);
                let Mt, ae;
                Fe.forEachGlyph(at, A, C, (ve, we, He, Je) => {
                    we += Le, Je += Be.start, Mt = we, ae = ve;
                    const Ye = g.charAt(Je),
                        mt = ve.advanceWidth * yt,
                        Pt = k.count;
                    let St;
                    if ("isEmpty" in ve || (ve.isWhitespace = !!Ye && new RegExp(i).test(Ye), ve.canBreakAfter = !!Ye && s.test(Ye), ve.isEmpty = ve.xMin === ve.xMax || ve.yMin === ve.yMax || n.test(Ye)), !ve.isWhitespace && !ve.isEmpty && De++, Ce && ne && !ve.isWhitespace && we + mt + Xe > R && Pt) {
                        if (k.glyphAt(Pt - 1).glyphObj.canBreakAfter) St = new d, Xe = -we;
                        else
                            for (let ut = Pt; ut--;)
                                if (ut === 0 && D === "break-word") {
                                    St = new d, Xe = -we;
                                    break
                                } else if (k.glyphAt(ut).glyphObj.canBreakAfter) {
                            St = k.splitAt(ut + 1);
                            const Rt = St.glyphAt(0).x;
                            Xe -= Rt;
                            for (let nt = St.count; nt--;) St.glyphAt(nt).x -= Rt;
                            break
                        }
                        St && (k.isSoftWrapped = !0, k = St, z.push(k), J = R)
                    }
                    let tt = k.glyphAt(k.count);
                    tt.glyphObj = ve, tt.x = we + Xe, tt.y = He, tt.width = mt, tt.charIndex = Je, tt.fontData = We, Ye === `
` && (k = new d, z.push(k), Xe = -(we + mt + C * A) + T)
                }), Le = Mt + ae.advanceWidth * yt + C * A
            });
            let ue = 0;
            z.forEach(Be => {
                let Fe = !0;
                for (let Ne = Be.count; Ne--;) {
                    const ot = Be.glyphAt(Ne);
                    Fe && !ot.glyphObj.isWhitespace && (Be.width = ot.x + ot.width, Be.width > J && (J = Be.width), Fe = !1);
                    let {
                        lineHeight: je,
                        capHeight: Ze,
                        xHeight: it,
                        baseline: $e
                    } = ot.fontData;
                    je > Be.lineHeight && (Be.lineHeight = je);
                    const We = $e - Be.baseline;
                    We < 0 && (Be.baseline += We, Be.cap += We, Be.ex += We), Be.cap = Math.max(Be.cap, Be.baseline + Ze), Be.ex = Math.max(Be.ex, Be.baseline + it)
                }
                Be.baseline -= ue, Be.cap -= ue, Be.ex -= ue, ue += Be.lineHeight
            });
            let ye = 0,
                ge = 0;
            if (V && (typeof V == "number" ? ye = -V : typeof V == "string" && (ye = -J * (V === "left" ? 0 : V === "center" ? .5 : V === "right" ? 1 : c(V)))), H && (typeof H == "number" ? ge = -H : typeof H == "string" && (ge = H === "top" ? 0 : H === "top-baseline" ? -z[0].baseline : H === "top-cap" ? -z[0].cap : H === "top-ex" ? -z[0].ex : H === "middle" ? ue / 2 : H === "bottom" ? ue : H === "bottom-baseline" ? -z[z.length - 1].baseline : c(H) * ue)), !q) {
                const Be = e.getEmbeddingLevels(g, P);
                me = new Uint16Array(De), ce = new Uint8Array(De), _e = new Float32Array(De * 2), Oe = {}, pe = [1 / 0, 1 / 0, -1 / 0, -1 / 0], xe = [], Y && (Ee = new Float32Array(g.length * 4)), U && (ke = new Uint8Array(De * 3));
                let Fe = 0,
                    Ne = -1,
                    ot = -1,
                    je, Ze;
                if (z.forEach((it, $e) => {
                        let {
                            count: We,
                            width: yt
                        } = it;
                        if (We > 0) {
                            let at = 0;
                            for (let Je = We; Je-- && it.glyphAt(Je).glyphObj.isWhitespace;) at++;
                            let Mt = 0,
                                ae = 0;
                            if (b === "center") Mt = (J - yt) / 2;
                            else if (b === "right") Mt = J - yt;
                            else if (b === "justify" && it.isSoftWrapped) {
                                let Je = 0;
                                for (let Ye = We - at; Ye--;) it.glyphAt(Ye).glyphObj.isWhitespace && Je++;
                                ae = (J - yt) / Je
                            }
                            if (ae || Mt) {
                                let Je = 0;
                                for (let Ye = 0; Ye < We; Ye++) {
                                    let mt = it.glyphAt(Ye);
                                    const Pt = mt.glyphObj;
                                    mt.x += Mt + Je, ae !== 0 && Pt.isWhitespace && Ye < We - at && (Je += ae, mt.width += ae)
                                }
                            }
                            const ve = e.getReorderSegments(g, Be, it.glyphAt(0).charIndex, it.glyphAt(it.count - 1).charIndex);
                            for (let Je = 0; Je < ve.length; Je++) {
                                const [Ye, mt] = ve[Je];
                                let Pt = 1 / 0,
                                    St = -1 / 0;
                                for (let tt = 0; tt < We; tt++)
                                    if (it.glyphAt(tt).charIndex >= Ye) {
                                        let ut = tt,
                                            Rt = tt;
                                        for (; Rt < We; Rt++) {
                                            let nt = it.glyphAt(Rt);
                                            if (nt.charIndex > mt) break;
                                            Rt < We - at && (Pt = Math.min(Pt, nt.x), St = Math.max(St, nt.x + nt.width))
                                        }
                                        for (let nt = ut; nt < Rt; nt++) {
                                            const It = it.glyphAt(nt);
                                            It.x = St - (It.x + It.width - Pt)
                                        }
                                        break
                                    }
                            }
                            let we;
                            const He = Je => we = Je;
                            for (let Je = 0; Je < We; Je++) {
                                const Ye = it.glyphAt(Je);
                                we = Ye.glyphObj;
                                const mt = we.index,
                                    Pt = Be.levels[Ye.charIndex] & 1;
                                if (Pt) {
                                    const St = e.getMirroredCharacter(g[Ye.charIndex]);
                                    St && Ye.fontData.fontObj.forEachGlyph(St, 0, 0, He)
                                }
                                if (Y) {
                                    const {
                                        charIndex: St,
                                        fontData: tt
                                    } = Ye, ut = Ye.x + ye, Rt = Ye.x + Ye.width + ye;
                                    Ee[St * 4] = Pt ? Rt : ut, Ee[St * 4 + 1] = Pt ? ut : Rt, Ee[St * 4 + 2] = it.baseline + tt.caretBottom + ge, Ee[St * 4 + 3] = it.baseline + tt.caretTop + ge;
                                    const nt = St - Ne;
                                    nt > 1 && u(Ee, Ne, nt), Ne = St
                                }
                                if (U) {
                                    const {
                                        charIndex: St
                                    } = Ye;
                                    for (; St > ot;) ot++, U.hasOwnProperty(ot) && (Ze = U[ot])
                                }
                                if (!we.isWhitespace && !we.isEmpty) {
                                    const St = Fe++,
                                        {
                                            fontSizeMult: tt,
                                            src: ut,
                                            index: Rt
                                        } = Ye.fontData,
                                        nt = Oe[ut] || (Oe[ut] = {});
                                    nt[mt] || (nt[mt] = {
                                        path: we.path,
                                        pathBounds: [we.xMin, we.yMin, we.xMax, we.yMax]
                                    });
                                    const It = Ye.x + ye,
                                        pt = Ye.y + it.baseline + ge;
                                    _e[St * 2] = It, _e[St * 2 + 1] = pt;
                                    const Ct = It + we.xMin * tt,
                                        ln = pt + we.yMin * tt,
                                        Dt = It + we.xMax * tt,
                                        gt = pt + we.yMax * tt;
                                    Ct < pe[0] && (pe[0] = Ct), ln < pe[1] && (pe[1] = ln), Dt > pe[2] && (pe[2] = Dt), gt > pe[3] && (pe[3] = gt), St % Z === 0 && (je = {
                                        start: St,
                                        end: St,
                                        rect: [1 / 0, 1 / 0, -1 / 0, -1 / 0]
                                    }, xe.push(je)), je.end++;
                                    const $t = je.rect;
                                    if (Ct < $t[0] && ($t[0] = Ct), ln < $t[1] && ($t[1] = ln), Dt > $t[2] && ($t[2] = Dt), gt > $t[3] && ($t[3] = gt), me[St] = mt, ce[St] = Rt, U) {
                                        const rn = St * 3;
                                        ke[rn] = Ze >> 16 & 255, ke[rn + 1] = Ze >> 8 & 255, ke[rn + 2] = Ze & 255
                                    }
                                }
                            }
                        }
                    }), Ee) {
                    const it = g.length - Ne;
                    it > 1 && u(Ee, Ne, it)
                }
            }
            const Re = [];
            se.forEach(({
                index: Be,
                src: Fe,
                unitsPerEm: Ne,
                ascender: ot,
                descender: je,
                lineHeight: Ze,
                capHeight: it,
                xHeight: $e
            }) => {
                Re[Be] = {
                    src: Fe,
                    unitsPerEm: Ne,
                    ascender: ot,
                    descender: je,
                    lineHeight: Ze,
                    capHeight: it,
                    xHeight: $e
                }
            }), he.typesetting = f() - Se, j({
                glyphIds: me,
                glyphFontIndices: ce,
                glyphPositions: _e,
                glyphData: Oe,
                fontData: Re,
                caretPositions: Ee,
                glyphColors: ke,
                chunkedBounds: xe,
                fontSize: A,
                topBaseline: ge + z[0].baseline,
                blockBounds: [ye, ge - ue, ye + J, ge],
                visibleBounds: pe,
                timings: he
            })
        })
    }

    function l(g, y) {
        a({ ...g,
            metricsOnly: !0
        }, v => {
            const [_, A, S, M] = v.blockBounds;
            y({
                width: S - _,
                height: M - A
            })
        })
    }

    function c(g) {
        let y = g.match(/^([\d.]+)%$/),
            v = y ? parseFloat(y[1]) : NaN;
        return isNaN(v) ? 0 : v / 100
    }

    function u(g, y, v) {
        const _ = g[y * 4],
            A = g[y * 4 + 1],
            S = g[y * 4 + 2],
            M = g[y * 4 + 3],
            C = (A - _) / v;
        for (let E = 0; E < v; E++) {
            const R = (y + E) * 4;
            g[R] = _ + C * E, g[R + 1] = _ + C * (E + 1), g[R + 2] = S, g[R + 3] = M
        }
    }

    function f() {
        return (self.performance || Date).now()
    }

    function d() {
        this.data = []
    }
    const m = ["glyphObj", "x", "y", "width", "charIndex", "fontData"];
    return d.prototype = {
        width: 0,
        lineHeight: 0,
        baseline: 0,
        cap: 0,
        ex: 0,
        isSoftWrapped: !1,
        get count() {
            return Math.ceil(this.data.length / m.length)
        },
        glyphAt(g) {
            let y = d.flyweight;
            return y.data = this.data, y.index = g, y
        },
        splitAt(g) {
            let y = new d;
            return y.data = this.data.splice(g * m.length), y
        }
    }, d.flyweight = m.reduce((g, y, v, _) => (Object.defineProperty(g, y, {
        get() {
            return this.data[this.index * m.length + v]
        },
        set(A) {
            this.data[this.index * m.length + v] = A
        }
    }), g), {
        data: null,
        index: 0
    }), {
        typeset: a,
        measure: l
    }
}
const qc = () => (self.performance || Date).now(),
    ky = kD();
let ZC;

function k9(r, e, t, n, i, s, o, a, l, c, u = !0) {
    return u ? G9(r, e, t, n, i, s, o, a, l, c).then(null, f => (ZC || (console.warn("WebGL SDF generation failed, falling back to JS", f), ZC = !0), $C(r, e, t, n, i, s, o, a, l, c))) : $C(r, e, t, n, i, s, o, a, l, c)
}
const L0 = [],
    z9 = 5;
let FA = 0;

function GD() {
    const r = qc();
    for (; L0.length && qc() - r < z9;) L0.shift()();
    FA = L0.length ? setTimeout(GD, 0) : 0
}
const G9 = (...r) => new Promise((e, t) => {
        L0.push(() => {
            const n = qc();
            try {
                ky.webgl.generateIntoCanvas(...r), e({
                    timing: qc() - n
                })
            } catch (i) {
                t(i)
            }
        }), FA || (FA = setTimeout(GD, 0))
    }),
    H9 = 4,
    V9 = 2e3,
    QC = {};
let W9 = 0;

function $C(r, e, t, n, i, s, o, a, l, c) {
    const u = "TroikaTextSDFGenerator_JS_" + W9++ % H9;
    let f = QC[u];
    return f || (f = QC[u] = {
        workerModule: hh({
            name: u,
            workerId: u,
            dependencies: [kD, qc],
            init(d, m) {
                const g = d().javascript.generate;
                return function(...y) {
                    const v = m();
                    return {
                        textureData: g(...y),
                        timing: m() - v
                    }
                }
            },
            getTransferables(d) {
                return [d.textureData.buffer]
            }
        }),
        requests: 0,
        idleTimer: null
    }), f.requests++, clearTimeout(f.idleTimer), f.workerModule(r, e, t, n, i, s).then(({
        textureData: d,
        timing: m
    }) => {
        const g = qc(),
            y = new Uint8Array(d.length * 4);
        for (let v = 0; v < d.length; v++) y[v * 4 + c] = d[v];
        return ky.webglUtils.renderImageData(o, y, a, l, r, e, 1 << 3 - c), m += qc() - g, --f.requests === 0 && (f.idleTimer = setTimeout(() => {
            A9(u)
        }, V9)), {
            timing: m
        }
    })
}

function j9(r) {
    r._warm || (ky.webgl.isSupported(r), r._warm = !0)
}
const X9 = ky.webglUtils.resizeWebGLCanvasWithoutClearing,
    uf = {
        defaultFontURL: null,
        unicodeFontsURL: null,
        sdfGlyphSize: 64,
        sdfMargin: 1 / 16,
        sdfExponent: 9,
        textureWidth: 2048,
        useWorker: !0
    },
    Y9 = new rt;

function rf() {
    return (self.performance || Date).now()
}
const eR = Object.create(null);

function HD(r, e) {
    r = q9({}, r);
    const t = rf(),
        {
            defaultFontURL: n
        } = uf,
        i = [];
    if (n && i.push({
            label: "default",
            src: tR(n)
        }), r.font && i.push({
            label: "user",
            src: tR(r.font)
        }), r.font = i, r.text = "" + r.text, r.sdfGlyphSize = r.sdfGlyphSize || uf.sdfGlyphSize, r.unicodeFontsURL = r.unicodeFontsURL || uf.unicodeFontsURL, r.colorRanges != null) {
        let m = {};
        for (let g in r.colorRanges)
            if (r.colorRanges.hasOwnProperty(g)) {
                let y = r.colorRanges[g];
                typeof y != "number" && (y = Y9.set(y).getHex()), m[g] = y
            }
        r.colorRanges = m
    }
    Object.freeze(r);
    const {
        textureWidth: s,
        sdfExponent: o
    } = uf, {
        sdfGlyphSize: a
    } = r, l = s / a * 4;
    let c = eR[a];
    if (!c) {
        const m = document.createElement("canvas");
        m.width = s, m.height = a * 256 / l, c = eR[a] = {
            glyphCount: 0,
            sdfGlyphSize: a,
            sdfCanvas: m,
            sdfTexture: new gn(m, void 0, void 0, void 0, nn, nn),
            contextLost: !1,
            glyphsByFont: new Map
        }, c.sdfTexture.generateMipmaps = !1, J9(c)
    }
    const {
        sdfTexture: u,
        sdfCanvas: f
    } = c;
    jD(r).then(m => {
        const {
            glyphIds: g,
            glyphFontIndices: y,
            fontData: v,
            glyphPositions: _,
            fontSize: A,
            timings: S
        } = m, M = [], C = new Float32Array(g.length * 4);
        let E = 0,
            R = 0;
        const P = rf(),
            b = v.map(H => {
                let q = c.glyphsByFont.get(H.src);
                return q || c.glyphsByFont.set(H.src, q = new Map), q
            });
        g.forEach((H, q) => {
            const X = y[q],
                {
                    src: oe,
                    unitsPerEm: Y
                } = v[X];
            let Z = b[X].get(H);
            if (!Z) {
                const {
                    path: $,
                    pathBounds: ne
                } = m.glyphData[oe][H], me = Math.max(ne[2] - ne[0], ne[3] - ne[1]) / a * (uf.sdfMargin * a + .5), ce = c.glyphCount++, _e = [ne[0] - me, ne[1] - me, ne[2] + me, ne[3] + me];
                b[X].set(H, Z = {
                    path: $,
                    atlasIndex: ce,
                    sdfViewBox: _e
                }), M.push(Z)
            }
            const {
                sdfViewBox: U
            } = Z, j = _[R++], te = _[R++], he = A / Y;
            C[E++] = j + U[0] * he, C[E++] = te + U[1] * he, C[E++] = j + U[2] * he, C[E++] = te + U[3] * he, g[q] = Z.atlasIndex
        }), S.quads = (S.quads || 0) + (rf() - P);
        const T = rf();
        S.sdf = {};
        const L = f.height,
            D = Math.ceil(c.glyphCount / l),
            V = Math.pow(2, Math.ceil(Math.log2(D * a)));
        V > L && (console.info(`Increasing SDF texture size ${L}->${V}`), X9(f, s, V), u.dispose()), Promise.all(M.map(H => VD(H, c, r.gpuAccelerateSDF).then(({
            timing: q
        }) => {
            S.sdf[H.atlasIndex] = q
        }))).then(() => {
            M.length && !c.contextLost && (WD(c), u.needsUpdate = !0), S.sdfTotal = rf() - T, S.total = rf() - t, e(Object.freeze({
                parameters: r,
                sdfTexture: u,
                sdfGlyphSize: a,
                sdfExponent: o,
                glyphBounds: C,
                glyphAtlasIndices: g,
                glyphColors: m.glyphColors,
                caretPositions: m.caretPositions,
                chunkedBounds: m.chunkedBounds,
                ascender: m.ascender,
                descender: m.descender,
                lineHeight: m.lineHeight,
                capHeight: m.capHeight,
                xHeight: m.xHeight,
                topBaseline: m.topBaseline,
                blockBounds: m.blockBounds,
                visibleBounds: m.visibleBounds,
                timings: m.timings
            }))
        })
    }), Promise.resolve().then(() => {
        c.contextLost || j9(f)
    })
}

function VD({
    path: r,
    atlasIndex: e,
    sdfViewBox: t
}, {
    sdfGlyphSize: n,
    sdfCanvas: i,
    contextLost: s
}, o) {
    if (s) return Promise.resolve({
        timing: -1
    });
    const {
        textureWidth: a,
        sdfExponent: l
    } = uf, c = Math.max(t[2] - t[0], t[3] - t[1]), u = Math.floor(e / 4), f = u % (a / n) * n, d = Math.floor(u / (a / n)) * n, m = e % 4;
    return k9(n, n, r, t, c, l, i, f, d, m, o)
}

function J9(r) {
    const e = r.sdfCanvas;
    e.addEventListener("webglcontextlost", t => {
        console.log("Context Lost", t), t.preventDefault(), r.contextLost = !0
    }), e.addEventListener("webglcontextrestored", t => {
        console.log("Context Restored", t), r.contextLost = !1;
        const n = [];
        r.glyphsByFont.forEach(i => {
            i.forEach(s => {
                n.push(VD(s, r, !0))
            })
        }), Promise.all(n).then(() => {
            WD(r), r.sdfTexture.needsUpdate = !0
        })
    })
}

function K9({
    font: r,
    characters: e,
    sdfGlyphSize: t
}, n) {
    let i = Array.isArray(e) ? e.join(`
`) : "" + e;
    HD({
        font: r,
        sdfGlyphSize: t,
        text: i
    }, n)
}

function q9(r, e) {
    for (let t in e) e.hasOwnProperty(t) && (r[t] = e[t]);
    return r
}
let u0;

function tR(r) {
    return u0 || (u0 = typeof document > "u" ? {} : document.createElement("a")), u0.href = r, u0.href
}

function WD(r) {
    if (typeof createImageBitmap != "function") {
        console.info("Safari<15: applying SDF canvas workaround");
        const {
            sdfCanvas: e,
            sdfTexture: t
        } = r, {
            width: n,
            height: i
        } = e, s = r.sdfCanvas.getContext("webgl");
        let o = t.image.data;
        (!o || o.length !== n * i * 4) && (o = new Uint8Array(n * i * 4), t.image = {
            width: n,
            height: i,
            data: o
        }, t.flipY = !1, t.isDataTexture = !0), s.readPixels(0, 0, n, i, s.RGBA, s.UNSIGNED_BYTE, o)
    }
}
const Z9 = hh({
        name: "Typesetter",
        dependencies: [N9, O9, M9],
        init(r, e, t) {
            return r(e, t())
        }
    }),
    jD = hh({
        name: "Typesetter",
        dependencies: [Z9],
        init(r) {
            return function(e) {
                return new Promise(t => {
                    r.typeset(e, t)
                })
            }
        },
        getTransferables(r) {
            const e = [];
            for (let t in r) r[t] && r[t].buffer && e.push(r[t].buffer);
            return e
        }
    });
jD.onMainThread;
const nR = {};

function Q9(r) {
    let e = nR[r];
    return e || (e = nR[r] = new bs(1, 1, r, r).translate(.5, .5, 0)), e
}
const $9 = "aTroikaGlyphBounds",
    iR = "aTroikaGlyphIndex",
    eW = "aTroikaGlyphColor";
class tW extends pM {
    constructor() {
        super(), this.detail = 1, this.curveRadius = 0, this.groups = [{
            start: 0,
            count: 1 / 0,
            materialIndex: 0
        }, {
            start: 0,
            count: 1 / 0,
            materialIndex: 1
        }], this.boundingSphere = new ji, this.boundingBox = new Wi
    }
    computeBoundingSphere() {}
    computeBoundingBox() {}
    set detail(e) {
        if (e !== this._detail) {
            this._detail = e, (typeof e != "number" || e < 1) && (e = 1);
            let t = Q9(e);
            ["position", "normal", "uv"].forEach(n => {
                this.attributes[n] = t.attributes[n].clone()
            }), this.setIndex(t.getIndex().clone())
        }
    }
    get detail() {
        return this._detail
    }
    set curveRadius(e) {
        e !== this._curveRadius && (this._curveRadius = e, this._updateBounds())
    }
    get curveRadius() {
        return this._curveRadius
    }
    updateGlyphs(e, t, n, i, s) {
        this.updateAttributeData($9, e, 4), this.updateAttributeData(iR, t, 1), this.updateAttributeData(eW, s, 3), this._blockBounds = n, this._chunkedBounds = i, this.instanceCount = t.length, this._updateBounds()
    }
    _updateBounds() {
        const e = this._blockBounds;
        if (e) {
            const {
                curveRadius: t,
                boundingBox: n
            } = this;
            if (t) {
                const {
                    PI: i,
                    floor: s,
                    min: o,
                    max: a,
                    sin: l,
                    cos: c
                } = Math, u = i / 2, f = i * 2, d = Math.abs(t), m = e[0] / d, g = e[2] / d, y = s((m + u) / f) !== s((g + u) / f) ? -d : o(l(m) * d, l(g) * d), v = s((m - u) / f) !== s((g - u) / f) ? d : a(l(m) * d, l(g) * d), _ = s((m + i) / f) !== s((g + i) / f) ? d * 2 : a(d - c(m) * d, d - c(g) * d);
                n.min.set(y, e[1], t < 0 ? -_ : 0), n.max.set(v, e[3], t < 0 ? 0 : _)
            } else n.min.set(e[0], e[1], 0), n.max.set(e[2], e[3], 0);
            n.getBoundingSphere(this.boundingSphere)
        }
    }
    applyClipRect(e) {
        let t = this.getAttribute(iR).count,
            n = this._chunkedBounds;
        if (n)
            for (let i = n.length; i--;) {
                t = n[i].end;
                let s = n[i].rect;
                if (s[1] < e.w && s[3] > e.y && s[0] < e.z && s[2] > e.x) break
            }
        this.instanceCount = t
    }
    updateAttributeData(e, t, n) {
        const i = this.getAttribute(e);
        t ? i && i.array.length === t.length ? (i.array.set(t), i.needsUpdate = !0) : (this.setAttribute(e, new El(t, n)), delete this._maxInstanceCount, this.dispose()) : i && this.deleteAttribute(e)
    }
}
const nW = `
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform vec4 uTroikaTotalBounds;
uniform vec4 uTroikaClipRect;
uniform mat3 uTroikaOrient;
uniform bool uTroikaUseGlyphColors;
uniform float uTroikaEdgeOffset;
uniform float uTroikaBlurRadius;
uniform vec2 uTroikaPositionOffset;
uniform float uTroikaCurveRadius;
attribute vec4 aTroikaGlyphBounds;
attribute float aTroikaGlyphIndex;
attribute vec3 aTroikaGlyphColor;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec3 vTroikaGlyphColor;
varying vec2 vTroikaGlyphDimensions;
`,
    iW = `
vec4 bounds = aTroikaGlyphBounds;
bounds.xz += uTroikaPositionOffset.x;
bounds.yw -= uTroikaPositionOffset.y;

vec4 outlineBounds = vec4(
  bounds.xy - uTroikaEdgeOffset - uTroikaBlurRadius,
  bounds.zw + uTroikaEdgeOffset + uTroikaBlurRadius
);
vec4 clippedBounds = vec4(
  clamp(outlineBounds.xy, uTroikaClipRect.xy, uTroikaClipRect.zw),
  clamp(outlineBounds.zw, uTroikaClipRect.xy, uTroikaClipRect.zw)
);

vec2 clippedXY = (mix(clippedBounds.xy, clippedBounds.zw, position.xy) - bounds.xy) / (bounds.zw - bounds.xy);

position.xy = mix(bounds.xy, bounds.zw, clippedXY);

uv = (position.xy - uTroikaTotalBounds.xy) / (uTroikaTotalBounds.zw - uTroikaTotalBounds.xy);

float rad = uTroikaCurveRadius;
if (rad != 0.0) {
  float angle = position.x / rad;
  position.xz = vec2(sin(angle) * rad, rad - cos(angle) * rad);
  normal.xz = vec2(sin(angle), cos(angle));
}
  
position = uTroikaOrient * position;
normal = uTroikaOrient * normal;

vTroikaGlyphUV = clippedXY.xy;
vTroikaGlyphDimensions = vec2(bounds[2] - bounds[0], bounds[3] - bounds[1]);


float txCols = uTroikaSDFTextureSize.x / uTroikaSDFGlyphSize;
vec2 txUvPerSquare = uTroikaSDFGlyphSize / uTroikaSDFTextureSize;
vec2 txStartUV = txUvPerSquare * vec2(
  mod(floor(aTroikaGlyphIndex / 4.0), txCols),
  floor(floor(aTroikaGlyphIndex / 4.0) / txCols)
);
vTroikaTextureUVBounds = vec4(txStartUV, vec2(txStartUV) + txUvPerSquare);
vTroikaTextureChannel = mod(aTroikaGlyphIndex, 4.0);
`,
    rW = `
uniform sampler2D uTroikaSDFTexture;
uniform vec2 uTroikaSDFTextureSize;
uniform float uTroikaSDFGlyphSize;
uniform float uTroikaSDFExponent;
uniform float uTroikaEdgeOffset;
uniform float uTroikaFillOpacity;
uniform float uTroikaBlurRadius;
uniform vec3 uTroikaStrokeColor;
uniform float uTroikaStrokeWidth;
uniform float uTroikaStrokeOpacity;
uniform bool uTroikaSDFDebug;
varying vec2 vTroikaGlyphUV;
varying vec4 vTroikaTextureUVBounds;
varying float vTroikaTextureChannel;
varying vec2 vTroikaGlyphDimensions;

float troikaSdfValueToSignedDistance(float alpha) {
  // Inverse of exponential encoding in webgl-sdf-generator
  
  float maxDimension = max(vTroikaGlyphDimensions.x, vTroikaGlyphDimensions.y);
  float absDist = (1.0 - pow(2.0 * (alpha > 0.5 ? 1.0 - alpha : alpha), 1.0 / uTroikaSDFExponent)) * maxDimension;
  float signedDist = absDist * (alpha > 0.5 ? -1.0 : 1.0);
  return signedDist;
}

float troikaGlyphUvToSdfValue(vec2 glyphUV) {
  vec2 textureUV = mix(vTroikaTextureUVBounds.xy, vTroikaTextureUVBounds.zw, glyphUV);
  vec4 rgba = texture2D(uTroikaSDFTexture, textureUV);
  float ch = floor(vTroikaTextureChannel + 0.5); //NOTE: can't use round() in WebGL1
  return ch == 0.0 ? rgba.r : ch == 1.0 ? rgba.g : ch == 2.0 ? rgba.b : rgba.a;
}

float troikaGlyphUvToDistance(vec2 uv) {
  return troikaSdfValueToSignedDistance(troikaGlyphUvToSdfValue(uv));
}

float troikaGetAADist() {
  
  #if defined(GL_OES_standard_derivatives) || __VERSION__ >= 300
  return length(fwidth(vTroikaGlyphUV * vTroikaGlyphDimensions)) * 0.5;
  #else
  return vTroikaGlyphDimensions.x / 64.0;
  #endif
}

float troikaGetFragDistValue() {
  vec2 clampedGlyphUV = clamp(vTroikaGlyphUV, 0.5 / uTroikaSDFGlyphSize, 1.0 - 0.5 / uTroikaSDFGlyphSize);
  float distance = troikaGlyphUvToDistance(clampedGlyphUV);
 
  // Extrapolate distance when outside bounds:
  distance += clampedGlyphUV == vTroikaGlyphUV ? 0.0 : 
    length((vTroikaGlyphUV - clampedGlyphUV) * vTroikaGlyphDimensions);

  

  return distance;
}

float troikaGetEdgeAlpha(float distance, float distanceOffset, float aaDist) {
  #if defined(IS_DEPTH_MATERIAL) || defined(IS_DISTANCE_MATERIAL)
  float alpha = step(-distanceOffset, -distance);
  #else

  float alpha = smoothstep(
    distanceOffset + aaDist,
    distanceOffset - aaDist,
    distance
  );
  #endif

  return alpha;
}
`,
    sW = `
float aaDist = troikaGetAADist();
float fragDistance = troikaGetFragDistValue();
float edgeAlpha = uTroikaSDFDebug ?
  troikaGlyphUvToSdfValue(vTroikaGlyphUV) :
  troikaGetEdgeAlpha(fragDistance, uTroikaEdgeOffset, max(aaDist, uTroikaBlurRadius));

#if !defined(IS_DEPTH_MATERIAL) && !defined(IS_DISTANCE_MATERIAL)
vec4 fillRGBA = gl_FragColor;
fillRGBA.a *= uTroikaFillOpacity;
vec4 strokeRGBA = uTroikaStrokeWidth == 0.0 ? fillRGBA : vec4(uTroikaStrokeColor, uTroikaStrokeOpacity);
if (fillRGBA.a == 0.0) fillRGBA.rgb = strokeRGBA.rgb;
gl_FragColor = mix(fillRGBA, strokeRGBA, smoothstep(
  -uTroikaStrokeWidth - aaDist,
  -uTroikaStrokeWidth + aaDist,
  fragDistance
));
gl_FragColor.a *= edgeAlpha;
#endif

if (edgeAlpha == 0.0) {
  discard;
}
`;

function oW(r) {
    const e = LA(r, {
        chained: !0,
        extensions: {
            derivatives: !0
        },
        uniforms: {
            uTroikaSDFTexture: {
                value: null
            },
            uTroikaSDFTextureSize: {
                value: new Ue
            },
            uTroikaSDFGlyphSize: {
                value: 0
            },
            uTroikaSDFExponent: {
                value: 0
            },
            uTroikaTotalBounds: {
                value: new An(0, 0, 0, 0)
            },
            uTroikaClipRect: {
                value: new An(0, 0, 0, 0)
            },
            uTroikaEdgeOffset: {
                value: 0
            },
            uTroikaFillOpacity: {
                value: 1
            },
            uTroikaPositionOffset: {
                value: new Ue
            },
            uTroikaCurveRadius: {
                value: 0
            },
            uTroikaBlurRadius: {
                value: 0
            },
            uTroikaStrokeWidth: {
                value: 0
            },
            uTroikaStrokeColor: {
                value: new rt
            },
            uTroikaStrokeOpacity: {
                value: 1
            },
            uTroikaOrient: {
                value: new jt
            },
            uTroikaUseGlyphColors: {
                value: !0
            },
            uTroikaSDFDebug: {
                value: !1
            }
        },
        vertexDefs: nW,
        vertexTransform: iW,
        fragmentDefs: rW,
        fragmentColorTransform: sW,
        customRewriter({
            vertexShader: t,
            fragmentShader: n
        }) {
            let i = /\buniform\s+vec3\s+diffuse\b/;
            return i.test(n) && (n = n.replace(i, "varying vec3 vTroikaGlyphColor").replace(/\bdiffuse\b/g, "vTroikaGlyphColor"), i.test(t) || (t = t.replace(zD, `uniform vec3 diffuse;
$&
vTroikaGlyphColor = uTroikaUseGlyphColors ? aTroikaGlyphColor / 255.0 : diffuse;
`))), {
                vertexShader: t,
                fragmentShader: n
            }
        }
    });
    return e.transparent = !0, e.forceSinglePass = !0, Object.defineProperties(e, {
        isTroikaTextMaterial: {
            value: !0
        },
        shadowSide: {
            get() {
                return this.side
            },
            set() {}
        }
    }), e
}
const CM = new Mi({
        color: 16777215,
        side: hn,
        transparent: !0
    }),
    rR = 8421504,
    sR = new Ot,
    f0 = new K,
    c1 = new K,
    ld = [],
    aW = new K,
    u1 = "+x+y";

function oR(r) {
    return Array.isArray(r) ? r[0] : r
}
let XD = () => {
        const r = new Tn(new bs(1, 1), CM);
        return XD = () => r, r
    },
    YD = () => {
        const r = new Tn(new bs(1, 1, 32, 1), CM);
        return YD = () => r, r
    };
const lW = {
        type: "syncstart"
    },
    cW = {
        type: "synccomplete"
    },
    JD = ["font", "fontSize", "fontStyle", "fontWeight", "lang", "letterSpacing", "lineHeight", "maxWidth", "overflowWrap", "text", "direction", "textAlign", "textIndent", "whiteSpace", "anchorX", "anchorY", "colorRanges", "sdfGlyphSize"],
    uW = JD.concat("material", "color", "depthOffset", "clipRect", "curveRadius", "orientation", "glyphGeometryDetail");
let KD = class extends Tn {
    constructor() {
        const e = new tW;
        super(e, null), this.text = "", this.anchorX = 0, this.anchorY = 0, this.curveRadius = 0, this.direction = "auto", this.font = null, this.unicodeFontsURL = null, this.fontSize = .1, this.fontWeight = "normal", this.fontStyle = "normal", this.lang = null, this.letterSpacing = 0, this.lineHeight = "normal", this.maxWidth = 1 / 0, this.overflowWrap = "normal", this.textAlign = "left", this.textIndent = 0, this.whiteSpace = "normal", this.material = null, this.color = null, this.colorRanges = null, this.outlineWidth = 0, this.outlineColor = 0, this.outlineOpacity = 1, this.outlineBlur = 0, this.outlineOffsetX = 0, this.outlineOffsetY = 0, this.strokeWidth = 0, this.strokeColor = rR, this.strokeOpacity = 1, this.fillOpacity = 1, this.depthOffset = 0, this.clipRect = null, this.orientation = u1, this.glyphGeometryDetail = 1, this.sdfGlyphSize = null, this.gpuAccelerateSDF = !0, this.debugSDF = !1
    }
    sync(e) {
        this._needsSync && (this._needsSync = !1, this._isSyncing ? (this._queuedSyncs || (this._queuedSyncs = [])).push(e) : (this._isSyncing = !0, this.dispatchEvent(lW), HD({
            text: this.text,
            font: this.font,
            lang: this.lang,
            fontSize: this.fontSize || .1,
            fontWeight: this.fontWeight || "normal",
            fontStyle: this.fontStyle || "normal",
            letterSpacing: this.letterSpacing || 0,
            lineHeight: this.lineHeight || "normal",
            maxWidth: this.maxWidth,
            direction: this.direction || "auto",
            textAlign: this.textAlign,
            textIndent: this.textIndent,
            whiteSpace: this.whiteSpace,
            overflowWrap: this.overflowWrap,
            anchorX: this.anchorX,
            anchorY: this.anchorY,
            colorRanges: this.colorRanges,
            includeCaretPositions: !0,
            sdfGlyphSize: this.sdfGlyphSize,
            gpuAccelerateSDF: this.gpuAccelerateSDF,
            unicodeFontsURL: this.unicodeFontsURL
        }, t => {
            this._isSyncing = !1, this._textRenderInfo = t, this.geometry.updateGlyphs(t.glyphBounds, t.glyphAtlasIndices, t.blockBounds, t.chunkedBounds, t.glyphColors);
            const n = this._queuedSyncs;
            n && (this._queuedSyncs = null, this._needsSync = !0, this.sync(() => {
                n.forEach(i => i && i())
            })), this.dispatchEvent(cW), e && e()
        })))
    }
    onBeforeRender(e, t, n, i, s, o) {
        this.sync(), s.isTroikaTextMaterial && this._prepareForRender(s)
    }
    dispose() {
        this.geometry.dispose()
    }
    get textRenderInfo() {
        return this._textRenderInfo || null
    }
    createDerivedMaterial(e) {
        return oW(e)
    }
    get material() {
        let e = this._derivedMaterial;
        const t = this._baseMaterial || this._defaultMaterial || (this._defaultMaterial = CM.clone());
        if ((!e || !e.isDerivedFrom(t)) && (e = this._derivedMaterial = this.createDerivedMaterial(t), t.addEventListener("dispose", function n() {
                t.removeEventListener("dispose", n), e.dispose()
            })), this.hasOutline()) {
            let n = e._outlineMtl;
            return n || (n = e._outlineMtl = Object.create(e, {
                id: {
                    value: e.id + .1
                }
            }), n.isTextOutlineMaterial = !0, n.depthWrite = !1, n.map = null, e.addEventListener("dispose", function i() {
                e.removeEventListener("dispose", i), n.dispose()
            })), [n, e]
        } else return e
    }
    set material(e) {
        e && e.isTroikaTextMaterial ? (this._derivedMaterial = e, this._baseMaterial = e.baseMaterial) : this._baseMaterial = e
    }
    hasOutline() {
        return !!(this.outlineWidth || this.outlineBlur || this.outlineOffsetX || this.outlineOffsetY)
    }
    get glyphGeometryDetail() {
        return this.geometry.detail
    }
    set glyphGeometryDetail(e) {
        this.geometry.detail = e
    }
    get curveRadius() {
        return this.geometry.curveRadius
    }
    set curveRadius(e) {
        this.geometry.curveRadius = e
    }
    get customDepthMaterial() {
        return oR(this.material).getDepthMaterial()
    }
    get customDistanceMaterial() {
        return oR(this.material).getDistanceMaterial()
    }
    _prepareForRender(e) {
        const t = e.isTextOutlineMaterial,
            n = e.uniforms,
            i = this.textRenderInfo;
        if (i) {
            const {
                sdfTexture: a,
                blockBounds: l
            } = i;
            n.uTroikaSDFTexture.value = a, n.uTroikaSDFTextureSize.value.set(a.image.width, a.image.height), n.uTroikaSDFGlyphSize.value = i.sdfGlyphSize, n.uTroikaSDFExponent.value = i.sdfExponent, n.uTroikaTotalBounds.value.fromArray(l), n.uTroikaUseGlyphColors.value = !t && !!i.glyphColors;
            let c = 0,
                u = 0,
                f = 0,
                d, m, g, y = 0,
                v = 0;
            if (t) {
                let {
                    outlineWidth: A,
                    outlineOffsetX: S,
                    outlineOffsetY: M,
                    outlineBlur: C,
                    outlineOpacity: E
                } = this;
                c = this._parsePercent(A) || 0, u = Math.max(0, this._parsePercent(C) || 0), d = E, y = this._parsePercent(S) || 0, v = this._parsePercent(M) || 0
            } else f = Math.max(0, this._parsePercent(this.strokeWidth) || 0), f && (g = this.strokeColor, n.uTroikaStrokeColor.value.set(g ? ? rR), m = this.strokeOpacity, m == null && (m = 1)), d = this.fillOpacity;
            n.uTroikaEdgeOffset.value = c, n.uTroikaPositionOffset.value.set(y, v), n.uTroikaBlurRadius.value = u, n.uTroikaStrokeWidth.value = f, n.uTroikaStrokeOpacity.value = m, n.uTroikaFillOpacity.value = d ? ? 1, n.uTroikaCurveRadius.value = this.curveRadius || 0;
            let _ = this.clipRect;
            if (_ && Array.isArray(_) && _.length === 4) n.uTroikaClipRect.value.fromArray(_);
            else {
                const A = (this.fontSize || .1) * 100;
                n.uTroikaClipRect.value.set(l[0] - A, l[1] - A, l[2] + A, l[3] + A)
            }
            this.geometry.applyClipRect(n.uTroikaClipRect.value)
        }
        n.uTroikaSDFDebug.value = !!this.debugSDF, e.polygonOffset = !!this.depthOffset, e.polygonOffsetFactor = e.polygonOffsetUnits = this.depthOffset || 0;
        const s = t ? this.outlineColor || 0 : this.color;
        if (s == null) delete e.color;
        else {
            const a = e.hasOwnProperty("color") ? e.color : e.color = new rt;
            (s !== a._input || typeof s == "object") && a.set(a._input = s)
        }
        let o = this.orientation || u1;
        if (o !== e._orientation) {
            let a = n.uTroikaOrient.value;
            o = o.replace(/[^-+xyz]/g, "");
            let l = o !== u1 && o.match(/^([-+])([xyz])([-+])([xyz])$/);
            if (l) {
                let [, c, u, f, d] = l;
                f0.set(0, 0, 0)[u] = c === "-" ? 1 : -1, c1.set(0, 0, 0)[d] = f === "-" ? -1 : 1, sR.lookAt(aW, f0.cross(c1), c1), a.setFromMatrix4(sR)
            } else a.identity();
            e._orientation = o
        }
    }
    _parsePercent(e) {
        if (typeof e == "string") {
            let t = e.match(/^(-?[\d.]+)%$/),
                n = t ? parseFloat(t[1]) : NaN;
            e = (isNaN(n) ? 0 : n / 100) * this.fontSize
        }
        return e
    }
    localPositionToTextCoords(e, t = new Ue) {
        t.copy(e);
        const n = this.curveRadius;
        return n && (t.x = Math.atan2(e.x, Math.abs(n) - Math.abs(e.z)) * Math.abs(n)), t
    }
    worldPositionToTextCoords(e, t = new Ue) {
        return f0.copy(e), this.localPositionToTextCoords(this.worldToLocal(f0), t)
    }
    raycast(e, t) {
        const {
            textRenderInfo: n,
            curveRadius: i
        } = this;
        if (n) {
            const s = n.blockBounds,
                o = i ? YD() : XD(),
                a = o.geometry,
                {
                    position: l,
                    uv: c
                } = a.attributes;
            for (let u = 0; u < c.count; u++) {
                let f = s[0] + c.getX(u) * (s[2] - s[0]);
                const d = s[1] + c.getY(u) * (s[3] - s[1]);
                let m = 0;
                i && (m = i - Math.cos(f / i) * i, f = Math.sin(f / i) * i), l.setXYZ(u, f, d, m)
            }
            a.boundingSphere = this.geometry.boundingSphere, a.boundingBox = this.geometry.boundingBox, o.matrixWorld = this.matrixWorld, o.material.side = this.material.side, ld.length = 0, o.raycast(e, ld);
            for (let u = 0; u < ld.length; u++) ld[u].object = this, t.push(ld[u])
        }
    }
    copy(e) {
        const t = this.geometry;
        return super.copy(e), this.geometry = t, uW.forEach(n => {
            this[n] = e[n]
        }), this
    }
    clone() {
        return new this.constructor().copy(this)
    }
};
JD.forEach(r => {
    const e = "_private_" + r;
    Object.defineProperty(KD.prototype, r, {
        get() {
            return this[e]
        },
        set(t) {
            t !== this[e] && (this[e] = t, this._needsSync = !0)
        }
    })
});
new Wi;
new rt;
const Di = N.forwardRef(({
    sdfGlyphSize: r = 64,
    anchorX: e = "center",
    anchorY: t = "middle",
    font: n,
    fontSize: i = 1,
    children: s,
    characters: o,
    onSync: a,
    ...l
}, c) => {
    const u = qn(({
            invalidate: g
        }) => g),
        [f] = N.useState(() => new KD),
        [d, m] = N.useMemo(() => {
            const g = [];
            let y = "";
            return N.Children.forEach(s, v => {
                typeof v == "string" || typeof v == "number" ? y += v : g.push(v)
            }), [g, y]
        }, [s]);
    return cD(() => new Promise(g => K9({
        font: n,
        characters: o
    }, g)), ["troika-text", n, o]), N.useLayoutEffect(() => void f.sync(() => {
        u(), a && a(f)
    })), N.useEffect(() => () => f.dispose(), [f]), N.createElement("primitive", Cl({
        object: f,
        ref: c,
        font: n,
        text: m,
        anchorX: e,
        anchorY: t,
        fontSize: i,
        sdfGlyphSize: r
    }, l), d)
});

function fW(r, e, t, n) {
    const i = class extends Fn {
        constructor(o = {}) {
            const a = Object.entries(r);
            super({
                uniforms: a.reduce((l, [c, u]) => {
                    const f = bl.clone({
                        [c]: {
                            value: u
                        }
                    });
                    return { ...l,
                        ...f
                    }
                }, {}),
                vertexShader: e,
                fragmentShader: t
            }), this.key = "", a.forEach(([l]) => Object.defineProperty(this, l, {
                get: () => this.uniforms[l].value,
                set: c => this.uniforms[l].value = c
            })), Object.assign(this, o)
        }
    };
    return i.key = ha.generateUUID(), i
}
const f1 = r => r === Object(r) && !Array.isArray(r) && typeof r != "function";

function _u(r, e) {
    const t = qn(s => s.gl),
        n = vr(zo, f1(r) ? Object.values(r) : r);
    return N.useLayoutEffect(() => {
        e == null || e(n)
    }, [e]), N.useEffect(() => {
        if ("initTexture" in t) {
            let s = [];
            Array.isArray(n) ? s = n : n instanceof gn ? s = [n] : f1(n) && (s = Object.values(n)), s.forEach(o => {
                o instanceof gn && t.initTexture(o)
            })
        }
    }, [t, n]), N.useMemo(() => {
        if (f1(r)) {
            const s = {};
            let o = 0;
            for (const a in r) s[a] = n[o++];
            return s
        } else return n
    }, [r, n])
}
_u.preload = r => vr.preload(zo, r);
_u.clear = r => vr.clear(zo, r);
let h0 = null,
    qD = "https://www.gstatic.com/draco/versioned/decoders/1.5.5/";

function ZD(r = !0, e = !0, t) {
    return n => {
        t && t(n), r && (h0 || (h0 = new m9), h0.setDecoderPath(typeof r == "string" ? r : qD), n.setDRACOLoader(h0)), e && n.setMeshoptDecoder(typeof a1 == "function" ? a1() : a1)
    }
}
const $s = (r, e, t, n) => vr(EM, r, ZD(e, t, n));
$s.preload = (r, e, t, n) => vr.preload(EM, r, ZD(e, t, n));
$s.clear = r => vr.clear(EM, r);
$s.setDecoderPath = r => {
    qD = r
};

function Nv(r, e, t) {
    const n = qn(d => d.size),
        i = qn(d => d.viewport),
        s = typeof r == "number" ? r : n.width * i.dpr,
        o = n.height * i.dpr,
        a = (typeof r == "number" ? t : r) || {},
        {
            samples: l = 0,
            depth: c,
            ...u
        } = a,
        f = N.useMemo(() => {
            const d = new Zn(s, o, {
                minFilter: nn,
                magFilter: nn,
                type: Ri,
                ...u
            });
            return c && (d.depthTexture = new Yp(s, o, Bn)), d.samples = l, d
        }, []);
    return N.useLayoutEffect(() => {
        f.setSize(s, o), l && (f.samples = l)
    }, [l, f, s, o]), N.useEffect(() => () => f.dispose(), []), f
}
const hW = r => typeof r == "function",
    dW = N.forwardRef(({
        envMap: r,
        resolution: e = 256,
        frames: t = 1 / 0,
        children: n,
        makeDefault: i,
        ...s
    }, o) => {
        const a = qn(({
                set: v
            }) => v),
            l = qn(({
                camera: v
            }) => v),
            c = qn(({
                size: v
            }) => v),
            u = N.useRef(null);
        N.useImperativeHandle(o, () => u.current, []);
        const f = N.useRef(null),
            d = Nv(e);
        N.useLayoutEffect(() => {
            s.manual || u.current.updateProjectionMatrix()
        }, [c, s]), N.useLayoutEffect(() => {
            u.current.updateProjectionMatrix()
        }), N.useLayoutEffect(() => {
            if (i) {
                const v = l;
                return a(() => ({
                    camera: u.current
                })), () => a(() => ({
                    camera: v
                }))
            }
        }, [u, i, a]);
        let m = 0,
            g = null;
        const y = hW(n);
        return Es(v => {
            y && (t === 1 / 0 || m < t) && (f.current.visible = !1, v.gl.setRenderTarget(d), g = v.scene.background, r && (v.scene.background = r), v.gl.render(v.scene, u.current), v.scene.background = g, v.gl.setRenderTarget(null), f.current.visible = !0, m++)
        }), N.createElement(N.Fragment, null, N.createElement("orthographicCamera", Cl({
            left: c.width / -2,
            right: c.width / 2,
            top: c.height / 2,
            bottom: c.height / -2,
            ref: u
        }, s), !y && n), N.createElement("group", {
            ref: f
        }, y && n(d.texture)))
    }),
    pW = r => typeof r == "function",
    QD = N.forwardRef(({
        envMap: r,
        resolution: e = 256,
        frames: t = 1 / 0,
        makeDefault: n,
        children: i,
        ...s
    }, o) => {
        const a = qn(({
                set: v
            }) => v),
            l = qn(({
                camera: v
            }) => v),
            c = qn(({
                size: v
            }) => v),
            u = N.useRef(null);
        N.useImperativeHandle(o, () => u.current, []);
        const f = N.useRef(null),
            d = Nv(e);
        N.useLayoutEffect(() => {
            s.manual || (u.current.aspect = c.width / c.height)
        }, [c, s]), N.useLayoutEffect(() => {
            u.current.updateProjectionMatrix()
        });
        let m = 0,
            g = null;
        const y = pW(i);
        return Es(v => {
            y && (t === 1 / 0 || m < t) && (f.current.visible = !1, v.gl.setRenderTarget(d), g = v.scene.background, r && (v.scene.background = r), v.gl.render(v.scene, u.current), v.scene.background = g, v.gl.setRenderTarget(null), f.current.visible = !0, m++)
        }), N.useLayoutEffect(() => {
            if (n) {
                const v = l;
                return a(() => ({
                    camera: u.current
                })), () => a(() => ({
                    camera: v
                }))
            }
        }, [u, n, a]), N.createElement(N.Fragment, null, N.createElement("perspectiveCamera", Cl({
            ref: u
        }, s), !y && i), N.createElement("group", {
            ref: f
        }, y && i(d.texture)))
    }),
    mW = 3e3,
    gW = 3001,
    vW = fW({}, "void main() { }", "void main() { gl_FragColor = vec4(0.0, 0.0, 0.0, 0.0); discard;  }");
class yW extends Ts {
    constructor(e = 6, t = !1) {
        super(), this.uniforms = {
            chromaticAberration: {
                value: .05
            },
            transmission: {
                value: 0
            },
            _transmission: {
                value: 1
            },
            transmissionMap: {
                value: null
            },
            roughness: {
                value: 0
            },
            thickness: {
                value: 0
            },
            thicknessMap: {
                value: null
            },
            attenuationDistance: {
                value: 1 / 0
            },
            attenuationColor: {
                value: new rt("white")
            },
            anisotropicBlur: {
                value: .1
            },
            time: {
                value: 0
            },
            distortion: {
                value: 0
            },
            distortionScale: {
                value: .5
            },
            temporalDistortion: {
                value: 0
            },
            buffer: {
                value: null
            }
        }, this.onBeforeCompile = n => {
            n.uniforms = { ...n.uniforms,
                ...this.uniforms
            }, this.anisotropy > 0 && (n.defines.USE_ANISOTROPY = ""), t ? n.defines.USE_SAMPLER = "" : n.defines.USE_TRANSMISSION = "", n.fragmentShader = `
      uniform float chromaticAberration;         
      uniform float anisotropicBlur;      
      uniform float time;
      uniform float distortion;
      uniform float distortionScale;
      uniform float temporalDistortion;
      uniform sampler2D buffer;

      vec3 random3(vec3 c) {
        float j = 4096.0*sin(dot(c,vec3(17.0, 59.4, 15.0)));
        vec3 r;
        r.z = fract(512.0*j);
        j *= .125;
        r.x = fract(512.0*j);
        j *= .125;
        r.y = fract(512.0*j);
        return r-0.5;
      }

      uint hash( uint x ) {
        x += ( x << 10u );
        x ^= ( x >>  6u );
        x += ( x <<  3u );
        x ^= ( x >> 11u );
        x += ( x << 15u );
        return x;
      }

      // Compound versions of the hashing algorithm I whipped together.
      uint hash( uvec2 v ) { return hash( v.x ^ hash(v.y)                         ); }
      uint hash( uvec3 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z)             ); }
      uint hash( uvec4 v ) { return hash( v.x ^ hash(v.y) ^ hash(v.z) ^ hash(v.w) ); }

      // Construct a float with half-open range [0:1] using low 23 bits.
      // All zeroes yields 0.0, all ones yields the next smallest representable value below 1.0.
      float floatConstruct( uint m ) {
        const uint ieeeMantissa = 0x007FFFFFu; // binary32 mantissa bitmask
        const uint ieeeOne      = 0x3F800000u; // 1.0 in IEEE binary32
        m &= ieeeMantissa;                     // Keep only mantissa bits (fractional part)
        m |= ieeeOne;                          // Add fractional part to 1.0
        float  f = uintBitsToFloat( m );       // Range [1:2]
        return f - 1.0;                        // Range [0:1]
      }

      // Pseudo-random value in half-open range [0:1].
      float randomBase( float x ) { return floatConstruct(hash(floatBitsToUint(x))); }
      float randomBase( vec2  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
      float randomBase( vec3  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
      float randomBase( vec4  v ) { return floatConstruct(hash(floatBitsToUint(v))); }
      float rand(float seed) {
        float result = randomBase(vec3(gl_FragCoord.xy, seed));
        return result;
      }

      const float F3 =  0.3333333;
      const float G3 =  0.1666667;

      float snoise(vec3 p) {
        vec3 s = floor(p + dot(p, vec3(F3)));
        vec3 x = p - s + dot(s, vec3(G3));
        vec3 e = step(vec3(0.0), x - x.yzx);
        vec3 i1 = e*(1.0 - e.zxy);
        vec3 i2 = 1.0 - e.zxy*(1.0 - e);
        vec3 x1 = x - i1 + G3;
        vec3 x2 = x - i2 + 2.0*G3;
        vec3 x3 = x - 1.0 + 3.0*G3;
        vec4 w, d;
        w.x = dot(x, x);
        w.y = dot(x1, x1);
        w.z = dot(x2, x2);
        w.w = dot(x3, x3);
        w = max(0.6 - w, 0.0);
        d.x = dot(random3(s), x);
        d.y = dot(random3(s + i1), x1);
        d.z = dot(random3(s + i2), x2);
        d.w = dot(random3(s + 1.0), x3);
        w *= w;
        w *= w;
        d *= w;
        return dot(d, vec4(52.0));
      }

      float snoiseFractal(vec3 m) {
        return 0.5333333* snoise(m)
              +0.2666667* snoise(2.0*m)
              +0.1333333* snoise(4.0*m)
              +0.0666667* snoise(8.0*m);
      }
` + n.fragmentShader, n.fragmentShader = n.fragmentShader.replace("#include <transmission_pars_fragment>", `
        #ifdef USE_TRANSMISSION
          // Transmission code is based on glTF-Sampler-Viewer
          // https://github.com/KhronosGroup/glTF-Sample-Viewer
          uniform float _transmission;
          uniform float thickness;
          uniform float attenuationDistance;
          uniform vec3 attenuationColor;
          #ifdef USE_TRANSMISSIONMAP
            uniform sampler2D transmissionMap;
          #endif
          #ifdef USE_THICKNESSMAP
            uniform sampler2D thicknessMap;
          #endif
          uniform vec2 transmissionSamplerSize;
          uniform sampler2D transmissionSamplerMap;
          uniform mat4 modelMatrix;
          uniform mat4 projectionMatrix;
          varying vec3 vWorldPosition;
          vec3 getVolumeTransmissionRay( const in vec3 n, const in vec3 v, const in float thickness, const in float ior, const in mat4 modelMatrix ) {
            // Direction of refracted light.
            vec3 refractionVector = refract( - v, normalize( n ), 1.0 / ior );
            // Compute rotation-independant scaling of the model matrix.
            vec3 modelScale;
            modelScale.x = length( vec3( modelMatrix[ 0 ].xyz ) );
            modelScale.y = length( vec3( modelMatrix[ 1 ].xyz ) );
            modelScale.z = length( vec3( modelMatrix[ 2 ].xyz ) );
            // The thickness is specified in local space.
            return normalize( refractionVector ) * thickness * modelScale;
          }
          float applyIorToRoughness( const in float roughness, const in float ior ) {
            // Scale roughness with IOR so that an IOR of 1.0 results in no microfacet refraction and
            // an IOR of 1.5 results in the default amount of microfacet refraction.
            return roughness * clamp( ior * 2.0 - 2.0, 0.0, 1.0 );
          }
          vec4 getTransmissionSample( const in vec2 fragCoord, const in float roughness, const in float ior ) {
            float framebufferLod = log2( transmissionSamplerSize.x ) * applyIorToRoughness( roughness, ior );            
            #ifdef USE_SAMPLER
              #ifdef texture2DLodEXT
                return texture2DLodEXT(transmissionSamplerMap, fragCoord.xy, framebufferLod);
              #else
                return texture2D(transmissionSamplerMap, fragCoord.xy, framebufferLod);
              #endif
            #else
              return texture2D(buffer, fragCoord.xy);
            #endif
          }
          vec3 applyVolumeAttenuation( const in vec3 radiance, const in float transmissionDistance, const in vec3 attenuationColor, const in float attenuationDistance ) {
            if ( isinf( attenuationDistance ) ) {
              // Attenuation distance is +, i.e. the transmitted color is not attenuated at all.
              return radiance;
            } else {
              // Compute light attenuation using Beer's law.
              vec3 attenuationCoefficient = -log( attenuationColor ) / attenuationDistance;
              vec3 transmittance = exp( - attenuationCoefficient * transmissionDistance ); // Beer's law
              return transmittance * radiance;
            }
          }
          vec4 getIBLVolumeRefraction( const in vec3 n, const in vec3 v, const in float roughness, const in vec3 diffuseColor,
            const in vec3 specularColor, const in float specularF90, const in vec3 position, const in mat4 modelMatrix,
            const in mat4 viewMatrix, const in mat4 projMatrix, const in float ior, const in float thickness,
            const in vec3 attenuationColor, const in float attenuationDistance ) {
            vec3 transmissionRay = getVolumeTransmissionRay( n, v, thickness, ior, modelMatrix );
            vec3 refractedRayExit = position + transmissionRay;
            // Project refracted vector on the framebuffer, while mapping to normalized device coordinates.
            vec4 ndcPos = projMatrix * viewMatrix * vec4( refractedRayExit, 1.0 );
            vec2 refractionCoords = ndcPos.xy / ndcPos.w;
            refractionCoords += 1.0;
            refractionCoords /= 2.0;
            // Sample framebuffer to get pixel the refracted ray hits.
            vec4 transmittedLight = getTransmissionSample( refractionCoords, roughness, ior );
            vec3 attenuatedColor = applyVolumeAttenuation( transmittedLight.rgb, length( transmissionRay ), attenuationColor, attenuationDistance );
            // Get the specular component.
            vec3 F = EnvironmentBRDF( n, v, specularColor, specularF90, roughness );
            return vec4( ( 1.0 - F ) * attenuatedColor * diffuseColor, transmittedLight.a );
          }
        #endif
`), n.fragmentShader = n.fragmentShader.replace("#include <transmission_fragment>", `  
        // Improve the refraction to use the world pos
        material.transmission = _transmission;
        material.transmissionAlpha = 1.0;
        material.thickness = thickness;
        material.attenuationDistance = attenuationDistance;
        material.attenuationColor = attenuationColor;
        #ifdef USE_TRANSMISSIONMAP
          material.transmission *= texture2D( transmissionMap, vUv ).r;
        #endif
        #ifdef USE_THICKNESSMAP
          material.thickness *= texture2D( thicknessMap, vUv ).g;
        #endif
        
        vec3 pos = vWorldPosition;
        float runningSeed = 0.0;
        vec3 v = normalize( cameraPosition - pos );
        vec3 n = inverseTransformDirection( normal, viewMatrix );
        vec3 transmission = vec3(0.0);
        float transmissionR, transmissionB, transmissionG;
        float randomCoords = rand(runningSeed++);
        float thickness_smear = thickness * max(pow(roughnessFactor, 0.33), anisotropicBlur);
        vec3 distortionNormal = vec3(0.0);
        vec3 temporalOffset = vec3(time, -time, -time) * temporalDistortion;
        if (distortion > 0.0) {
          distortionNormal = distortion * vec3(snoiseFractal(vec3((pos * distortionScale + temporalOffset))), snoiseFractal(vec3(pos.zxy * distortionScale - temporalOffset)), snoiseFractal(vec3(pos.yxz * distortionScale + temporalOffset)));
        }
        for (float i = 0.0; i < ${e}.0; i ++) {
          vec3 sampleNorm = normalize(n + roughnessFactor * roughnessFactor * 2.0 * normalize(vec3(rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5, rand(runningSeed++) - 0.5)) * pow(rand(runningSeed++), 0.33) + distortionNormal);
          transmissionR = getIBLVolumeRefraction(
            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior, material.thickness  + thickness_smear * (i + randomCoords) / float(${e}),
            material.attenuationColor, material.attenuationDistance
          ).r;
          transmissionG = getIBLVolumeRefraction(
            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior  * (1.0 + chromaticAberration * (i + randomCoords) / float(${e})) , material.thickness + thickness_smear * (i + randomCoords) / float(${e}),
            material.attenuationColor, material.attenuationDistance
          ).g;
          transmissionB = getIBLVolumeRefraction(
            sampleNorm, v, material.roughness, material.diffuseColor, material.specularColor, material.specularF90,
            pos, modelMatrix, viewMatrix, projectionMatrix, material.ior * (1.0 + 2.0 * chromaticAberration * (i + randomCoords) / float(${e})), material.thickness + thickness_smear * (i + randomCoords) / float(${e}),
            material.attenuationColor, material.attenuationDistance
          ).b;
          transmission.r += transmissionR;
          transmission.g += transmissionG;
          transmission.b += transmissionB;
        }
        transmission /= ${e}.0;
        totalDiffuse = mix( totalDiffuse, transmission.rgb, material.transmission );
`)
        }, Object.keys(this.uniforms).forEach(n => Object.defineProperty(this, n, {
            get: () => this.uniforms[n].value,
            set: i => this.uniforms[n].value = i
        }))
    }
}
const rm = N.forwardRef(({
        buffer: r,
        transmissionSampler: e = !1,
        backside: t = !1,
        side: n = Zs,
        transmission: i = 1,
        thickness: s = 0,
        backsideThickness: o = 0,
        backsideEnvMapIntensity: a = 1,
        samples: l = 10,
        resolution: c,
        backsideResolution: u,
        background: f,
        anisotropy: d,
        anisotropicBlur: m,
        ...g
    }, y) => {
        Ny({
            MeshTransmissionMaterial: yW
        });
        const v = N.useRef(null),
            [_] = N.useState(() => new vW),
            A = Nv(u || c),
            S = Nv(c);
        let M, C, E, R;
        return Es(P => {
            v.current.time = P.clock.getElapsedTime(), v.current.buffer === S.texture && !e && (R = v.current.__r3f.parent, R && (E = P.gl.toneMapping, M = P.scene.background, C = v.current.envMapIntensity, P.gl.toneMapping = Js, f && (P.scene.background = f), R.material = _, t && (P.gl.setRenderTarget(A), P.gl.render(P.scene, P.camera), R.material = v.current, R.material.buffer = A.texture, R.material.thickness = o, R.material.side = di, R.material.envMapIntensity = a), P.gl.setRenderTarget(S), P.gl.render(P.scene, P.camera), R.material = v.current, R.material.thickness = s, R.material.side = n, R.material.buffer = S.texture, R.material.envMapIntensity = C, P.scene.background = M, P.gl.setRenderTarget(null), P.gl.toneMapping = E))
        }), N.useImperativeHandle(y, () => v.current, []), N.createElement("meshTransmissionMaterial", Cl({
            args: [l, e],
            ref: v
        }, g, {
            buffer: r || S.texture,
            _transmission: i,
            anisotropicBlur: m ? ? d,
            transmission: e ? i : 0,
            thickness: s,
            side: n
        }))
    }),
    $D = (r, e, t) => {
        let n;
        switch (r) {
            case Yi:
                n = new Uint8ClampedArray(e * t * 4);
                break;
            case Ri:
                n = new Uint16Array(e * t * 4);
                break;
            case fo:
                n = new Uint32Array(e * t * 4);
                break;
            case oy:
                n = new Int8Array(e * t * 4);
                break;
            case ay:
                n = new Int16Array(e * t * 4);
                break;
            case Gp:
                n = new Int32Array(e * t * 4);
                break;
            case Bn:
                n = new Float32Array(e * t * 4);
                break;
            default:
                throw new Error("Unsupported data type")
        }
        return n
    };
let d0;
const _W = (r, e, t, n) => {
    if (d0 !== void 0) return d0;
    const i = new Zn(1, 1, n);
    e.setRenderTarget(i);
    const s = new Tn(new bs, new Mi({
        color: 16777215
    }));
    e.render(s, t), e.setRenderTarget(null);
    const o = $D(r, i.width, i.height);
    return e.readRenderTargetPixels(i, 0, 0, i.width, i.height, o), i.dispose(), s.geometry.dispose(), s.material.dispose(), d0 = o[0] !== 0, d0
};
class RM {
    constructor(e) {
        var t, n, i, s, o, a, l, c, u, f, d, m, g, y, v, _;
        this._rendererIsDisposable = !1, this._supportsReadPixels = !0, this.render = () => {
            this._renderer.setRenderTarget(this._renderTarget);
            try {
                this._renderer.render(this._scene, this._camera)
            } catch (S) {
                throw this._renderer.setRenderTarget(null), S
            }
            this._renderer.setRenderTarget(null)
        }, this._width = e.width, this._height = e.height, this._type = e.type, this._colorSpace = e.colorSpace;
        const A = {
            format: kn,
            depthBuffer: !1,
            stencilBuffer: !1,
            type: this._type,
            colorSpace: this._colorSpace,
            anisotropy: ((t = e.renderTargetOptions) === null || t === void 0 ? void 0 : t.anisotropy) !== void 0 ? (n = e.renderTargetOptions) === null || n === void 0 ? void 0 : n.anisotropy : 1,
            generateMipmaps: ((i = e.renderTargetOptions) === null || i === void 0 ? void 0 : i.generateMipmaps) !== void 0 ? (s = e.renderTargetOptions) === null || s === void 0 ? void 0 : s.generateMipmaps : !1,
            magFilter: ((o = e.renderTargetOptions) === null || o === void 0 ? void 0 : o.magFilter) !== void 0 ? (a = e.renderTargetOptions) === null || a === void 0 ? void 0 : a.magFilter : nn,
            minFilter: ((l = e.renderTargetOptions) === null || l === void 0 ? void 0 : l.minFilter) !== void 0 ? (c = e.renderTargetOptions) === null || c === void 0 ? void 0 : c.minFilter : nn,
            samples: ((u = e.renderTargetOptions) === null || u === void 0 ? void 0 : u.samples) !== void 0 ? (f = e.renderTargetOptions) === null || f === void 0 ? void 0 : f.samples : void 0,
            wrapS: ((d = e.renderTargetOptions) === null || d === void 0 ? void 0 : d.wrapS) !== void 0 ? (m = e.renderTargetOptions) === null || m === void 0 ? void 0 : m.wrapS : Nn,
            wrapT: ((g = e.renderTargetOptions) === null || g === void 0 ? void 0 : g.wrapT) !== void 0 ? (y = e.renderTargetOptions) === null || y === void 0 ? void 0 : y.wrapT : Nn
        };
        if (this._material = e.material, e.renderer ? this._renderer = e.renderer : (this._renderer = RM.instantiateRenderer(), this._rendererIsDisposable = !0), this._scene = new ho, this._camera = new Ca, this._camera.position.set(0, 0, 10), this._camera.left = -.5, this._camera.right = .5, this._camera.top = .5, this._camera.bottom = -.5, this._camera.updateProjectionMatrix(), !_W(this._type, this._renderer, this._camera, A)) {
            let S;
            switch (this._type) {
                case Ri:
                    S = this._renderer.extensions.has("EXT_color_buffer_float") ? Bn : void 0;
                    break
            }
            S !== void 0 ? (console.warn(`This browser does not support reading pixels from ${this._type} RenderTargets, switching to ${Bn}`), this._type = S) : (this._supportsReadPixels = !1, console.warn("This browser dos not support toArray or toDataTexture, calls to those methods will result in an error thrown"))
        }
        this._quad = new Tn(new bs, this._material), this._quad.geometry.computeBoundingBox(), this._scene.add(this._quad), this._renderTarget = new Zn(this.width, this.height, A), this._renderTarget.texture.mapping = ((v = e.renderTargetOptions) === null || v === void 0 ? void 0 : v.mapping) !== void 0 ? (_ = e.renderTargetOptions) === null || _ === void 0 ? void 0 : _.mapping : xl
    }
    static instantiateRenderer() {
        const e = new KS;
        return e.setSize(128, 128), e
    }
    toArray() {
        if (!this._supportsReadPixels) throw new Error("Can't read pixels in this browser");
        const e = $D(this._type, this._width, this._height);
        return this._renderer.readRenderTargetPixels(this._renderTarget, 0, 0, this._width, this._height, e), e
    }
    toDataTexture(e) {
        const t = new qr(this.toArray(), this.width, this.height, kn, this._type, (e == null ? void 0 : e.mapping) || xl, (e == null ? void 0 : e.wrapS) || Nn, (e == null ? void 0 : e.wrapT) || Nn, (e == null ? void 0 : e.magFilter) || nn, (e == null ? void 0 : e.minFilter) || nn, (e == null ? void 0 : e.anisotropy) || 1, Qs);
        return t.generateMipmaps = (e == null ? void 0 : e.generateMipmaps) !== void 0 ? e == null ? void 0 : e.generateMipmaps : !1, t
    }
    disposeOnDemandRenderer() {
        this._renderer.setRenderTarget(null), this._rendererIsDisposable && (this._renderer.dispose(), this._renderer.forceContextLoss())
    }
    dispose(e) {
        this.disposeOnDemandRenderer(), e && this.renderTarget.dispose(), this.material instanceof Fn && Object.values(this.material.uniforms).forEach(t => {
            t.value instanceof gn && t.value.dispose()
        }), Object.values(this.material).forEach(t => {
            t instanceof gn && t.dispose()
        }), this.material.dispose(), this._quad.geometry.dispose()
    }
    get width() {
        return this._width
    }
    set width(e) {
        this._width = e, this._renderTarget.setSize(this._width, this._height)
    }
    get height() {
        return this._height
    }
    set height(e) {
        this._height = e, this._renderTarget.setSize(this._width, this._height)
    }
    get renderer() {
        return this._renderer
    }
    get renderTarget() {
        return this._renderTarget
    }
    set renderTarget(e) {
        this._renderTarget = e, this._width = e.width, this._height = e.height
    }
    get material() {
        return this._material
    }
    get type() {
        return this._type
    }
    get colorSpace() {
        return this._colorSpace
    }
}
const xW = `
varying vec2 vUv;

void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}
`,
    AW = `
// min half float value
#define HALF_FLOAT_MIN vec3( -65504, -65504, -65504 )
// max half float value
#define HALF_FLOAT_MAX vec3( 65504, 65504, 65504 )

uniform sampler2D sdr;
uniform sampler2D gainMap;
uniform vec3 gamma;
uniform vec3 offsetHdr;
uniform vec3 offsetSdr;
uniform vec3 gainMapMin;
uniform vec3 gainMapMax;
uniform float weightFactor;

varying vec2 vUv;

void main() {
  vec3 rgb = texture2D( sdr, vUv ).rgb;
  vec3 recovery = texture2D( gainMap, vUv ).rgb;
  vec3 logRecovery = pow( recovery, gamma );
  vec3 logBoost = gainMapMin * ( 1.0 - logRecovery ) + gainMapMax * logRecovery;
  vec3 hdrColor = (rgb + offsetSdr) * exp2( logBoost * weightFactor ) - offsetHdr;
  vec3 clampedHdrColor = max( HALF_FLOAT_MIN, min( HALF_FLOAT_MAX, hdrColor ));
  gl_FragColor = vec4( clampedHdrColor , 1.0 );
}
`;
class SW extends Fn {
    constructor({
        gamma: e,
        offsetHdr: t,
        offsetSdr: n,
        gainMapMin: i,
        gainMapMax: s,
        maxDisplayBoost: o,
        hdrCapacityMin: a,
        hdrCapacityMax: l,
        sdr: c,
        gainMap: u
    }) {
        super({
            name: "GainMapDecoderMaterial",
            vertexShader: xW,
            fragmentShader: AW,
            uniforms: {
                sdr: {
                    value: c
                },
                gainMap: {
                    value: u
                },
                gamma: {
                    value: new K(1 / e[0], 1 / e[1], 1 / e[2])
                },
                offsetHdr: {
                    value: new K().fromArray(t)
                },
                offsetSdr: {
                    value: new K().fromArray(n)
                },
                gainMapMin: {
                    value: new K().fromArray(i)
                },
                gainMapMax: {
                    value: new K().fromArray(s)
                },
                weightFactor: {
                    value: (Math.log2(o) - a) / (l - a)
                }
            },
            blending: pi,
            depthTest: !1,
            depthWrite: !1
        }), this._maxDisplayBoost = o, this._hdrCapacityMin = a, this._hdrCapacityMax = l, this.needsUpdate = !0, this.uniformsNeedUpdate = !0
    }
    get sdr() {
        return this.uniforms.sdr.value
    }
    set sdr(e) {
        this.uniforms.sdr.value = e
    }
    get gainMap() {
        return this.uniforms.gainMap.value
    }
    set gainMap(e) {
        this.uniforms.gainMap.value = e
    }
    get offsetHdr() {
        return this.uniforms.offsetHdr.value.toArray()
    }
    set offsetHdr(e) {
        this.uniforms.offsetHdr.value.fromArray(e)
    }
    get offsetSdr() {
        return this.uniforms.offsetSdr.value.toArray()
    }
    set offsetSdr(e) {
        this.uniforms.offsetSdr.value.fromArray(e)
    }
    get gainMapMin() {
        return this.uniforms.gainMapMin.value.toArray()
    }
    set gainMapMin(e) {
        this.uniforms.gainMapMin.value.fromArray(e)
    }
    get gainMapMax() {
        return this.uniforms.gainMapMax.value.toArray()
    }
    set gainMapMax(e) {
        this.uniforms.gainMapMax.value.fromArray(e)
    }
    get gamma() {
        const e = this.uniforms.gamma.value;
        return [1 / e.x, 1 / e.y, 1 / e.z]
    }
    set gamma(e) {
        const t = this.uniforms.gamma.value;
        t.x = 1 / e[0], t.y = 1 / e[1], t.z = 1 / e[2]
    }
    get hdrCapacityMin() {
        return this._hdrCapacityMin
    }
    set hdrCapacityMin(e) {
        this._hdrCapacityMin = e, this.calculateWeight()
    }
    get hdrCapacityMax() {
        return this._hdrCapacityMax
    }
    set hdrCapacityMax(e) {
        this._hdrCapacityMax = e, this.calculateWeight()
    }
    get maxDisplayBoost() {
        return this._maxDisplayBoost
    }
    set maxDisplayBoost(e) {
        this._maxDisplayBoost = Math.max(1, Math.min(65504, e)), this.calculateWeight()
    }
    calculateWeight() {
        const e = (Math.log2(this._maxDisplayBoost) - this._hdrCapacityMin) / (this._hdrCapacityMax - this._hdrCapacityMin);
        this.uniforms.weightFactor.value = Math.max(0, Math.min(1, e))
    }
}
class eL extends Error {}
class tL extends Error {}
const cd = (r, e, t) => {
        const n = new RegExp(`${e}="([^"]*)"`, "i").exec(r);
        if (n) return n[1];
        const i = new RegExp(`<${e}[^>]*>([\\s\\S]*?)</${e}>`, "i").exec(r);
        if (i) {
            const s = i[1].match(/<rdf:li>([^<]*)<\/rdf:li>/g);
            return s && s.length === 3 ? s.map(o => o.replace(/<\/?rdf:li>/g, "")) : i[1].trim()
        }
        if (t !== void 0) return t;
        throw new Error(`Can't find ${e} in gainmap metadata`)
    },
    MW = r => {
        let e;
        typeof TextDecoder < "u" ? e = new TextDecoder().decode(r) : e = r.toString();
        let t = e.indexOf("<x:xmpmeta");
        for (; t !== -1;) {
            const n = e.indexOf("x:xmpmeta>", t),
                i = e.slice(t, n + 10);
            try {
                const s = cd(i, "hdrgm:GainMapMin", "0"),
                    o = cd(i, "hdrgm:GainMapMax"),
                    a = cd(i, "hdrgm:Gamma", "1"),
                    l = cd(i, "hdrgm:OffsetSDR", "0.015625"),
                    c = cd(i, "hdrgm:OffsetHDR", "0.015625"),
                    u = /hdrgm:HDRCapacityMin="([^"]*)"/.exec(i),
                    f = u ? u[1] : "0",
                    d = /hdrgm:HDRCapacityMax="([^"]*)"/.exec(i);
                if (!d) throw new Error("Incomplete gainmap metadata");
                const m = d[1];
                return {
                    gainMapMin: Array.isArray(s) ? s.map(g => parseFloat(g)) : [parseFloat(s), parseFloat(s), parseFloat(s)],
                    gainMapMax: Array.isArray(o) ? o.map(g => parseFloat(g)) : [parseFloat(o), parseFloat(o), parseFloat(o)],
                    gamma: Array.isArray(a) ? a.map(g => parseFloat(g)) : [parseFloat(a), parseFloat(a), parseFloat(a)],
                    offsetSdr: Array.isArray(l) ? l.map(g => parseFloat(g)) : [parseFloat(l), parseFloat(l), parseFloat(l)],
                    offsetHdr: Array.isArray(c) ? c.map(g => parseFloat(g)) : [parseFloat(c), parseFloat(c), parseFloat(c)],
                    hdrCapacityMin: parseFloat(f),
                    hdrCapacityMax: parseFloat(m)
                }
            } catch {}
            t = e.indexOf("<x:xmpmeta", n)
        }
    };
class wW {
    constructor(e) {
        this.options = {
            debug: e && e.debug !== void 0 ? e.debug : !1,
            extractFII: e && e.extractFII !== void 0 ? e.extractFII : !0,
            extractNonFII: e && e.extractNonFII !== void 0 ? e.extractNonFII : !0
        }
    }
    extract(e) {
        return new Promise((t, n) => {
            const i = this.options.debug,
                s = new DataView(e.buffer);
            if (s.getUint16(0) !== 65496) {
                n(new Error("Not a valid jpeg"));
                return
            }
            const o = s.byteLength;
            let a = 2,
                l = 0,
                c;
            for (; a < o;) {
                if (++l > 250) {
                    n(new Error(`Found no marker after ${l} loops `));
                    return
                }
                if (s.getUint8(a) !== 255) {
                    n(new Error(`Not a valid marker at offset 0x${a.toString(16)}, found: 0x${s.getUint8(a).toString(16)}`));
                    return
                }
                if (c = s.getUint8(a + 1), i && console.log(`Marker: ${c.toString(16)}`), c === 226) {
                    i && console.log("Found APP2 marker (0xffe2)");
                    const u = a + 4;
                    if (s.getUint32(u) === 1297106432) {
                        const f = u + 4;
                        let d;
                        if (s.getUint16(f) === 18761) d = !1;
                        else if (s.getUint16(f) === 19789) d = !0;
                        else {
                            n(new Error("No valid endianness marker found in TIFF header"));
                            return
                        }
                        if (s.getUint16(f + 2, !d) !== 42) {
                            n(new Error("Not valid TIFF data! (no 0x002A marker)"));
                            return
                        }
                        const m = s.getUint32(f + 4, !d);
                        if (m < 8) {
                            n(new Error("Not valid TIFF data! (First offset less than 8)"));
                            return
                        }
                        const g = f + m,
                            y = s.getUint16(g, !d),
                            v = g + 2;
                        let _ = 0;
                        for (let C = v; C < v + 12 * y; C += 12) s.getUint16(C, !d) === 45057 && (_ = s.getUint32(C + 8, !d));
                        const S = g + 2 + y * 12 + 4,
                            M = [];
                        for (let C = S; C < S + _ * 16; C += 16) {
                            const E = {
                                MPType: s.getUint32(C, !d),
                                size: s.getUint32(C + 4, !d),
                                dataOffset: s.getUint32(C + 8, !d),
                                dependantImages: s.getUint32(C + 12, !d),
                                start: -1,
                                end: -1,
                                isFII: !1
                            };
                            E.dataOffset ? (E.start = f + E.dataOffset, E.isFII = !1) : (E.start = 0, E.isFII = !0), E.end = E.start + E.size, M.push(E)
                        }
                        if (this.options.extractNonFII && M.length) {
                            const C = new Blob([s]),
                                E = [];
                            for (const R of M) {
                                if (R.isFII && !this.options.extractFII) continue;
                                const P = C.slice(R.start, R.end + 1, "image/jpeg");
                                E.push(P)
                            }
                            t(E)
                        }
                    }
                }
                a += 2 + s.getUint16(a + 2)
            }
        })
    }
}
const bW = async r => {
        const e = MW(r);
        if (!e) throw new tL("Gain map XMP metadata not found");
        const n = await new wW({
            extractFII: !0,
            extractNonFII: !0
        }).extract(r);
        if (n.length !== 2) throw new eL("Gain map recovery image not found");
        return {
            sdr: new Uint8Array(await n[0].arrayBuffer()),
            gainMap: new Uint8Array(await n[1].arrayBuffer()),
            metadata: e
        }
    },
    aR = r => new Promise((e, t) => {
        const n = document.createElement("img");
        n.onload = () => {
            e(n)
        }, n.onerror = i => {
            t(i)
        }, n.src = URL.createObjectURL(r)
    });
class nL extends er {
    constructor(e, t) {
        super(t), e && (this._renderer = e), this._internalLoadingManager = new Fy
    }
    setRenderer(e) {
        return this._renderer = e, this
    }
    setRenderTargetOptions(e) {
        return this._renderTargetOptions = e, this
    }
    prepareQuadRenderer() {
        this._renderer || console.warn("WARNING: An existing WebGL Renderer was not passed to this Loader constructor or in setRenderer, the result of this Loader will need to be converted to a Data Texture with toDataTexture() before you can use it in your renderer.");
        const e = new SW({
            gainMapMax: [1, 1, 1],
            gainMapMin: [0, 0, 0],
            gamma: [1, 1, 1],
            offsetHdr: [1, 1, 1],
            offsetSdr: [1, 1, 1],
            hdrCapacityMax: 1,
            hdrCapacityMin: 0,
            maxDisplayBoost: 1,
            gainMap: new gn,
            sdr: new gn
        });
        return new RM({
            width: 16,
            height: 16,
            type: Ri,
            colorSpace: Qs,
            material: e,
            renderer: this._renderer,
            renderTargetOptions: this._renderTargetOptions
        })
    }
    async render(e, t, n, i) {
        const s = i ? new Blob([i], {
                type: "image/jpeg"
            }) : void 0,
            o = new Blob([n], {
                type: "image/jpeg"
            });
        let a, l, c = !1;
        if (typeof createImageBitmap > "u") {
            const d = await Promise.all([s ? aR(s) : Promise.resolve(void 0), aR(o)]);
            l = d[0], a = d[1], c = !0
        } else {
            const d = await Promise.all([s ? createImageBitmap(s, {
                imageOrientation: "flipY"
            }) : Promise.resolve(void 0), createImageBitmap(o, {
                imageOrientation: "flipY"
            })]);
            l = d[0], a = d[1]
        }
        const u = new gn(l || new ImageData(2, 2), xl, Nn, Nn, nn, fA, kn, Yi, 1, Qs);
        u.flipY = c, u.needsUpdate = !0;
        const f = new gn(a, xl, Nn, Nn, nn, fA, kn, Yi, 1, Jn);
        f.flipY = c, f.needsUpdate = !0, e.width = a.width, e.height = a.height, e.material.gainMap = u, e.material.sdr = f, e.material.gainMapMin = t.gainMapMin, e.material.gainMapMax = t.gainMapMax, e.material.offsetHdr = t.offsetHdr, e.material.offsetSdr = t.offsetSdr, e.material.gamma = t.gamma, e.material.hdrCapacityMin = t.hdrCapacityMin, e.material.hdrCapacityMax = t.hdrCapacityMax, e.material.maxDisplayBoost = Math.pow(2, t.hdrCapacityMax), e.material.needsUpdate = !0, e.render()
    }
}
class TW extends nL {
    load([e, t, n], i, s, o) {
        const a = this.prepareQuadRenderer();
        let l, c, u;
        const f = async () => {
            if (l && c && u) {
                try {
                    await this.render(a, u, l, c)
                } catch (b) {
                    this.manager.itemError(e), this.manager.itemError(t), this.manager.itemError(n), typeof o == "function" && o(b), a.disposeOnDemandRenderer();
                    return
                }
                typeof i == "function" && i(a), this.manager.itemEnd(e), this.manager.itemEnd(t), this.manager.itemEnd(n), a.disposeOnDemandRenderer()
            }
        };
        let d = !0,
            m = 0,
            g = 0,
            y = !0,
            v = 0,
            _ = 0,
            A = !0,
            S = 0,
            M = 0;
        const C = () => {
            if (typeof s == "function") {
                const b = m + v + S,
                    T = g + _ + M,
                    L = d && y && A;
                s(new ProgressEvent("progress", {
                    lengthComputable: L,
                    loaded: T,
                    total: b
                }))
            }
        };
        this.manager.itemStart(e), this.manager.itemStart(t), this.manager.itemStart(n);
        const E = new $i(this._internalLoadingManager);
        E.setResponseType("arraybuffer"), E.setRequestHeader(this.requestHeader), E.setPath(this.path), E.setWithCredentials(this.withCredentials), E.load(e, async b => {
            if (typeof b == "string") throw new Error("Invalid sdr buffer");
            l = b, await f()
        }, b => {
            d = b.lengthComputable, g = b.loaded, m = b.total, C()
        }, b => {
            this.manager.itemError(e), typeof o == "function" && o(b)
        });
        const R = new $i(this._internalLoadingManager);
        R.setResponseType("arraybuffer"), R.setRequestHeader(this.requestHeader), R.setPath(this.path), R.setWithCredentials(this.withCredentials), R.load(t, async b => {
            if (typeof b == "string") throw new Error("Invalid gainmap buffer");
            c = b, await f()
        }, b => {
            y = b.lengthComputable, _ = b.loaded, v = b.total, C()
        }, b => {
            this.manager.itemError(t), typeof o == "function" && o(b)
        });
        const P = new $i(this._internalLoadingManager);
        return P.setRequestHeader(this.requestHeader), P.setPath(this.path), P.setWithCredentials(this.withCredentials), P.load(n, async b => {
            if (typeof b != "string") throw new Error("Invalid metadata string");
            u = JSON.parse(b), await f()
        }, b => {
            A = b.lengthComputable, M = b.loaded, S = b.total, C()
        }, b => {
            this.manager.itemError(n), typeof o == "function" && o(b)
        }), a
    }
}
class EW extends nL {
    load(e, t, n, i) {
        const s = this.prepareQuadRenderer(),
            o = new $i(this._internalLoadingManager);
        return o.setResponseType("arraybuffer"), o.setRequestHeader(this.requestHeader), o.setPath(this.path), o.setWithCredentials(this.withCredentials), this.manager.itemStart(e), o.load(e, async a => {
            if (typeof a == "string") throw new Error("Invalid buffer, received [string], was expecting [ArrayBuffer]");
            const l = new Uint8Array(a);
            let c, u, f;
            try {
                const d = await bW(l);
                c = d.sdr, u = d.gainMap, f = d.metadata
            } catch (d) {
                if (d instanceof tL || d instanceof eL) console.warn(`Failure to reconstruct an HDR image from ${e}: Gain map metadata not found in the file, HDRJPGLoader will render the SDR jpeg`), f = {
                    gainMapMin: [0, 0, 0],
                    gainMapMax: [1, 1, 1],
                    gamma: [1, 1, 1],
                    hdrCapacityMin: 0,
                    hdrCapacityMax: 1,
                    offsetHdr: [0, 0, 0],
                    offsetSdr: [0, 0, 0]
                }, c = l;
                else throw d
            }
            try {
                await this.render(s, f, c, u)
            } catch (d) {
                this.manager.itemError(e), typeof i == "function" && i(d), s.disposeOnDemandRenderer();
                return
            }
            typeof t == "function" && t(s), this.manager.itemEnd(e), s.disposeOnDemandRenderer()
        }, n, a => {
            this.manager.itemError(e), typeof i == "function" && i(a)
        }), s
    }
}
const bp = {
        apartment: "lebombo_1k.hdr",
        city: "potsdamer_platz_1k.hdr",
        dawn: "kiara_1_dawn_1k.hdr",
        forest: "forest_slope_1k.hdr",
        lobby: "st_fagans_interior_1k.hdr",
        night: "dikhololo_night_1k.hdr",
        park: "rooitou_park_1k.hdr",
        studio: "studio_small_03_1k.hdr",
        sunset: "venice_sunset_1k.hdr",
        warehouse: "empty_warehouse_01_1k.hdr"
    },
    iL = "https://raw.githack.com/pmndrs/drei-assets/456060a26bbeb8fdf79326f224b6d99b8bcce736/hdri/",
    Lf = r => Array.isArray(r),
    PM = ["/px.png", "/nx.png", "/py.png", "/ny.png", "/pz.png", "/nz.png"];

function zy({
    files: r = PM,
    path: e = "",
    preset: t = void 0,
    encoding: n = void 0,
    extensions: i
} = {}) {
    let s = null,
        o = !1;
    t && (IM(t), r = bp[t], e = iL), o = Lf(r);
    const {
        extension: a,
        isCubemap: l
    } = BM(r);
    if (s = DM(a), !s) throw new Error("useEnvironment: Unrecognized file extension: " + r);
    const c = qn(m => m.gl);
    N.useLayoutEffect(() => {
        if (a !== "webp" && a !== "jpg" && a !== "jpeg") return;

        function m() {
            vr.clear(s, o ? [r] : r)
        }
        c.domElement.addEventListener("webglcontextlost", m, {
            once: !0
        })
    }, [r, c.domElement]);
    const u = vr(s, o ? [r] : r, m => {
        (a === "webp" || a === "jpg" || a === "jpeg") && m.setRenderer(c), m.setPath == null || m.setPath(e), i && i(m)
    });
    let f = o ? u[0] : u;
    if (a === "jpg" || a === "jpeg" || a === "webp") {
        var d;
        f = (d = f.renderTarget) == null ? void 0 : d.texture
    }
    return f.mapping = l ? ko : ou, "colorSpace" in f ? f.colorSpace = n ? ? l ? "srgb" : "srgb-linear" : f.encoding = n ? ? l ? gW : mW, f
}
const CW = {
    files: PM,
    path: "",
    preset: void 0,
    extensions: void 0
};
zy.preload = r => {
    const e = { ...CW,
        ...r
    };
    let {
        files: t,
        path: n = ""
    } = e;
    const {
        preset: i,
        extensions: s
    } = e;
    i && (IM(i), t = bp[i], n = iL);
    const {
        extension: o
    } = BM(t);
    if (o === "webp" || o === "jpg" || o === "jpeg") throw new Error("useEnvironment: Preloading gainmaps is not supported");
    const a = DM(o);
    if (!a) throw new Error("useEnvironment: Unrecognized file extension: " + t);
    vr.preload(a, Lf(t) ? [t] : t, l => {
        l.setPath == null || l.setPath(n), s && s(l)
    })
};
const RW = {
    files: PM,
    preset: void 0
};
zy.clear = r => {
    const e = { ...RW,
        ...r
    };
    let {
        files: t
    } = e;
    const {
        preset: n
    } = e;
    n && (IM(n), t = bp[n]);
    const {
        extension: i
    } = BM(t), s = DM(i);
    if (!s) throw new Error("useEnvironment: Unrecognized file extension: " + t);
    vr.clear(s, Lf(t) ? [t] : t)
};

function IM(r) {
    if (!(r in bp)) throw new Error("Preset must be one of: " + Object.keys(bp).join(", "))
}

function BM(r) {
    var e;
    const t = Lf(r) && r.length === 6,
        n = Lf(r) && r.length === 3 && r.some(o => o.endsWith("json")),
        i = Lf(r) ? r[0] : r;
    return {
        extension: t ? "cube" : n ? "webp" : i.startsWith("data:application/exr") ? "exr" : i.startsWith("data:application/hdr") ? "hdr" : i.startsWith("data:image/jpeg") ? "jpg" : (e = i.split(".").pop()) == null || (e = e.split("?")) == null || (e = e.shift()) == null ? void 0 : e.toLowerCase(),
        isCubemap: t,
        isGainmap: n
    }
}

function DM(r) {
    return r === "cube" ? JB : r === "hdr" ? d9 : r === "exr" ? p9 : r === "jpg" || r === "jpeg" ? EW : r === "webp" ? TW : null
}
const PW = r => r.current && r.current.isScene,
    IW = r => PW(r) ? r.current : r;

function LM(r, e, t, n, i = {}) {
    var s, o, a, l;
    i = {
        backgroundBlurriness: 0,
        backgroundIntensity: 1,
        backgroundRotation: [0, 0, 0],
        environmentIntensity: 1,
        environmentRotation: [0, 0, 0],
        ...i
    };
    const c = IW(e || t),
        u = c.background,
        f = c.environment,
        d = {
            backgroundBlurriness: c.backgroundBlurriness,
            backgroundIntensity: c.backgroundIntensity,
            backgroundRotation: (s = (o = c.backgroundRotation) == null || o.clone == null ? void 0 : o.clone()) !== null && s !== void 0 ? s : [0, 0, 0],
            environmentIntensity: c.environmentIntensity,
            environmentRotation: (a = (l = c.environmentRotation) == null || l.clone == null ? void 0 : l.clone()) !== null && a !== void 0 ? a : [0, 0, 0]
        };
    return r !== "only" && (c.environment = n), r && (c.background = n), $a(c, i), () => {
        r !== "only" && (c.environment = f), r && (c.background = u), $a(c, d)
    }
}

function FM({
    scene: r,
    background: e = !1,
    map: t,
    ...n
}) {
    const i = qn(s => s.scene);
    return N.useLayoutEffect(() => {
        if (t) return LM(e, r, i, t, n)
    }), null
}

function rL({
    background: r = !1,
    scene: e,
    blur: t,
    backgroundBlurriness: n,
    backgroundIntensity: i,
    backgroundRotation: s,
    environmentIntensity: o,
    environmentRotation: a,
    ...l
}) {
    const c = zy(l),
        u = qn(f => f.scene);
    return N.useLayoutEffect(() => LM(r, e, u, c, {
        backgroundBlurriness: t ? ? n,
        backgroundIntensity: i,
        backgroundRotation: s,
        environmentIntensity: o,
        environmentRotation: a
    })), null
}

function BW({
    children: r,
    near: e = .1,
    far: t = 1e3,
    resolution: n = 256,
    frames: i = 1,
    map: s,
    background: o = !1,
    blur: a,
    backgroundBlurriness: l,
    backgroundIntensity: c,
    backgroundRotation: u,
    environmentIntensity: f,
    environmentRotation: d,
    scene: m,
    files: g,
    path: y,
    preset: v = void 0,
    extensions: _
}) {
    const A = qn(P => P.gl),
        S = qn(P => P.scene),
        M = N.useRef(null),
        [C] = N.useState(() => new ho),
        E = N.useMemo(() => {
            const P = new py(n);
            return P.texture.type = Ri, P
        }, [n]);
    N.useLayoutEffect(() => {
        if (i === 1) {
            const P = A.autoClear;
            A.autoClear = !0, M.current.update(A, C), A.autoClear = P
        }
        return LM(o, m, S, E.texture, {
            backgroundBlurriness: a ? ? l,
            backgroundIntensity: c,
            backgroundRotation: u,
            environmentIntensity: f,
            environmentRotation: d
        })
    }, [r, C, E.texture, m, S, o, i, A]);
    let R = 1;
    return Es(() => {
        if (i === 1 / 0 || R < i) {
            const P = A.autoClear;
            A.autoClear = !0, M.current.update(A, C), A.autoClear = P, R++
        }
    }), N.createElement(N.Fragment, null, N8(N.createElement(N.Fragment, null, r, N.createElement("cubeCamera", {
        ref: M,
        args: [e, t, E]
    }), g || v ? N.createElement(rL, {
        background: !0,
        files: g,
        preset: v,
        path: y,
        extensions: _
    }) : s ? N.createElement(FM, {
        background: !0,
        map: s,
        extensions: _
    }) : null), C))
}

function DW(r) {
    var e, t, n, i;
    const s = zy(r),
        o = r.map || s;
    N.useMemo(() => Ny({
        GroundProjectedEnvImpl: I6
    }), []);
    const a = N.useMemo(() => [o], [o]),
        l = (e = r.ground) == null ? void 0 : e.height,
        c = (t = r.ground) == null ? void 0 : t.radius,
        u = (n = (i = r.ground) == null ? void 0 : i.scale) !== null && n !== void 0 ? n : 1e3;
    return N.createElement(N.Fragment, null, N.createElement(FM, Cl({}, r, {
        map: o
    })), N.createElement("groundProjectedEnvImpl", {
        args: a,
        scale: u,
        height: l,
        radius: c
    }))
}

function UM(r) {
    return r.ground ? N.createElement(DW, r) : r.map ? N.createElement(FM, r) : r.children ? N.createElement(BW, r) : N.createElement(rL, r)
}

function OM({
    all: r,
    scene: e,
    camera: t
}) {
    const n = qn(({
            gl: o
        }) => o),
        i = qn(({
            camera: o
        }) => o),
        s = qn(({
            scene: o
        }) => o);
    return N.useLayoutEffect(() => {
        const o = [];
        r && (e || s).traverse(c => {
            c.visible === !1 && (o.push(c), c.visible = !0)
        }), n.compile(e || s, t || i);
        const a = new py(128);
        new YS(.01, 1e5, a).update(n, e || s), a.dispose(), o.forEach(c => c.visible = !1)
    }, []), null
}
const LW = "" + new URL("coin-DwpxS9M2.glb",
        import.meta.url).href,
    NM = "" + new URL("adamsbridge-CNYmQDu8.hdr",
        import.meta.url).href,
    nh = "" + new URL("TT Firs Neue Regular-CrhbcxNn.ttf",
        import.meta.url).href,
    sm = "" + new URL("Matcap9-BBrvg8KV.png",
        import.meta.url).href,
    dh = TM(r => ({
        isLoaderReady: !1,
        setIsLoaderReady: e => r({
            isLoaderReady: e
        }),
        isSceneReady: !1,
        setIsSceneReady: e => r({
            isSceneReady: e
        }),
        stepsCompleted: 0,
        totalSteps: 1,
        setSteps: (e, t) => r({
            stepsCompleted: e,
            totalSteps: t
        })
    })),
    sL = N.createContext(void 0),
    FW = ({
        children: r
    }) => {
        const [e, t] = N.useState(typeof window < "u" ? window.innerWidth < 768 : !1), n = N.useRef(e), {
            setIsLoaderReady: i,
            setIsSceneReady: s,
            setSteps: o
        } = dh();
        return N.useEffect(() => {
            function a() {
                if (e !== window.innerWidth < 768) {
                    const l = document.getElementById("root");
                    l && l.scrollTo(0, 0)
                }
                t(window.innerWidth < 768)
            }
            return window.addEventListener("resize", a), () => window.removeEventListener("resize", a)
        }, []), N.useEffect(() => {
            n.current !== e && (i(!1), s(!1), o(0, 1), n.current = e)
        }, [e, i, s, o]), G.jsx(sL.Provider, {
            value: {
                isMobile: e
            },
            children: r
        })
    },
    Nl = () => {
        const r = N.useContext(sL);
        if (!r) throw new Error("useResponsive    ResponsiveProvider");
        return r
    },
    UW = () => {
        const {
            isMobile: r
        } = Nl(), e = N.useRef(null), {
            setIsLoaderReady: t,
            setIsSceneReady: n
        } = dh(), [i, s] = N.useState(!0), [o, a] = N.useState(0);
        N.useEffect(() => {
            if (o >= 100) {
                const c = setTimeout(() => {
                    e.current && et.to(e.current, {
                        opacity: 0,
                        duration: 1,
                        ease: "power2.out",
                        onComplete: () => {
                            s(!1), n(!0)
                        }
                    })
                }, 1e3);
                return () => clearTimeout(c)
            }
        }, [o]);
        const l = () => {
            new Promise(c => setTimeout(c, 2e3)).then(() => t(!0))
        };
        return i ? G.jsxs("div", {
            className: "loader",
            ref: e,
            children: [G.jsxs("div", {
                className: "text-container",
                children: [G.jsx("h3", {
                    className: "title",
                    children: "Sage"
                }), G.jsxs("p", {
                    className: "description",
                    children: ["AI model marketplace for anyone to upload their", G.jsx("br", {}), "custom models and monetize them"]
                })]
            }), G.jsx("div", {
                className: "loader-canvas",
                children: G.jsxs(TA, {
                    gl: {
                        antialias: !0,
                        alpha: !0,
                        toneMapping: ry
                    },
                    onCreated: l,
                    children: [G.jsx("ambientLight", {
                        intensity: .5
                    }), G.jsx("pointLight", {
                        position: [10, 10, 10]
                    }), G.jsx(dW, {
                        makeDefault: !0,
                        zoom: r ? 130 : 280,
                        position: [0, -.25, 5],
                        near: .1,
                        far: 1e3
                    }), G.jsx(UM, {
                        files: NM,
                        backgroundIntensity: 3,
                        environmentIntensity: 3
                    }), G.jsx(OW, {
                        onPercentChange: c => a(c)
                    })]
                })
            })]
        }) : null
    };

function OW(r) {
    const e = N.useRef(null),
        {
            stepsCompleted: t,
            totalSteps: n
        } = dh(),
        {
            isMobile: i
        } = Nl(),
        {
            nodes: s
        } = $s(LW),
        [o, a] = N.useState(0),
        l = N.useRef(0),
        c = _u(sm);
    N.useEffect(() => {
        e.current && (et.set(e.current.rotation, {
            y: Math.PI / 2
        }), et.to(e.current.rotation, {
            y: `+=${Math.PI*8}`,
            duration: 3,
            repeat: -1,
            ease: "expo.out"
        }))
    }, []), N.useEffect(() => {
        let f = 0;
        n > 0 && (f = t / n * 100), et.to(l, {
            current: f,
            duration: .8,
            ease: "power2.out",
            onUpdate: () => {
                const d = Math.round(l.current);
                a(d), r.onPercentChange(d)
            }
        })
    }, [t, n, r]);
    const u = new Mi({
        color: "#fff",
        side: hn
    });
    return G.jsxs("group", {
        children: [G.jsx("group", {
            rotation: [0, Math.PI * .5, Math.PI],
            children: G.jsxs(Di, {
                position: i ? [2, 0, 0] : [-1, 0, 0],
                rotation: [0, Math.PI * .5, Math.PI],
                font: nh,
                fontSize: .5,
                anchorX: "center",
                anchorY: "middle",
                material: u,
                children: [o, "%"]
            })
        }), G.jsx(N.Suspense, {
            children: G.jsx("group", {
                ref: e,
                children: G.jsx("group", {
                    dispose: null,
                    rotation: [0, Math.PI * .5, Math.PI],
                    children: G.jsx("group", {
                        rotation: [Math.PI / 2, 0, 0],
                        children: G.jsx("mesh", {
                            castShadow: !0,
                            receiveShadow: !0,
                            geometry: s.Cylinder.geometry,
                            rotation: [-Math.PI, 0, 0],
                            scale: [-1.027, .126, 1.027],
                            children: i ? G.jsx("meshMatcapMaterial", {
                                matcap: c,
                                side: hn,
                                transparent: !0,
                                opacity: .5
                            }) : G.jsx(rm, {
                                samples: 32,
                                thickness: .4,
                                roughness: .05,
                                chromaticAberration: 0,
                                anisotropicBlur: 0,
                                distortion: .1,
                                distortionScale: .05,
                                temporalDistortion: 0,
                                backside: !1,
                                background: new rt("#111"),
                                transmissionSampler: !1,
                                transmission: 1,
                                side: hn
                            })
                        })
                    })
                })
            })
        })]
    })
}
/*!
 * ScrollToPlugin 3.12.5
 * https://gsap.com
 *
 * @license Copyright 2008-2024, GreenSock. All rights reserved.
 * Subject to the terms at https://gsap.com/standard-license or for
 * Club GSAP members, the agreement issued with that membership.
 * @author: Jack Doyle, jack@greensock.com
 */
var Nr, oL, xa, Bo, ml, aL, lL, p0, cL = function() {
        return typeof window < "u"
    },
    uL = function() {
        return Nr || cL() && (Nr = window.gsap) && Nr.registerPlugin && Nr
    },
    fL = function(e) {
        return typeof e == "string"
    },
    lR = function(e) {
        return typeof e == "function"
    },
    Tp = function(e, t) {
        var n = t === "x" ? "Width" : "Height",
            i = "scroll" + n,
            s = "client" + n;
        return e === xa || e === Bo || e === ml ? Math.max(Bo[i], ml[i]) - (xa["inner" + n] || Bo[s] || ml[s]) : e[i] - e["offset" + n]
    },
    Ep = function(e, t) {
        var n = "scroll" + (t === "x" ? "Left" : "Top");
        return e === xa && (e.pageXOffset != null ? n = "page" + t.toUpperCase() + "Offset" : e = Bo[n] != null ? Bo : ml),
            function() {
                return e[n]
            }
    },
    NW = function(e, t, n, i) {
        if (lR(e) && (e = e(t, n, i)), typeof e != "object") return fL(e) && e !== "max" && e.charAt(1) !== "=" ? {
            x: e,
            y: e
        } : {
            y: e
        };
        if (e.nodeType) return {
            y: e,
            x: e
        };
        var s = {},
            o;
        for (o in e) s[o] = o !== "onAutoKill" && lR(e[o]) ? e[o](t, n, i) : e[o];
        return s
    },
    hL = function(e, t) {
        if (e = aL(e)[0], !e || !e.getBoundingClientRect) return console.warn("scrollTo target doesn't exist. Using 0") || {
            x: 0,
            y: 0
        };
        var n = e.getBoundingClientRect(),
            i = !t || t === xa || t === ml,
            s = i ? {
                top: Bo.clientTop - (xa.pageYOffset || Bo.scrollTop || ml.scrollTop || 0),
                left: Bo.clientLeft - (xa.pageXOffset || Bo.scrollLeft || ml.scrollLeft || 0)
            } : t.getBoundingClientRect(),
            o = {
                x: n.left - s.left,
                y: n.top - s.top
            };
        return !i && t && (o.x += Ep(t, "x")(), o.y += Ep(t, "y")()), o
    },
    cR = function(e, t, n, i, s) {
        return !isNaN(e) && typeof e != "object" ? parseFloat(e) - s : fL(e) && e.charAt(1) === "=" ? parseFloat(e.substr(2)) * (e.charAt(0) === "-" ? -1 : 1) + i - s : e === "max" ? Tp(t, n) - s : Math.min(Tp(t, n), hL(e, t)[n] - s)
    },
    uR = function() {
        Nr = uL(), cL() && Nr && typeof document < "u" && document.body && (xa = window, ml = document.body, Bo = document.documentElement, aL = Nr.utils.toArray, Nr.config({
            autoKillThreshold: 7
        }), lL = Nr.config(), oL = 1)
    },
    om = {
        version: "3.12.5",
        name: "scrollTo",
        rawVars: 1,
        register: function(e) {
            Nr = e, uR()
        },
        init: function(e, t, n, i, s) {
            oL || uR();
            var o = this,
                a = Nr.getProperty(e, "scrollSnapType");
            o.isWin = e === xa, o.target = e, o.tween = n, t = NW(t, i, e, s), o.vars = t, o.autoKill = !!t.autoKill, o.getX = Ep(e, "x"), o.getY = Ep(e, "y"), o.x = o.xPrev = o.getX(), o.y = o.yPrev = o.getY(), p0 || (p0 = Nr.core.globals().ScrollTrigger), Nr.getProperty(e, "scrollBehavior") === "smooth" && Nr.set(e, {
                scrollBehavior: "auto"
            }), a && a !== "none" && (o.snap = 1, o.snapInline = e.style.scrollSnapType, e.style.scrollSnapType = "none"), t.x != null ? (o.add(o, "x", o.x, cR(t.x, e, "x", o.x, t.offsetX || 0), i, s), o._props.push("scrollTo_x")) : o.skipX = 1, t.y != null ? (o.add(o, "y", o.y, cR(t.y, e, "y", o.y, t.offsetY || 0), i, s), o._props.push("scrollTo_y")) : o.skipY = 1
        },
        render: function(e, t) {
            for (var n = t._pt, i = t.target, s = t.tween, o = t.autoKill, a = t.xPrev, l = t.yPrev, c = t.isWin, u = t.snap, f = t.snapInline, d, m, g, y, v; n;) n.r(e, n.d), n = n._next;
            d = c || !t.skipX ? t.getX() : a, m = c || !t.skipY ? t.getY() : l, g = m - l, y = d - a, v = lL.autoKillThreshold, t.x < 0 && (t.x = 0), t.y < 0 && (t.y = 0), o && (!t.skipX && (y > v || y < -v) && d < Tp(i, "x") && (t.skipX = 1), !t.skipY && (g > v || g < -v) && m < Tp(i, "y") && (t.skipY = 1), t.skipX && t.skipY && (s.kill(), t.vars.onAutoKill && t.vars.onAutoKill.apply(s, t.vars.onAutoKillParams || []))), c ? xa.scrollTo(t.skipX ? d : t.x, t.skipY ? m : t.y) : (t.skipY || (i.scrollTop = t.y), t.skipX || (i.scrollLeft = t.x)), u && (e === 1 || e === 0) && (m = i.scrollTop, d = i.scrollLeft, f ? i.style.scrollSnapType = f : i.style.removeProperty("scroll-snap-type"), i.scrollTop = m + 1, i.scrollLeft = d + 1, i.scrollTop = m, i.scrollLeft = d), t.xPrev = t.x, t.yPrev = t.y, p0 && p0.update()
        },
        kill: function(e) {
            var t = e === "scrollTo",
                n = this._props.indexOf(e);
            return (t || e === "scrollTo_x") && (this.skipX = 1), (t || e === "scrollTo_y") && (this.skipY = 1), n > -1 && this._props.splice(n, 1), !this._props.length
        }
    };
om.max = Tp;
om.getOffset = hL;
om.buildGetter = Ep;
uL() && Nr.registerPlugin(om);
et.registerPlugin(Zt, om);
const kW = () => (N.useEffect(() => {
        function r() {
            const e = document.getElementById("root");
            if (!e) {
                console.error("Element with ID 'root' not found.");
                return
            }
            const t = document.createElement("div");
            t.classList.add("custom-scrollbar");
            const n = document.createElement("div");
            n.id = "custom-scrollbar-thumb", n.classList.add("custom-scrollbar-thumb"), t.appendChild(n), document.body.appendChild(t);
            const i = () => e.scrollHeight - e.clientHeight;
            let s = i();
            window.addEventListener("resize", () => {
                s = i()
            });
            let o = !1,
                a;
            const l = 1;
            n.addEventListener("mousedown", m => {
                o = !0, a = m.clientY, document.body.style.userSelect = "none"
            }), document.addEventListener("mouseup", () => {
                o = !1, document.body.style.userSelect = ""
            }), document.addEventListener("mousemove", m => {
                if (!o) return;
                const g = (m.clientY - a) * l;
                a = m.clientY;
                const y = t.clientHeight - n.offsetHeight;
                let v = n.offsetTop + g;
                v = Math.min(Math.max(0, v), y);
                const _ = v / y;
                n.style.top = `${v}px`, et.to(e, {
                    scrollTo: {
                        y: _ * s,
                        autoKill: !1
                    },
                    ease: "none",
                    duration: .1
                })
            }), e.addEventListener("scroll", () => {
                if (o) return;
                const m = e.scrollTop / s,
                    g = t.clientHeight - n.offsetHeight;
                n.style.top = `${m*g}px`
            }), Zt.create({
                trigger: e,
                start: "top top",
                end: () => `+=${s}`,
                onUpdate: m => {
                    if (o) return;
                    const g = m.progress,
                        y = t.clientHeight - n.offsetHeight;
                    n.style.top = `${g*y}px`
                },
                scrub: !0
            });
            let c, u, f;
            const d = () => {
                u && u.kill(), u = et.to(n, {
                    background: "rgba(255, 255, 255, 1)",
                    duration: .2
                }), clearTimeout(c), c = setTimeout(() => {
                    f && f.kill(), f = et.to(n, {
                        background: "rgba(255, 255, 255, 0.25)",
                        duration: .5
                    })
                }, 100)
            };
            e.addEventListener("scroll", d), d(), n.addEventListener("mouseenter", () => {
                f && f.kill(), c && clearTimeout(c), et.to(n, {
                    background: "rgba(255, 255, 255, 1)",
                    duration: .3,
                    ease: "power2.out"
                })
            }), n.addEventListener("mouseleave", () => {
                et.to(n, {
                    background: "rgba(255, 255, 255, 0.25)",
                    duration: .3,
                    ease: "power2.out"
                })
            })
        }
        return r(), () => {
            var t;
            const e = (t = document.getElementById("custom-scrollbar-thumb")) == null ? void 0 : t.parentElement;
            e && e.parentNode && e.parentNode.removeChild(e)
        }
    }, []), null),
    zW = () => G.jsx("div", {
        className: "noise"
    }),
    GW = () => G.jsx("div", {
        className: "mobile-html"
    });

function HW(r) {
    if (typeof Proxy > "u") return r;
    const e = new Map,
        t = (...n) => r(...n);
    return new Proxy(t, {
        get: (n, i) => i === "create" ? r : (e.has(i) || e.set(i, r(i)), e.get(i))
    })
}

function Gy(r) {
    return r !== null && typeof r == "object" && typeof r.start == "function"
}
const UA = r => Array.isArray(r);

function dL(r, e) {
    if (!Array.isArray(e)) return !1;
    const t = e.length;
    if (t !== r.length) return !1;
    for (let n = 0; n < t; n++)
        if (e[n] !== r[n]) return !1;
    return !0
}

function Cp(r) {
    return typeof r == "string" || Array.isArray(r)
}

function fR(r) {
    const e = [{}, {}];
    return r == null || r.values.forEach((t, n) => {
        e[0][n] = t.get(), e[1][n] = t.getVelocity()
    }), e
}

function kM(r, e, t, n) {
    if (typeof e == "function") {
        const [i, s] = fR(n);
        e = e(t !== void 0 ? t : r.custom, i, s)
    }
    if (typeof e == "string" && (e = r.variants && r.variants[e]), typeof e == "function") {
        const [i, s] = fR(n);
        e = e(t !== void 0 ? t : r.custom, i, s)
    }
    return e
}

function Hy(r, e, t) {
    const n = r.getProps();
    return kM(n, e, t !== void 0 ? t : n.custom, r)
}
const zM = ["animate", "whileInView", "whileFocus", "whileHover", "whileTap", "whileDrag", "exit"],
    GM = ["initial", ...zM],
    am = ["transformPerspective", "x", "y", "z", "translateX", "translateY", "translateZ", "scale", "scaleX", "scaleY", "rotate", "rotateX", "rotateY", "rotateZ", "skew", "skewX", "skewY"],
    xu = new Set(am),
    Aa = r => r * 1e3,
    Sa = r => r / 1e3,
    VW = {
        type: "spring",
        stiffness: 500,
        damping: 25,
        restSpeed: 10
    },
    WW = r => ({
        type: "spring",
        stiffness: 550,
        damping: r === 0 ? 2 * Math.sqrt(550) : 30,
        restSpeed: 10
    }),
    jW = {
        type: "keyframes",
        duration: .8
    },
    XW = {
        type: "keyframes",
        ease: [.25, .1, .35, 1],
        duration: .3
    },
    YW = (r, {
        keyframes: e
    }) => e.length > 2 ? jW : xu.has(r) ? r.startsWith("scale") ? WW(e[1]) : VW : XW;

function HM(r, e) {
    return r ? r[e] || r.default || r : void 0
}
const JW = {
        skipAnimations: !1,
        useManualTiming: !1
    },
    KW = r => r !== null;

function Vy(r, {
    repeat: e,
    repeatType: t = "loop"
}, n) {
    const i = r.filter(KW),
        s = e && t !== "loop" && e % 2 === 1 ? 0 : i.length - 1;
    return !s || n === void 0 ? i[s] : n
}
const _s = r => r;
let OA = _s;

function qW(r) {
    let e = new Set,
        t = new Set,
        n = !1,
        i = !1;
    const s = new WeakSet;
    let o = {
        delta: 0,
        timestamp: 0,
        isProcessing: !1
    };

    function a(c) {
        s.has(c) && (l.schedule(c), r()), c(o)
    }
    const l = {
        schedule: (c, u = !1, f = !1) => {
            const m = f && n ? e : t;
            return u && s.add(c), m.has(c) || m.add(c), c
        },
        cancel: c => {
            t.delete(c), s.delete(c)
        },
        process: c => {
            if (o = c, n) {
                i = !0;
                return
            }
            n = !0, [e, t] = [t, e], e.forEach(a), e.clear(), n = !1, i && (i = !1, l.process(c))
        }
    };
    return l
}
const m0 = ["read", "resolveKeyframes", "update", "preRender", "render", "postRender"],
    ZW = 40;

function pL(r, e) {
    let t = !1,
        n = !0;
    const i = {
            delta: 0,
            timestamp: 0,
            isProcessing: !1
        },
        s = () => t = !0,
        o = m0.reduce((_, A) => (_[A] = qW(s), _), {}),
        {
            read: a,
            resolveKeyframes: l,
            update: c,
            preRender: u,
            render: f,
            postRender: d
        } = o,
        m = () => {
            const _ = performance.now();
            t = !1, i.delta = n ? 1e3 / 60 : Math.max(Math.min(_ - i.timestamp, ZW), 1), i.timestamp = _, i.isProcessing = !0, a.process(i), l.process(i), c.process(i), u.process(i), f.process(i), d.process(i), i.isProcessing = !1, t && e && (n = !1, r(m))
        },
        g = () => {
            t = !0, n = !0, i.isProcessing || r(m)
        };
    return {
        schedule: m0.reduce((_, A) => {
            const S = o[A];
            return _[A] = (M, C = !1, E = !1) => (t || g(), S.schedule(M, C, E)), _
        }, {}),
        cancel: _ => {
            for (let A = 0; A < m0.length; A++) o[m0[A]].cancel(_)
        },
        state: i,
        steps: o
    }
}
const {
    schedule: Xn,
    cancel: Rl,
    state: qi,
    steps: h1
} = pL(typeof requestAnimationFrame < "u" ? requestAnimationFrame : _s, !0), mL = (r, e, t) => (((1 - 3 * t + 3 * e) * r + (3 * t - 6 * e)) * r + 3 * e) * r, QW = 1e-7, $W = 12;

function ej(r, e, t, n, i) {
    let s, o, a = 0;
    do o = e + (t - e) / 2, s = mL(o, n, i) - r, s > 0 ? t = o : e = o; while (Math.abs(s) > QW && ++a < $W);
    return o
}

function lm(r, e, t, n) {
    if (r === e && t === n) return _s;
    const i = s => ej(s, 0, 1, r, t);
    return s => s === 0 || s === 1 ? s : mL(i(s), e, n)
}
const gL = r => e => e <= .5 ? r(2 * e) / 2 : (2 - r(2 * (1 - e))) / 2,
    vL = r => e => 1 - r(1 - e),
    yL = lm(.33, 1.53, .69, .99),
    VM = vL(yL),
    _L = gL(VM),
    xL = r => (r *= 2) < 1 ? .5 * VM(r) : .5 * (2 - Math.pow(2, -10 * (r - 1))),
    WM = r => 1 - Math.sin(Math.acos(r)),
    AL = vL(WM),
    SL = gL(WM),
    ML = r => /^0[^.\s]+$/u.test(r);

function tj(r) {
    return typeof r == "number" ? r === 0 : r !== null ? r === "none" || r === "0" || ML(r) : !0
}
const wL = r => /^-?(?:\d+(?:\.\d+)?|\.\d+)$/u.test(r),
    bL = r => e => typeof e == "string" && e.startsWith(r),
    TL = bL("--"),
    nj = bL("var(--"),
    jM = r => nj(r) ? ij.test(r.split("/*")[0].trim()) : !1,
    ij = /var\(--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)$/iu,
    rj = /^var\(--(?:([\w-]+)|([\w-]+), ?([a-zA-Z\d ()%#.,-]+))\)/u;

function sj(r) {
    const e = rj.exec(r);
    if (!e) return [, ];
    const [, t, n, i] = e;
    return [`--${t??n}`, i]
}

function EL(r, e, t = 1) {
    const [n, i] = sj(r);
    if (!n) return;
    const s = window.getComputedStyle(e).getPropertyValue(n);
    if (s) {
        const o = s.trim();
        return wL(o) ? parseFloat(o) : o
    }
    return jM(i) ? EL(i, e, t + 1) : i
}
const Ea = (r, e, t) => t > e ? e : t < r ? r : t,
    ph = {
        test: r => typeof r == "number",
        parse: parseFloat,
        transform: r => r
    },
    Rp = { ...ph,
        transform: r => Ea(0, 1, r)
    },
    g0 = { ...ph,
        default: 1
    },
    cm = r => ({
        test: e => typeof e == "string" && e.endsWith(r) && e.split(" ").length === 1,
        parse: parseFloat,
        transform: e => `${e}${r}`
    }),
    Qa = cm("deg"),
    Uo = cm("%"),
    kt = cm("px"),
    oj = cm("vh"),
    aj = cm("vw"),
    hR = { ...Uo,
        parse: r => Uo.parse(r) / 100,
        transform: r => Uo.transform(r * 100)
    },
    lj = new Set(["width", "height", "top", "left", "right", "bottom", "x", "y", "translateX", "translateY"]),
    dR = r => r === ph || r === kt,
    pR = (r, e) => parseFloat(r.split(", ")[e]),
    mR = (r, e) => (t, {
        transform: n
    }) => {
        if (n === "none" || !n) return 0;
        const i = n.match(/^matrix3d\((.+)\)$/u);
        if (i) return pR(i[1], e); {
            const s = n.match(/^matrix\((.+)\)$/u);
            return s ? pR(s[1], r) : 0
        }
    },
    cj = new Set(["x", "y", "z"]),
    uj = am.filter(r => !cj.has(r));

function fj(r) {
    const e = [];
    return uj.forEach(t => {
        const n = r.getValue(t);
        n !== void 0 && (e.push([t, n.get()]), n.set(t.startsWith("scale") ? 1 : 0))
    }), e
}
const ih = {
    width: ({
        x: r
    }, {
        paddingLeft: e = "0",
        paddingRight: t = "0"
    }) => r.max - r.min - parseFloat(e) - parseFloat(t),
    height: ({
        y: r
    }, {
        paddingTop: e = "0",
        paddingBottom: t = "0"
    }) => r.max - r.min - parseFloat(e) - parseFloat(t),
    top: (r, {
        top: e
    }) => parseFloat(e),
    left: (r, {
        left: e
    }) => parseFloat(e),
    bottom: ({
        y: r
    }, {
        top: e
    }) => parseFloat(e) + (r.max - r.min),
    right: ({
        x: r
    }, {
        left: e
    }) => parseFloat(e) + (r.max - r.min),
    x: mR(4, 13),
    y: mR(5, 14)
};
ih.translateX = ih.x;
ih.translateY = ih.y;
const CL = r => e => e.test(r),
    hj = {
        test: r => r === "auto",
        parse: r => r
    },
    RL = [ph, kt, Uo, Qa, aj, oj, hj],
    gR = r => RL.find(CL(r)),
    Zc = new Set;
let NA = !1,
    kA = !1;

function PL() {
    if (kA) {
        const r = Array.from(Zc).filter(n => n.needsMeasurement),
            e = new Set(r.map(n => n.element)),
            t = new Map;
        e.forEach(n => {
            const i = fj(n);
            i.length && (t.set(n, i), n.render())
        }), r.forEach(n => n.measureInitialState()), e.forEach(n => {
            n.render();
            const i = t.get(n);
            i && i.forEach(([s, o]) => {
                var a;
                (a = n.getValue(s)) === null || a === void 0 || a.set(o)
            })
        }), r.forEach(n => n.measureEndState()), r.forEach(n => {
            n.suspendedScrollY !== void 0 && window.scrollTo(0, n.suspendedScrollY)
        })
    }
    kA = !1, NA = !1, Zc.forEach(r => r.complete()), Zc.clear()
}

function IL() {
    Zc.forEach(r => {
        r.readKeyframes(), r.needsMeasurement && (kA = !0)
    })
}

function dj() {
    IL(), PL()
}
class XM {
    constructor(e, t, n, i, s, o = !1) {
        this.isComplete = !1, this.isAsync = !1, this.needsMeasurement = !1, this.isScheduled = !1, this.unresolvedKeyframes = [...e], this.onComplete = t, this.name = n, this.motionValue = i, this.element = s, this.isAsync = o
    }
    scheduleResolve() {
        this.isScheduled = !0, this.isAsync ? (Zc.add(this), NA || (NA = !0, Xn.read(IL), Xn.resolveKeyframes(PL))) : (this.readKeyframes(), this.complete())
    }
    readKeyframes() {
        const {
            unresolvedKeyframes: e,
            name: t,
            element: n,
            motionValue: i
        } = this;
        for (let s = 0; s < e.length; s++)
            if (e[s] === null)
                if (s === 0) {
                    const o = i == null ? void 0 : i.get(),
                        a = e[e.length - 1];
                    if (o !== void 0) e[0] = o;
                    else if (n && t) {
                        const l = n.readValue(t, a);
                        l != null && (e[0] = l)
                    }
                    e[0] === void 0 && (e[0] = a), i && o === void 0 && i.set(e[0])
                } else e[s] = e[s - 1]
    }
    setFinalKeyframe() {}
    measureInitialState() {}
    renderEndStyles() {}
    measureEndState() {}
    complete() {
        this.isComplete = !0, this.onComplete(this.unresolvedKeyframes, this.finalKeyframe), Zc.delete(this)
    }
    cancel() {
        this.isComplete || (this.isScheduled = !1, Zc.delete(this))
    }
    resume() {
        this.isComplete || this.scheduleResolve()
    }
}
const Qd = r => Math.round(r * 1e5) / 1e5,
    YM = /-?(?:\d+(?:\.\d+)?|\.\d+)/gu;

function pj(r) {
    return r == null
}
const mj = /^(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))$/iu,
    JM = (r, e) => t => !!(typeof t == "string" && mj.test(t) && t.startsWith(r) || e && !pj(t) && Object.prototype.hasOwnProperty.call(t, e)),
    BL = (r, e, t) => n => {
        if (typeof n != "string") return n;
        const [i, s, o, a] = n.match(YM);
        return {
            [r]: parseFloat(i),
            [e]: parseFloat(s),
            [t]: parseFloat(o),
            alpha: a !== void 0 ? parseFloat(a) : 1
        }
    },
    gj = r => Ea(0, 255, r),
    d1 = { ...ph,
        transform: r => Math.round(gj(r))
    },
    Nc = {
        test: JM("rgb", "red"),
        parse: BL("red", "green", "blue"),
        transform: ({
            red: r,
            green: e,
            blue: t,
            alpha: n = 1
        }) => "rgba(" + d1.transform(r) + ", " + d1.transform(e) + ", " + d1.transform(t) + ", " + Qd(Rp.transform(n)) + ")"
    };

function vj(r) {
    let e = "",
        t = "",
        n = "",
        i = "";
    return r.length > 5 ? (e = r.substring(1, 3), t = r.substring(3, 5), n = r.substring(5, 7), i = r.substring(7, 9)) : (e = r.substring(1, 2), t = r.substring(2, 3), n = r.substring(3, 4), i = r.substring(4, 5), e += e, t += t, n += n, i += i), {
        red: parseInt(e, 16),
        green: parseInt(t, 16),
        blue: parseInt(n, 16),
        alpha: i ? parseInt(i, 16) / 255 : 1
    }
}
const zA = {
        test: JM("#"),
        parse: vj,
        transform: Nc.transform
    },
    _f = {
        test: JM("hsl", "hue"),
        parse: BL("hue", "saturation", "lightness"),
        transform: ({
            hue: r,
            saturation: e,
            lightness: t,
            alpha: n = 1
        }) => "hsla(" + Math.round(r) + ", " + Uo.transform(Qd(e)) + ", " + Uo.transform(Qd(t)) + ", " + Qd(Rp.transform(n)) + ")"
    },
    ur = {
        test: r => Nc.test(r) || zA.test(r) || _f.test(r),
        parse: r => Nc.test(r) ? Nc.parse(r) : _f.test(r) ? _f.parse(r) : zA.parse(r),
        transform: r => typeof r == "string" ? r : r.hasOwnProperty("red") ? Nc.transform(r) : _f.transform(r)
    },
    yj = /(?:#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\))/giu;

function _j(r) {
    var e, t;
    return isNaN(r) && typeof r == "string" && (((e = r.match(YM)) === null || e === void 0 ? void 0 : e.length) || 0) + (((t = r.match(yj)) === null || t === void 0 ? void 0 : t.length) || 0) > 0
}
const DL = "number",
    LL = "color",
    xj = "var",
    Aj = "var(",
    vR = "${}",
    Sj = /var\s*\(\s*--(?:[\w-]+\s*|[\w-]+\s*,(?:\s*[^)(\s]|\s*\((?:[^)(]|\([^)(]*\))*\))+\s*)\)|#[\da-f]{3,8}|(?:rgb|hsl)a?\((?:-?[\d.]+%?[,\s]+){2}-?[\d.]+%?\s*(?:[,/]\s*)?(?:\b\d+(?:\.\d+)?|\.\d+)?%?\)|-?(?:\d+(?:\.\d+)?|\.\d+)/giu;

function Pp(r) {
    const e = r.toString(),
        t = [],
        n = {
            color: [],
            number: [],
            var: []
        },
        i = [];
    let s = 0;
    const a = e.replace(Sj, l => (ur.test(l) ? (n.color.push(s), i.push(LL), t.push(ur.parse(l))) : l.startsWith(Aj) ? (n.var.push(s), i.push(xj), t.push(l)) : (n.number.push(s), i.push(DL), t.push(parseFloat(l))), ++s, vR)).split(vR);
    return {
        values: t,
        split: a,
        indexes: n,
        types: i
    }
}

function FL(r) {
    return Pp(r).values
}

function UL(r) {
    const {
        split: e,
        types: t
    } = Pp(r), n = e.length;
    return i => {
        let s = "";
        for (let o = 0; o < n; o++)
            if (s += e[o], i[o] !== void 0) {
                const a = t[o];
                a === DL ? s += Qd(i[o]) : a === LL ? s += ur.transform(i[o]) : s += i[o]
            }
        return s
    }
}
const Mj = r => typeof r == "number" ? 0 : r;

function wj(r) {
    const e = FL(r);
    return UL(r)(e.map(Mj))
}
const Pl = {
        test: _j,
        parse: FL,
        createTransformer: UL,
        getAnimatableNone: wj
    },
    bj = new Set(["brightness", "contrast", "saturate", "opacity"]);

function Tj(r) {
    const [e, t] = r.slice(0, -1).split("(");
    if (e === "drop-shadow") return r;
    const [n] = t.match(YM) || [];
    if (!n) return r;
    const i = t.replace(n, "");
    let s = bj.has(e) ? 1 : 0;
    return n !== t && (s *= 100), e + "(" + s + i + ")"
}
const Ej = /\b([a-z-]*)\(.*?\)/gu,
    GA = { ...Pl,
        getAnimatableNone: r => {
            const e = r.match(Ej);
            return e ? e.map(Tj).join(" ") : r
        }
    },
    Cj = {
        borderWidth: kt,
        borderTopWidth: kt,
        borderRightWidth: kt,
        borderBottomWidth: kt,
        borderLeftWidth: kt,
        borderRadius: kt,
        radius: kt,
        borderTopLeftRadius: kt,
        borderTopRightRadius: kt,
        borderBottomRightRadius: kt,
        borderBottomLeftRadius: kt,
        width: kt,
        maxWidth: kt,
        height: kt,
        maxHeight: kt,
        top: kt,
        right: kt,
        bottom: kt,
        left: kt,
        padding: kt,
        paddingTop: kt,
        paddingRight: kt,
        paddingBottom: kt,
        paddingLeft: kt,
        margin: kt,
        marginTop: kt,
        marginRight: kt,
        marginBottom: kt,
        marginLeft: kt,
        backgroundPositionX: kt,
        backgroundPositionY: kt
    },
    Rj = {
        rotate: Qa,
        rotateX: Qa,
        rotateY: Qa,
        rotateZ: Qa,
        scale: g0,
        scaleX: g0,
        scaleY: g0,
        scaleZ: g0,
        skew: Qa,
        skewX: Qa,
        skewY: Qa,
        distance: kt,
        translateX: kt,
        translateY: kt,
        translateZ: kt,
        x: kt,
        y: kt,
        z: kt,
        perspective: kt,
        transformPerspective: kt,
        opacity: Rp,
        originX: hR,
        originY: hR,
        originZ: kt
    },
    yR = { ...ph,
        transform: Math.round
    },
    KM = { ...Cj,
        ...Rj,
        zIndex: yR,
        size: kt,
        fillOpacity: Rp,
        strokeOpacity: Rp,
        numOctaves: yR
    },
    Pj = { ...KM,
        color: ur,
        backgroundColor: ur,
        outlineColor: ur,
        fill: ur,
        stroke: ur,
        borderColor: ur,
        borderTopColor: ur,
        borderRightColor: ur,
        borderBottomColor: ur,
        borderLeftColor: ur,
        filter: GA,
        WebkitFilter: GA
    },
    qM = r => Pj[r];

function OL(r, e) {
    let t = qM(r);
    return t !== GA && (t = Pl), t.getAnimatableNone ? t.getAnimatableNone(e) : void 0
}
const Ij = new Set(["auto", "none", "0"]);

function Bj(r, e, t) {
    let n = 0,
        i;
    for (; n < r.length && !i;) {
        const s = r[n];
        typeof s == "string" && !Ij.has(s) && Pp(s).values.length && (i = r[n]), n++
    }
    if (i && t)
        for (const s of e) r[s] = OL(t, i)
}
class NL extends XM {
    constructor(e, t, n, i, s) {
        super(e, t, n, i, s, !0)
    }
    readKeyframes() {
        const {
            unresolvedKeyframes: e,
            element: t,
            name: n
        } = this;
        if (!t || !t.current) return;
        super.readKeyframes();
        for (let l = 0; l < e.length; l++) {
            let c = e[l];
            if (typeof c == "string" && (c = c.trim(), jM(c))) {
                const u = EL(c, t.current);
                u !== void 0 && (e[l] = u), l === e.length - 1 && (this.finalKeyframe = c)
            }
        }
        if (this.resolveNoneKeyframes(), !lj.has(n) || e.length !== 2) return;
        const [i, s] = e, o = gR(i), a = gR(s);
        if (o !== a)
            if (dR(o) && dR(a))
                for (let l = 0; l < e.length; l++) {
                    const c = e[l];
                    typeof c == "string" && (e[l] = parseFloat(c))
                } else this.needsMeasurement = !0
    }
    resolveNoneKeyframes() {
        const {
            unresolvedKeyframes: e,
            name: t
        } = this, n = [];
        for (let i = 0; i < e.length; i++) tj(e[i]) && n.push(i);
        n.length && Bj(e, n, t)
    }
    measureInitialState() {
        const {
            element: e,
            unresolvedKeyframes: t,
            name: n
        } = this;
        if (!e || !e.current) return;
        n === "height" && (this.suspendedScrollY = window.pageYOffset), this.measuredOrigin = ih[n](e.measureViewportBox(), window.getComputedStyle(e.current)), t[0] = this.measuredOrigin;
        const i = t[t.length - 1];
        i !== void 0 && e.getValue(n, i).jump(i, !1)
    }
    measureEndState() {
        var e;
        const {
            element: t,
            name: n,
            unresolvedKeyframes: i
        } = this;
        if (!t || !t.current) return;
        const s = t.getValue(n);
        s && s.jump(this.measuredOrigin, !1);
        const o = i.length - 1,
            a = i[o];
        i[o] = ih[n](t.measureViewportBox(), window.getComputedStyle(t.current)), a !== null && this.finalKeyframe === void 0 && (this.finalKeyframe = a), !((e = this.removedTransforms) === null || e === void 0) && e.length && this.removedTransforms.forEach(([l, c]) => {
            t.getValue(l).set(c)
        }), this.resolveNoneKeyframes()
    }
}

function ZM(r) {
    return typeof r == "function"
}
let F0;

function Dj() {
    F0 = void 0
}
const Oo = {
        now: () => (F0 === void 0 && Oo.set(qi.isProcessing || JW.useManualTiming ? qi.timestamp : performance.now()), F0),
        set: r => {
            F0 = r, queueMicrotask(Dj)
        }
    },
    _R = (r, e) => e === "zIndex" ? !1 : !!(typeof r == "number" || Array.isArray(r) || typeof r == "string" && (Pl.test(r) || r === "0") && !r.startsWith("url("));

function Lj(r) {
    const e = r[0];
    if (r.length === 1) return !0;
    for (let t = 0; t < r.length; t++)
        if (r[t] !== e) return !0
}

function Fj(r, e, t, n) {
    const i = r[0];
    if (i === null) return !1;
    if (e === "display" || e === "visibility") return !0;
    const s = r[r.length - 1],
        o = _R(i, e),
        a = _R(s, e);
    return !o || !a ? !1 : Lj(r) || (t === "spring" || ZM(t)) && n
}
const Uj = 40;
class kL {
    constructor({
        autoplay: e = !0,
        delay: t = 0,
        type: n = "keyframes",
        repeat: i = 0,
        repeatDelay: s = 0,
        repeatType: o = "loop",
        ...a
    }) {
        this.isStopped = !1, this.hasAttemptedResolve = !1, this.createdAt = Oo.now(), this.options = {
            autoplay: e,
            delay: t,
            type: n,
            repeat: i,
            repeatDelay: s,
            repeatType: o,
            ...a
        }, this.updateFinishedPromise()
    }
    calcStartTime() {
        return this.resolvedAt ? this.resolvedAt - this.createdAt > Uj ? this.resolvedAt : this.createdAt : this.createdAt
    }
    get resolved() {
        return !this._resolved && !this.hasAttemptedResolve && dj(), this._resolved
    }
    onKeyframesResolved(e, t) {
        this.resolvedAt = Oo.now(), this.hasAttemptedResolve = !0;
        const {
            name: n,
            type: i,
            velocity: s,
            delay: o,
            onComplete: a,
            onUpdate: l,
            isGenerator: c
        } = this.options;
        if (!c && !Fj(e, n, i, s))
            if (o) this.options.duration = 0;
            else {
                l == null || l(Vy(e, this.options, t)), a == null || a(), this.resolveFinishedPromise();
                return
            }
        const u = this.initPlayback(e, t);
        u !== !1 && (this._resolved = {
            keyframes: e,
            finalKeyframe: t,
            ...u
        }, this.onPostResolved())
    }
    onPostResolved() {}
    then(e, t) {
        return this.currentFinishedPromise.then(e, t)
    }
    flatten() {
        this.options.type = "keyframes", this.options.ease = "linear"
    }
    updateFinishedPromise() {
        this.currentFinishedPromise = new Promise(e => {
            this.resolveFinishedPromise = e
        })
    }
}
const rh = (r, e, t) => {
        const n = e - r;
        return n === 0 ? 1 : (t - r) / n
    },
    zL = (r, e, t = 10) => {
        let n = "";
        const i = Math.max(Math.round(e / t), 2);
        for (let s = 0; s < i; s++) n += r(rh(0, i - 1, s)) + ", ";
        return `linear(${n.substring(0,n.length-2)})`
    };

function GL(r, e) {
    return e ? r * (1e3 / e) : 0
}
const Oj = 5;

function HL(r, e, t) {
    const n = Math.max(e - Oj, 0);
    return GL(t - r(n), e - n)
}
const ui = {
        stiffness: 100,
        damping: 10,
        mass: 1,
        velocity: 0,
        duration: 800,
        bounce: .3,
        visualDuration: .3,
        restSpeed: {
            granular: .01,
            default: 2
        },
        restDelta: {
            granular: .005,
            default: .5
        },
        minDuration: .01,
        maxDuration: 10,
        minDamping: .05,
        maxDamping: 1
    },
    p1 = .001;

function Nj({
    duration: r = ui.duration,
    bounce: e = ui.bounce,
    velocity: t = ui.velocity,
    mass: n = ui.mass
}) {
    let i, s, o = 1 - e;
    o = Ea(ui.minDamping, ui.maxDamping, o), r = Ea(ui.minDuration, ui.maxDuration, Sa(r)), o < 1 ? (i = c => {
        const u = c * o,
            f = u * r,
            d = u - t,
            m = HA(c, o),
            g = Math.exp(-f);
        return p1 - d / m * g
    }, s = c => {
        const f = c * o * r,
            d = f * t + t,
            m = Math.pow(o, 2) * Math.pow(c, 2) * r,
            g = Math.exp(-f),
            y = HA(Math.pow(c, 2), o);
        return (-i(c) + p1 > 0 ? -1 : 1) * ((d - m) * g) / y
    }) : (i = c => {
        const u = Math.exp(-c * r),
            f = (c - t) * r + 1;
        return -p1 + u * f
    }, s = c => {
        const u = Math.exp(-c * r),
            f = (t - c) * (r * r);
        return u * f
    });
    const a = 5 / r,
        l = zj(i, s, a);
    if (r = Aa(r), isNaN(l)) return {
        stiffness: ui.stiffness,
        damping: ui.damping,
        duration: r
    }; {
        const c = Math.pow(l, 2) * n;
        return {
            stiffness: c,
            damping: o * 2 * Math.sqrt(n * c),
            duration: r
        }
    }
}
const kj = 12;

function zj(r, e, t) {
    let n = t;
    for (let i = 1; i < kj; i++) n = n - r(n) / e(n);
    return n
}

function HA(r, e) {
    return r * Math.sqrt(1 - e * e)
}
const VA = 2e4;

function VL(r) {
    let e = 0;
    const t = 50;
    let n = r.next(e);
    for (; !n.done && e < VA;) e += t, n = r.next(e);
    return e >= VA ? 1 / 0 : e
}
const Gj = ["duration", "bounce"],
    Hj = ["stiffness", "damping", "mass"];

function xR(r, e) {
    return e.some(t => r[t] !== void 0)
}

function Vj(r) {
    let e = {
        velocity: ui.velocity,
        stiffness: ui.stiffness,
        damping: ui.damping,
        mass: ui.mass,
        isResolvedFromDuration: !1,
        ...r
    };
    if (!xR(r, Hj) && xR(r, Gj))
        if (r.visualDuration) {
            const t = r.visualDuration,
                n = 2 * Math.PI / (t * 1.2),
                i = n * n,
                s = 2 * Ea(.05, 1, 1 - r.bounce) * Math.sqrt(i);
            e = { ...e,
                mass: ui.mass,
                stiffness: i,
                damping: s
            }
        } else {
            const t = Nj(r);
            e = { ...e,
                ...t,
                mass: ui.mass
            }, e.isResolvedFromDuration = !0
        }
    return e
}

function WL(r = ui.visualDuration, e = ui.bounce) {
    const t = typeof r != "object" ? {
        visualDuration: r,
        keyframes: [0, 1],
        bounce: e
    } : r;
    let {
        restSpeed: n,
        restDelta: i
    } = t;
    const s = t.keyframes[0],
        o = t.keyframes[t.keyframes.length - 1],
        a = {
            done: !1,
            value: s
        },
        {
            stiffness: l,
            damping: c,
            mass: u,
            duration: f,
            velocity: d,
            isResolvedFromDuration: m
        } = Vj({ ...t,
            velocity: -Sa(t.velocity || 0)
        }),
        g = d || 0,
        y = c / (2 * Math.sqrt(l * u)),
        v = o - s,
        _ = Sa(Math.sqrt(l / u)),
        A = Math.abs(v) < 5;
    n || (n = A ? ui.restSpeed.granular : ui.restSpeed.default), i || (i = A ? ui.restDelta.granular : ui.restDelta.default);
    let S;
    if (y < 1) {
        const C = HA(_, y);
        S = E => {
            const R = Math.exp(-y * _ * E);
            return o - R * ((g + y * _ * v) / C * Math.sin(C * E) + v * Math.cos(C * E))
        }
    } else if (y === 1) S = C => o - Math.exp(-_ * C) * (v + (g + _ * v) * C);
    else {
        const C = _ * Math.sqrt(y * y - 1);
        S = E => {
            const R = Math.exp(-y * _ * E),
                P = Math.min(C * E, 300);
            return o - R * ((g + y * _ * v) * Math.sinh(P) + C * v * Math.cosh(P)) / C
        }
    }
    const M = {
        calculatedDuration: m && f || null,
        next: C => {
            const E = S(C);
            if (m) a.done = C >= f;
            else {
                let R = 0;
                y < 1 && (R = C === 0 ? Aa(g) : HL(S, C, E));
                const P = Math.abs(R) <= n,
                    b = Math.abs(o - E) <= i;
                a.done = P && b
            }
            return a.value = a.done ? o : E, a
        },
        toString: () => {
            const C = Math.min(VL(M), VA),
                E = zL(R => M.next(C * R).value, C, 30);
            return C + "ms " + E
        }
    };
    return M
}

function AR({
    keyframes: r,
    velocity: e = 0,
    power: t = .8,
    timeConstant: n = 325,
    bounceDamping: i = 10,
    bounceStiffness: s = 500,
    modifyTarget: o,
    min: a,
    max: l,
    restDelta: c = .5,
    restSpeed: u
}) {
    const f = r[0],
        d = {
            done: !1,
            value: f
        },
        m = P => a !== void 0 && P < a || l !== void 0 && P > l,
        g = P => a === void 0 ? l : l === void 0 || Math.abs(a - P) < Math.abs(l - P) ? a : l;
    let y = t * e;
    const v = f + y,
        _ = o === void 0 ? v : o(v);
    _ !== v && (y = _ - f);
    const A = P => -y * Math.exp(-P / n),
        S = P => _ + A(P),
        M = P => {
            const b = A(P),
                T = S(P);
            d.done = Math.abs(b) <= c, d.value = d.done ? _ : T
        };
    let C, E;
    const R = P => {
        m(d.value) && (C = P, E = WL({
            keyframes: [d.value, g(d.value)],
            velocity: HL(S, P, d.value),
            damping: i,
            stiffness: s,
            restDelta: c,
            restSpeed: u
        }))
    };
    return R(0), {
        calculatedDuration: null,
        next: P => {
            let b = !1;
            return !E && C === void 0 && (b = !0, M(P), R(P)), C !== void 0 && P >= C ? E.next(P - C) : (!b && M(P), d)
        }
    }
}
const Wj = lm(.42, 0, 1, 1),
    jj = lm(0, 0, .58, 1),
    jL = lm(.42, 0, .58, 1),
    Xj = r => Array.isArray(r) && typeof r[0] != "number",
    QM = r => Array.isArray(r) && typeof r[0] == "number",
    SR = {
        linear: _s,
        easeIn: Wj,
        easeInOut: jL,
        easeOut: jj,
        circIn: WM,
        circInOut: SL,
        circOut: AL,
        backIn: VM,
        backInOut: _L,
        backOut: yL,
        anticipate: xL
    },
    MR = r => {
        if (QM(r)) {
            OA(r.length === 4);
            const [e, t, n, i] = r;
            return lm(e, t, n, i)
        } else if (typeof r == "string") return OA(SR[r] !== void 0), SR[r];
        return r
    },
    Yj = (r, e) => t => e(r(t)),
    um = (...r) => r.reduce(Yj),
    ai = (r, e, t) => r + (e - r) * t;

function m1(r, e, t) {
    return t < 0 && (t += 1), t > 1 && (t -= 1), t < 1 / 6 ? r + (e - r) * 6 * t : t < 1 / 2 ? e : t < 2 / 3 ? r + (e - r) * (2 / 3 - t) * 6 : r
}

function Jj({
    hue: r,
    saturation: e,
    lightness: t,
    alpha: n
}) {
    r /= 360, e /= 100, t /= 100;
    let i = 0,
        s = 0,
        o = 0;
    if (!e) i = s = o = t;
    else {
        const a = t < .5 ? t * (1 + e) : t + e - t * e,
            l = 2 * t - a;
        i = m1(l, a, r + 1 / 3), s = m1(l, a, r), o = m1(l, a, r - 1 / 3)
    }
    return {
        red: Math.round(i * 255),
        green: Math.round(s * 255),
        blue: Math.round(o * 255),
        alpha: n
    }
}

function kv(r, e) {
    return t => t > 0 ? e : r
}
const g1 = (r, e, t) => {
        const n = r * r,
            i = t * (e * e - n) + n;
        return i < 0 ? 0 : Math.sqrt(i)
    },
    Kj = [zA, Nc, _f],
    qj = r => Kj.find(e => e.test(r));

function wR(r) {
    const e = qj(r);
    if (!e) return !1;
    let t = e.parse(r);
    return e === _f && (t = Jj(t)), t
}
const bR = (r, e) => {
        const t = wR(r),
            n = wR(e);
        if (!t || !n) return kv(r, e);
        const i = { ...t
        };
        return s => (i.red = g1(t.red, n.red, s), i.green = g1(t.green, n.green, s), i.blue = g1(t.blue, n.blue, s), i.alpha = ai(t.alpha, n.alpha, s), Nc.transform(i))
    },
    WA = new Set(["none", "hidden"]);

function Zj(r, e) {
    return WA.has(r) ? t => t <= 0 ? r : e : t => t >= 1 ? e : r
}

function Qj(r, e) {
    return t => ai(r, e, t)
}

function $M(r) {
    return typeof r == "number" ? Qj : typeof r == "string" ? jM(r) ? kv : ur.test(r) ? bR : tX : Array.isArray(r) ? XL : typeof r == "object" ? ur.test(r) ? bR : $j : kv
}

function XL(r, e) {
    const t = [...r],
        n = t.length,
        i = r.map((s, o) => $M(s)(s, e[o]));
    return s => {
        for (let o = 0; o < n; o++) t[o] = i[o](s);
        return t
    }
}

function $j(r, e) {
    const t = { ...r,
            ...e
        },
        n = {};
    for (const i in t) r[i] !== void 0 && e[i] !== void 0 && (n[i] = $M(r[i])(r[i], e[i]));
    return i => {
        for (const s in n) t[s] = n[s](i);
        return t
    }
}

function eX(r, e) {
    var t;
    const n = [],
        i = {
            color: 0,
            var: 0,
            number: 0
        };
    for (let s = 0; s < e.values.length; s++) {
        const o = e.types[s],
            a = r.indexes[o][i[o]],
            l = (t = r.values[a]) !== null && t !== void 0 ? t : 0;
        n[s] = l, i[o]++
    }
    return n
}
const tX = (r, e) => {
    const t = Pl.createTransformer(e),
        n = Pp(r),
        i = Pp(e);
    return n.indexes.var.length === i.indexes.var.length && n.indexes.color.length === i.indexes.color.length && n.indexes.number.length >= i.indexes.number.length ? WA.has(r) && !i.values.length || WA.has(e) && !n.values.length ? Zj(r, e) : um(XL(eX(n, i), i.values), t) : kv(r, e)
};

function YL(r, e, t) {
    return typeof r == "number" && typeof e == "number" && typeof t == "number" ? ai(r, e, t) : $M(r)(r, e)
}

function nX(r, e, t) {
    const n = [],
        i = t || YL,
        s = r.length - 1;
    for (let o = 0; o < s; o++) {
        let a = i(r[o], r[o + 1]);
        if (e) {
            const l = Array.isArray(e) ? e[o] || _s : e;
            a = um(l, a)
        }
        n.push(a)
    }
    return n
}

function iX(r, e, {
    clamp: t = !0,
    ease: n,
    mixer: i
} = {}) {
    const s = r.length;
    if (OA(s === e.length), s === 1) return () => e[0];
    if (s === 2 && r[0] === r[1]) return () => e[1];
    r[0] > r[s - 1] && (r = [...r].reverse(), e = [...e].reverse());
    const o = nX(e, n, i),
        a = o.length,
        l = c => {
            let u = 0;
            if (a > 1)
                for (; u < r.length - 2 && !(c < r[u + 1]); u++);
            const f = rh(r[u], r[u + 1], c);
            return o[u](f)
        };
    return t ? c => l(Ea(r[0], r[s - 1], c)) : l
}

function rX(r, e) {
    const t = r[r.length - 1];
    for (let n = 1; n <= e; n++) {
        const i = rh(0, e, n);
        r.push(ai(t, 1, i))
    }
}

function sX(r) {
    const e = [0];
    return rX(e, r.length - 1), e
}

function oX(r, e) {
    return r.map(t => t * e)
}

function aX(r, e) {
    return r.map(() => e || jL).splice(0, r.length - 1)
}

function zv({
    duration: r = 300,
    keyframes: e,
    times: t,
    ease: n = "easeInOut"
}) {
    const i = Xj(n) ? n.map(MR) : MR(n),
        s = {
            done: !1,
            value: e[0]
        },
        o = oX(t && t.length === e.length ? t : sX(e), r),
        a = iX(o, e, {
            ease: Array.isArray(i) ? i : aX(e, i)
        });
    return {
        calculatedDuration: r,
        next: l => (s.value = a(l), s.done = l >= r, s)
    }
}
const lX = r => {
        const e = ({
            timestamp: t
        }) => r(t);
        return {
            start: () => Xn.update(e, !0),
            stop: () => Rl(e),
            now: () => qi.isProcessing ? qi.timestamp : Oo.now()
        }
    },
    cX = {
        decay: AR,
        inertia: AR,
        tween: zv,
        keyframes: zv,
        spring: WL
    },
    uX = r => r / 100;
class ew extends kL {
    constructor(e) {
        super(e), this.holdTime = null, this.cancelTime = null, this.currentTime = 0, this.playbackSpeed = 1, this.pendingPlayState = "running", this.startTime = null, this.state = "idle", this.stop = () => {
            if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return;
            this.teardown();
            const {
                onStop: l
            } = this.options;
            l && l()
        };
        const {
            name: t,
            motionValue: n,
            element: i,
            keyframes: s
        } = this.options, o = (i == null ? void 0 : i.KeyframeResolver) || XM, a = (l, c) => this.onKeyframesResolved(l, c);
        this.resolver = new o(s, a, t, n, i), this.resolver.scheduleResolve()
    }
    flatten() {
        super.flatten(), this._resolved && Object.assign(this._resolved, this.initPlayback(this._resolved.keyframes))
    }
    initPlayback(e) {
        const {
            type: t = "keyframes",
            repeat: n = 0,
            repeatDelay: i = 0,
            repeatType: s,
            velocity: o = 0
        } = this.options, a = ZM(t) ? t : cX[t] || zv;
        let l, c;
        a !== zv && typeof e[0] != "number" && (l = um(uX, YL(e[0], e[1])), e = [0, 100]);
        const u = a({ ...this.options,
            keyframes: e
        });
        s === "mirror" && (c = a({ ...this.options,
            keyframes: [...e].reverse(),
            velocity: -o
        })), u.calculatedDuration === null && (u.calculatedDuration = VL(u));
        const {
            calculatedDuration: f
        } = u, d = f + i, m = d * (n + 1) - i;
        return {
            generator: u,
            mirroredGenerator: c,
            mapPercentToKeyframes: l,
            calculatedDuration: f,
            resolvedDuration: d,
            totalDuration: m
        }
    }
    onPostResolved() {
        const {
            autoplay: e = !0
        } = this.options;
        this.play(), this.pendingPlayState === "paused" || !e ? this.pause() : this.state = this.pendingPlayState
    }
    tick(e, t = !1) {
        const {
            resolved: n
        } = this;
        if (!n) {
            const {
                keyframes: P
            } = this.options;
            return {
                done: !0,
                value: P[P.length - 1]
            }
        }
        const {
            finalKeyframe: i,
            generator: s,
            mirroredGenerator: o,
            mapPercentToKeyframes: a,
            keyframes: l,
            calculatedDuration: c,
            totalDuration: u,
            resolvedDuration: f
        } = n;
        if (this.startTime === null) return s.next(0);
        const {
            delay: d,
            repeat: m,
            repeatType: g,
            repeatDelay: y,
            onUpdate: v
        } = this.options;
        this.speed > 0 ? this.startTime = Math.min(this.startTime, e) : this.speed < 0 && (this.startTime = Math.min(e - u / this.speed, this.startTime)), t ? this.currentTime = e : this.holdTime !== null ? this.currentTime = this.holdTime : this.currentTime = Math.round(e - this.startTime) * this.speed;
        const _ = this.currentTime - d * (this.speed >= 0 ? 1 : -1),
            A = this.speed >= 0 ? _ < 0 : _ > u;
        this.currentTime = Math.max(_, 0), this.state === "finished" && this.holdTime === null && (this.currentTime = u);
        let S = this.currentTime,
            M = s;
        if (m) {
            const P = Math.min(this.currentTime, u) / f;
            let b = Math.floor(P),
                T = P % 1;
            !T && P >= 1 && (T = 1), T === 1 && b--, b = Math.min(b, m + 1), !!(b % 2) && (g === "reverse" ? (T = 1 - T, y && (T -= y / f)) : g === "mirror" && (M = o)), S = Ea(0, 1, T) * f
        }
        const C = A ? {
            done: !1,
            value: l[0]
        } : M.next(S);
        a && (C.value = a(C.value));
        let {
            done: E
        } = C;
        !A && c !== null && (E = this.speed >= 0 ? this.currentTime >= u : this.currentTime <= 0);
        const R = this.holdTime === null && (this.state === "finished" || this.state === "running" && E);
        return R && i !== void 0 && (C.value = Vy(l, this.options, i)), v && v(C.value), R && this.finish(), C
    }
    get duration() {
        const {
            resolved: e
        } = this;
        return e ? Sa(e.calculatedDuration) : 0
    }
    get time() {
        return Sa(this.currentTime)
    }
    set time(e) {
        e = Aa(e), this.currentTime = e, this.holdTime !== null || this.speed === 0 ? this.holdTime = e : this.driver && (this.startTime = this.driver.now() - e / this.speed)
    }
    get speed() {
        return this.playbackSpeed
    }
    set speed(e) {
        const t = this.playbackSpeed !== e;
        this.playbackSpeed = e, t && (this.time = Sa(this.currentTime))
    }
    play() {
        if (this.resolver.isScheduled || this.resolver.resume(), !this._resolved) {
            this.pendingPlayState = "running";
            return
        }
        if (this.isStopped) return;
        const {
            driver: e = lX,
            onPlay: t,
            startTime: n
        } = this.options;
        this.driver || (this.driver = e(s => this.tick(s))), t && t();
        const i = this.driver.now();
        this.holdTime !== null ? this.startTime = i - this.holdTime : this.startTime ? this.state === "finished" && (this.startTime = i) : this.startTime = n ? ? this.calcStartTime(), this.state === "finished" && this.updateFinishedPromise(), this.cancelTime = this.startTime, this.holdTime = null, this.state = "running", this.driver.start()
    }
    pause() {
        var e;
        if (!this._resolved) {
            this.pendingPlayState = "paused";
            return
        }
        this.state = "paused", this.holdTime = (e = this.currentTime) !== null && e !== void 0 ? e : 0
    }
    complete() {
        this.state !== "running" && this.play(), this.pendingPlayState = this.state = "finished", this.holdTime = null
    }
    finish() {
        this.teardown(), this.state = "finished";
        const {
            onComplete: e
        } = this.options;
        e && e()
    }
    cancel() {
        this.cancelTime !== null && this.tick(this.cancelTime), this.teardown(), this.updateFinishedPromise()
    }
    teardown() {
        this.state = "idle", this.stopDriver(), this.resolveFinishedPromise(), this.updateFinishedPromise(), this.startTime = this.cancelTime = null, this.resolver.cancel()
    }
    stopDriver() {
        this.driver && (this.driver.stop(), this.driver = void 0)
    }
    sample(e) {
        return this.startTime = 0, this.tick(e, !0)
    }
}
const fX = new Set(["opacity", "clipPath", "filter", "transform"]);

function tw(r) {
    let e;
    return () => (e === void 0 && (e = r()), e)
}
const hX = {
    linearEasing: void 0
};

function dX(r, e) {
    const t = tw(r);
    return () => {
        var n;
        return (n = hX[e]) !== null && n !== void 0 ? n : t()
    }
}
const Gv = dX(() => {
    try {
        document.createElement("div").animate({
            opacity: 0
        }, {
            easing: "linear(0, 1)"
        })
    } catch {
        return !1
    }
    return !0
}, "linearEasing");

function JL(r) {
    return !!(typeof r == "function" && Gv() || !r || typeof r == "string" && (r in jA || Gv()) || QM(r) || Array.isArray(r) && r.every(JL))
}
const wd = ([r, e, t, n]) => `cubic-bezier(${r}, ${e}, ${t}, ${n})`,
    jA = {
        linear: "linear",
        ease: "ease",
        easeIn: "ease-in",
        easeOut: "ease-out",
        easeInOut: "ease-in-out",
        circIn: wd([0, .65, .55, 1]),
        circOut: wd([.55, 0, 1, .45]),
        backIn: wd([.31, .01, .66, -.59]),
        backOut: wd([.33, 1.53, .69, .99])
    };

function KL(r, e) {
    if (r) return typeof r == "function" && Gv() ? zL(r, e) : QM(r) ? wd(r) : Array.isArray(r) ? r.map(t => KL(t, e) || jA.easeOut) : jA[r]
}

function pX(r, e, t, {
    delay: n = 0,
    duration: i = 300,
    repeat: s = 0,
    repeatType: o = "loop",
    ease: a = "easeInOut",
    times: l
} = {}) {
    const c = {
        [e]: t
    };
    l && (c.offset = l);
    const u = KL(a, i);
    return Array.isArray(u) && (c.easing = u), r.animate(c, {
        delay: n,
        duration: i,
        easing: Array.isArray(u) ? "linear" : u,
        fill: "both",
        iterations: s + 1,
        direction: o === "reverse" ? "alternate" : "normal"
    })
}

function TR(r, e) {
    r.timeline = e, r.onfinish = null
}
const mX = tw(() => Object.hasOwnProperty.call(Element.prototype, "animate")),
    Hv = 10,
    gX = 2e4;

function vX(r) {
    return ZM(r.type) || r.type === "spring" || !JL(r.ease)
}

function yX(r, e) {
    const t = new ew({ ...e,
        keyframes: r,
        repeat: 0,
        delay: 0,
        isGenerator: !0
    });
    let n = {
        done: !1,
        value: r[0]
    };
    const i = [];
    let s = 0;
    for (; !n.done && s < gX;) n = t.sample(s), i.push(n.value), s += Hv;
    return {
        times: void 0,
        keyframes: i,
        duration: s - Hv,
        ease: "linear"
    }
}
const qL = {
    anticipate: xL,
    backInOut: _L,
    circInOut: SL
};

function _X(r) {
    return r in qL
}
class ER extends kL {
    constructor(e) {
        super(e);
        const {
            name: t,
            motionValue: n,
            element: i,
            keyframes: s
        } = this.options;
        this.resolver = new NL(s, (o, a) => this.onKeyframesResolved(o, a), t, n, i), this.resolver.scheduleResolve()
    }
    initPlayback(e, t) {
        var n;
        let {
            duration: i = 300,
            times: s,
            ease: o,
            type: a,
            motionValue: l,
            name: c,
            startTime: u
        } = this.options;
        if (!(!((n = l.owner) === null || n === void 0) && n.current)) return !1;
        if (typeof o == "string" && Gv() && _X(o) && (o = qL[o]), vX(this.options)) {
            const {
                onComplete: d,
                onUpdate: m,
                motionValue: g,
                element: y,
                ...v
            } = this.options, _ = yX(e, v);
            e = _.keyframes, e.length === 1 && (e[1] = e[0]), i = _.duration, s = _.times, o = _.ease, a = "keyframes"
        }
        const f = pX(l.owner.current, c, e, { ...this.options,
            duration: i,
            times: s,
            ease: o
        });
        return f.startTime = u ? ? this.calcStartTime(), this.pendingTimeline ? (TR(f, this.pendingTimeline), this.pendingTimeline = void 0) : f.onfinish = () => {
            const {
                onComplete: d
            } = this.options;
            l.set(Vy(e, this.options, t)), d && d(), this.cancel(), this.resolveFinishedPromise()
        }, {
            animation: f,
            duration: i,
            times: s,
            type: a,
            ease: o,
            keyframes: e
        }
    }
    get duration() {
        const {
            resolved: e
        } = this;
        if (!e) return 0;
        const {
            duration: t
        } = e;
        return Sa(t)
    }
    get time() {
        const {
            resolved: e
        } = this;
        if (!e) return 0;
        const {
            animation: t
        } = e;
        return Sa(t.currentTime || 0)
    }
    set time(e) {
        const {
            resolved: t
        } = this;
        if (!t) return;
        const {
            animation: n
        } = t;
        n.currentTime = Aa(e)
    }
    get speed() {
        const {
            resolved: e
        } = this;
        if (!e) return 1;
        const {
            animation: t
        } = e;
        return t.playbackRate
    }
    set speed(e) {
        const {
            resolved: t
        } = this;
        if (!t) return;
        const {
            animation: n
        } = t;
        n.playbackRate = e
    }
    get state() {
        const {
            resolved: e
        } = this;
        if (!e) return "idle";
        const {
            animation: t
        } = e;
        return t.playState
    }
    get startTime() {
        const {
            resolved: e
        } = this;
        if (!e) return null;
        const {
            animation: t
        } = e;
        return t.startTime
    }
    attachTimeline(e) {
        if (!this._resolved) this.pendingTimeline = e;
        else {
            const {
                resolved: t
            } = this;
            if (!t) return _s;
            const {
                animation: n
            } = t;
            TR(n, e)
        }
        return _s
    }
    play() {
        if (this.isStopped) return;
        const {
            resolved: e
        } = this;
        if (!e) return;
        const {
            animation: t
        } = e;
        t.playState === "finished" && this.updateFinishedPromise(), t.play()
    }
    pause() {
        const {
            resolved: e
        } = this;
        if (!e) return;
        const {
            animation: t
        } = e;
        t.pause()
    }
    stop() {
        if (this.resolver.cancel(), this.isStopped = !0, this.state === "idle") return;
        this.resolveFinishedPromise(), this.updateFinishedPromise();
        const {
            resolved: e
        } = this;
        if (!e) return;
        const {
            animation: t,
            keyframes: n,
            duration: i,
            type: s,
            ease: o,
            times: a
        } = e;
        if (t.playState === "idle" || t.playState === "finished") return;
        if (this.time) {
            const {
                motionValue: c,
                onUpdate: u,
                onComplete: f,
                element: d,
                ...m
            } = this.options, g = new ew({ ...m,
                keyframes: n,
                duration: i,
                type: s,
                ease: o,
                times: a,
                isGenerator: !0
            }), y = Aa(this.time);
            c.setWithVelocity(g.sample(y - Hv).value, g.sample(y).value, Hv)
        }
        const {
            onStop: l
        } = this.options;
        l && l(), this.cancel()
    }
    complete() {
        const {
            resolved: e
        } = this;
        e && e.animation.finish()
    }
    cancel() {
        const {
            resolved: e
        } = this;
        e && e.animation.cancel()
    }
    static supports(e) {
        const {
            motionValue: t,
            name: n,
            repeatDelay: i,
            repeatType: s,
            damping: o,
            type: a
        } = e;
        return mX() && n && fX.has(n) && t && t.owner && t.owner.current instanceof HTMLElement && !t.owner.getProps().onUpdate && !i && s !== "mirror" && o !== 0 && a !== "inertia"
    }
}
const xX = tw(() => window.ScrollTimeline !== void 0);
class AX {
    constructor(e) {
        this.stop = () => this.runAll("stop"), this.animations = e.filter(Boolean)
    }
    then(e, t) {
        return Promise.all(this.animations).then(e).catch(t)
    }
    getAll(e) {
        return this.animations[0][e]
    }
    setAll(e, t) {
        for (let n = 0; n < this.animations.length; n++) this.animations[n][e] = t
    }
    attachTimeline(e, t) {
        const n = this.animations.map(i => xX() && i.attachTimeline ? i.attachTimeline(e) : t(i));
        return () => {
            n.forEach((i, s) => {
                i && i(), this.animations[s].stop()
            })
        }
    }
    get time() {
        return this.getAll("time")
    }
    set time(e) {
        this.setAll("time", e)
    }
    get speed() {
        return this.getAll("speed")
    }
    set speed(e) {
        this.setAll("speed", e)
    }
    get startTime() {
        return this.getAll("startTime")
    }
    get duration() {
        let e = 0;
        for (let t = 0; t < this.animations.length; t++) e = Math.max(e, this.animations[t].duration);
        return e
    }
    runAll(e) {
        this.animations.forEach(t => t[e]())
    }
    flatten() {
        this.runAll("flatten")
    }
    play() {
        this.runAll("play")
    }
    pause() {
        this.runAll("pause")
    }
    cancel() {
        this.runAll("cancel")
    }
    complete() {
        this.runAll("complete")
    }
}

function SX({
    when: r,
    delay: e,
    delayChildren: t,
    staggerChildren: n,
    staggerDirection: i,
    repeat: s,
    repeatType: o,
    repeatDelay: a,
    from: l,
    elapsed: c,
    ...u
}) {
    return !!Object.keys(u).length
}
const nw = (r, e, t, n = {}, i, s) => o => {
        const a = HM(n, r) || {},
            l = a.delay || n.delay || 0;
        let {
            elapsed: c = 0
        } = n;
        c = c - Aa(l);
        let u = {
            keyframes: Array.isArray(t) ? t : [null, t],
            ease: "easeOut",
            velocity: e.getVelocity(),
            ...a,
            delay: -c,
            onUpdate: d => {
                e.set(d), a.onUpdate && a.onUpdate(d)
            },
            onComplete: () => {
                o(), a.onComplete && a.onComplete()
            },
            name: r,
            motionValue: e,
            element: s ? void 0 : i
        };
        SX(a) || (u = { ...u,
            ...YW(r, u)
        }), u.duration && (u.duration = Aa(u.duration)), u.repeatDelay && (u.repeatDelay = Aa(u.repeatDelay)), u.from !== void 0 && (u.keyframes[0] = u.from);
        let f = !1;
        if ((u.type === !1 || u.duration === 0 && !u.repeatDelay) && (u.duration = 0, u.delay === 0 && (f = !0)), f && !s && e.get() !== void 0) {
            const d = Vy(u.keyframes, a);
            if (d !== void 0) return Xn.update(() => {
                u.onUpdate(d), u.onComplete()
            }), new AX([])
        }
        return !s && ER.supports(u) ? new ER(u) : new ew(u)
    },
    MX = r => !!(r && typeof r == "object" && r.mix && r.toValue),
    wX = r => UA(r) ? r[r.length - 1] || 0 : r;

function iw(r, e) {
    r.indexOf(e) === -1 && r.push(e)
}

function rw(r, e) {
    const t = r.indexOf(e);
    t > -1 && r.splice(t, 1)
}
class sw {
    constructor() {
        this.subscriptions = []
    }
    add(e) {
        return iw(this.subscriptions, e), () => rw(this.subscriptions, e)
    }
    notify(e, t, n) {
        const i = this.subscriptions.length;
        if (i)
            if (i === 1) this.subscriptions[0](e, t, n);
            else
                for (let s = 0; s < i; s++) {
                    const o = this.subscriptions[s];
                    o && o(e, t, n)
                }
    }
    getSize() {
        return this.subscriptions.length
    }
    clear() {
        this.subscriptions.length = 0
    }
}
const CR = 30,
    bX = r => !isNaN(parseFloat(r));
class TX {
    constructor(e, t = {}) {
        this.version = "11.15.0", this.canTrackVelocity = null, this.events = {}, this.updateAndNotify = (n, i = !0) => {
            const s = Oo.now();
            this.updatedAt !== s && this.setPrevFrameValue(), this.prev = this.current, this.setCurrent(n), this.current !== this.prev && this.events.change && this.events.change.notify(this.current), i && this.events.renderRequest && this.events.renderRequest.notify(this.current)
        }, this.hasAnimated = !1, this.setCurrent(e), this.owner = t.owner
    }
    setCurrent(e) {
        this.current = e, this.updatedAt = Oo.now(), this.canTrackVelocity === null && e !== void 0 && (this.canTrackVelocity = bX(this.current))
    }
    setPrevFrameValue(e = this.current) {
        this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt
    }
    onChange(e) {
        return this.on("change", e)
    }
    on(e, t) {
        this.events[e] || (this.events[e] = new sw);
        const n = this.events[e].add(t);
        return e === "change" ? () => {
            n(), Xn.read(() => {
                this.events.change.getSize() || this.stop()
            })
        } : n
    }
    clearListeners() {
        for (const e in this.events) this.events[e].clear()
    }
    attach(e, t) {
        this.passiveEffect = e, this.stopPassiveEffect = t
    }
    set(e, t = !0) {
        !t || !this.passiveEffect ? this.updateAndNotify(e, t) : this.passiveEffect(e, this.updateAndNotify)
    }
    setWithVelocity(e, t, n) {
        this.set(t), this.prev = void 0, this.prevFrameValue = e, this.prevUpdatedAt = this.updatedAt - n
    }
    jump(e, t = !0) {
        this.updateAndNotify(e), this.prev = e, this.prevUpdatedAt = this.prevFrameValue = void 0, t && this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
    get() {
        return this.current
    }
    getPrevious() {
        return this.prev
    }
    getVelocity() {
        const e = Oo.now();
        if (!this.canTrackVelocity || this.prevFrameValue === void 0 || e - this.updatedAt > CR) return 0;
        const t = Math.min(this.updatedAt - this.prevUpdatedAt, CR);
        return GL(parseFloat(this.current) - parseFloat(this.prevFrameValue), t)
    }
    start(e) {
        return this.stop(), new Promise(t => {
            this.hasAnimated = !0, this.animation = e(t), this.events.animationStart && this.events.animationStart.notify()
        }).then(() => {
            this.events.animationComplete && this.events.animationComplete.notify(), this.clearAnimation()
        })
    }
    stop() {
        this.animation && (this.animation.stop(), this.events.animationCancel && this.events.animationCancel.notify()), this.clearAnimation()
    }
    isAnimating() {
        return !!this.animation
    }
    clearAnimation() {
        delete this.animation
    }
    destroy() {
        this.clearListeners(), this.stop(), this.stopPassiveEffect && this.stopPassiveEffect()
    }
}

function Ip(r, e) {
    return new TX(r, e)
}

function EX(r, e, t) {
    r.hasValue(e) ? r.getValue(e).set(t) : r.addValue(e, Ip(t))
}

function CX(r, e) {
    const t = Hy(r, e);
    let {
        transitionEnd: n = {},
        transition: i = {},
        ...s
    } = t || {};
    s = { ...s,
        ...n
    };
    for (const o in s) {
        const a = wX(s[o]);
        EX(r, o, a)
    }
}
const ow = r => r.replace(/([a-z])([A-Z])/gu, "$1-$2").toLowerCase(),
    RX = "framerAppearId",
    ZL = "data-" + ow(RX);

function QL(r) {
    return r.props[ZL]
}
const dr = r => !!(r && r.getVelocity);

function PX(r) {
    return !!(dr(r) && r.add)
}

function XA(r, e) {
    const t = r.getValue("willChange");
    if (PX(t)) return t.add(e)
}

function IX({
    protectedKeys: r,
    needsAnimating: e
}, t) {
    const n = r.hasOwnProperty(t) && e[t] !== !0;
    return e[t] = !1, n
}

function $L(r, e, {
    delay: t = 0,
    transitionOverride: n,
    type: i
} = {}) {
    var s;
    let {
        transition: o = r.getDefaultTransition(),
        transitionEnd: a,
        ...l
    } = e;
    n && (o = n);
    const c = [],
        u = i && r.animationState && r.animationState.getState()[i];
    for (const f in l) {
        const d = r.getValue(f, (s = r.latestValues[f]) !== null && s !== void 0 ? s : null),
            m = l[f];
        if (m === void 0 || u && IX(u, f)) continue;
        const g = {
            delay: t,
            ...HM(o || {}, f)
        };
        let y = !1;
        if (window.MotionHandoffAnimation) {
            const _ = QL(r);
            if (_) {
                const A = window.MotionHandoffAnimation(_, f, Xn);
                A !== null && (g.startTime = A, y = !0)
            }
        }
        XA(r, f), d.start(nw(f, d, m, r.shouldReduceMotion && xu.has(f) ? {
            type: !1
        } : g, r, y));
        const v = d.animation;
        v && c.push(v)
    }
    return a && Promise.all(c).then(() => {
        Xn.update(() => {
            a && CX(r, a)
        })
    }), c
}

function YA(r, e, t = {}) {
    var n;
    const i = Hy(r, e, t.type === "exit" ? (n = r.presenceContext) === null || n === void 0 ? void 0 : n.custom : void 0);
    let {
        transition: s = r.getDefaultTransition() || {}
    } = i || {};
    t.transitionOverride && (s = t.transitionOverride);
    const o = i ? () => Promise.all($L(r, i, t)) : () => Promise.resolve(),
        a = r.variantChildren && r.variantChildren.size ? (c = 0) => {
            const {
                delayChildren: u = 0,
                staggerChildren: f,
                staggerDirection: d
            } = s;
            return BX(r, e, u + c, f, d, t)
        } : () => Promise.resolve(),
        {
            when: l
        } = s;
    if (l) {
        const [c, u] = l === "beforeChildren" ? [o, a] : [a, o];
        return c().then(() => u())
    } else return Promise.all([o(), a(t.delay)])
}

function BX(r, e, t = 0, n = 0, i = 1, s) {
    const o = [],
        a = (r.variantChildren.size - 1) * n,
        l = i === 1 ? (c = 0) => c * n : (c = 0) => a - c * n;
    return Array.from(r.variantChildren).sort(DX).forEach((c, u) => {
        c.notify("AnimationStart", e), o.push(YA(c, e, { ...s,
            delay: t + l(u)
        }).then(() => c.notify("AnimationComplete", e)))
    }), Promise.all(o)
}

function DX(r, e) {
    return r.sortNodePosition(e)
}

function LX(r, e, t = {}) {
    r.notify("AnimationStart", e);
    let n;
    if (Array.isArray(e)) {
        const i = e.map(s => YA(r, s, t));
        n = Promise.all(i)
    } else if (typeof e == "string") n = YA(r, e, t);
    else {
        const i = typeof e == "function" ? Hy(r, e, t.custom) : e;
        n = Promise.all($L(r, i, t))
    }
    return n.then(() => {
        r.notify("AnimationComplete", e)
    })
}
const FX = GM.length;

function e3(r) {
    if (!r) return;
    if (!r.isControllingVariants) {
        const t = r.parent ? e3(r.parent) || {} : {};
        return r.props.initial !== void 0 && (t.initial = r.props.initial), t
    }
    const e = {};
    for (let t = 0; t < FX; t++) {
        const n = GM[t],
            i = r.props[n];
        (Cp(i) || i === !1) && (e[n] = i)
    }
    return e
}
const UX = [...zM].reverse(),
    OX = zM.length;

function NX(r) {
    return e => Promise.all(e.map(({
        animation: t,
        options: n
    }) => LX(r, t, n)))
}

function kX(r) {
    let e = NX(r),
        t = RR(),
        n = !0;
    const i = l => (c, u) => {
        var f;
        const d = Hy(r, u, l === "exit" ? (f = r.presenceContext) === null || f === void 0 ? void 0 : f.custom : void 0);
        if (d) {
            const {
                transition: m,
                transitionEnd: g,
                ...y
            } = d;
            c = { ...c,
                ...y,
                ...g
            }
        }
        return c
    };

    function s(l) {
        e = l(r)
    }

    function o(l) {
        const {
            props: c
        } = r, u = e3(r.parent) || {}, f = [], d = new Set;
        let m = {},
            g = 1 / 0;
        for (let v = 0; v < OX; v++) {
            const _ = UX[v],
                A = t[_],
                S = c[_] !== void 0 ? c[_] : u[_],
                M = Cp(S),
                C = _ === l ? A.isActive : null;
            C === !1 && (g = v);
            let E = S === u[_] && S !== c[_] && M;
            if (E && n && r.manuallyAnimateOnMount && (E = !1), A.protectedKeys = { ...m
                }, !A.isActive && C === null || !S && !A.prevProp || Gy(S) || typeof S == "boolean") continue;
            const R = zX(A.prevProp, S);
            let P = R || _ === l && A.isActive && !E && M || v > g && M,
                b = !1;
            const T = Array.isArray(S) ? S : [S];
            let L = T.reduce(i(_), {});
            C === !1 && (L = {});
            const {
                prevResolvedValues: D = {}
            } = A, V = { ...D,
                ...L
            }, H = oe => {
                P = !0, d.has(oe) && (b = !0, d.delete(oe)), A.needsAnimating[oe] = !0;
                const Y = r.getValue(oe);
                Y && (Y.liveStyle = !1)
            };
            for (const oe in V) {
                const Y = L[oe],
                    Z = D[oe];
                if (m.hasOwnProperty(oe)) continue;
                let U = !1;
                UA(Y) && UA(Z) ? U = !dL(Y, Z) : U = Y !== Z, U ? Y != null ? H(oe) : d.add(oe) : Y !== void 0 && d.has(oe) ? H(oe) : A.protectedKeys[oe] = !0
            }
            A.prevProp = S, A.prevResolvedValues = L, A.isActive && (m = { ...m,
                ...L
            }), n && r.blockInitialAnimation && (P = !1), P && (!(E && R) || b) && f.push(...T.map(oe => ({
                animation: oe,
                options: {
                    type: _
                }
            })))
        }
        if (d.size) {
            const v = {};
            d.forEach(_ => {
                const A = r.getBaseTarget(_),
                    S = r.getValue(_);
                S && (S.liveStyle = !0), v[_] = A ? ? null
            }), f.push({
                animation: v
            })
        }
        let y = !!f.length;
        return n && (c.initial === !1 || c.initial === c.animate) && !r.manuallyAnimateOnMount && (y = !1), n = !1, y ? e(f) : Promise.resolve()
    }

    function a(l, c) {
        var u;
        if (t[l].isActive === c) return Promise.resolve();
        (u = r.variantChildren) === null || u === void 0 || u.forEach(d => {
            var m;
            return (m = d.animationState) === null || m === void 0 ? void 0 : m.setActive(l, c)
        }), t[l].isActive = c;
        const f = o(l);
        for (const d in t) t[d].protectedKeys = {};
        return f
    }
    return {
        animateChanges: o,
        setActive: a,
        setAnimateFunction: s,
        getState: () => t,
        reset: () => {
            t = RR(), n = !0
        }
    }
}

function zX(r, e) {
    return typeof e == "string" ? e !== r : Array.isArray(e) ? !dL(e, r) : !1
}

function yc(r = !1) {
    return {
        isActive: r,
        protectedKeys: {},
        needsAnimating: {},
        prevResolvedValues: {}
    }
}

function RR() {
    return {
        animate: yc(!0),
        whileInView: yc(),
        whileHover: yc(),
        whileTap: yc(),
        whileDrag: yc(),
        whileFocus: yc(),
        exit: yc()
    }
}
class kl {
    constructor(e) {
        this.isMounted = !1, this.node = e
    }
    update() {}
}
class GX extends kl {
    constructor(e) {
        super(e), e.animationState || (e.animationState = kX(e))
    }
    updateAnimationControlsSubscription() {
        const {
            animate: e
        } = this.node.getProps();
        Gy(e) && (this.unmountControls = e.subscribe(this.node))
    }
    mount() {
        this.updateAnimationControlsSubscription()
    }
    update() {
        const {
            animate: e
        } = this.node.getProps(), {
            animate: t
        } = this.node.prevProps || {};
        e !== t && this.updateAnimationControlsSubscription()
    }
    unmount() {
        var e;
        this.node.animationState.reset(), (e = this.unmountControls) === null || e === void 0 || e.call(this)
    }
}
let HX = 0;
class VX extends kl {
    constructor() {
        super(...arguments), this.id = HX++
    }
    update() {
        if (!this.node.presenceContext) return;
        const {
            isPresent: e,
            onExitComplete: t
        } = this.node.presenceContext, {
            isPresent: n
        } = this.node.prevPresenceContext || {};
        if (!this.node.animationState || e === n) return;
        const i = this.node.animationState.setActive("exit", !e);
        t && !e && i.then(() => t(this.id))
    }
    mount() {
        const {
            register: e
        } = this.node.presenceContext || {};
        e && (this.unmount = e(this.id))
    }
    unmount() {}
}
const WX = {
        animation: {
            Feature: GX
        },
        exit: {
            Feature: VX
        }
    },
    ao = {
        x: !1,
        y: !1
    };

function t3() {
    return ao.x || ao.y
}

function jX(r, e, t) {
    var n;
    if (r instanceof Element) return [r];
    if (typeof r == "string") {
        let i = document;
        const s = (n = void 0) !== null && n !== void 0 ? n : i.querySelectorAll(r);
        return s ? Array.from(s) : []
    }
    return Array.from(r)
}

function n3(r, e) {
    const t = jX(r),
        n = new AbortController,
        i = {
            passive: !0,
            ...e,
            signal: n.signal
        };
    return [t, i, () => n.abort()]
}

function PR(r) {
    return e => {
        e.pointerType === "touch" || t3() || r(e)
    }
}

function XX(r, e, t = {}) {
    const [n, i, s] = n3(r, t), o = PR(a => {
        const {
            target: l
        } = a, c = e(a);
        if (!c || !l) return;
        const u = PR(f => {
            c(f), l.removeEventListener("pointerleave", u)
        });
        l.addEventListener("pointerleave", u, i)
    });
    return n.forEach(a => {
        a.addEventListener("pointerenter", o, i)
    }), s
}
const aw = r => r.pointerType === "mouse" ? typeof r.button != "number" || r.button <= 0 : r.isPrimary !== !1,
    bd = new WeakSet;

function IR(r) {
    return e => {
        e.key === "Enter" && r(e)
    }
}

function v1(r, e) {
    r.dispatchEvent(new PointerEvent("pointer" + e, {
        isPrimary: !0,
        bubbles: !0
    }))
}
const YX = (r, e) => {
        const t = r.currentTarget;
        if (!t) return;
        const n = IR(() => {
            if (bd.has(t)) return;
            v1(t, "down");
            const i = IR(() => {
                    v1(t, "up")
                }),
                s = () => v1(t, "cancel");
            t.addEventListener("keyup", i, e), t.addEventListener("blur", s, e)
        });
        t.addEventListener("keydown", n, e), t.addEventListener("blur", () => t.removeEventListener("keydown", n), e)
    },
    JX = new Set(["BUTTON", "INPUT", "SELECT", "TEXTAREA", "A"]);

function KX(r) {
    return JX.has(r.tagName) || r.tabIndex !== -1
}
const i3 = (r, e) => e ? r === e ? !0 : i3(r, e.parentElement) : !1;

function BR(r) {
    return aw(r) && !t3()
}

function qX(r, e, t = {}) {
    const [n, i, s] = n3(r, t), o = a => {
        const l = a.currentTarget;
        if (!BR(a) || bd.has(l)) return;
        bd.add(l);
        const c = e(a),
            u = (m, g) => {
                window.removeEventListener("pointerup", f), window.removeEventListener("pointercancel", d), !(!BR(m) || !bd.has(l)) && (bd.delete(l), c && c(m, {
                    success: g
                }))
            },
            f = m => {
                u(m, t.useGlobalTarget || i3(l, m.target))
            },
            d = m => {
                u(m, !1)
            };
        window.addEventListener("pointerup", f, i), window.addEventListener("pointercancel", d, i)
    };
    return n.forEach(a => {
        KX(a) || (a.tabIndex = 0), (t.useGlobalTarget ? window : a).addEventListener("pointerdown", o, i), a.addEventListener("focus", c => YX(c, i), i)
    }), s
}

function ZX(r) {
    return r === "x" || r === "y" ? ao[r] ? null : (ao[r] = !0, () => {
        ao[r] = !1
    }) : ao.x || ao.y ? null : (ao.x = ao.y = !0, () => {
        ao.x = ao.y = !1
    })
}

function fm(r) {
    return {
        point: {
            x: r.pageX,
            y: r.pageY
        }
    }
}
const QX = r => e => aw(e) && r(e, fm(e));

function Bp(r, e, t, n = {
    passive: !0
}) {
    return r.addEventListener(e, t, n), () => r.removeEventListener(e, t)
}

function $d(r, e, t, n) {
    return Bp(r, e, QX(t), n)
}
const DR = (r, e) => Math.abs(r - e);

function $X(r, e) {
    const t = DR(r.x, e.x),
        n = DR(r.y, e.y);
    return Math.sqrt(t ** 2 + n ** 2)
}
class r3 {
    constructor(e, t, {
        transformPagePoint: n,
        contextWindow: i,
        dragSnapToOrigin: s = !1
    } = {}) {
        if (this.startEvent = null, this.lastMoveEvent = null, this.lastMoveEventInfo = null, this.handlers = {}, this.contextWindow = window, this.updatePoint = () => {
                if (!(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                const f = _1(this.lastMoveEventInfo, this.history),
                    d = this.startEvent !== null,
                    m = $X(f.offset, {
                        x: 0,
                        y: 0
                    }) >= 3;
                if (!d && !m) return;
                const {
                    point: g
                } = f, {
                    timestamp: y
                } = qi;
                this.history.push({ ...g,
                    timestamp: y
                });
                const {
                    onStart: v,
                    onMove: _
                } = this.handlers;
                d || (v && v(this.lastMoveEvent, f), this.startEvent = this.lastMoveEvent), _ && _(this.lastMoveEvent, f)
            }, this.handlePointerMove = (f, d) => {
                this.lastMoveEvent = f, this.lastMoveEventInfo = y1(d, this.transformPagePoint), Xn.update(this.updatePoint, !0)
            }, this.handlePointerUp = (f, d) => {
                this.end();
                const {
                    onEnd: m,
                    onSessionEnd: g,
                    resumeAnimation: y
                } = this.handlers;
                if (this.dragSnapToOrigin && y && y(), !(this.lastMoveEvent && this.lastMoveEventInfo)) return;
                const v = _1(f.type === "pointercancel" ? this.lastMoveEventInfo : y1(d, this.transformPagePoint), this.history);
                this.startEvent && m && m(f, v), g && g(f, v)
            }, !aw(e)) return;
        this.dragSnapToOrigin = s, this.handlers = t, this.transformPagePoint = n, this.contextWindow = i || window;
        const o = fm(e),
            a = y1(o, this.transformPagePoint),
            {
                point: l
            } = a,
            {
                timestamp: c
            } = qi;
        this.history = [{ ...l,
            timestamp: c
        }];
        const {
            onSessionStart: u
        } = t;
        u && u(e, _1(a, this.history)), this.removeListeners = um($d(this.contextWindow, "pointermove", this.handlePointerMove), $d(this.contextWindow, "pointerup", this.handlePointerUp), $d(this.contextWindow, "pointercancel", this.handlePointerUp))
    }
    updateHandlers(e) {
        this.handlers = e
    }
    end() {
        this.removeListeners && this.removeListeners(), Rl(this.updatePoint)
    }
}

function y1(r, e) {
    return e ? {
        point: e(r.point)
    } : r
}

function LR(r, e) {
    return {
        x: r.x - e.x,
        y: r.y - e.y
    }
}

function _1({
    point: r
}, e) {
    return {
        point: r,
        delta: LR(r, s3(e)),
        offset: LR(r, e7(e)),
        velocity: t7(e, .1)
    }
}

function e7(r) {
    return r[0]
}

function s3(r) {
    return r[r.length - 1]
}

function t7(r, e) {
    if (r.length < 2) return {
        x: 0,
        y: 0
    };
    let t = r.length - 1,
        n = null;
    const i = s3(r);
    for (; t >= 0 && (n = r[t], !(i.timestamp - n.timestamp > Aa(e)));) t--;
    if (!n) return {
        x: 0,
        y: 0
    };
    const s = Sa(i.timestamp - n.timestamp);
    if (s === 0) return {
        x: 0,
        y: 0
    };
    const o = {
        x: (i.x - n.x) / s,
        y: (i.y - n.y) / s
    };
    return o.x === 1 / 0 && (o.x = 0), o.y === 1 / 0 && (o.y = 0), o
}

function xf(r) {
    return r && typeof r == "object" && Object.prototype.hasOwnProperty.call(r, "current")
}
const o3 = 1e-4,
    n7 = 1 - o3,
    i7 = 1 + o3,
    a3 = .01,
    r7 = 0 - a3,
    s7 = 0 + a3;

function Ss(r) {
    return r.max - r.min
}

function o7(r, e, t) {
    return Math.abs(r - e) <= t
}

function FR(r, e, t, n = .5) {
    r.origin = n, r.originPoint = ai(e.min, e.max, r.origin), r.scale = Ss(t) / Ss(e), r.translate = ai(t.min, t.max, r.origin) - r.originPoint, (r.scale >= n7 && r.scale <= i7 || isNaN(r.scale)) && (r.scale = 1), (r.translate >= r7 && r.translate <= s7 || isNaN(r.translate)) && (r.translate = 0)
}

function ep(r, e, t, n) {
    FR(r.x, e.x, t.x, n ? n.originX : void 0), FR(r.y, e.y, t.y, n ? n.originY : void 0)
}

function UR(r, e, t) {
    r.min = t.min + e.min, r.max = r.min + Ss(e)
}

function a7(r, e, t) {
    UR(r.x, e.x, t.x), UR(r.y, e.y, t.y)
}

function OR(r, e, t) {
    r.min = e.min - t.min, r.max = r.min + Ss(e)
}

function tp(r, e, t) {
    OR(r.x, e.x, t.x), OR(r.y, e.y, t.y)
}

function l7(r, {
    min: e,
    max: t
}, n) {
    return e !== void 0 && r < e ? r = n ? ai(e, r, n.min) : Math.max(r, e) : t !== void 0 && r > t && (r = n ? ai(t, r, n.max) : Math.min(r, t)), r
}

function NR(r, e, t) {
    return {
        min: e !== void 0 ? r.min + e : void 0,
        max: t !== void 0 ? r.max + t - (r.max - r.min) : void 0
    }
}

function c7(r, {
    top: e,
    left: t,
    bottom: n,
    right: i
}) {
    return {
        x: NR(r.x, t, i),
        y: NR(r.y, e, n)
    }
}

function kR(r, e) {
    let t = e.min - r.min,
        n = e.max - r.max;
    return e.max - e.min < r.max - r.min && ([t, n] = [n, t]), {
        min: t,
        max: n
    }
}

function u7(r, e) {
    return {
        x: kR(r.x, e.x),
        y: kR(r.y, e.y)
    }
}

function f7(r, e) {
    let t = .5;
    const n = Ss(r),
        i = Ss(e);
    return i > n ? t = rh(e.min, e.max - n, r.min) : n > i && (t = rh(r.min, r.max - i, e.min)), Ea(0, 1, t)
}

function h7(r, e) {
    const t = {};
    return e.min !== void 0 && (t.min = e.min - r.min), e.max !== void 0 && (t.max = e.max - r.min), t
}
const JA = .35;

function d7(r = JA) {
    return r === !1 ? r = 0 : r === !0 && (r = JA), {
        x: zR(r, "left", "right"),
        y: zR(r, "top", "bottom")
    }
}

function zR(r, e, t) {
    return {
        min: GR(r, e),
        max: GR(r, t)
    }
}

function GR(r, e) {
    return typeof r == "number" ? r : r[e] || 0
}
const HR = () => ({
        translate: 0,
        scale: 1,
        origin: 0,
        originPoint: 0
    }),
    Af = () => ({
        x: HR(),
        y: HR()
    }),
    VR = () => ({
        min: 0,
        max: 0
    }),
    xi = () => ({
        x: VR(),
        y: VR()
    });

function ks(r) {
    return [r("x"), r("y")]
}

function l3({
    top: r,
    left: e,
    right: t,
    bottom: n
}) {
    return {
        x: {
            min: e,
            max: t
        },
        y: {
            min: r,
            max: n
        }
    }
}

function p7({
    x: r,
    y: e
}) {
    return {
        top: e.min,
        right: r.max,
        bottom: e.max,
        left: r.min
    }
}

function m7(r, e) {
    if (!e) return r;
    const t = e({
            x: r.left,
            y: r.top
        }),
        n = e({
            x: r.right,
            y: r.bottom
        });
    return {
        top: t.y,
        left: t.x,
        bottom: n.y,
        right: n.x
    }
}

function x1(r) {
    return r === void 0 || r === 1
}

function KA({
    scale: r,
    scaleX: e,
    scaleY: t
}) {
    return !x1(r) || !x1(e) || !x1(t)
}

function bc(r) {
    return KA(r) || c3(r) || r.z || r.rotate || r.rotateX || r.rotateY || r.skewX || r.skewY
}

function c3(r) {
    return WR(r.x) || WR(r.y)
}

function WR(r) {
    return r && r !== "0%"
}

function Vv(r, e, t) {
    const n = r - t,
        i = e * n;
    return t + i
}

function jR(r, e, t, n, i) {
    return i !== void 0 && (r = Vv(r, i, n)), Vv(r, t, n) + e
}

function qA(r, e = 0, t = 1, n, i) {
    r.min = jR(r.min, e, t, n, i), r.max = jR(r.max, e, t, n, i)
}

function u3(r, {
    x: e,
    y: t
}) {
    qA(r.x, e.translate, e.scale, e.originPoint), qA(r.y, t.translate, t.scale, t.originPoint)
}
const XR = .999999999999,
    YR = 1.0000000000001;

function g7(r, e, t, n = !1) {
    const i = t.length;
    if (!i) return;
    e.x = e.y = 1;
    let s, o;
    for (let a = 0; a < i; a++) {
        s = t[a], o = s.projectionDelta;
        const {
            visualElement: l
        } = s.options;
        l && l.props.style && l.props.style.display === "contents" || (n && s.options.layoutScroll && s.scroll && s !== s.root && Mf(r, {
            x: -s.scroll.offset.x,
            y: -s.scroll.offset.y
        }), o && (e.x *= o.x.scale, e.y *= o.y.scale, u3(r, o)), n && bc(s.latestValues) && Mf(r, s.latestValues))
    }
    e.x < YR && e.x > XR && (e.x = 1), e.y < YR && e.y > XR && (e.y = 1)
}

function Sf(r, e) {
    r.min = r.min + e, r.max = r.max + e
}

function JR(r, e, t, n, i = .5) {
    const s = ai(r.min, r.max, i);
    qA(r, e, t, s, n)
}

function Mf(r, e) {
    JR(r.x, e.x, e.scaleX, e.scale, e.originX), JR(r.y, e.y, e.scaleY, e.scale, e.originY)
}

function f3(r, e) {
    return l3(m7(r.getBoundingClientRect(), e))
}

function v7(r, e, t) {
    const n = f3(r, t),
        {
            scroll: i
        } = e;
    return i && (Sf(n.x, i.offset.x), Sf(n.y, i.offset.y)), n
}
const h3 = ({
        current: r
    }) => r ? r.ownerDocument.defaultView : null,
    y7 = new WeakMap;
class _7 {
    constructor(e) {
        this.openDragLock = null, this.isDragging = !1, this.currentDirection = null, this.originPoint = {
            x: 0,
            y: 0
        }, this.constraints = !1, this.hasMutatedConstraints = !1, this.elastic = xi(), this.visualElement = e
    }
    start(e, {
        snapToCursor: t = !1
    } = {}) {
        const {
            presenceContext: n
        } = this.visualElement;
        if (n && n.isPresent === !1) return;
        const i = u => {
                const {
                    dragSnapToOrigin: f
                } = this.getProps();
                f ? this.pauseAnimation() : this.stopAnimation(), t && this.snapToCursor(fm(u).point)
            },
            s = (u, f) => {
                const {
                    drag: d,
                    dragPropagation: m,
                    onDragStart: g
                } = this.getProps();
                if (d && !m && (this.openDragLock && this.openDragLock(), this.openDragLock = ZX(d), !this.openDragLock)) return;
                this.isDragging = !0, this.currentDirection = null, this.resolveConstraints(), this.visualElement.projection && (this.visualElement.projection.isAnimationBlocked = !0, this.visualElement.projection.target = void 0), ks(v => {
                    let _ = this.getAxisMotionValue(v).get() || 0;
                    if (Uo.test(_)) {
                        const {
                            projection: A
                        } = this.visualElement;
                        if (A && A.layout) {
                            const S = A.layout.layoutBox[v];
                            S && (_ = Ss(S) * (parseFloat(_) / 100))
                        }
                    }
                    this.originPoint[v] = _
                }), g && Xn.postRender(() => g(u, f)), XA(this.visualElement, "transform");
                const {
                    animationState: y
                } = this.visualElement;
                y && y.setActive("whileDrag", !0)
            },
            o = (u, f) => {
                const {
                    dragPropagation: d,
                    dragDirectionLock: m,
                    onDirectionLock: g,
                    onDrag: y
                } = this.getProps();
                if (!d && !this.openDragLock) return;
                const {
                    offset: v
                } = f;
                if (m && this.currentDirection === null) {
                    this.currentDirection = x7(v), this.currentDirection !== null && g && g(this.currentDirection);
                    return
                }
                this.updateAxis("x", f.point, v), this.updateAxis("y", f.point, v), this.visualElement.render(), y && y(u, f)
            },
            a = (u, f) => this.stop(u, f),
            l = () => ks(u => {
                var f;
                return this.getAnimationState(u) === "paused" && ((f = this.getAxisMotionValue(u).animation) === null || f === void 0 ? void 0 : f.play())
            }),
            {
                dragSnapToOrigin: c
            } = this.getProps();
        this.panSession = new r3(e, {
            onSessionStart: i,
            onStart: s,
            onMove: o,
            onSessionEnd: a,
            resumeAnimation: l
        }, {
            transformPagePoint: this.visualElement.getTransformPagePoint(),
            dragSnapToOrigin: c,
            contextWindow: h3(this.visualElement)
        })
    }
    stop(e, t) {
        const n = this.isDragging;
        if (this.cancel(), !n) return;
        const {
            velocity: i
        } = t;
        this.startAnimation(i);
        const {
            onDragEnd: s
        } = this.getProps();
        s && Xn.postRender(() => s(e, t))
    }
    cancel() {
        this.isDragging = !1;
        const {
            projection: e,
            animationState: t
        } = this.visualElement;
        e && (e.isAnimationBlocked = !1), this.panSession && this.panSession.end(), this.panSession = void 0;
        const {
            dragPropagation: n
        } = this.getProps();
        !n && this.openDragLock && (this.openDragLock(), this.openDragLock = null), t && t.setActive("whileDrag", !1)
    }
    updateAxis(e, t, n) {
        const {
            drag: i
        } = this.getProps();
        if (!n || !v0(e, i, this.currentDirection)) return;
        const s = this.getAxisMotionValue(e);
        let o = this.originPoint[e] + n[e];
        this.constraints && this.constraints[e] && (o = l7(o, this.constraints[e], this.elastic[e])), s.set(o)
    }
    resolveConstraints() {
        var e;
        const {
            dragConstraints: t,
            dragElastic: n
        } = this.getProps(), i = this.visualElement.projection && !this.visualElement.projection.layout ? this.visualElement.projection.measure(!1) : (e = this.visualElement.projection) === null || e === void 0 ? void 0 : e.layout, s = this.constraints;
        t && xf(t) ? this.constraints || (this.constraints = this.resolveRefConstraints()) : t && i ? this.constraints = c7(i.layoutBox, t) : this.constraints = !1, this.elastic = d7(n), s !== this.constraints && i && this.constraints && !this.hasMutatedConstraints && ks(o => {
            this.constraints !== !1 && this.getAxisMotionValue(o) && (this.constraints[o] = h7(i.layoutBox[o], this.constraints[o]))
        })
    }
    resolveRefConstraints() {
        const {
            dragConstraints: e,
            onMeasureDragConstraints: t
        } = this.getProps();
        if (!e || !xf(e)) return !1;
        const n = e.current,
            {
                projection: i
            } = this.visualElement;
        if (!i || !i.layout) return !1;
        const s = v7(n, i.root, this.visualElement.getTransformPagePoint());
        let o = u7(i.layout.layoutBox, s);
        if (t) {
            const a = t(p7(o));
            this.hasMutatedConstraints = !!a, a && (o = l3(a))
        }
        return o
    }
    startAnimation(e) {
        const {
            drag: t,
            dragMomentum: n,
            dragElastic: i,
            dragTransition: s,
            dragSnapToOrigin: o,
            onDragTransitionEnd: a
        } = this.getProps(), l = this.constraints || {}, c = ks(u => {
            if (!v0(u, t, this.currentDirection)) return;
            let f = l && l[u] || {};
            o && (f = {
                min: 0,
                max: 0
            });
            const d = i ? 200 : 1e6,
                m = i ? 40 : 1e7,
                g = {
                    type: "inertia",
                    velocity: n ? e[u] : 0,
                    bounceStiffness: d,
                    bounceDamping: m,
                    timeConstant: 750,
                    restDelta: 1,
                    restSpeed: 10,
                    ...s,
                    ...f
                };
            return this.startAxisValueAnimation(u, g)
        });
        return Promise.all(c).then(a)
    }
    startAxisValueAnimation(e, t) {
        const n = this.getAxisMotionValue(e);
        return XA(this.visualElement, e), n.start(nw(e, n, 0, t, this.visualElement, !1))
    }
    stopAnimation() {
        ks(e => this.getAxisMotionValue(e).stop())
    }
    pauseAnimation() {
        ks(e => {
            var t;
            return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.pause()
        })
    }
    getAnimationState(e) {
        var t;
        return (t = this.getAxisMotionValue(e).animation) === null || t === void 0 ? void 0 : t.state
    }
    getAxisMotionValue(e) {
        const t = `_drag${e.toUpperCase()}`,
            n = this.visualElement.getProps(),
            i = n[t];
        return i || this.visualElement.getValue(e, (n.initial ? n.initial[e] : void 0) || 0)
    }
    snapToCursor(e) {
        ks(t => {
            const {
                drag: n
            } = this.getProps();
            if (!v0(t, n, this.currentDirection)) return;
            const {
                projection: i
            } = this.visualElement, s = this.getAxisMotionValue(t);
            if (i && i.layout) {
                const {
                    min: o,
                    max: a
                } = i.layout.layoutBox[t];
                s.set(e[t] - ai(o, a, .5))
            }
        })
    }
    scalePositionWithinConstraints() {
        if (!this.visualElement.current) return;
        const {
            drag: e,
            dragConstraints: t
        } = this.getProps(), {
            projection: n
        } = this.visualElement;
        if (!xf(t) || !n || !this.constraints) return;
        this.stopAnimation();
        const i = {
            x: 0,
            y: 0
        };
        ks(o => {
            const a = this.getAxisMotionValue(o);
            if (a && this.constraints !== !1) {
                const l = a.get();
                i[o] = f7({
                    min: l,
                    max: l
                }, this.constraints[o])
            }
        });
        const {
            transformTemplate: s
        } = this.visualElement.getProps();
        this.visualElement.current.style.transform = s ? s({}, "") : "none", n.root && n.root.updateScroll(), n.updateLayout(), this.resolveConstraints(), ks(o => {
            if (!v0(o, e, null)) return;
            const a = this.getAxisMotionValue(o),
                {
                    min: l,
                    max: c
                } = this.constraints[o];
            a.set(ai(l, c, i[o]))
        })
    }
    addListeners() {
        if (!this.visualElement.current) return;
        y7.set(this.visualElement, this);
        const e = this.visualElement.current,
            t = $d(e, "pointerdown", l => {
                const {
                    drag: c,
                    dragListener: u = !0
                } = this.getProps();
                c && u && this.start(l)
            }),
            n = () => {
                const {
                    dragConstraints: l
                } = this.getProps();
                xf(l) && l.current && (this.constraints = this.resolveRefConstraints())
            },
            {
                projection: i
            } = this.visualElement,
            s = i.addEventListener("measure", n);
        i && !i.layout && (i.root && i.root.updateScroll(), i.updateLayout()), Xn.read(n);
        const o = Bp(window, "resize", () => this.scalePositionWithinConstraints()),
            a = i.addEventListener("didUpdate", ({
                delta: l,
                hasLayoutChanged: c
            }) => {
                this.isDragging && c && (ks(u => {
                    const f = this.getAxisMotionValue(u);
                    f && (this.originPoint[u] += l[u].translate, f.set(f.get() + l[u].translate))
                }), this.visualElement.render())
            });
        return () => {
            o(), t(), s(), a && a()
        }
    }
    getProps() {
        const e = this.visualElement.getProps(),
            {
                drag: t = !1,
                dragDirectionLock: n = !1,
                dragPropagation: i = !1,
                dragConstraints: s = !1,
                dragElastic: o = JA,
                dragMomentum: a = !0
            } = e;
        return { ...e,
            drag: t,
            dragDirectionLock: n,
            dragPropagation: i,
            dragConstraints: s,
            dragElastic: o,
            dragMomentum: a
        }
    }
}

function v0(r, e, t) {
    return (e === !0 || e === r) && (t === null || t === r)
}

function x7(r, e = 10) {
    let t = null;
    return Math.abs(r.y) > e ? t = "y" : Math.abs(r.x) > e && (t = "x"), t
}
class A7 extends kl {
    constructor(e) {
        super(e), this.removeGroupControls = _s, this.removeListeners = _s, this.controls = new _7(e)
    }
    mount() {
        const {
            dragControls: e
        } = this.node.getProps();
        e && (this.removeGroupControls = e.subscribe(this.controls)), this.removeListeners = this.controls.addListeners() || _s
    }
    unmount() {
        this.removeGroupControls(), this.removeListeners()
    }
}
const KR = r => (e, t) => {
    r && Xn.postRender(() => r(e, t))
};
class S7 extends kl {
    constructor() {
        super(...arguments), this.removePointerDownListener = _s
    }
    onPointerDown(e) {
        this.session = new r3(e, this.createPanHandlers(), {
            transformPagePoint: this.node.getTransformPagePoint(),
            contextWindow: h3(this.node)
        })
    }
    createPanHandlers() {
        const {
            onPanSessionStart: e,
            onPanStart: t,
            onPan: n,
            onPanEnd: i
        } = this.node.getProps();
        return {
            onSessionStart: KR(e),
            onStart: KR(t),
            onMove: n,
            onEnd: (s, o) => {
                delete this.session, i && Xn.postRender(() => i(s, o))
            }
        }
    }
    mount() {
        this.removePointerDownListener = $d(this.node.current, "pointerdown", e => this.onPointerDown(e))
    }
    update() {
        this.session && this.session.updateHandlers(this.createPanHandlers())
    }
    unmount() {
        this.removePointerDownListener(), this.session && this.session.end()
    }
}
const Wy = N.createContext(null);

function M7() {
    const r = N.useContext(Wy);
    if (r === null) return [!0, null];
    const {
        isPresent: e,
        onExitComplete: t,
        register: n
    } = r, i = N.useId();
    N.useEffect(() => n(i), []);
    const s = N.useCallback(() => t && t(i), [i, t]);
    return !e && t ? [!1, s] : [!0]
}
const lw = N.createContext({}),
    d3 = N.createContext({}),
    U0 = {
        hasAnimatedSinceResize: !0,
        hasEverUpdated: !1
    };

function qR(r, e) {
    return e.max === e.min ? 0 : r / (e.max - e.min) * 100
}
const ud = {
        correct: (r, e) => {
            if (!e.target) return r;
            if (typeof r == "string")
                if (kt.test(r)) r = parseFloat(r);
                else return r;
            const t = qR(r, e.target.x),
                n = qR(r, e.target.y);
            return `${t}% ${n}%`
        }
    },
    w7 = {
        correct: (r, {
            treeScale: e,
            projectionDelta: t
        }) => {
            const n = r,
                i = Pl.parse(r);
            if (i.length > 5) return n;
            const s = Pl.createTransformer(r),
                o = typeof i[0] != "number" ? 1 : 0,
                a = t.x.scale * e.x,
                l = t.y.scale * e.y;
            i[0 + o] /= a, i[1 + o] /= l;
            const c = ai(a, l, .5);
            return typeof i[2 + o] == "number" && (i[2 + o] /= c), typeof i[3 + o] == "number" && (i[3 + o] /= c), s(i)
        }
    },
    Wv = {};

function b7(r) {
    Object.assign(Wv, r)
}
const {
    schedule: cw,
    cancel: RQ
} = pL(queueMicrotask, !1);
class T7 extends N.Component {
    componentDidMount() {
        const {
            visualElement: e,
            layoutGroup: t,
            switchLayoutGroup: n,
            layoutId: i
        } = this.props, {
            projection: s
        } = e;
        b7(E7), s && (t.group && t.group.add(s), n && n.register && i && n.register(s), s.root.didUpdate(), s.addEventListener("animationComplete", () => {
            this.safeToRemove()
        }), s.setOptions({ ...s.options,
            onExitComplete: () => this.safeToRemove()
        })), U0.hasEverUpdated = !0
    }
    getSnapshotBeforeUpdate(e) {
        const {
            layoutDependency: t,
            visualElement: n,
            drag: i,
            isPresent: s
        } = this.props, o = n.projection;
        return o && (o.isPresent = s, i || e.layoutDependency !== t || t === void 0 ? o.willUpdate() : this.safeToRemove(), e.isPresent !== s && (s ? o.promote() : o.relegate() || Xn.postRender(() => {
            const a = o.getStack();
            (!a || !a.members.length) && this.safeToRemove()
        }))), null
    }
    componentDidUpdate() {
        const {
            projection: e
        } = this.props.visualElement;
        e && (e.root.didUpdate(), cw.postRender(() => {
            !e.currentAnimation && e.isLead() && this.safeToRemove()
        }))
    }
    componentWillUnmount() {
        const {
            visualElement: e,
            layoutGroup: t,
            switchLayoutGroup: n
        } = this.props, {
            projection: i
        } = e;
        i && (i.scheduleCheckAfterUnmount(), t && t.group && t.group.remove(i), n && n.deregister && n.deregister(i))
    }
    safeToRemove() {
        const {
            safeToRemove: e
        } = this.props;
        e && e()
    }
    render() {
        return null
    }
}

function p3(r) {
    const [e, t] = M7(), n = N.useContext(lw);
    return G.jsx(T7, { ...r,
        layoutGroup: n,
        switchLayoutGroup: N.useContext(d3),
        isPresent: e,
        safeToRemove: t
    })
}
const E7 = {
        borderRadius: { ...ud,
            applyTo: ["borderTopLeftRadius", "borderTopRightRadius", "borderBottomLeftRadius", "borderBottomRightRadius"]
        },
        borderTopLeftRadius: ud,
        borderTopRightRadius: ud,
        borderBottomLeftRadius: ud,
        borderBottomRightRadius: ud,
        boxShadow: w7
    },
    m3 = ["TopLeft", "TopRight", "BottomLeft", "BottomRight"],
    C7 = m3.length,
    ZR = r => typeof r == "string" ? parseFloat(r) : r,
    QR = r => typeof r == "number" || kt.test(r);

function R7(r, e, t, n, i, s) {
    i ? (r.opacity = ai(0, t.opacity !== void 0 ? t.opacity : 1, P7(n)), r.opacityExit = ai(e.opacity !== void 0 ? e.opacity : 1, 0, I7(n))) : s && (r.opacity = ai(e.opacity !== void 0 ? e.opacity : 1, t.opacity !== void 0 ? t.opacity : 1, n));
    for (let o = 0; o < C7; o++) {
        const a = `border${m3[o]}Radius`;
        let l = $R(e, a),
            c = $R(t, a);
        if (l === void 0 && c === void 0) continue;
        l || (l = 0), c || (c = 0), l === 0 || c === 0 || QR(l) === QR(c) ? (r[a] = Math.max(ai(ZR(l), ZR(c), n), 0), (Uo.test(c) || Uo.test(l)) && (r[a] += "%")) : r[a] = c
    }(e.rotate || t.rotate) && (r.rotate = ai(e.rotate || 0, t.rotate || 0, n))
}

function $R(r, e) {
    return r[e] !== void 0 ? r[e] : r.borderRadius
}
const P7 = g3(0, .5, AL),
    I7 = g3(.5, .95, _s);

function g3(r, e, t) {
    return n => n < r ? 0 : n > e ? 1 : t(rh(r, e, n))
}

function e2(r, e) {
    r.min = e.min, r.max = e.max
}

function Os(r, e) {
    e2(r.x, e.x), e2(r.y, e.y)
}

function t2(r, e) {
    r.translate = e.translate, r.scale = e.scale, r.originPoint = e.originPoint, r.origin = e.origin
}

function n2(r, e, t, n, i) {
    return r -= e, r = Vv(r, 1 / t, n), i !== void 0 && (r = Vv(r, 1 / i, n)), r
}

function B7(r, e = 0, t = 1, n = .5, i, s = r, o = r) {
    if (Uo.test(e) && (e = parseFloat(e), e = ai(o.min, o.max, e / 100) - o.min), typeof e != "number") return;
    let a = ai(s.min, s.max, n);
    r === s && (a -= e), r.min = n2(r.min, e, t, a, i), r.max = n2(r.max, e, t, a, i)
}

function i2(r, e, [t, n, i], s, o) {
    B7(r, e[t], e[n], e[i], e.scale, s, o)
}
const D7 = ["x", "scaleX", "originX"],
    L7 = ["y", "scaleY", "originY"];

function r2(r, e, t, n) {
    i2(r.x, e, D7, t ? t.x : void 0, n ? n.x : void 0), i2(r.y, e, L7, t ? t.y : void 0, n ? n.y : void 0)
}

function s2(r) {
    return r.translate === 0 && r.scale === 1
}

function v3(r) {
    return s2(r.x) && s2(r.y)
}

function o2(r, e) {
    return r.min === e.min && r.max === e.max
}

function F7(r, e) {
    return o2(r.x, e.x) && o2(r.y, e.y)
}

function a2(r, e) {
    return Math.round(r.min) === Math.round(e.min) && Math.round(r.max) === Math.round(e.max)
}

function y3(r, e) {
    return a2(r.x, e.x) && a2(r.y, e.y)
}

function l2(r) {
    return Ss(r.x) / Ss(r.y)
}

function c2(r, e) {
    return r.translate === e.translate && r.scale === e.scale && r.originPoint === e.originPoint
}
class U7 {
    constructor() {
        this.members = []
    }
    add(e) {
        iw(this.members, e), e.scheduleRender()
    }
    remove(e) {
        if (rw(this.members, e), e === this.prevLead && (this.prevLead = void 0), e === this.lead) {
            const t = this.members[this.members.length - 1];
            t && this.promote(t)
        }
    }
    relegate(e) {
        const t = this.members.findIndex(i => e === i);
        if (t === 0) return !1;
        let n;
        for (let i = t; i >= 0; i--) {
            const s = this.members[i];
            if (s.isPresent !== !1) {
                n = s;
                break
            }
        }
        return n ? (this.promote(n), !0) : !1
    }
    promote(e, t) {
        const n = this.lead;
        if (e !== n && (this.prevLead = n, this.lead = e, e.show(), n)) {
            n.instance && n.scheduleRender(), e.scheduleRender(), e.resumeFrom = n, t && (e.resumeFrom.preserveOpacity = !0), n.snapshot && (e.snapshot = n.snapshot, e.snapshot.latestValues = n.animationValues || n.latestValues), e.root && e.root.isUpdating && (e.isLayoutDirty = !0);
            const {
                crossfade: i
            } = e.options;
            i === !1 && n.hide()
        }
    }
    exitAnimationComplete() {
        this.members.forEach(e => {
            const {
                options: t,
                resumingFrom: n
            } = e;
            t.onExitComplete && t.onExitComplete(), n && n.options.onExitComplete && n.options.onExitComplete()
        })
    }
    scheduleRender() {
        this.members.forEach(e => {
            e.instance && e.scheduleRender(!1)
        })
    }
    removeLeadSnapshot() {
        this.lead && this.lead.snapshot && (this.lead.snapshot = void 0)
    }
}

function O7(r, e, t) {
    let n = "";
    const i = r.x.translate / e.x,
        s = r.y.translate / e.y,
        o = (t == null ? void 0 : t.z) || 0;
    if ((i || s || o) && (n = `translate3d(${i}px, ${s}px, ${o}px) `), (e.x !== 1 || e.y !== 1) && (n += `scale(${1/e.x}, ${1/e.y}) `), t) {
        const {
            transformPerspective: c,
            rotate: u,
            rotateX: f,
            rotateY: d,
            skewX: m,
            skewY: g
        } = t;
        c && (n = `perspective(${c}px) ${n}`), u && (n += `rotate(${u}deg) `), f && (n += `rotateX(${f}deg) `), d && (n += `rotateY(${d}deg) `), m && (n += `skewX(${m}deg) `), g && (n += `skewY(${g}deg) `)
    }
    const a = r.x.scale * e.x,
        l = r.y.scale * e.y;
    return (a !== 1 || l !== 1) && (n += `scale(${a}, ${l})`), n || "none"
}
const N7 = (r, e) => r.depth - e.depth;
class k7 {
    constructor() {
        this.children = [], this.isDirty = !1
    }
    add(e) {
        iw(this.children, e), this.isDirty = !0
    }
    remove(e) {
        rw(this.children, e), this.isDirty = !0
    }
    forEach(e) {
        this.isDirty && this.children.sort(N7), this.isDirty = !1, this.children.forEach(e)
    }
}

function O0(r) {
    const e = dr(r) ? r.get() : r;
    return MX(e) ? e.toValue() : e
}

function z7(r, e) {
    const t = Oo.now(),
        n = ({
            timestamp: i
        }) => {
            const s = i - t;
            s >= e && (Rl(n), r(s - e))
        };
    return Xn.read(n, !0), () => Rl(n)
}

function G7(r) {
    return r instanceof SVGElement && r.tagName !== "svg"
}

function H7(r, e, t) {
    const n = dr(r) ? r : Ip(r);
    return n.start(nw("", n, e, t)), n.animation
}
const Tc = {
        type: "projectionFrame",
        totalNodes: 0,
        resolvedTargetDeltas: 0,
        recalculatedProjection: 0
    },
    Td = typeof window < "u" && window.MotionDebug !== void 0,
    A1 = ["", "X", "Y", "Z"],
    V7 = {
        visibility: "hidden"
    },
    u2 = 1e3;
let W7 = 0;

function S1(r, e, t, n) {
    const {
        latestValues: i
    } = e;
    i[r] && (t[r] = i[r], e.setStaticValue(r, 0), n && (n[r] = 0))
}

function _3(r) {
    if (r.hasCheckedOptimisedAppear = !0, r.root === r) return;
    const {
        visualElement: e
    } = r.options;
    if (!e) return;
    const t = QL(e);
    if (window.MotionHasOptimisedAnimation(t, "transform")) {
        const {
            layout: i,
            layoutId: s
        } = r.options;
        window.MotionCancelOptimisedAnimation(t, "transform", Xn, !(i || s))
    }
    const {
        parent: n
    } = r;
    n && !n.hasCheckedOptimisedAppear && _3(n)
}

function x3({
    attachResizeListener: r,
    defaultParent: e,
    measureScroll: t,
    checkIsScrollRoot: n,
    resetTransform: i
}) {
    return class {
        constructor(o = {}, a = e == null ? void 0 : e()) {
            this.id = W7++, this.animationId = 0, this.children = new Set, this.options = {}, this.isTreeAnimating = !1, this.isAnimationBlocked = !1, this.isLayoutDirty = !1, this.isProjectionDirty = !1, this.isSharedProjectionDirty = !1, this.isTransformDirty = !1, this.updateManuallyBlocked = !1, this.updateBlockedByResize = !1, this.isUpdating = !1, this.isSVG = !1, this.needsReset = !1, this.shouldResetTransform = !1, this.hasCheckedOptimisedAppear = !1, this.treeScale = {
                x: 1,
                y: 1
            }, this.eventHandlers = new Map, this.hasTreeAnimated = !1, this.updateScheduled = !1, this.scheduleUpdate = () => this.update(), this.projectionUpdateScheduled = !1, this.checkUpdateFailed = () => {
                this.isUpdating && (this.isUpdating = !1, this.clearAllSnapshots())
            }, this.updateProjection = () => {
                this.projectionUpdateScheduled = !1, Td && (Tc.totalNodes = Tc.resolvedTargetDeltas = Tc.recalculatedProjection = 0), this.nodes.forEach(Y7), this.nodes.forEach(Q7), this.nodes.forEach($7), this.nodes.forEach(J7), Td && window.MotionDebug.record(Tc)
            }, this.resolvedRelativeTargetAt = 0, this.hasProjected = !1, this.isVisible = !0, this.animationProgress = 0, this.sharedNodes = new Map, this.latestValues = o, this.root = a ? a.root || a : this, this.path = a ? [...a.path, a] : [], this.parent = a, this.depth = a ? a.depth + 1 : 0;
            for (let l = 0; l < this.path.length; l++) this.path[l].shouldResetTransform = !0;
            this.root === this && (this.nodes = new k7)
        }
        addEventListener(o, a) {
            return this.eventHandlers.has(o) || this.eventHandlers.set(o, new sw), this.eventHandlers.get(o).add(a)
        }
        notifyListeners(o, ...a) {
            const l = this.eventHandlers.get(o);
            l && l.notify(...a)
        }
        hasListeners(o) {
            return this.eventHandlers.has(o)
        }
        mount(o, a = this.root.hasTreeAnimated) {
            if (this.instance) return;
            this.isSVG = G7(o), this.instance = o;
            const {
                layoutId: l,
                layout: c,
                visualElement: u
            } = this.options;
            if (u && !u.current && u.mount(o), this.root.nodes.add(this), this.parent && this.parent.children.add(this), a && (c || l) && (this.isLayoutDirty = !0), r) {
                let f;
                const d = () => this.root.updateBlockedByResize = !1;
                r(o, () => {
                    this.root.updateBlockedByResize = !0, f && f(), f = z7(d, 250), U0.hasAnimatedSinceResize && (U0.hasAnimatedSinceResize = !1, this.nodes.forEach(h2))
                })
            }
            l && this.root.registerSharedNode(l, this), this.options.animate !== !1 && u && (l || c) && this.addEventListener("didUpdate", ({
                delta: f,
                hasLayoutChanged: d,
                hasRelativeTargetChanged: m,
                layout: g
            }) => {
                if (this.isTreeAnimationBlocked()) {
                    this.target = void 0, this.relativeTarget = void 0;
                    return
                }
                const y = this.options.transition || u.getDefaultTransition() || rY,
                    {
                        onLayoutAnimationStart: v,
                        onLayoutAnimationComplete: _
                    } = u.getProps(),
                    A = !this.targetLayout || !y3(this.targetLayout, g) || m,
                    S = !d && m;
                if (this.options.layoutRoot || this.resumeFrom && this.resumeFrom.instance || S || d && (A || !this.currentAnimation)) {
                    this.resumeFrom && (this.resumingFrom = this.resumeFrom, this.resumingFrom.resumingFrom = void 0), this.setAnimationOrigin(f, S);
                    const M = { ...HM(y, "layout"),
                        onPlay: v,
                        onComplete: _
                    };
                    (u.shouldReduceMotion || this.options.layoutRoot) && (M.delay = 0, M.type = !1), this.startAnimation(M)
                } else d || h2(this), this.isLead() && this.options.onExitComplete && this.options.onExitComplete();
                this.targetLayout = g
            })
        }
        unmount() {
            this.options.layoutId && this.willUpdate(), this.root.nodes.remove(this);
            const o = this.getStack();
            o && o.remove(this), this.parent && this.parent.children.delete(this), this.instance = void 0, Rl(this.updateProjection)
        }
        blockUpdate() {
            this.updateManuallyBlocked = !0
        }
        unblockUpdate() {
            this.updateManuallyBlocked = !1
        }
        isUpdateBlocked() {
            return this.updateManuallyBlocked || this.updateBlockedByResize
        }
        isTreeAnimationBlocked() {
            return this.isAnimationBlocked || this.parent && this.parent.isTreeAnimationBlocked() || !1
        }
        startUpdate() {
            this.isUpdateBlocked() || (this.isUpdating = !0, this.nodes && this.nodes.forEach(eY), this.animationId++)
        }
        getTransformTemplate() {
            const {
                visualElement: o
            } = this.options;
            return o && o.getProps().transformTemplate
        }
        willUpdate(o = !0) {
            if (this.root.hasTreeAnimated = !0, this.root.isUpdateBlocked()) {
                this.options.onExitComplete && this.options.onExitComplete();
                return
            }
            if (window.MotionCancelOptimisedAnimation && !this.hasCheckedOptimisedAppear && _3(this), !this.root.isUpdating && this.root.startUpdate(), this.isLayoutDirty) return;
            this.isLayoutDirty = !0;
            for (let u = 0; u < this.path.length; u++) {
                const f = this.path[u];
                f.shouldResetTransform = !0, f.updateScroll("snapshot"), f.options.layoutRoot && f.willUpdate(!1)
            }
            const {
                layoutId: a,
                layout: l
            } = this.options;
            if (a === void 0 && !l) return;
            const c = this.getTransformTemplate();
            this.prevTransformTemplateValue = c ? c(this.latestValues, "") : void 0, this.updateSnapshot(), o && this.notifyListeners("willUpdate")
        }
        update() {
            if (this.updateScheduled = !1, this.isUpdateBlocked()) {
                this.unblockUpdate(), this.clearAllSnapshots(), this.nodes.forEach(f2);
                return
            }
            this.isUpdating || this.nodes.forEach(q7), this.isUpdating = !1, this.nodes.forEach(Z7), this.nodes.forEach(j7), this.nodes.forEach(X7), this.clearAllSnapshots();
            const a = Oo.now();
            qi.delta = Ea(0, 1e3 / 60, a - qi.timestamp), qi.timestamp = a, qi.isProcessing = !0, h1.update.process(qi), h1.preRender.process(qi), h1.render.process(qi), qi.isProcessing = !1
        }
        didUpdate() {
            this.updateScheduled || (this.updateScheduled = !0, cw.read(this.scheduleUpdate))
        }
        clearAllSnapshots() {
            this.nodes.forEach(K7), this.sharedNodes.forEach(tY)
        }
        scheduleUpdateProjection() {
            this.projectionUpdateScheduled || (this.projectionUpdateScheduled = !0, Xn.preRender(this.updateProjection, !1, !0))
        }
        scheduleCheckAfterUnmount() {
            Xn.postRender(() => {
                this.isLayoutDirty ? this.root.didUpdate() : this.root.checkUpdateFailed()
            })
        }
        updateSnapshot() {
            this.snapshot || !this.instance || (this.snapshot = this.measure())
        }
        updateLayout() {
            if (!this.instance || (this.updateScroll(), !(this.options.alwaysMeasureLayout && this.isLead()) && !this.isLayoutDirty)) return;
            if (this.resumeFrom && !this.resumeFrom.instance)
                for (let l = 0; l < this.path.length; l++) this.path[l].updateScroll();
            const o = this.layout;
            this.layout = this.measure(!1), this.layoutCorrected = xi(), this.isLayoutDirty = !1, this.projectionDelta = void 0, this.notifyListeners("measure", this.layout.layoutBox);
            const {
                visualElement: a
            } = this.options;
            a && a.notify("LayoutMeasure", this.layout.layoutBox, o ? o.layoutBox : void 0)
        }
        updateScroll(o = "measure") {
            let a = !!(this.options.layoutScroll && this.instance);
            if (this.scroll && this.scroll.animationId === this.root.animationId && this.scroll.phase === o && (a = !1), a) {
                const l = n(this.instance);
                this.scroll = {
                    animationId: this.root.animationId,
                    phase: o,
                    isRoot: l,
                    offset: t(this.instance),
                    wasRoot: this.scroll ? this.scroll.isRoot : l
                }
            }
        }
        resetTransform() {
            if (!i) return;
            const o = this.isLayoutDirty || this.shouldResetTransform || this.options.alwaysMeasureLayout,
                a = this.projectionDelta && !v3(this.projectionDelta),
                l = this.getTransformTemplate(),
                c = l ? l(this.latestValues, "") : void 0,
                u = c !== this.prevTransformTemplateValue;
            o && (a || bc(this.latestValues) || u) && (i(this.instance, c), this.shouldResetTransform = !1, this.scheduleRender())
        }
        measure(o = !0) {
            const a = this.measurePageBox();
            let l = this.removeElementScroll(a);
            return o && (l = this.removeTransform(l)), sY(l), {
                animationId: this.root.animationId,
                measuredBox: a,
                layoutBox: l,
                latestValues: {},
                source: this.id
            }
        }
        measurePageBox() {
            var o;
            const {
                visualElement: a
            } = this.options;
            if (!a) return xi();
            const l = a.measureViewportBox();
            if (!(((o = this.scroll) === null || o === void 0 ? void 0 : o.wasRoot) || this.path.some(oY))) {
                const {
                    scroll: u
                } = this.root;
                u && (Sf(l.x, u.offset.x), Sf(l.y, u.offset.y))
            }
            return l
        }
        removeElementScroll(o) {
            var a;
            const l = xi();
            if (Os(l, o), !((a = this.scroll) === null || a === void 0) && a.wasRoot) return l;
            for (let c = 0; c < this.path.length; c++) {
                const u = this.path[c],
                    {
                        scroll: f,
                        options: d
                    } = u;
                u !== this.root && f && d.layoutScroll && (f.wasRoot && Os(l, o), Sf(l.x, f.offset.x), Sf(l.y, f.offset.y))
            }
            return l
        }
        applyTransform(o, a = !1) {
            const l = xi();
            Os(l, o);
            for (let c = 0; c < this.path.length; c++) {
                const u = this.path[c];
                !a && u.options.layoutScroll && u.scroll && u !== u.root && Mf(l, {
                    x: -u.scroll.offset.x,
                    y: -u.scroll.offset.y
                }), bc(u.latestValues) && Mf(l, u.latestValues)
            }
            return bc(this.latestValues) && Mf(l, this.latestValues), l
        }
        removeTransform(o) {
            const a = xi();
            Os(a, o);
            for (let l = 0; l < this.path.length; l++) {
                const c = this.path[l];
                if (!c.instance || !bc(c.latestValues)) continue;
                KA(c.latestValues) && c.updateSnapshot();
                const u = xi(),
                    f = c.measurePageBox();
                Os(u, f), r2(a, c.latestValues, c.snapshot ? c.snapshot.layoutBox : void 0, u)
            }
            return bc(this.latestValues) && r2(a, this.latestValues), a
        }
        setTargetDelta(o) {
            this.targetDelta = o, this.root.scheduleUpdateProjection(), this.isProjectionDirty = !0
        }
        setOptions(o) {
            this.options = { ...this.options,
                ...o,
                crossfade: o.crossfade !== void 0 ? o.crossfade : !0
            }
        }
        clearMeasurements() {
            this.scroll = void 0, this.layout = void 0, this.snapshot = void 0, this.prevTransformTemplateValue = void 0, this.targetDelta = void 0, this.target = void 0, this.isLayoutDirty = !1
        }
        forceRelativeParentToResolveTarget() {
            this.relativeParent && this.relativeParent.resolvedRelativeTargetAt !== qi.timestamp && this.relativeParent.resolveTargetDelta(!0)
        }
        resolveTargetDelta(o = !1) {
            var a;
            const l = this.getLead();
            this.isProjectionDirty || (this.isProjectionDirty = l.isProjectionDirty), this.isTransformDirty || (this.isTransformDirty = l.isTransformDirty), this.isSharedProjectionDirty || (this.isSharedProjectionDirty = l.isSharedProjectionDirty);
            const c = !!this.resumingFrom || this !== l;
            if (!(o || c && this.isSharedProjectionDirty || this.isProjectionDirty || !((a = this.parent) === null || a === void 0) && a.isProjectionDirty || this.attemptToResolveRelativeTarget || this.root.updateBlockedByResize)) return;
            const {
                layout: f,
                layoutId: d
            } = this.options;
            if (!(!this.layout || !(f || d))) {
                if (this.resolvedRelativeTargetAt = qi.timestamp, !this.targetDelta && !this.relativeTarget) {
                    const m = this.getClosestProjectingParent();
                    m && m.layout && this.animationProgress !== 1 ? (this.relativeParent = m, this.forceRelativeParentToResolveTarget(), this.relativeTarget = xi(), this.relativeTargetOrigin = xi(), tp(this.relativeTargetOrigin, this.layout.layoutBox, m.layout.layoutBox), Os(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                }
                if (!(!this.relativeTarget && !this.targetDelta)) {
                    if (this.target || (this.target = xi(), this.targetWithTransforms = xi()), this.relativeTarget && this.relativeTargetOrigin && this.relativeParent && this.relativeParent.target ? (this.forceRelativeParentToResolveTarget(), a7(this.target, this.relativeTarget, this.relativeParent.target)) : this.targetDelta ? (this.resumingFrom ? this.target = this.applyTransform(this.layout.layoutBox) : Os(this.target, this.layout.layoutBox), u3(this.target, this.targetDelta)) : Os(this.target, this.layout.layoutBox), this.attemptToResolveRelativeTarget) {
                        this.attemptToResolveRelativeTarget = !1;
                        const m = this.getClosestProjectingParent();
                        m && !!m.resumingFrom == !!this.resumingFrom && !m.options.layoutScroll && m.target && this.animationProgress !== 1 ? (this.relativeParent = m, this.forceRelativeParentToResolveTarget(), this.relativeTarget = xi(), this.relativeTargetOrigin = xi(), tp(this.relativeTargetOrigin, this.target, m.target), Os(this.relativeTarget, this.relativeTargetOrigin)) : this.relativeParent = this.relativeTarget = void 0
                    }
                    Td && Tc.resolvedTargetDeltas++
                }
            }
        }
        getClosestProjectingParent() {
            if (!(!this.parent || KA(this.parent.latestValues) || c3(this.parent.latestValues))) return this.parent.isProjecting() ? this.parent : this.parent.getClosestProjectingParent()
        }
        isProjecting() {
            return !!((this.relativeTarget || this.targetDelta || this.options.layoutRoot) && this.layout)
        }
        calcProjection() {
            var o;
            const a = this.getLead(),
                l = !!this.resumingFrom || this !== a;
            let c = !0;
            if ((this.isProjectionDirty || !((o = this.parent) === null || o === void 0) && o.isProjectionDirty) && (c = !1), l && (this.isSharedProjectionDirty || this.isTransformDirty) && (c = !1), this.resolvedRelativeTargetAt === qi.timestamp && (c = !1), c) return;
            const {
                layout: u,
                layoutId: f
            } = this.options;
            if (this.isTreeAnimating = !!(this.parent && this.parent.isTreeAnimating || this.currentAnimation || this.pendingAnimation), this.isTreeAnimating || (this.targetDelta = this.relativeTarget = void 0), !this.layout || !(u || f)) return;
            Os(this.layoutCorrected, this.layout.layoutBox);
            const d = this.treeScale.x,
                m = this.treeScale.y;
            g7(this.layoutCorrected, this.treeScale, this.path, l), a.layout && !a.target && (this.treeScale.x !== 1 || this.treeScale.y !== 1) && (a.target = a.layout.layoutBox, a.targetWithTransforms = xi());
            const {
                target: g
            } = a;
            if (!g) {
                this.prevProjectionDelta && (this.createProjectionDeltas(), this.scheduleRender());
                return
            }!this.projectionDelta || !this.prevProjectionDelta ? this.createProjectionDeltas() : (t2(this.prevProjectionDelta.x, this.projectionDelta.x), t2(this.prevProjectionDelta.y, this.projectionDelta.y)), ep(this.projectionDelta, this.layoutCorrected, g, this.latestValues), (this.treeScale.x !== d || this.treeScale.y !== m || !c2(this.projectionDelta.x, this.prevProjectionDelta.x) || !c2(this.projectionDelta.y, this.prevProjectionDelta.y)) && (this.hasProjected = !0, this.scheduleRender(), this.notifyListeners("projectionUpdate", g)), Td && Tc.recalculatedProjection++
        }
        hide() {
            this.isVisible = !1
        }
        show() {
            this.isVisible = !0
        }
        scheduleRender(o = !0) {
            var a;
            if ((a = this.options.visualElement) === null || a === void 0 || a.scheduleRender(), o) {
                const l = this.getStack();
                l && l.scheduleRender()
            }
            this.resumingFrom && !this.resumingFrom.instance && (this.resumingFrom = void 0)
        }
        createProjectionDeltas() {
            this.prevProjectionDelta = Af(), this.projectionDelta = Af(), this.projectionDeltaWithTransform = Af()
        }
        setAnimationOrigin(o, a = !1) {
            const l = this.snapshot,
                c = l ? l.latestValues : {},
                u = { ...this.latestValues
                },
                f = Af();
            (!this.relativeParent || !this.relativeParent.options.layoutRoot) && (this.relativeTarget = this.relativeTargetOrigin = void 0), this.attemptToResolveRelativeTarget = !a;
            const d = xi(),
                m = l ? l.source : void 0,
                g = this.layout ? this.layout.source : void 0,
                y = m !== g,
                v = this.getStack(),
                _ = !v || v.members.length <= 1,
                A = !!(y && !_ && this.options.crossfade === !0 && !this.path.some(iY));
            this.animationProgress = 0;
            let S;
            this.mixTargetDelta = M => {
                const C = M / 1e3;
                d2(f.x, o.x, C), d2(f.y, o.y, C), this.setTargetDelta(f), this.relativeTarget && this.relativeTargetOrigin && this.layout && this.relativeParent && this.relativeParent.layout && (tp(d, this.layout.layoutBox, this.relativeParent.layout.layoutBox), nY(this.relativeTarget, this.relativeTargetOrigin, d, C), S && F7(this.relativeTarget, S) && (this.isProjectionDirty = !1), S || (S = xi()), Os(S, this.relativeTarget)), y && (this.animationValues = u, R7(u, c, this.latestValues, C, A, _)), this.root.scheduleUpdateProjection(), this.scheduleRender(), this.animationProgress = C
            }, this.mixTargetDelta(this.options.layoutRoot ? 1e3 : 0)
        }
        startAnimation(o) {
            this.notifyListeners("animationStart"), this.currentAnimation && this.currentAnimation.stop(), this.resumingFrom && this.resumingFrom.currentAnimation && this.resumingFrom.currentAnimation.stop(), this.pendingAnimation && (Rl(this.pendingAnimation), this.pendingAnimation = void 0), this.pendingAnimation = Xn.update(() => {
                U0.hasAnimatedSinceResize = !0, this.currentAnimation = H7(0, u2, { ...o,
                    onUpdate: a => {
                        this.mixTargetDelta(a), o.onUpdate && o.onUpdate(a)
                    },
                    onComplete: () => {
                        o.onComplete && o.onComplete(), this.completeAnimation()
                    }
                }), this.resumingFrom && (this.resumingFrom.currentAnimation = this.currentAnimation), this.pendingAnimation = void 0
            })
        }
        completeAnimation() {
            this.resumingFrom && (this.resumingFrom.currentAnimation = void 0, this.resumingFrom.preserveOpacity = void 0);
            const o = this.getStack();
            o && o.exitAnimationComplete(), this.resumingFrom = this.currentAnimation = this.animationValues = void 0, this.notifyListeners("animationComplete")
        }
        finishAnimation() {
            this.currentAnimation && (this.mixTargetDelta && this.mixTargetDelta(u2), this.currentAnimation.stop()), this.completeAnimation()
        }
        applyTransformsToTarget() {
            const o = this.getLead();
            let {
                targetWithTransforms: a,
                target: l,
                layout: c,
                latestValues: u
            } = o;
            if (!(!a || !l || !c)) {
                if (this !== o && this.layout && c && A3(this.options.animationType, this.layout.layoutBox, c.layoutBox)) {
                    l = this.target || xi();
                    const f = Ss(this.layout.layoutBox.x);
                    l.x.min = o.target.x.min, l.x.max = l.x.min + f;
                    const d = Ss(this.layout.layoutBox.y);
                    l.y.min = o.target.y.min, l.y.max = l.y.min + d
                }
                Os(a, l), Mf(a, u), ep(this.projectionDeltaWithTransform, this.layoutCorrected, a, u)
            }
        }
        registerSharedNode(o, a) {
            this.sharedNodes.has(o) || this.sharedNodes.set(o, new U7), this.sharedNodes.get(o).add(a);
            const c = a.options.initialPromotionConfig;
            a.promote({
                transition: c ? c.transition : void 0,
                preserveFollowOpacity: c && c.shouldPreserveFollowOpacity ? c.shouldPreserveFollowOpacity(a) : void 0
            })
        }
        isLead() {
            const o = this.getStack();
            return o ? o.lead === this : !0
        }
        getLead() {
            var o;
            const {
                layoutId: a
            } = this.options;
            return a ? ((o = this.getStack()) === null || o === void 0 ? void 0 : o.lead) || this : this
        }
        getPrevLead() {
            var o;
            const {
                layoutId: a
            } = this.options;
            return a ? (o = this.getStack()) === null || o === void 0 ? void 0 : o.prevLead : void 0
        }
        getStack() {
            const {
                layoutId: o
            } = this.options;
            if (o) return this.root.sharedNodes.get(o)
        }
        promote({
            needsReset: o,
            transition: a,
            preserveFollowOpacity: l
        } = {}) {
            const c = this.getStack();
            c && c.promote(this, l), o && (this.projectionDelta = void 0, this.needsReset = !0), a && this.setOptions({
                transition: a
            })
        }
        relegate() {
            const o = this.getStack();
            return o ? o.relegate(this) : !1
        }
        resetSkewAndRotation() {
            const {
                visualElement: o
            } = this.options;
            if (!o) return;
            let a = !1;
            const {
                latestValues: l
            } = o;
            if ((l.z || l.rotate || l.rotateX || l.rotateY || l.rotateZ || l.skewX || l.skewY) && (a = !0), !a) return;
            const c = {};
            l.z && S1("z", o, c, this.animationValues);
            for (let u = 0; u < A1.length; u++) S1(`rotate${A1[u]}`, o, c, this.animationValues), S1(`skew${A1[u]}`, o, c, this.animationValues);
            o.render();
            for (const u in c) o.setStaticValue(u, c[u]), this.animationValues && (this.animationValues[u] = c[u]);
            o.scheduleRender()
        }
        getProjectionStyles(o) {
            var a, l;
            if (!this.instance || this.isSVG) return;
            if (!this.isVisible) return V7;
            const c = {
                    visibility: ""
                },
                u = this.getTransformTemplate();
            if (this.needsReset) return this.needsReset = !1, c.opacity = "", c.pointerEvents = O0(o == null ? void 0 : o.pointerEvents) || "", c.transform = u ? u(this.latestValues, "") : "none", c;
            const f = this.getLead();
            if (!this.projectionDelta || !this.layout || !f.target) {
                const y = {};
                return this.options.layoutId && (y.opacity = this.latestValues.opacity !== void 0 ? this.latestValues.opacity : 1, y.pointerEvents = O0(o == null ? void 0 : o.pointerEvents) || ""), this.hasProjected && !bc(this.latestValues) && (y.transform = u ? u({}, "") : "none", this.hasProjected = !1), y
            }
            const d = f.animationValues || f.latestValues;
            this.applyTransformsToTarget(), c.transform = O7(this.projectionDeltaWithTransform, this.treeScale, d), u && (c.transform = u(d, c.transform));
            const {
                x: m,
                y: g
            } = this.projectionDelta;
            c.transformOrigin = `${m.origin*100}% ${g.origin*100}% 0`, f.animationValues ? c.opacity = f === this ? (l = (a = d.opacity) !== null && a !== void 0 ? a : this.latestValues.opacity) !== null && l !== void 0 ? l : 1 : this.preserveOpacity ? this.latestValues.opacity : d.opacityExit : c.opacity = f === this ? d.opacity !== void 0 ? d.opacity : "" : d.opacityExit !== void 0 ? d.opacityExit : 0;
            for (const y in Wv) {
                if (d[y] === void 0) continue;
                const {
                    correct: v,
                    applyTo: _
                } = Wv[y], A = c.transform === "none" ? d[y] : v(d[y], f);
                if (_) {
                    const S = _.length;
                    for (let M = 0; M < S; M++) c[_[M]] = A
                } else c[y] = A
            }
            return this.options.layoutId && (c.pointerEvents = f === this ? O0(o == null ? void 0 : o.pointerEvents) || "" : "none"), c
        }
        clearSnapshot() {
            this.resumeFrom = this.snapshot = void 0
        }
        resetTree() {
            this.root.nodes.forEach(o => {
                var a;
                return (a = o.currentAnimation) === null || a === void 0 ? void 0 : a.stop()
            }), this.root.nodes.forEach(f2), this.root.sharedNodes.clear()
        }
    }
}

function j7(r) {
    r.updateLayout()
}

function X7(r) {
    var e;
    const t = ((e = r.resumeFrom) === null || e === void 0 ? void 0 : e.snapshot) || r.snapshot;
    if (r.isLead() && r.layout && t && r.hasListeners("didUpdate")) {
        const {
            layoutBox: n,
            measuredBox: i
        } = r.layout, {
            animationType: s
        } = r.options, o = t.source !== r.layout.source;
        s === "size" ? ks(f => {
            const d = o ? t.measuredBox[f] : t.layoutBox[f],
                m = Ss(d);
            d.min = n[f].min, d.max = d.min + m
        }) : A3(s, t.layoutBox, n) && ks(f => {
            const d = o ? t.measuredBox[f] : t.layoutBox[f],
                m = Ss(n[f]);
            d.max = d.min + m, r.relativeTarget && !r.currentAnimation && (r.isProjectionDirty = !0, r.relativeTarget[f].max = r.relativeTarget[f].min + m)
        });
        const a = Af();
        ep(a, n, t.layoutBox);
        const l = Af();
        o ? ep(l, r.applyTransform(i, !0), t.measuredBox) : ep(l, n, t.layoutBox);
        const c = !v3(a);
        let u = !1;
        if (!r.resumeFrom) {
            const f = r.getClosestProjectingParent();
            if (f && !f.resumeFrom) {
                const {
                    snapshot: d,
                    layout: m
                } = f;
                if (d && m) {
                    const g = xi();
                    tp(g, t.layoutBox, d.layoutBox);
                    const y = xi();
                    tp(y, n, m.layoutBox), y3(g, y) || (u = !0), f.options.layoutRoot && (r.relativeTarget = y, r.relativeTargetOrigin = g, r.relativeParent = f)
                }
            }
        }
        r.notifyListeners("didUpdate", {
            layout: n,
            snapshot: t,
            delta: l,
            layoutDelta: a,
            hasLayoutChanged: c,
            hasRelativeTargetChanged: u
        })
    } else if (r.isLead()) {
        const {
            onExitComplete: n
        } = r.options;
        n && n()
    }
    r.options.transition = void 0
}

function Y7(r) {
    Td && Tc.totalNodes++, r.parent && (r.isProjecting() || (r.isProjectionDirty = r.parent.isProjectionDirty), r.isSharedProjectionDirty || (r.isSharedProjectionDirty = !!(r.isProjectionDirty || r.parent.isProjectionDirty || r.parent.isSharedProjectionDirty)), r.isTransformDirty || (r.isTransformDirty = r.parent.isTransformDirty))
}

function J7(r) {
    r.isProjectionDirty = r.isSharedProjectionDirty = r.isTransformDirty = !1
}

function K7(r) {
    r.clearSnapshot()
}

function f2(r) {
    r.clearMeasurements()
}

function q7(r) {
    r.isLayoutDirty = !1
}

function Z7(r) {
    const {
        visualElement: e
    } = r.options;
    e && e.getProps().onBeforeLayoutMeasure && e.notify("BeforeLayoutMeasure"), r.resetTransform()
}

function h2(r) {
    r.finishAnimation(), r.targetDelta = r.relativeTarget = r.target = void 0, r.isProjectionDirty = !0
}

function Q7(r) {
    r.resolveTargetDelta()
}

function $7(r) {
    r.calcProjection()
}

function eY(r) {
    r.resetSkewAndRotation()
}

function tY(r) {
    r.removeLeadSnapshot()
}

function d2(r, e, t) {
    r.translate = ai(e.translate, 0, t), r.scale = ai(e.scale, 1, t), r.origin = e.origin, r.originPoint = e.originPoint
}

function p2(r, e, t, n) {
    r.min = ai(e.min, t.min, n), r.max = ai(e.max, t.max, n)
}

function nY(r, e, t, n) {
    p2(r.x, e.x, t.x, n), p2(r.y, e.y, t.y, n)
}

function iY(r) {
    return r.animationValues && r.animationValues.opacityExit !== void 0
}
const rY = {
        duration: .45,
        ease: [.4, 0, .1, 1]
    },
    m2 = r => typeof navigator < "u" && navigator.userAgent && navigator.userAgent.toLowerCase().includes(r),
    g2 = m2("applewebkit/") && !m2("chrome/") ? Math.round : _s;

function v2(r) {
    r.min = g2(r.min), r.max = g2(r.max)
}

function sY(r) {
    v2(r.x), v2(r.y)
}

function A3(r, e, t) {
    return r === "position" || r === "preserve-aspect" && !o7(l2(e), l2(t), .2)
}

function oY(r) {
    var e;
    return r !== r.root && ((e = r.scroll) === null || e === void 0 ? void 0 : e.wasRoot)
}
const aY = x3({
        attachResizeListener: (r, e) => Bp(r, "resize", e),
        measureScroll: () => ({
            x: document.documentElement.scrollLeft || document.body.scrollLeft,
            y: document.documentElement.scrollTop || document.body.scrollTop
        }),
        checkIsScrollRoot: () => !0
    }),
    M1 = {
        current: void 0
    },
    S3 = x3({
        measureScroll: r => ({
            x: r.scrollLeft,
            y: r.scrollTop
        }),
        defaultParent: () => {
            if (!M1.current) {
                const r = new aY({});
                r.mount(window), r.setOptions({
                    layoutScroll: !0
                }), M1.current = r
            }
            return M1.current
        },
        resetTransform: (r, e) => {
            r.style.transform = e !== void 0 ? e : "none"
        },
        checkIsScrollRoot: r => window.getComputedStyle(r).position === "fixed"
    }),
    lY = {
        pan: {
            Feature: S7
        },
        drag: {
            Feature: A7,
            ProjectionNode: S3,
            MeasureLayout: p3
        }
    };

function y2(r, e, t) {
    const {
        props: n
    } = r;
    r.animationState && n.whileHover && r.animationState.setActive("whileHover", t === "Start");
    const i = "onHover" + t,
        s = n[i];
    s && Xn.postRender(() => s(e, fm(e)))
}
class cY extends kl {
    mount() {
        const {
            current: e
        } = this.node;
        e && (this.unmount = XX(e, t => (y2(this.node, t, "Start"), n => y2(this.node, n, "End"))))
    }
    unmount() {}
}
class uY extends kl {
    constructor() {
        super(...arguments), this.isActive = !1
    }
    onFocus() {
        let e = !1;
        try {
            e = this.node.current.matches(":focus-visible")
        } catch {
            e = !0
        }!e || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !0), this.isActive = !0)
    }
    onBlur() {
        !this.isActive || !this.node.animationState || (this.node.animationState.setActive("whileFocus", !1), this.isActive = !1)
    }
    mount() {
        this.unmount = um(Bp(this.node.current, "focus", () => this.onFocus()), Bp(this.node.current, "blur", () => this.onBlur()))
    }
    unmount() {}
}

function _2(r, e, t) {
    const {
        props: n
    } = r;
    r.animationState && n.whileTap && r.animationState.setActive("whileTap", t === "Start");
    const i = "onTap" + (t === "End" ? "" : t),
        s = n[i];
    s && Xn.postRender(() => s(e, fm(e)))
}
class fY extends kl {
    mount() {
        const {
            current: e
        } = this.node;
        e && (this.unmount = qX(e, t => (_2(this.node, t, "Start"), (n, {
            success: i
        }) => _2(this.node, n, i ? "End" : "Cancel")), {
            useGlobalTarget: this.node.props.globalTapTarget
        }))
    }
    unmount() {}
}
const ZA = new WeakMap,
    w1 = new WeakMap,
    hY = r => {
        const e = ZA.get(r.target);
        e && e(r)
    },
    dY = r => {
        r.forEach(hY)
    };

function pY({
    root: r,
    ...e
}) {
    const t = r || document;
    w1.has(t) || w1.set(t, {});
    const n = w1.get(t),
        i = JSON.stringify(e);
    return n[i] || (n[i] = new IntersectionObserver(dY, {
        root: r,
        ...e
    })), n[i]
}

function mY(r, e, t) {
    const n = pY(e);
    return ZA.set(r, t), n.observe(r), () => {
        ZA.delete(r), n.unobserve(r)
    }
}
const gY = {
    some: 0,
    all: 1
};
class vY extends kl {
    constructor() {
        super(...arguments), this.hasEnteredView = !1, this.isInView = !1
    }
    startObserver() {
        this.unmount();
        const {
            viewport: e = {}
        } = this.node.getProps(), {
            root: t,
            margin: n,
            amount: i = "some",
            once: s
        } = e, o = {
            root: t ? t.current : void 0,
            rootMargin: n,
            threshold: typeof i == "number" ? i : gY[i]
        }, a = l => {
            const {
                isIntersecting: c
            } = l;
            if (this.isInView === c || (this.isInView = c, s && !c && this.hasEnteredView)) return;
            c && (this.hasEnteredView = !0), this.node.animationState && this.node.animationState.setActive("whileInView", c);
            const {
                onViewportEnter: u,
                onViewportLeave: f
            } = this.node.getProps(), d = c ? u : f;
            d && d(l)
        };
        return mY(this.node.current, o, a)
    }
    mount() {
        this.startObserver()
    }
    update() {
        if (typeof IntersectionObserver > "u") return;
        const {
            props: e,
            prevProps: t
        } = this.node;
        ["amount", "margin", "root"].some(yY(e, t)) && this.startObserver()
    }
    unmount() {}
}

function yY({
    viewport: r = {}
}, {
    viewport: e = {}
} = {}) {
    return t => r[t] !== e[t]
}
const _Y = {
        inView: {
            Feature: vY
        },
        tap: {
            Feature: fY
        },
        focus: {
            Feature: uY
        },
        hover: {
            Feature: cY
        }
    },
    xY = {
        layout: {
            ProjectionNode: S3,
            MeasureLayout: p3
        }
    },
    uw = N.createContext({
        transformPagePoint: r => r,
        isStatic: !1,
        reducedMotion: "never"
    }),
    jy = N.createContext({}),
    fw = typeof window < "u",
    M3 = fw ? N.useLayoutEffect : N.useEffect,
    w3 = N.createContext({
        strict: !1
    });

function AY(r, e, t, n, i) {
    var s, o;
    const {
        visualElement: a
    } = N.useContext(jy), l = N.useContext(w3), c = N.useContext(Wy), u = N.useContext(uw).reducedMotion, f = N.useRef(null);
    n = n || l.renderer, !f.current && n && (f.current = n(r, {
        visualState: e,
        parent: a,
        props: t,
        presenceContext: c,
        blockInitialAnimation: c ? c.initial === !1 : !1,
        reducedMotionConfig: u
    }));
    const d = f.current,
        m = N.useContext(d3);
    d && !d.projection && i && (d.type === "html" || d.type === "svg") && SY(f.current, t, i, m);
    const g = N.useRef(!1);
    N.useInsertionEffect(() => {
        d && g.current && d.update(t, c)
    });
    const y = t[ZL],
        v = N.useRef(!!y && !(!((s = window.MotionHandoffIsComplete) === null || s === void 0) && s.call(window, y)) && ((o = window.MotionHasOptimisedAnimation) === null || o === void 0 ? void 0 : o.call(window, y)));
    return M3(() => {
        d && (g.current = !0, window.MotionIsMounted = !0, d.updateFeatures(), cw.render(d.render), v.current && d.animationState && d.animationState.animateChanges())
    }), N.useEffect(() => {
        d && (!v.current && d.animationState && d.animationState.animateChanges(), v.current && (queueMicrotask(() => {
            var _;
            (_ = window.MotionHandoffMarkAsComplete) === null || _ === void 0 || _.call(window, y)
        }), v.current = !1))
    }), d
}

function SY(r, e, t, n) {
    const {
        layoutId: i,
        layout: s,
        drag: o,
        dragConstraints: a,
        layoutScroll: l,
        layoutRoot: c
    } = e;
    r.projection = new t(r.latestValues, e["data-framer-portal-id"] ? void 0 : b3(r.parent)), r.projection.setOptions({
        layoutId: i,
        layout: s,
        alwaysMeasureLayout: !!o || a && xf(a),
        visualElement: r,
        animationType: typeof s == "string" ? s : "both",
        initialPromotionConfig: n,
        layoutScroll: l,
        layoutRoot: c
    })
}

function b3(r) {
    if (r) return r.options.allowProjection !== !1 ? r.projection : b3(r.parent)
}

function MY(r, e, t) {
    return N.useCallback(n => {
        n && r.mount && r.mount(n), e && (n ? e.mount(n) : e.unmount()), t && (typeof t == "function" ? t(n) : xf(t) && (t.current = n))
    }, [e])
}

function Xy(r) {
    return Gy(r.animate) || GM.some(e => Cp(r[e]))
}

function T3(r) {
    return !!(Xy(r) || r.variants)
}

function wY(r, e) {
    if (Xy(r)) {
        const {
            initial: t,
            animate: n
        } = r;
        return {
            initial: t === !1 || Cp(t) ? t : void 0,
            animate: Cp(n) ? n : void 0
        }
    }
    return r.inherit !== !1 ? e : {}
}

function bY(r) {
    const {
        initial: e,
        animate: t
    } = wY(r, N.useContext(jy));
    return N.useMemo(() => ({
        initial: e,
        animate: t
    }), [x2(e), x2(t)])
}

function x2(r) {
    return Array.isArray(r) ? r.join(" ") : r
}
const A2 = {
        animation: ["animate", "variants", "whileHover", "whileTap", "exit", "whileInView", "whileFocus", "whileDrag"],
        exit: ["exit"],
        drag: ["drag", "dragControls"],
        focus: ["whileFocus"],
        hover: ["whileHover", "onHoverStart", "onHoverEnd"],
        tap: ["whileTap", "onTap", "onTapStart", "onTapCancel"],
        pan: ["onPan", "onPanStart", "onPanSessionStart", "onPanEnd"],
        inView: ["whileInView", "onViewportEnter", "onViewportLeave"],
        layout: ["layout", "layoutId"]
    },
    sh = {};
for (const r in A2) sh[r] = {
    isEnabled: e => A2[r].some(t => !!e[t])
};

function TY(r) {
    for (const e in r) sh[e] = { ...sh[e],
        ...r[e]
    }
}
const EY = Symbol.for("motionComponentSymbol");

function CY({
    preloadedFeatures: r,
    createVisualElement: e,
    useRender: t,
    useVisualState: n,
    Component: i
}) {
    r && TY(r);

    function s(a, l) {
        let c;
        const u = { ...N.useContext(uw),
                ...a,
                layoutId: RY(a)
            },
            {
                isStatic: f
            } = u,
            d = bY(a),
            m = n(a, f);
        if (!f && fw) {
            PY();
            const g = IY(u);
            c = g.MeasureLayout, d.visualElement = AY(i, m, u, e, g.ProjectionNode)
        }
        return G.jsxs(jy.Provider, {
            value: d,
            children: [c && d.visualElement ? G.jsx(c, {
                visualElement: d.visualElement,
                ...u
            }) : null, t(i, a, MY(m, d.visualElement, l), m, f, d.visualElement)]
        })
    }
    const o = N.forwardRef(s);
    return o[EY] = i, o
}

function RY({
    layoutId: r
}) {
    const e = N.useContext(lw).id;
    return e && r !== void 0 ? e + "-" + r : r
}

function PY(r, e) {
    N.useContext(w3).strict
}

function IY(r) {
    const {
        drag: e,
        layout: t
    } = sh;
    if (!e && !t) return {};
    const n = { ...e,
        ...t
    };
    return {
        MeasureLayout: e != null && e.isEnabled(r) || t != null && t.isEnabled(r) ? n.MeasureLayout : void 0,
        ProjectionNode: n.ProjectionNode
    }
}
const BY = ["animate", "circle", "defs", "desc", "ellipse", "g", "image", "line", "filter", "marker", "mask", "metadata", "path", "pattern", "polygon", "polyline", "rect", "stop", "switch", "symbol", "svg", "text", "tspan", "use", "view"];

function hw(r) {
    return typeof r != "string" || r.includes("-") ? !1 : !!(BY.indexOf(r) > -1 || /[A-Z]/u.test(r))
}

function E3(r, {
    style: e,
    vars: t
}, n, i) {
    Object.assign(r.style, e, i && i.getProjectionStyles(n));
    for (const s in t) r.style.setProperty(s, t[s])
}
const C3 = new Set(["baseFrequency", "diffuseConstant", "kernelMatrix", "kernelUnitLength", "keySplines", "keyTimes", "limitingConeAngle", "markerHeight", "markerWidth", "numOctaves", "targetX", "targetY", "surfaceScale", "specularConstant", "specularExponent", "stdDeviation", "tableValues", "viewBox", "gradientTransform", "pathLength", "startOffset", "textLength", "lengthAdjust"]);

function R3(r, e, t, n) {
    E3(r, e, void 0, n);
    for (const i in e.attrs) r.setAttribute(C3.has(i) ? i : ow(i), e.attrs[i])
}

function P3(r, {
    layout: e,
    layoutId: t
}) {
    return xu.has(r) || r.startsWith("origin") || (e || t !== void 0) && (!!Wv[r] || r === "opacity")
}

function dw(r, e, t) {
    var n;
    const {
        style: i
    } = r, s = {};
    for (const o in i)(dr(i[o]) || e.style && dr(e.style[o]) || P3(o, r) || ((n = t == null ? void 0 : t.getValue(o)) === null || n === void 0 ? void 0 : n.liveStyle) !== void 0) && (s[o] = i[o]);
    return s
}

function I3(r, e, t) {
    const n = dw(r, e, t);
    for (const i in r)
        if (dr(r[i]) || dr(e[i])) {
            const s = am.indexOf(i) !== -1 ? "attr" + i.charAt(0).toUpperCase() + i.substring(1) : i;
            n[s] = r[i]
        }
    return n
}

function pw(r) {
    const e = N.useRef(null);
    return e.current === null && (e.current = r()), e.current
}

function DY({
    scrapeMotionValuesFromProps: r,
    createRenderState: e,
    onMount: t
}, n, i, s) {
    const o = {
        latestValues: LY(n, i, s, r),
        renderState: e()
    };
    return t && (o.mount = a => t(n, a, o)), o
}
const B3 = r => (e, t) => {
    const n = N.useContext(jy),
        i = N.useContext(Wy),
        s = () => DY(r, e, n, i);
    return t ? s() : pw(s)
};

function LY(r, e, t, n) {
    const i = {},
        s = n(r, {});
    for (const d in s) i[d] = O0(s[d]);
    let {
        initial: o,
        animate: a
    } = r;
    const l = Xy(r),
        c = T3(r);
    e && c && !l && r.inherit !== !1 && (o === void 0 && (o = e.initial), a === void 0 && (a = e.animate));
    let u = t ? t.initial === !1 : !1;
    u = u || o === !1;
    const f = u ? a : o;
    if (f && typeof f != "boolean" && !Gy(f)) {
        const d = Array.isArray(f) ? f : [f];
        for (let m = 0; m < d.length; m++) {
            const g = kM(r, d[m]);
            if (g) {
                const {
                    transitionEnd: y,
                    transition: v,
                    ..._
                } = g;
                for (const A in _) {
                    let S = _[A];
                    if (Array.isArray(S)) {
                        const M = u ? S.length - 1 : 0;
                        S = S[M]
                    }
                    S !== null && (i[A] = S)
                }
                for (const A in y) i[A] = y[A]
            }
        }
    }
    return i
}
const mw = () => ({
        style: {},
        transform: {},
        transformOrigin: {},
        vars: {}
    }),
    D3 = () => ({ ...mw(),
        attrs: {}
    }),
    L3 = (r, e) => e && typeof r == "number" ? e.transform(r) : r,
    FY = {
        x: "translateX",
        y: "translateY",
        z: "translateZ",
        transformPerspective: "perspective"
    },
    UY = am.length;

function OY(r, e, t) {
    let n = "",
        i = !0;
    for (let s = 0; s < UY; s++) {
        const o = am[s],
            a = r[o];
        if (a === void 0) continue;
        let l = !0;
        if (typeof a == "number" ? l = a === (o.startsWith("scale") ? 1 : 0) : l = parseFloat(a) === 0, !l || t) {
            const c = L3(a, KM[o]);
            if (!l) {
                i = !1;
                const u = FY[o] || o;
                n += `${u}(${c}) `
            }
            t && (e[o] = c)
        }
    }
    return n = n.trim(), t ? n = t(e, i ? "" : n) : i && (n = "none"), n
}

function gw(r, e, t) {
    const {
        style: n,
        vars: i,
        transformOrigin: s
    } = r;
    let o = !1,
        a = !1;
    for (const l in e) {
        const c = e[l];
        if (xu.has(l)) {
            o = !0;
            continue
        } else if (TL(l)) {
            i[l] = c;
            continue
        } else {
            const u = L3(c, KM[l]);
            l.startsWith("origin") ? (a = !0, s[l] = u) : n[l] = u
        }
    }
    if (e.transform || (o || t ? n.transform = OY(e, r.transform, t) : n.transform && (n.transform = "none")), a) {
        const {
            originX: l = "50%",
            originY: c = "50%",
            originZ: u = 0
        } = s;
        n.transformOrigin = `${l} ${c} ${u}`
    }
}

function S2(r, e, t) {
    return typeof r == "string" ? r : kt.transform(e + t * r)
}

function NY(r, e, t) {
    const n = S2(e, r.x, r.width),
        i = S2(t, r.y, r.height);
    return `${n} ${i}`
}
const kY = {
        offset: "stroke-dashoffset",
        array: "stroke-dasharray"
    },
    zY = {
        offset: "strokeDashoffset",
        array: "strokeDasharray"
    };

function GY(r, e, t = 1, n = 0, i = !0) {
    r.pathLength = 1;
    const s = i ? kY : zY;
    r[s.offset] = kt.transform(-n);
    const o = kt.transform(e),
        a = kt.transform(t);
    r[s.array] = `${o} ${a}`
}

function vw(r, {
    attrX: e,
    attrY: t,
    attrScale: n,
    originX: i,
    originY: s,
    pathLength: o,
    pathSpacing: a = 1,
    pathOffset: l = 0,
    ...c
}, u, f) {
    if (gw(r, c, f), u) {
        r.style.viewBox && (r.attrs.viewBox = r.style.viewBox);
        return
    }
    r.attrs = r.style, r.style = {};
    const {
        attrs: d,
        style: m,
        dimensions: g
    } = r;
    d.transform && (g && (m.transform = d.transform), delete d.transform), g && (i !== void 0 || s !== void 0 || m.transform) && (m.transformOrigin = NY(g, i !== void 0 ? i : .5, s !== void 0 ? s : .5)), e !== void 0 && (d.x = e), t !== void 0 && (d.y = t), n !== void 0 && (d.scale = n), o !== void 0 && GY(d, o, a, l, !1)
}
const yw = r => typeof r == "string" && r.toLowerCase() === "svg",
    HY = {
        useVisualState: B3({
            scrapeMotionValuesFromProps: I3,
            createRenderState: D3,
            onMount: (r, e, {
                renderState: t,
                latestValues: n
            }) => {
                Xn.read(() => {
                    try {
                        t.dimensions = typeof e.getBBox == "function" ? e.getBBox() : e.getBoundingClientRect()
                    } catch {
                        t.dimensions = {
                            x: 0,
                            y: 0,
                            width: 0,
                            height: 0
                        }
                    }
                }), Xn.render(() => {
                    vw(t, n, yw(e.tagName), r.transformTemplate), R3(e, t)
                })
            }
        })
    },
    VY = {
        useVisualState: B3({
            scrapeMotionValuesFromProps: dw,
            createRenderState: mw
        })
    };

function F3(r, e, t) {
    for (const n in e) !dr(e[n]) && !P3(n, t) && (r[n] = e[n])
}

function WY({
    transformTemplate: r
}, e) {
    return N.useMemo(() => {
        const t = mw();
        return gw(t, e, r), Object.assign({}, t.vars, t.style)
    }, [e])
}

function jY(r, e) {
    const t = r.style || {},
        n = {};
    return F3(n, t, r), Object.assign(n, WY(r, e)), n
}

function XY(r, e) {
    const t = {},
        n = jY(r, e);
    return r.drag && r.dragListener !== !1 && (t.draggable = !1, n.userSelect = n.WebkitUserSelect = n.WebkitTouchCallout = "none", n.touchAction = r.drag === !0 ? "none" : `pan-${r.drag==="x"?"y":"x"}`), r.tabIndex === void 0 && (r.onTap || r.onTapStart || r.whileTap) && (t.tabIndex = 0), t.style = n, t
}
const YY = new Set(["animate", "exit", "variants", "initial", "style", "values", "variants", "transition", "transformTemplate", "custom", "inherit", "onBeforeLayoutMeasure", "onAnimationStart", "onAnimationComplete", "onUpdate", "onDragStart", "onDrag", "onDragEnd", "onMeasureDragConstraints", "onDirectionLock", "onDragTransitionEnd", "_dragX", "_dragY", "onHoverStart", "onHoverEnd", "onViewportEnter", "onViewportLeave", "globalTapTarget", "ignoreStrict", "viewport"]);

function jv(r) {
    return r.startsWith("while") || r.startsWith("drag") && r !== "draggable" || r.startsWith("layout") || r.startsWith("onTap") || r.startsWith("onPan") || r.startsWith("onLayout") || YY.has(r)
}
let U3 = r => !jv(r);

function JY(r) {
    r && (U3 = e => e.startsWith("on") ? !jv(e) : r(e))
}
try {
    JY(require("@emotion/is-prop-valid").default)
} catch {}

function KY(r, e, t) {
    const n = {};
    for (const i in r) i === "values" && typeof r.values == "object" || (U3(i) || t === !0 && jv(i) || !e && !jv(i) || r.draggable && i.startsWith("onDrag")) && (n[i] = r[i]);
    return n
}

function qY(r, e, t, n) {
    const i = N.useMemo(() => {
        const s = D3();
        return vw(s, e, yw(n), r.transformTemplate), { ...s.attrs,
            style: { ...s.style
            }
        }
    }, [e]);
    if (r.style) {
        const s = {};
        F3(s, r.style, r), i.style = { ...s,
            ...i.style
        }
    }
    return i
}

function ZY(r = !1) {
    return (t, n, i, {
        latestValues: s
    }, o) => {
        const l = (hw(t) ? qY : XY)(n, s, o, t),
            c = KY(n, typeof t == "string", r),
            u = t !== N.Fragment ? { ...c,
                ...l,
                ref: i
            } : {},
            {
                children: f
            } = n,
            d = N.useMemo(() => dr(f) ? f.get() : f, [f]);
        return N.createElement(t, { ...u,
            children: d
        })
    }
}

function QY(r, e) {
    return function(n, {
        forwardMotionProps: i
    } = {
        forwardMotionProps: !1
    }) {
        const o = { ...hw(n) ? HY : VY,
            preloadedFeatures: r,
            useRender: ZY(i),
            createVisualElement: e,
            Component: n
        };
        return CY(o)
    }
}
const QA = {
        current: null
    },
    O3 = {
        current: !1
    };

function $Y() {
    if (O3.current = !0, !!fw)
        if (window.matchMedia) {
            const r = window.matchMedia("(prefers-reduced-motion)"),
                e = () => QA.current = r.matches;
            r.addListener(e), e()
        } else QA.current = !1
}

function eJ(r, e, t) {
    for (const n in e) {
        const i = e[n],
            s = t[n];
        if (dr(i)) r.addValue(n, i);
        else if (dr(s)) r.addValue(n, Ip(i, {
            owner: r
        }));
        else if (s !== i)
            if (r.hasValue(n)) {
                const o = r.getValue(n);
                o.liveStyle === !0 ? o.jump(i) : o.hasAnimated || o.set(i)
            } else {
                const o = r.getStaticValue(n);
                r.addValue(n, Ip(o !== void 0 ? o : i, {
                    owner: r
                }))
            }
    }
    for (const n in t) e[n] === void 0 && r.removeValue(n);
    return e
}
const M2 = new WeakMap,
    tJ = [...RL, ur, Pl],
    nJ = r => tJ.find(CL(r)),
    w2 = ["AnimationStart", "AnimationComplete", "Update", "BeforeLayoutMeasure", "LayoutMeasure", "LayoutAnimationStart", "LayoutAnimationComplete"];
class iJ {
    scrapeMotionValuesFromProps(e, t, n) {
        return {}
    }
    constructor({
        parent: e,
        props: t,
        presenceContext: n,
        reducedMotionConfig: i,
        blockInitialAnimation: s,
        visualState: o
    }, a = {}) {
        this.current = null, this.children = new Set, this.isVariantNode = !1, this.isControllingVariants = !1, this.shouldReduceMotion = null, this.values = new Map, this.KeyframeResolver = XM, this.features = {}, this.valueSubscriptions = new Map, this.prevMotionValues = {}, this.events = {}, this.propEventSubscriptions = {}, this.notifyUpdate = () => this.notify("Update", this.latestValues), this.render = () => {
            this.current && (this.triggerBuild(), this.renderInstance(this.current, this.renderState, this.props.style, this.projection))
        }, this.renderScheduledAt = 0, this.scheduleRender = () => {
            const d = Oo.now();
            this.renderScheduledAt < d && (this.renderScheduledAt = d, Xn.render(this.render, !1, !0))
        };
        const {
            latestValues: l,
            renderState: c
        } = o;
        this.latestValues = l, this.baseTarget = { ...l
        }, this.initialValues = t.initial ? { ...l
        } : {}, this.renderState = c, this.parent = e, this.props = t, this.presenceContext = n, this.depth = e ? e.depth + 1 : 0, this.reducedMotionConfig = i, this.options = a, this.blockInitialAnimation = !!s, this.isControllingVariants = Xy(t), this.isVariantNode = T3(t), this.isVariantNode && (this.variantChildren = new Set), this.manuallyAnimateOnMount = !!(e && e.current);
        const {
            willChange: u,
            ...f
        } = this.scrapeMotionValuesFromProps(t, {}, this);
        for (const d in f) {
            const m = f[d];
            l[d] !== void 0 && dr(m) && m.set(l[d], !1)
        }
    }
    mount(e) {
        this.current = e, M2.set(e, this), this.projection && !this.projection.instance && this.projection.mount(e), this.parent && this.isVariantNode && !this.isControllingVariants && (this.removeFromVariantTree = this.parent.addVariantChild(this)), this.values.forEach((t, n) => this.bindToMotionValue(n, t)), O3.current || $Y(), this.shouldReduceMotion = this.reducedMotionConfig === "never" ? !1 : this.reducedMotionConfig === "always" ? !0 : QA.current, this.parent && this.parent.children.add(this), this.update(this.props, this.presenceContext)
    }
    unmount() {
        M2.delete(this.current), this.projection && this.projection.unmount(), Rl(this.notifyUpdate), Rl(this.render), this.valueSubscriptions.forEach(e => e()), this.valueSubscriptions.clear(), this.removeFromVariantTree && this.removeFromVariantTree(), this.parent && this.parent.children.delete(this);
        for (const e in this.events) this.events[e].clear();
        for (const e in this.features) {
            const t = this.features[e];
            t && (t.unmount(), t.isMounted = !1)
        }
        this.current = null
    }
    bindToMotionValue(e, t) {
        this.valueSubscriptions.has(e) && this.valueSubscriptions.get(e)();
        const n = xu.has(e),
            i = t.on("change", a => {
                this.latestValues[e] = a, this.props.onUpdate && Xn.preRender(this.notifyUpdate), n && this.projection && (this.projection.isTransformDirty = !0)
            }),
            s = t.on("renderRequest", this.scheduleRender);
        let o;
        window.MotionCheckAppearSync && (o = window.MotionCheckAppearSync(this, e, t)), this.valueSubscriptions.set(e, () => {
            i(), s(), o && o(), t.owner && t.stop()
        })
    }
    sortNodePosition(e) {
        return !this.current || !this.sortInstanceNodePosition || this.type !== e.type ? 0 : this.sortInstanceNodePosition(this.current, e.current)
    }
    updateFeatures() {
        let e = "animation";
        for (e in sh) {
            const t = sh[e];
            if (!t) continue;
            const {
                isEnabled: n,
                Feature: i
            } = t;
            if (!this.features[e] && i && n(this.props) && (this.features[e] = new i(this)), this.features[e]) {
                const s = this.features[e];
                s.isMounted ? s.update() : (s.mount(), s.isMounted = !0)
            }
        }
    }
    triggerBuild() {
        this.build(this.renderState, this.latestValues, this.props)
    }
    measureViewportBox() {
        return this.current ? this.measureInstanceViewportBox(this.current, this.props) : xi()
    }
    getStaticValue(e) {
        return this.latestValues[e]
    }
    setStaticValue(e, t) {
        this.latestValues[e] = t
    }
    update(e, t) {
        (e.transformTemplate || this.props.transformTemplate) && this.scheduleRender(), this.prevProps = this.props, this.props = e, this.prevPresenceContext = this.presenceContext, this.presenceContext = t;
        for (let n = 0; n < w2.length; n++) {
            const i = w2[n];
            this.propEventSubscriptions[i] && (this.propEventSubscriptions[i](), delete this.propEventSubscriptions[i]);
            const s = "on" + i,
                o = e[s];
            o && (this.propEventSubscriptions[i] = this.on(i, o))
        }
        this.prevMotionValues = eJ(this, this.scrapeMotionValuesFromProps(e, this.prevProps, this), this.prevMotionValues), this.handleChildMotionValue && this.handleChildMotionValue()
    }
    getProps() {
        return this.props
    }
    getVariant(e) {
        return this.props.variants ? this.props.variants[e] : void 0
    }
    getDefaultTransition() {
        return this.props.transition
    }
    getTransformPagePoint() {
        return this.props.transformPagePoint
    }
    getClosestVariantNode() {
        return this.isVariantNode ? this : this.parent ? this.parent.getClosestVariantNode() : void 0
    }
    addVariantChild(e) {
        const t = this.getClosestVariantNode();
        if (t) return t.variantChildren && t.variantChildren.add(e), () => t.variantChildren.delete(e)
    }
    addValue(e, t) {
        const n = this.values.get(e);
        t !== n && (n && this.removeValue(e), this.bindToMotionValue(e, t), this.values.set(e, t), this.latestValues[e] = t.get())
    }
    removeValue(e) {
        this.values.delete(e);
        const t = this.valueSubscriptions.get(e);
        t && (t(), this.valueSubscriptions.delete(e)), delete this.latestValues[e], this.removeValueFromRenderState(e, this.renderState)
    }
    hasValue(e) {
        return this.values.has(e)
    }
    getValue(e, t) {
        if (this.props.values && this.props.values[e]) return this.props.values[e];
        let n = this.values.get(e);
        return n === void 0 && t !== void 0 && (n = Ip(t === null ? void 0 : t, {
            owner: this
        }), this.addValue(e, n)), n
    }
    readValue(e, t) {
        var n;
        let i = this.latestValues[e] !== void 0 || !this.current ? this.latestValues[e] : (n = this.getBaseTargetFromProps(this.props, e)) !== null && n !== void 0 ? n : this.readValueFromInstance(this.current, e, this.options);
        return i != null && (typeof i == "string" && (wL(i) || ML(i)) ? i = parseFloat(i) : !nJ(i) && Pl.test(t) && (i = OL(e, t)), this.setBaseTarget(e, dr(i) ? i.get() : i)), dr(i) ? i.get() : i
    }
    setBaseTarget(e, t) {
        this.baseTarget[e] = t
    }
    getBaseTarget(e) {
        var t;
        const {
            initial: n
        } = this.props;
        let i;
        if (typeof n == "string" || typeof n == "object") {
            const o = kM(this.props, n, (t = this.presenceContext) === null || t === void 0 ? void 0 : t.custom);
            o && (i = o[e])
        }
        if (n && i !== void 0) return i;
        const s = this.getBaseTargetFromProps(this.props, e);
        return s !== void 0 && !dr(s) ? s : this.initialValues[e] !== void 0 && i === void 0 ? void 0 : this.baseTarget[e]
    }
    on(e, t) {
        return this.events[e] || (this.events[e] = new sw), this.events[e].add(t)
    }
    notify(e, ...t) {
        this.events[e] && this.events[e].notify(...t)
    }
}
class N3 extends iJ {
    constructor() {
        super(...arguments), this.KeyframeResolver = NL
    }
    sortInstanceNodePosition(e, t) {
        return e.compareDocumentPosition(t) & 2 ? 1 : -1
    }
    getBaseTargetFromProps(e, t) {
        return e.style ? e.style[t] : void 0
    }
    removeValueFromRenderState(e, {
        vars: t,
        style: n
    }) {
        delete t[e], delete n[e]
    }
    handleChildMotionValue() {
        this.childSubscription && (this.childSubscription(), delete this.childSubscription);
        const {
            children: e
        } = this.props;
        dr(e) && (this.childSubscription = e.on("change", t => {
            this.current && (this.current.textContent = `${t}`)
        }))
    }
}

function rJ(r) {
    return window.getComputedStyle(r)
}
class sJ extends N3 {
    constructor() {
        super(...arguments), this.type = "html", this.renderInstance = E3
    }
    readValueFromInstance(e, t) {
        if (xu.has(t)) {
            const n = qM(t);
            return n && n.default || 0
        } else {
            const n = rJ(e),
                i = (TL(t) ? n.getPropertyValue(t) : n[t]) || 0;
            return typeof i == "string" ? i.trim() : i
        }
    }
    measureInstanceViewportBox(e, {
        transformPagePoint: t
    }) {
        return f3(e, t)
    }
    build(e, t, n) {
        gw(e, t, n.transformTemplate)
    }
    scrapeMotionValuesFromProps(e, t, n) {
        return dw(e, t, n)
    }
}
class oJ extends N3 {
    constructor() {
        super(...arguments), this.type = "svg", this.isSVGTag = !1, this.measureInstanceViewportBox = xi
    }
    getBaseTargetFromProps(e, t) {
        return e[t]
    }
    readValueFromInstance(e, t) {
        if (xu.has(t)) {
            const n = qM(t);
            return n && n.default || 0
        }
        return t = C3.has(t) ? t : ow(t), e.getAttribute(t)
    }
    scrapeMotionValuesFromProps(e, t, n) {
        return I3(e, t, n)
    }
    build(e, t, n) {
        vw(e, t, this.isSVGTag, n.transformTemplate)
    }
    renderInstance(e, t, n, i) {
        R3(e, t, n, i)
    }
    mount(e) {
        this.isSVGTag = yw(e.tagName), super.mount(e)
    }
}
const aJ = (r, e) => hw(r) ? new oJ(e) : new sJ(e, {
        allowProjection: r !== N.Fragment
    }),
    lJ = QY({ ...WX,
        ..._Y,
        ...lY,
        ...xY
    }, aJ),
    Vt = HW(lJ);
class cJ extends N.Component {
    getSnapshotBeforeUpdate(e) {
        const t = this.props.childRef.current;
        if (t && e.isPresent && !this.props.isPresent) {
            const n = this.props.sizeRef.current;
            n.height = t.offsetHeight || 0, n.width = t.offsetWidth || 0, n.top = t.offsetTop, n.left = t.offsetLeft
        }
        return null
    }
    componentDidUpdate() {}
    render() {
        return this.props.children
    }
}

function uJ({
    children: r,
    isPresent: e
}) {
    const t = N.useId(),
        n = N.useRef(null),
        i = N.useRef({
            width: 0,
            height: 0,
            top: 0,
            left: 0
        }),
        {
            nonce: s
        } = N.useContext(uw);
    return N.useInsertionEffect(() => {
        const {
            width: o,
            height: a,
            top: l,
            left: c
        } = i.current;
        if (e || !n.current || !o || !a) return;
        n.current.dataset.motionPopId = t;
        const u = document.createElement("style");
        return s && (u.nonce = s), document.head.appendChild(u), u.sheet && u.sheet.insertRule(`
          [data-motion-pop-id="${t}"] {
            position: absolute !important;
            width: ${o}px !important;
            height: ${a}px !important;
            top: ${l}px !important;
            left: ${c}px !important;
          }
        `), () => {
            document.head.removeChild(u)
        }
    }, [e]), G.jsx(cJ, {
        isPresent: e,
        childRef: n,
        sizeRef: i,
        children: N.cloneElement(r, {
            ref: n
        })
    })
}
const fJ = ({
    children: r,
    initial: e,
    isPresent: t,
    onExitComplete: n,
    custom: i,
    presenceAffectsLayout: s,
    mode: o
}) => {
    const a = pw(hJ),
        l = N.useId(),
        c = N.useCallback(f => {
            a.set(f, !0);
            for (const d of a.values())
                if (!d) return;
            n && n()
        }, [a, n]),
        u = N.useMemo(() => ({
            id: l,
            initial: e,
            isPresent: t,
            custom: i,
            onExitComplete: c,
            register: f => (a.set(f, !1), () => a.delete(f))
        }), s ? [Math.random(), c] : [t, c]);
    return N.useMemo(() => {
        a.forEach((f, d) => a.set(d, !1))
    }, [t]), N.useEffect(() => {
        !t && !a.size && n && n()
    }, [t]), o === "popLayout" && (r = G.jsx(uJ, {
        isPresent: t,
        children: r
    })), G.jsx(Wy.Provider, {
        value: u,
        children: r
    })
};

function hJ() {
    return new Map
}
const y0 = r => r.key || "";

function b2(r) {
    const e = [];
    return N.Children.forEach(r, t => {
        N.isValidElement(t) && e.push(t)
    }), e
}
const _w = ({
        children: r,
        exitBeforeEnter: e,
        custom: t,
        initial: n = !0,
        onExitComplete: i,
        presenceAffectsLayout: s = !0,
        mode: o = "sync"
    }) => {
        const a = N.useMemo(() => b2(r), [r]),
            l = a.map(y0),
            c = N.useRef(!0),
            u = N.useRef(a),
            f = pw(() => new Map),
            [d, m] = N.useState(a),
            [g, y] = N.useState(a);
        M3(() => {
            c.current = !1, u.current = a;
            for (let A = 0; A < g.length; A++) {
                const S = y0(g[A]);
                l.includes(S) ? f.delete(S) : f.get(S) !== !0 && f.set(S, !1)
            }
        }, [g, l.length, l.join("-")]);
        const v = [];
        if (a !== d) {
            let A = [...a];
            for (let S = 0; S < g.length; S++) {
                const M = g[S],
                    C = y0(M);
                l.includes(C) || (A.splice(S, 0, M), v.push(M))
            }
            o === "wait" && v.length && (A = v), y(b2(A)), m(a);
            return
        }
        const {
            forceRender: _
        } = N.useContext(lw);
        return G.jsx(G.Fragment, {
            children: g.map(A => {
                const S = y0(A),
                    M = a === g || l.includes(S),
                    C = () => {
                        if (f.has(S)) f.set(S, !0);
                        else return;
                        let E = !0;
                        f.forEach(R => {
                            R || (E = !1)
                        }), E && (_ == null || _(), y(u.current), i && i())
                    };
                return G.jsx(fJ, {
                    isPresent: M,
                    initial: !c.current || n ? void 0 : !1,
                    custom: M ? void 0 : t,
                    presenceAffectsLayout: s,
                    mode: o,
                    onExitComplete: M ? void 0 : C,
                    children: A
                }, S)
            })
        })
    },
    k3 = "" + new URL("logo_main-DXlK6-sl.png",
        import.meta.url).href,
    xw = (r = 500) => {
        const [e, t] = N.useState(0), n = N.useRef(), i = N.useRef(null), s = N.useRef(0), o = N.useRef(!1), a = N.useRef(), l = (d, m) => {
            i.current || (i.current = d, s.current = e);
            const g = d - i.current,
                y = s.current,
                v = m ? 1 - y : y,
                _ = Math.max(r * v, 1),
                A = g / _,
                S = m ? y + A : y - A,
                M = Math.min(1, Math.max(0, S));
            t(M), m && M < 1 || !m && M > 0 ? n.current = requestAnimationFrame(C => l(C, m)) : (o.current = !1, i.current = null, s.current = M)
        }, c = d => {
            o.current && a.current !== (d ? "forward" : "backward") && (cancelAnimationFrame(n.current), i.current = null), o.current = !0, a.current = d ? "forward" : "backward", n.current = requestAnimationFrame(m => l(m, d))
        }, u = () => {
            c(!0)
        }, f = () => {
            c(!1)
        };
        return N.useEffect(() => () => {
            n.current && cancelAnimationFrame(n.current)
        }, []), {
            progress: e,
            handleMouseEnter: u,
            handleMouseLeave: f
        }
    },
    z3 = TM(r => ({
        zoomLevel: 1,
        setZoomLevel: e => r({
            zoomLevel: e
        }),
        adjustZoomLevel: e => r(t => ({
            zoomLevel: e(t.zoomLevel)
        }))
    })),
    hm = TM((r, e) => ({
        isSoundOn: !1,
        wasSoundOn: !1,
        firstClickHandled: !1,
        toggleSound: () => r(t => ({
            isSoundOn: !t.isSoundOn,
            firstClickHandled: !0,
            wasSoundOn: t.isSoundOn ? !1 : t.wasSoundOn
        })),
        autoEnableSound: () => r(t => !t.firstClickHandled && !t.isSoundOn ? {
            isSoundOn: !0,
            firstClickHandled: !0
        } : {}),
        pauseSound: () => r(t => ({
            wasSoundOn: t.isSoundOn ? !0 : t.wasSoundOn,
            isSoundOn: !1
        })),
        resumeSound: () => r(t => ({
            isSoundOn: t.wasSoundOn ? !0 : t.isSoundOn,
            wasSoundOn: !1
        }))
    })),
    mh = (r, e) => {
        const t = N.useRef(null);
        return N.useEffect(() => (t.current = new Audio(r), () => {
            t.current && (t.current.pause(), t.current.src = "", t.current = null)
        }), [r]), () => {
            if (!hm.getState().isSoundOn) return;
            const i = t.current;
            i && (i.volume = e, i.currentTime = 0, i.play().catch(() => {}))
        }
    },
    gh = "" + new URL("button-cLlI7nv4.mp3",
        import.meta.url).href,
    Aw = () => {
        const {
            progress: r,
            handleMouseEnter: e,
            handleMouseLeave: t
        } = xw(), [n, i] = N.useState(!1), [s, o] = N.useState(!1), [a, l] = N.useState({
            x: 0,
            y: 0
        }), {
            adjustZoomLevel: c
        } = z3(), u = mh(gh, .5), f = () => {
            c(v => Math.min(v + .1, 2))
        }, d = () => {
            c(v => Math.max(v - .1, 1))
        }, m = v => {
            const _ = v.currentTarget.getBoundingClientRect();
            l({
                x: v.clientX - _.left,
                y: v.clientY - _.top
            }), i(!0)
        }, g = v => {
            const _ = v.currentTarget.getBoundingClientRect();
            l({
                x: v.clientX - _.left,
                y: v.clientY - _.top
            }), setTimeout(() => i(!1), 50)
        }, y = () => {
            o(!0), setTimeout(() => o(!1), 200), window.open("https://fantik.studio", "_blank")
        };
        return G.jsxs(Vt.div, {
            onClick: y,
            className: "btn-bt pointer-events-auto relative bg-black text-white flex items-center justify-center cursor-pointer",
            onMouseEnter: v => {
                e(), m(v), f(), u()
            },
            onMouseLeave: v => {
                t(), g(v), d()
            },
            animate: {
                scale: s ? .9 : n ? 1.2 : 1
            },
            transition: {
                scale: {
                    duration: .3,
                    ease: "easeInOut"
                }
            },
            children: [G.jsx("div", {
                className: "btn-bt-content_hover flex items-center justify-center",
                style: {
                    background: r > 0 ? `conic-gradient(white ${r*100}%, transparent ${r*100}%)` : "transparent"
                }
            }), G.jsx("div", {
                className: "btn-bt-content_not-border flex items-center justify-center"
            }), G.jsxs("div", {
                className: "btn-bt-content_text flex items-center justify-center",
                children: [G.jsx(_w, {
                    children: n && G.jsx(Vt.div, {
                        className: "absolute bg-white rounded-full pointer-events-none mix-blend-difference",
                        style: {
                            width: "15px",
                            height: "15px",
                            top: `${a.y}px`,
                            left: `${a.x}px`,
                            transform: "translate(-50%, -50%)"
                        },
                        initial: {
                            width: 15,
                            height: 15,
                            opacity: 1
                        },
                        animate: {
                            width: 500,
                            height: 500,
                            opacity: 1
                        },
                        exit: {
                            width: 15,
                            height: 15,
                            opacity: 1
                        },
                        transition: {
                            initial: {
                                duration: .5,
                                ease: "easeIn"
                            },
                            animate: {
                                duration: .5,
                                ease: "easeOut"
                            },
                            exit: {
                                duration: .5,
                                ease: "easeOut"
                            }
                        }
                    })
                }), G.jsxs("div", {
                    className: "btn-bt-content_not-border-content",
                    children: [G.jsx(Vt.span, {
                        className: "mix-blend-difference",
                        initial: {
                            y: 11,
                            z: -10
                        },
                        animate: n ? {
                            y: -20
                        } : {
                            y: 11
                        },
                        transition: {
                            duration: .3,
                            ease: "easeInOut"
                        },
                        children: "Enter App"
                    }), G.jsx(Vt.span, {
                        className: "mix-blend-difference",
                        initial: {
                            y: 16,
                            z: -10
                        },
                        animate: n ? {
                            y: -12
                        } : {
                            y: 16
                        },
                        transition: {
                            duration: .3,
                            ease: "easeInOut"
                        },
                        children: "Enter App"
                    })]
                })]
            })]
        })
    },
    dJ = document.getElementById("root"),
    pJ = document.getElementById("scroll-container");

function qt(r = {}) {
    return {
        scroller: dJ,
        target: pJ,
        toggleActions: "play none none reverse",
        scrub: !0,
        ...r
    }
}
et.registerPlugin(Zt);
const mJ = () => {
        const [r, e] = N.useState(0);
        return N.useEffect(() => {
            et.to({}, {
                scrollTrigger: qt({
                    start: 0,
                    end: "+=11400",
                    onUpdate: t => {
                        e(t.progress)
                    }
                })
            })
        }, []), G.jsxs("div", {
            className: "trackScroll-container",
            children: [G.jsx("div", {
                className: "trackScroll-back"
            }), G.jsx("div", {
                className: "trackScroll",
                style: {
                    background: `conic-gradient(white calc(${Math.trunc(r*100)} * 1%), transparent calc(${Math.trunc(r*100)} * 1%))`
                }
            })]
        })
    },
    Sw = "-",
    gJ = r => {
        const e = yJ(r),
            {
                conflictingClassGroups: t,
                conflictingClassGroupModifiers: n
            } = r;
        return {
            getClassGroupId: o => {
                const a = o.split(Sw);
                return a[0] === "" && a.length !== 1 && a.shift(), G3(a, e) || vJ(o)
            },
            getConflictingClassGroupIds: (o, a) => {
                const l = t[o] || [];
                return a && n[o] ? [...l, ...n[o]] : l
            }
        }
    },
    G3 = (r, e) => {
        var o;
        if (r.length === 0) return e.classGroupId;
        const t = r[0],
            n = e.nextPart.get(t),
            i = n ? G3(r.slice(1), n) : void 0;
        if (i) return i;
        if (e.validators.length === 0) return;
        const s = r.join(Sw);
        return (o = e.validators.find(({
            validator: a
        }) => a(s))) == null ? void 0 : o.classGroupId
    },
    T2 = /^\[(.+)\]$/,
    vJ = r => {
        if (T2.test(r)) {
            const e = T2.exec(r)[1],
                t = e == null ? void 0 : e.substring(0, e.indexOf(":"));
            if (t) return "arbitrary.." + t
        }
    },
    yJ = r => {
        const {
            theme: e,
            prefix: t
        } = r, n = {
            nextPart: new Map,
            validators: []
        };
        return xJ(Object.entries(r.classGroups), t).forEach(([s, o]) => {
            $A(o, n, s, e)
        }), n
    },
    $A = (r, e, t, n) => {
        r.forEach(i => {
            if (typeof i == "string") {
                const s = i === "" ? e : E2(e, i);
                s.classGroupId = t;
                return
            }
            if (typeof i == "function") {
                if (_J(i)) {
                    $A(i(n), e, t, n);
                    return
                }
                e.validators.push({
                    validator: i,
                    classGroupId: t
                });
                return
            }
            Object.entries(i).forEach(([s, o]) => {
                $A(o, E2(e, s), t, n)
            })
        })
    },
    E2 = (r, e) => {
        let t = r;
        return e.split(Sw).forEach(n => {
            t.nextPart.has(n) || t.nextPart.set(n, {
                nextPart: new Map,
                validators: []
            }), t = t.nextPart.get(n)
        }), t
    },
    _J = r => r.isThemeGetter,
    xJ = (r, e) => e ? r.map(([t, n]) => {
        const i = n.map(s => typeof s == "string" ? e + s : typeof s == "object" ? Object.fromEntries(Object.entries(s).map(([o, a]) => [e + o, a])) : s);
        return [t, i]
    }) : r,
    AJ = r => {
        if (r < 1) return {
            get: () => {},
            set: () => {}
        };
        let e = 0,
            t = new Map,
            n = new Map;
        const i = (s, o) => {
            t.set(s, o), e++, e > r && (e = 0, n = t, t = new Map)
        };
        return {
            get(s) {
                let o = t.get(s);
                if (o !== void 0) return o;
                if ((o = n.get(s)) !== void 0) return i(s, o), o
            },
            set(s, o) {
                t.has(s) ? t.set(s, o) : i(s, o)
            }
        }
    },
    H3 = "!",
    SJ = r => {
        const {
            separator: e,
            experimentalParseClassName: t
        } = r, n = e.length === 1, i = e[0], s = e.length, o = a => {
            const l = [];
            let c = 0,
                u = 0,
                f;
            for (let v = 0; v < a.length; v++) {
                let _ = a[v];
                if (c === 0) {
                    if (_ === i && (n || a.slice(v, v + s) === e)) {
                        l.push(a.slice(u, v)), u = v + s;
                        continue
                    }
                    if (_ === "/") {
                        f = v;
                        continue
                    }
                }
                _ === "[" ? c++ : _ === "]" && c--
            }
            const d = l.length === 0 ? a : a.substring(u),
                m = d.startsWith(H3),
                g = m ? d.substring(1) : d,
                y = f && f > u ? f - u : void 0;
            return {
                modifiers: l,
                hasImportantModifier: m,
                baseClassName: g,
                maybePostfixModifierPosition: y
            }
        };
        return t ? a => t({
            className: a,
            parseClassName: o
        }) : o
    },
    MJ = r => {
        if (r.length <= 1) return r;
        const e = [];
        let t = [];
        return r.forEach(n => {
            n[0] === "[" ? (e.push(...t.sort(), n), t = []) : t.push(n)
        }), e.push(...t.sort()), e
    },
    wJ = r => ({
        cache: AJ(r.cacheSize),
        parseClassName: SJ(r),
        ...gJ(r)
    }),
    bJ = /\s+/,
    TJ = (r, e) => {
        const {
            parseClassName: t,
            getClassGroupId: n,
            getConflictingClassGroupIds: i
        } = e, s = [], o = r.trim().split(bJ);
        let a = "";
        for (let l = o.length - 1; l >= 0; l -= 1) {
            const c = o[l],
                {
                    modifiers: u,
                    hasImportantModifier: f,
                    baseClassName: d,
                    maybePostfixModifierPosition: m
                } = t(c);
            let g = !!m,
                y = n(g ? d.substring(0, m) : d);
            if (!y) {
                if (!g) {
                    a = c + (a.length > 0 ? " " + a : a);
                    continue
                }
                if (y = n(d), !y) {
                    a = c + (a.length > 0 ? " " + a : a);
                    continue
                }
                g = !1
            }
            const v = MJ(u).join(":"),
                _ = f ? v + H3 : v,
                A = _ + y;
            if (s.includes(A)) continue;
            s.push(A);
            const S = i(y, g);
            for (let M = 0; M < S.length; ++M) {
                const C = S[M];
                s.push(_ + C)
            }
            a = c + (a.length > 0 ? " " + a : a)
        }
        return a
    };

function EJ() {
    let r = 0,
        e, t, n = "";
    for (; r < arguments.length;)(e = arguments[r++]) && (t = V3(e)) && (n && (n += " "), n += t);
    return n
}
const V3 = r => {
    if (typeof r == "string") return r;
    let e, t = "";
    for (let n = 0; n < r.length; n++) r[n] && (e = V3(r[n])) && (t && (t += " "), t += e);
    return t
};

function CJ(r, ...e) {
    let t, n, i, s = o;

    function o(l) {
        const c = e.reduce((u, f) => f(u), r());
        return t = wJ(c), n = t.cache.get, i = t.cache.set, s = a, a(l)
    }

    function a(l) {
        const c = n(l);
        if (c) return c;
        const u = TJ(l, t);
        return i(l, u), u
    }
    return function() {
        return s(EJ.apply(null, arguments))
    }
}
const Hn = r => {
        const e = t => t[r] || [];
        return e.isThemeGetter = !0, e
    },
    W3 = /^\[(?:([a-z-]+):)?(.+)\]$/i,
    RJ = /^\d+\/\d+$/,
    PJ = new Set(["px", "full", "screen"]),
    IJ = /^(\d+(\.\d+)?)?(xs|sm|md|lg|xl)$/,
    BJ = /\d+(%|px|r?em|[sdl]?v([hwib]|min|max)|pt|pc|in|cm|mm|cap|ch|ex|r?lh|cq(w|h|i|b|min|max))|\b(calc|min|max|clamp)\(.+\)|^0$/,
    DJ = /^(rgba?|hsla?|hwb|(ok)?(lab|lch))\(.+\)$/,
    LJ = /^(inset_)?-?((\d+)?\.?(\d+)[a-z]+|0)_-?((\d+)?\.?(\d+)[a-z]+|0)/,
    FJ = /^(url|image|image-set|cross-fade|element|(repeating-)?(linear|radial|conic)-gradient)\(.+\)$/,
    ia = r => Ff(r) || PJ.has(r) || RJ.test(r),
    Ja = r => vh(r, "length", VJ),
    Ff = r => !!r && !Number.isNaN(Number(r)),
    b1 = r => vh(r, "number", Ff),
    fd = r => !!r && Number.isInteger(Number(r)),
    UJ = r => r.endsWith("%") && Ff(r.slice(0, -1)),
    Qt = r => W3.test(r),
    Ka = r => IJ.test(r),
    OJ = new Set(["length", "size", "percentage"]),
    NJ = r => vh(r, OJ, j3),
    kJ = r => vh(r, "position", j3),
    zJ = new Set(["image", "url"]),
    GJ = r => vh(r, zJ, jJ),
    HJ = r => vh(r, "", WJ),
    hd = () => !0,
    vh = (r, e, t) => {
        const n = W3.exec(r);
        return n ? n[1] ? typeof e == "string" ? n[1] === e : e.has(n[1]) : t(n[2]) : !1
    },
    VJ = r => BJ.test(r) && !DJ.test(r),
    j3 = () => !1,
    WJ = r => LJ.test(r),
    jJ = r => FJ.test(r),
    XJ = () => {
        const r = Hn("colors"),
            e = Hn("spacing"),
            t = Hn("blur"),
            n = Hn("brightness"),
            i = Hn("borderColor"),
            s = Hn("borderRadius"),
            o = Hn("borderSpacing"),
            a = Hn("borderWidth"),
            l = Hn("contrast"),
            c = Hn("grayscale"),
            u = Hn("hueRotate"),
            f = Hn("invert"),
            d = Hn("gap"),
            m = Hn("gradientColorStops"),
            g = Hn("gradientColorStopPositions"),
            y = Hn("inset"),
            v = Hn("margin"),
            _ = Hn("opacity"),
            A = Hn("padding"),
            S = Hn("saturate"),
            M = Hn("scale"),
            C = Hn("sepia"),
            E = Hn("skew"),
            R = Hn("space"),
            P = Hn("translate"),
            b = () => ["auto", "contain", "none"],
            T = () => ["auto", "hidden", "clip", "visible", "scroll"],
            L = () => ["auto", Qt, e],
            D = () => [Qt, e],
            V = () => ["", ia, Ja],
            H = () => ["auto", Ff, Qt],
            q = () => ["bottom", "center", "left", "left-bottom", "left-top", "right", "right-bottom", "right-top", "top"],
            X = () => ["solid", "dashed", "dotted", "double", "none"],
            oe = () => ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn", "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"],
            Y = () => ["start", "end", "center", "between", "around", "evenly", "stretch"],
            Z = () => ["", "0", Qt],
            U = () => ["auto", "avoid", "all", "avoid-page", "page", "left", "right", "column"],
            j = () => [Ff, Qt];
        return {
            cacheSize: 500,
            separator: ":",
            theme: {
                colors: [hd],
                spacing: [ia, Ja],
                blur: ["none", "", Ka, Qt],
                brightness: j(),
                borderColor: [r],
                borderRadius: ["none", "", "full", Ka, Qt],
                borderSpacing: D(),
                borderWidth: V(),
                contrast: j(),
                grayscale: Z(),
                hueRotate: j(),
                invert: Z(),
                gap: D(),
                gradientColorStops: [r],
                gradientColorStopPositions: [UJ, Ja],
                inset: L(),
                margin: L(),
                opacity: j(),
                padding: D(),
                saturate: j(),
                scale: j(),
                sepia: Z(),
                skew: j(),
                space: D(),
                translate: D()
            },
            classGroups: {
                aspect: [{
                    aspect: ["auto", "square", "video", Qt]
                }],
                container: ["container"],
                columns: [{
                    columns: [Ka]
                }],
                "break-after": [{
                    "break-after": U()
                }],
                "break-before": [{
                    "break-before": U()
                }],
                "break-inside": [{
                    "break-inside": ["auto", "avoid", "avoid-page", "avoid-column"]
                }],
                "box-decoration": [{
                    "box-decoration": ["slice", "clone"]
                }],
                box: [{
                    box: ["border", "content"]
                }],
                display: ["block", "inline-block", "inline", "flex", "inline-flex", "table", "inline-table", "table-caption", "table-cell", "table-column", "table-column-group", "table-footer-group", "table-header-group", "table-row-group", "table-row", "flow-root", "grid", "inline-grid", "contents", "list-item", "hidden"],
                float: [{
                    float: ["right", "left", "none", "start", "end"]
                }],
                clear: [{
                    clear: ["left", "right", "both", "none", "start", "end"]
                }],
                isolation: ["isolate", "isolation-auto"],
                "object-fit": [{
                    object: ["contain", "cover", "fill", "none", "scale-down"]
                }],
                "object-position": [{
                    object: [...q(), Qt]
                }],
                overflow: [{
                    overflow: T()
                }],
                "overflow-x": [{
                    "overflow-x": T()
                }],
                "overflow-y": [{
                    "overflow-y": T()
                }],
                overscroll: [{
                    overscroll: b()
                }],
                "overscroll-x": [{
                    "overscroll-x": b()
                }],
                "overscroll-y": [{
                    "overscroll-y": b()
                }],
                position: ["static", "fixed", "absolute", "relative", "sticky"],
                inset: [{
                    inset: [y]
                }],
                "inset-x": [{
                    "inset-x": [y]
                }],
                "inset-y": [{
                    "inset-y": [y]
                }],
                start: [{
                    start: [y]
                }],
                end: [{
                    end: [y]
                }],
                top: [{
                    top: [y]
                }],
                right: [{
                    right: [y]
                }],
                bottom: [{
                    bottom: [y]
                }],
                left: [{
                    left: [y]
                }],
                visibility: ["visible", "invisible", "collapse"],
                z: [{
                    z: ["auto", fd, Qt]
                }],
                basis: [{
                    basis: L()
                }],
                "flex-direction": [{
                    flex: ["row", "row-reverse", "col", "col-reverse"]
                }],
                "flex-wrap": [{
                    flex: ["wrap", "wrap-reverse", "nowrap"]
                }],
                flex: [{
                    flex: ["1", "auto", "initial", "none", Qt]
                }],
                grow: [{
                    grow: Z()
                }],
                shrink: [{
                    shrink: Z()
                }],
                order: [{
                    order: ["first", "last", "none", fd, Qt]
                }],
                "grid-cols": [{
                    "grid-cols": [hd]
                }],
                "col-start-end": [{
                    col: ["auto", {
                        span: ["full", fd, Qt]
                    }, Qt]
                }],
                "col-start": [{
                    "col-start": H()
                }],
                "col-end": [{
                    "col-end": H()
                }],
                "grid-rows": [{
                    "grid-rows": [hd]
                }],
                "row-start-end": [{
                    row: ["auto", {
                        span: [fd, Qt]
                    }, Qt]
                }],
                "row-start": [{
                    "row-start": H()
                }],
                "row-end": [{
                    "row-end": H()
                }],
                "grid-flow": [{
                    "grid-flow": ["row", "col", "dense", "row-dense", "col-dense"]
                }],
                "auto-cols": [{
                    "auto-cols": ["auto", "min", "max", "fr", Qt]
                }],
                "auto-rows": [{
                    "auto-rows": ["auto", "min", "max", "fr", Qt]
                }],
                gap: [{
                    gap: [d]
                }],
                "gap-x": [{
                    "gap-x": [d]
                }],
                "gap-y": [{
                    "gap-y": [d]
                }],
                "justify-content": [{
                    justify: ["normal", ...Y()]
                }],
                "justify-items": [{
                    "justify-items": ["start", "end", "center", "stretch"]
                }],
                "justify-self": [{
                    "justify-self": ["auto", "start", "end", "center", "stretch"]
                }],
                "align-content": [{
                    content: ["normal", ...Y(), "baseline"]
                }],
                "align-items": [{
                    items: ["start", "end", "center", "baseline", "stretch"]
                }],
                "align-self": [{
                    self: ["auto", "start", "end", "center", "stretch", "baseline"]
                }],
                "place-content": [{
                    "place-content": [...Y(), "baseline"]
                }],
                "place-items": [{
                    "place-items": ["start", "end", "center", "baseline", "stretch"]
                }],
                "place-self": [{
                    "place-self": ["auto", "start", "end", "center", "stretch"]
                }],
                p: [{
                    p: [A]
                }],
                px: [{
                    px: [A]
                }],
                py: [{
                    py: [A]
                }],
                ps: [{
                    ps: [A]
                }],
                pe: [{
                    pe: [A]
                }],
                pt: [{
                    pt: [A]
                }],
                pr: [{
                    pr: [A]
                }],
                pb: [{
                    pb: [A]
                }],
                pl: [{
                    pl: [A]
                }],
                m: [{
                    m: [v]
                }],
                mx: [{
                    mx: [v]
                }],
                my: [{
                    my: [v]
                }],
                ms: [{
                    ms: [v]
                }],
                me: [{
                    me: [v]
                }],
                mt: [{
                    mt: [v]
                }],
                mr: [{
                    mr: [v]
                }],
                mb: [{
                    mb: [v]
                }],
                ml: [{
                    ml: [v]
                }],
                "space-x": [{
                    "space-x": [R]
                }],
                "space-x-reverse": ["space-x-reverse"],
                "space-y": [{
                    "space-y": [R]
                }],
                "space-y-reverse": ["space-y-reverse"],
                w: [{
                    w: ["auto", "min", "max", "fit", "svw", "lvw", "dvw", Qt, e]
                }],
                "min-w": [{
                    "min-w": [Qt, e, "min", "max", "fit"]
                }],
                "max-w": [{
                    "max-w": [Qt, e, "none", "full", "min", "max", "fit", "prose", {
                        screen: [Ka]
                    }, Ka]
                }],
                h: [{
                    h: [Qt, e, "auto", "min", "max", "fit", "svh", "lvh", "dvh"]
                }],
                "min-h": [{
                    "min-h": [Qt, e, "min", "max", "fit", "svh", "lvh", "dvh"]
                }],
                "max-h": [{
                    "max-h": [Qt, e, "min", "max", "fit", "svh", "lvh", "dvh"]
                }],
                size: [{
                    size: [Qt, e, "auto", "min", "max", "fit"]
                }],
                "font-size": [{
                    text: ["base", Ka, Ja]
                }],
                "font-smoothing": ["antialiased", "subpixel-antialiased"],
                "font-style": ["italic", "not-italic"],
                "font-weight": [{
                    font: ["thin", "extralight", "light", "normal", "medium", "semibold", "bold", "extrabold", "black", b1]
                }],
                "font-family": [{
                    font: [hd]
                }],
                "fvn-normal": ["normal-nums"],
                "fvn-ordinal": ["ordinal"],
                "fvn-slashed-zero": ["slashed-zero"],
                "fvn-figure": ["lining-nums", "oldstyle-nums"],
                "fvn-spacing": ["proportional-nums", "tabular-nums"],
                "fvn-fraction": ["diagonal-fractions", "stacked-fractions"],
                tracking: [{
                    tracking: ["tighter", "tight", "normal", "wide", "wider", "widest", Qt]
                }],
                "line-clamp": [{
                    "line-clamp": ["none", Ff, b1]
                }],
                leading: [{
                    leading: ["none", "tight", "snug", "normal", "relaxed", "loose", ia, Qt]
                }],
                "list-image": [{
                    "list-image": ["none", Qt]
                }],
                "list-style-type": [{
                    list: ["none", "disc", "decimal", Qt]
                }],
                "list-style-position": [{
                    list: ["inside", "outside"]
                }],
                "placeholder-color": [{
                    placeholder: [r]
                }],
                "placeholder-opacity": [{
                    "placeholder-opacity": [_]
                }],
                "text-alignment": [{
                    text: ["left", "center", "right", "justify", "start", "end"]
                }],
                "text-color": [{
                    text: [r]
                }],
                "text-opacity": [{
                    "text-opacity": [_]
                }],
                "text-decoration": ["underline", "overline", "line-through", "no-underline"],
                "text-decoration-style": [{
                    decoration: [...X(), "wavy"]
                }],
                "text-decoration-thickness": [{
                    decoration: ["auto", "from-font", ia, Ja]
                }],
                "underline-offset": [{
                    "underline-offset": ["auto", ia, Qt]
                }],
                "text-decoration-color": [{
                    decoration: [r]
                }],
                "text-transform": ["uppercase", "lowercase", "capitalize", "normal-case"],
                "text-overflow": ["truncate", "text-ellipsis", "text-clip"],
                "text-wrap": [{
                    text: ["wrap", "nowrap", "balance", "pretty"]
                }],
                indent: [{
                    indent: D()
                }],
                "vertical-align": [{
                    align: ["baseline", "top", "middle", "bottom", "text-top", "text-bottom", "sub", "super", Qt]
                }],
                whitespace: [{
                    whitespace: ["normal", "nowrap", "pre", "pre-line", "pre-wrap", "break-spaces"]
                }],
                break: [{
                    break: ["normal", "words", "all", "keep"]
                }],
                hyphens: [{
                    hyphens: ["none", "manual", "auto"]
                }],
                content: [{
                    content: ["none", Qt]
                }],
                "bg-attachment": [{
                    bg: ["fixed", "local", "scroll"]
                }],
                "bg-clip": [{
                    "bg-clip": ["border", "padding", "content", "text"]
                }],
                "bg-opacity": [{
                    "bg-opacity": [_]
                }],
                "bg-origin": [{
                    "bg-origin": ["border", "padding", "content"]
                }],
                "bg-position": [{
                    bg: [...q(), kJ]
                }],
                "bg-repeat": [{
                    bg: ["no-repeat", {
                        repeat: ["", "x", "y", "round", "space"]
                    }]
                }],
                "bg-size": [{
                    bg: ["auto", "cover", "contain", NJ]
                }],
                "bg-image": [{
                    bg: ["none", {
                        "gradient-to": ["t", "tr", "r", "br", "b", "bl", "l", "tl"]
                    }, GJ]
                }],
                "bg-color": [{
                    bg: [r]
                }],
                "gradient-from-pos": [{
                    from: [g]
                }],
                "gradient-via-pos": [{
                    via: [g]
                }],
                "gradient-to-pos": [{
                    to: [g]
                }],
                "gradient-from": [{
                    from: [m]
                }],
                "gradient-via": [{
                    via: [m]
                }],
                "gradient-to": [{
                    to: [m]
                }],
                rounded: [{
                    rounded: [s]
                }],
                "rounded-s": [{
                    "rounded-s": [s]
                }],
                "rounded-e": [{
                    "rounded-e": [s]
                }],
                "rounded-t": [{
                    "rounded-t": [s]
                }],
                "rounded-r": [{
                    "rounded-r": [s]
                }],
                "rounded-b": [{
                    "rounded-b": [s]
                }],
                "rounded-l": [{
                    "rounded-l": [s]
                }],
                "rounded-ss": [{
                    "rounded-ss": [s]
                }],
                "rounded-se": [{
                    "rounded-se": [s]
                }],
                "rounded-ee": [{
                    "rounded-ee": [s]
                }],
                "rounded-es": [{
                    "rounded-es": [s]
                }],
                "rounded-tl": [{
                    "rounded-tl": [s]
                }],
                "rounded-tr": [{
                    "rounded-tr": [s]
                }],
                "rounded-br": [{
                    "rounded-br": [s]
                }],
                "rounded-bl": [{
                    "rounded-bl": [s]
                }],
                "border-w": [{
                    border: [a]
                }],
                "border-w-x": [{
                    "border-x": [a]
                }],
                "border-w-y": [{
                    "border-y": [a]
                }],
                "border-w-s": [{
                    "border-s": [a]
                }],
                "border-w-e": [{
                    "border-e": [a]
                }],
                "border-w-t": [{
                    "border-t": [a]
                }],
                "border-w-r": [{
                    "border-r": [a]
                }],
                "border-w-b": [{
                    "border-b": [a]
                }],
                "border-w-l": [{
                    "border-l": [a]
                }],
                "border-opacity": [{
                    "border-opacity": [_]
                }],
                "border-style": [{
                    border: [...X(), "hidden"]
                }],
                "divide-x": [{
                    "divide-x": [a]
                }],
                "divide-x-reverse": ["divide-x-reverse"],
                "divide-y": [{
                    "divide-y": [a]
                }],
                "divide-y-reverse": ["divide-y-reverse"],
                "divide-opacity": [{
                    "divide-opacity": [_]
                }],
                "divide-style": [{
                    divide: X()
                }],
                "border-color": [{
                    border: [i]
                }],
                "border-color-x": [{
                    "border-x": [i]
                }],
                "border-color-y": [{
                    "border-y": [i]
                }],
                "border-color-s": [{
                    "border-s": [i]
                }],
                "border-color-e": [{
                    "border-e": [i]
                }],
                "border-color-t": [{
                    "border-t": [i]
                }],
                "border-color-r": [{
                    "border-r": [i]
                }],
                "border-color-b": [{
                    "border-b": [i]
                }],
                "border-color-l": [{
                    "border-l": [i]
                }],
                "divide-color": [{
                    divide: [i]
                }],
                "outline-style": [{
                    outline: ["", ...X()]
                }],
                "outline-offset": [{
                    "outline-offset": [ia, Qt]
                }],
                "outline-w": [{
                    outline: [ia, Ja]
                }],
                "outline-color": [{
                    outline: [r]
                }],
                "ring-w": [{
                    ring: V()
                }],
                "ring-w-inset": ["ring-inset"],
                "ring-color": [{
                    ring: [r]
                }],
                "ring-opacity": [{
                    "ring-opacity": [_]
                }],
                "ring-offset-w": [{
                    "ring-offset": [ia, Ja]
                }],
                "ring-offset-color": [{
                    "ring-offset": [r]
                }],
                shadow: [{
                    shadow: ["", "inner", "none", Ka, HJ]
                }],
                "shadow-color": [{
                    shadow: [hd]
                }],
                opacity: [{
                    opacity: [_]
                }],
                "mix-blend": [{
                    "mix-blend": [...oe(), "plus-lighter", "plus-darker"]
                }],
                "bg-blend": [{
                    "bg-blend": oe()
                }],
                filter: [{
                    filter: ["", "none"]
                }],
                blur: [{
                    blur: [t]
                }],
                brightness: [{
                    brightness: [n]
                }],
                contrast: [{
                    contrast: [l]
                }],
                "drop-shadow": [{
                    "drop-shadow": ["", "none", Ka, Qt]
                }],
                grayscale: [{
                    grayscale: [c]
                }],
                "hue-rotate": [{
                    "hue-rotate": [u]
                }],
                invert: [{
                    invert: [f]
                }],
                saturate: [{
                    saturate: [S]
                }],
                sepia: [{
                    sepia: [C]
                }],
                "backdrop-filter": [{
                    "backdrop-filter": ["", "none"]
                }],
                "backdrop-blur": [{
                    "backdrop-blur": [t]
                }],
                "backdrop-brightness": [{
                    "backdrop-brightness": [n]
                }],
                "backdrop-contrast": [{
                    "backdrop-contrast": [l]
                }],
                "backdrop-grayscale": [{
                    "backdrop-grayscale": [c]
                }],
                "backdrop-hue-rotate": [{
                    "backdrop-hue-rotate": [u]
                }],
                "backdrop-invert": [{
                    "backdrop-invert": [f]
                }],
                "backdrop-opacity": [{
                    "backdrop-opacity": [_]
                }],
                "backdrop-saturate": [{
                    "backdrop-saturate": [S]
                }],
                "backdrop-sepia": [{
                    "backdrop-sepia": [C]
                }],
                "border-collapse": [{
                    border: ["collapse", "separate"]
                }],
                "border-spacing": [{
                    "border-spacing": [o]
                }],
                "border-spacing-x": [{
                    "border-spacing-x": [o]
                }],
                "border-spacing-y": [{
                    "border-spacing-y": [o]
                }],
                "table-layout": [{
                    table: ["auto", "fixed"]
                }],
                caption: [{
                    caption: ["top", "bottom"]
                }],
                transition: [{
                    transition: ["none", "all", "", "colors", "opacity", "shadow", "transform", Qt]
                }],
                duration: [{
                    duration: j()
                }],
                ease: [{
                    ease: ["linear", "in", "out", "in-out", Qt]
                }],
                delay: [{
                    delay: j()
                }],
                animate: [{
                    animate: ["none", "spin", "ping", "pulse", "bounce", Qt]
                }],
                transform: [{
                    transform: ["", "gpu", "none"]
                }],
                scale: [{
                    scale: [M]
                }],
                "scale-x": [{
                    "scale-x": [M]
                }],
                "scale-y": [{
                    "scale-y": [M]
                }],
                rotate: [{
                    rotate: [fd, Qt]
                }],
                "translate-x": [{
                    "translate-x": [P]
                }],
                "translate-y": [{
                    "translate-y": [P]
                }],
                "skew-x": [{
                    "skew-x": [E]
                }],
                "skew-y": [{
                    "skew-y": [E]
                }],
                "transform-origin": [{
                    origin: ["center", "top", "top-right", "right", "bottom-right", "bottom", "bottom-left", "left", "top-left", Qt]
                }],
                accent: [{
                    accent: ["auto", r]
                }],
                appearance: [{
                    appearance: ["none", "auto"]
                }],
                cursor: [{
                    cursor: ["auto", "default", "pointer", "wait", "text", "move", "help", "not-allowed", "none", "context-menu", "progress", "cell", "crosshair", "vertical-text", "alias", "copy", "no-drop", "grab", "grabbing", "all-scroll", "col-resize", "row-resize", "n-resize", "e-resize", "s-resize", "w-resize", "ne-resize", "nw-resize", "se-resize", "sw-resize", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "zoom-in", "zoom-out", Qt]
                }],
                "caret-color": [{
                    caret: [r]
                }],
                "pointer-events": [{
                    "pointer-events": ["none", "auto"]
                }],
                resize: [{
                    resize: ["none", "y", "x", ""]
                }],
                "scroll-behavior": [{
                    scroll: ["auto", "smooth"]
                }],
                "scroll-m": [{
                    "scroll-m": D()
                }],
                "scroll-mx": [{
                    "scroll-mx": D()
                }],
                "scroll-my": [{
                    "scroll-my": D()
                }],
                "scroll-ms": [{
                    "scroll-ms": D()
                }],
                "scroll-me": [{
                    "scroll-me": D()
                }],
                "scroll-mt": [{
                    "scroll-mt": D()
                }],
                "scroll-mr": [{
                    "scroll-mr": D()
                }],
                "scroll-mb": [{
                    "scroll-mb": D()
                }],
                "scroll-ml": [{
                    "scroll-ml": D()
                }],
                "scroll-p": [{
                    "scroll-p": D()
                }],
                "scroll-px": [{
                    "scroll-px": D()
                }],
                "scroll-py": [{
                    "scroll-py": D()
                }],
                "scroll-ps": [{
                    "scroll-ps": D()
                }],
                "scroll-pe": [{
                    "scroll-pe": D()
                }],
                "scroll-pt": [{
                    "scroll-pt": D()
                }],
                "scroll-pr": [{
                    "scroll-pr": D()
                }],
                "scroll-pb": [{
                    "scroll-pb": D()
                }],
                "scroll-pl": [{
                    "scroll-pl": D()
                }],
                "snap-align": [{
                    snap: ["start", "end", "center", "align-none"]
                }],
                "snap-stop": [{
                    snap: ["normal", "always"]
                }],
                "snap-type": [{
                    snap: ["none", "x", "y", "both"]
                }],
                "snap-strictness": [{
                    snap: ["mandatory", "proximity"]
                }],
                touch: [{
                    touch: ["auto", "none", "manipulation"]
                }],
                "touch-x": [{
                    "touch-pan": ["x", "left", "right"]
                }],
                "touch-y": [{
                    "touch-pan": ["y", "up", "down"]
                }],
                "touch-pz": ["touch-pinch-zoom"],
                select: [{
                    select: ["none", "text", "all", "auto"]
                }],
                "will-change": [{
                    "will-change": ["auto", "scroll", "contents", "transform", Qt]
                }],
                fill: [{
                    fill: [r, "none"]
                }],
                "stroke-w": [{
                    stroke: [ia, Ja, b1]
                }],
                stroke: [{
                    stroke: [r, "none"]
                }],
                sr: ["sr-only", "not-sr-only"],
                "forced-color-adjust": [{
                    "forced-color-adjust": ["auto", "none"]
                }]
            },
            conflictingClassGroups: {
                overflow: ["overflow-x", "overflow-y"],
                overscroll: ["overscroll-x", "overscroll-y"],
                inset: ["inset-x", "inset-y", "start", "end", "top", "right", "bottom", "left"],
                "inset-x": ["right", "left"],
                "inset-y": ["top", "bottom"],
                flex: ["basis", "grow", "shrink"],
                gap: ["gap-x", "gap-y"],
                p: ["px", "py", "ps", "pe", "pt", "pr", "pb", "pl"],
                px: ["pr", "pl"],
                py: ["pt", "pb"],
                m: ["mx", "my", "ms", "me", "mt", "mr", "mb", "ml"],
                mx: ["mr", "ml"],
                my: ["mt", "mb"],
                size: ["w", "h"],
                "font-size": ["leading"],
                "fvn-normal": ["fvn-ordinal", "fvn-slashed-zero", "fvn-figure", "fvn-spacing", "fvn-fraction"],
                "fvn-ordinal": ["fvn-normal"],
                "fvn-slashed-zero": ["fvn-normal"],
                "fvn-figure": ["fvn-normal"],
                "fvn-spacing": ["fvn-normal"],
                "fvn-fraction": ["fvn-normal"],
                "line-clamp": ["display", "overflow"],
                rounded: ["rounded-s", "rounded-e", "rounded-t", "rounded-r", "rounded-b", "rounded-l", "rounded-ss", "rounded-se", "rounded-ee", "rounded-es", "rounded-tl", "rounded-tr", "rounded-br", "rounded-bl"],
                "rounded-s": ["rounded-ss", "rounded-es"],
                "rounded-e": ["rounded-se", "rounded-ee"],
                "rounded-t": ["rounded-tl", "rounded-tr"],
                "rounded-r": ["rounded-tr", "rounded-br"],
                "rounded-b": ["rounded-br", "rounded-bl"],
                "rounded-l": ["rounded-tl", "rounded-bl"],
                "border-spacing": ["border-spacing-x", "border-spacing-y"],
                "border-w": ["border-w-s", "border-w-e", "border-w-t", "border-w-r", "border-w-b", "border-w-l"],
                "border-w-x": ["border-w-r", "border-w-l"],
                "border-w-y": ["border-w-t", "border-w-b"],
                "border-color": ["border-color-s", "border-color-e", "border-color-t", "border-color-r", "border-color-b", "border-color-l"],
                "border-color-x": ["border-color-r", "border-color-l"],
                "border-color-y": ["border-color-t", "border-color-b"],
                "scroll-m": ["scroll-mx", "scroll-my", "scroll-ms", "scroll-me", "scroll-mt", "scroll-mr", "scroll-mb", "scroll-ml"],
                "scroll-mx": ["scroll-mr", "scroll-ml"],
                "scroll-my": ["scroll-mt", "scroll-mb"],
                "scroll-p": ["scroll-px", "scroll-py", "scroll-ps", "scroll-pe", "scroll-pt", "scroll-pr", "scroll-pb", "scroll-pl"],
                "scroll-px": ["scroll-pr", "scroll-pl"],
                "scroll-py": ["scroll-pt", "scroll-pb"],
                touch: ["touch-x", "touch-y", "touch-pz"],
                "touch-x": ["touch"],
                "touch-y": ["touch"],
                "touch-pz": ["touch"]
            },
            conflictingClassGroupModifiers: {
                "font-size": ["leading"]
            }
        }
    },
    YJ = CJ(XJ);

function Dp(...r) {
    return YJ(sA(r))
}
const T1 = N.memo(r => {
        const {
            progress: e,
            handleMouseEnter: t,
            handleMouseLeave: n
        } = xw(), [i, s] = N.useState(!1), [o, a] = N.useState(!1), [l, c] = N.useState({
            x: 0,
            y: 0
        }), u = mh(gh, .5), f = g => {
            const y = g.currentTarget.getBoundingClientRect();
            c({
                x: g.clientX - y.left,
                y: g.clientY - y.top
            }), s(!0)
        }, d = g => {
            const y = g.currentTarget.getBoundingClientRect();
            c({
                x: g.clientX - y.left,
                y: g.clientY - y.top
            }), setTimeout(() => s(!1), 50)
        }, m = () => {
            a(!0), setTimeout(() => a(!1), 200), window.open("https://fantik.studio", "_blank")
        };
        return G.jsxs(Vt.div, {
            onClick: m,
            className: "icon_lk pointer-events-auto relative bg-black text-white flex items-center justify-center cursor-pointer mr-2",
            onMouseEnter: g => {
                t(), f(g), u()
            },
            onMouseLeave: g => {
                n(), d(g)
            },
            animate: {
                scale: o ? .9 : i ? 1.2 : 1
            },
            transition: {
                scale: {
                    duration: .3,
                    ease: "easeInOut"
                }
            },
            children: [G.jsx("div", {
                className: "icon_lk-content_hover flex items-center justify-center",
                style: {
                    background: e > 0 ? `conic-gradient(white ${e*100}%, transparent ${e*100}%)` : "transparent"
                }
            }), G.jsx("div", {
                className: "icon_lk-content_not-border flex items-center justify-center"
            }), G.jsxs("div", {
                className: "icon_lk-content_text flex items-center justify-center",
                children: [G.jsx(_w, {
                    children: i && G.jsx(Vt.div, {
                        className: "absolute bg-white rounded-full pointer-events-none mix-blend-difference",
                        style: {
                            width: "15px",
                            height: "15px",
                            top: `${l.y}px`,
                            left: `${l.x}px`,
                            transform: "translate(-50%, -50%)"
                        },
                        initial: {
                            width: 15,
                            height: 15,
                            opacity: 1
                        },
                        animate: {
                            width: 500,
                            height: 500,
                            opacity: 1
                        },
                        exit: {
                            width: 15,
                            height: 15,
                            opacity: 1
                        },
                        transition: {
                            initial: {
                                duration: .5,
                                ease: "easeIn"
                            },
                            animate: {
                                duration: .5,
                                ease: "easeOut"
                            },
                            exit: {
                                duration: .5,
                                ease: "easeOut"
                            }
                        }
                    })
                }), G.jsxs("div", {
                    className: "icon-animation",
                    children: [G.jsx("div", {
                        className: "flex items-center justify-center",
                        children: G.jsx(Vt.img, {
                            className: Dp("cursor-pointer mix-blend-difference h-[13px]", r != null && r.isMain ? "w-[21px]" : "w-[14px]"),
                            src: r.iconRef,
                            initial: {
                                y: 7,
                                z: -10
                            },
                            animate: i ? {
                                y: -40
                            } : {
                                y: 7
                            },
                            transition: {
                                duration: .3,
                                ease: "easeInOut"
                            },
                            alt: "icon_ref"
                        })
                    }), G.jsx("div", {
                        className: "flex items-center justify-center",
                        children: G.jsx(Vt.img, {
                            className: Dp("cursor-pointer mix-blend-difference h-[13px]", r != null && r.isMain ? "w-[21px]" : "w-[14px]"),
                            src: r.iconRef,
                            initial: {
                                y: 15,
                                z: -10
                            },
                            animate: i ? {
                                y: -7
                            } : {
                                y: 15
                            },
                            transition: {
                                duration: .3,
                                ease: "easeInOut"
                            },
                            alt: "icon_ref-second"
                        })
                    })]
                })]
            })]
        })
    }),
    JJ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADwAAAA0CAYAAADWr1sfAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAKgSURBVHgB3ZqNkdowEIX3MimADkI6IB2QDuggpILQgUkFcQdcB5cOfB1wqcBQAXTwsjuSc47xv7Xrn29mxzMesPR4knYlTLRAAGw5Io6E4+bjxLGmpcBiVjmRVSQ0d7ybL97FJm40R7ybhwY3S6E5IXPQD9s2bs5XMNywTTCc80eaKNy5FV/2HN84NhSG++QEe6E/OA4cKwrLZTKCZdjyJeLYkh7X0QWz0B05R7ekzzgOKw/bOmwFw5V2InRPtkIz7k9kgNH8bOSJIU1kfgbKn0Lqfzh57hndOZMGeC/ie1dDJcRw8z57foruhN04QEdoCu9qrp0X9COmEMCVfSeE55+rubZ+oT8HGgLC1bdFZITsStqLMIwt9YG/uIeOUPjnrhXECu3rcejMzzzy3ENF2xECMBWhgqSYtaZYNKUk/sAGboHQFCrENX2IEI6kqhGthahIippFBGHFCnGZowlseEg3ymKFQ74BKf+0hy58G3uqATpihW2+kRT6JGg4BMewoqKJlaXgxgoHOpVaxq3YmBx9JghPihbJHrpihdoV+hlhHK9dmAzFCr+pRUf6ik/RsmaFjVjhSF1AO/GyAh/RwlVjscJ/G5FORx5wK+3GxyeOK8crxxufntxbPuNE7kzLii/ctzcaA+jl2UpoLOC2ldY8bBo+kB0R2XMt3rAUPMY59MPctRT8SvaMKvg7x4VsuRRvmAn2aesrGTpdlo4sHZYOXDhE9E/SpzT3mgrOYNFHvnwm3SF+Lbs5imDBuy2itdwep7pqA1y9niIsO5oycPvyZ4Qj1IswusC9cDb0jG1eb9zBuZ2iP5V/jY62aNURYEH7Q3Olp9t7mjNw/3HFHQSvaQnA7anTBrEnWhKoT1+3xbhbBO+Hi1kKS9Ai9/4FcM+cUv8QvDgAAAAASUVORK5CYII=",
    KJ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAADgAAAA0CAYAAADfRPtlAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAALFSURBVHgBzZprceswEEYFoRACIRAMIQxSBg2DhEEK4TIIBEMIBEG4EM6Np7kznlT7siQ7ZyZ/2tVjJX/SaqUEfFPP38dvlzrzaOPL0Zf9a6GPxy9TT57qSp2YOu7ow0kqvONnFmq5pg48+5eNti9WJSfacEwNwfeFfXsr+0M9TfX4qOtmtHfHKw300ToV7KVZv6cGPOo5o5PDg8mPmEt6nP62L9hLI1ylR4dzy78U5JnJvHwO6LM+pAVM5bA5pBoIzIzSofAo41vRL6kW4nq8CLZjoM367SDopLS5FmdmckawPzvbu6PjHiw3xPSofV6D0c4VnUyvSAl5ZiJ6zFIH6bEdBB3U9Hgs2EsB/FiwPWKzT70huFIi6+k0s/GsmKe0FiiRCzE97ll7xQw4OQqdKelRW6AyOr4AujW006OGP4DuAQE9Ej9QZ1bIDpggRy73gq0UwJsDtCm00eOcugC6Negr4aFgrx1eL+kdoZ0eh/SuEItcmh2tVoWYHquPVqtD8CShDMh6oVkUYnpcfLTaFNroMbNlJKPxnBmJkh6lAbmldwQ77TAEyryXHrHTDhMZvx6LudhNwE47zCnp0Z37WR18aYdXzoV6JD12ubVyQd3V2/BSVygXu5Zz2XBimpVP4X+Z36kO7W5kl9YC30H2PrOP7I/u3E9PB617uzwf8eeAuLcDOt1aeZ07E3BuVs4dnqF/If0Oxvi2g71SPqJHd2zbyrkDNuZqRyA8Y62jFQ3v7YhfzY2CbRs94twOFtQpZr4DtkOqBTuAXvTogNjVnHa02qWl4Lu326WFENOjey/1Nn6mo3PPNtx6JLiXWg1/YdPkKEPg6Qot9EjNw7flTmp6/Hz5jYrth9XQZvd2tHlKdkuVznW7t6Pd007xWeVoFGzyBs1w0iMPi9+pDjpvB0EnWzztzPzXI1s/4yg7aR3HPFz/AemAYNlkeBV5AAAAAElFTkSuQmCC",
    qJ = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAFYAAAAwCAYAAACL+42wAAAACXBIWXMAACxLAAAsSwGlPZapAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAOtSURBVHgB5ZuBddsgEIbPXqDuBmxQb1B1gmSDeoO4E0SZoO0EcSdIO4GVCeJOIDxBvMEVHqjB8iEBAhuc7z2esQzo9Os4gQwziAwiLsTHUqQbkZjOL3Tq4DodRHoWqZnNZju4ImYQCSFoJT7u4U1IX7hIjUgPQmQOiek5gMzvQd3gBnJAGHgn0ivG5VEkBokYsblNeW4X4yptREoeY1+kbtOFNXgi6iyD7RUVFyJ9x/PRogozk0F3UTu+erS9Muz1C4WiAhPpBS/DPUxA1scwlo7tt0adGlxBJWqLlyVIXFS2h9LiiAfim7d2vPoY1mIeeIuL022vR9p/6ldwMSonUTucxcVTbwpBjiAWA+c4GWG4GPaEeVKBAxjvmVBb2l9ShecjRknPuIU8ecTx2FeBmgTE4M5ynFEHrcKiGo95j+XOCAM10xvCebjkwMLSS8gbN+Sx0uiQqek5WeNwSBj6LQSq936iCpLvCrS3tlAGcn7/pX9QC76FuBzEuT72zvMChNfaPHbSYPzMVD5ddCILPJ2yMqrgibD6gbCCsqC66A2koep9J8Ml5bG5jgKGoB5SKTz2qF0ceOFCCZvqTqfk6Imte12qB+9nI89shShhKyiTpSUfG6cbdiQsqjc5uQ+xbFRGPuU1MJfzzAcqlYY5nmSQECO2vgthmZFP3etG25/7VsgZ9H1zH463sKXTXTCDC3NVHpsTfWEPUDad/RwuzFUJK16QZGN/X1gO5bIz8qkF5mMF+sLuoFz2Rj6psC5LoOZEhVLDwc6Sj42pD7cVooZbDZRJY+Q5pMMp5FDCPkN5cHOVoH6IcUjDXyPvJewGygsHDXEsVTgI81h9t39BWTwQx1L1vP/Caq1IcW1T2t9QDn8sT+kUHsuJleecKkgKq+NVKeKuqYP6GmKHtIY4xqmCQy9hvkH+sXYzMqaMHdKo9vZUQauw2uAHyBcO4/bF7HXcsj8hLOSId5xbzJPbM9u/trRPrr11MUz+A9piXtTgCKq9ElNpceCvbgxZxgmQ3RrZGjzB6V5bj7S/6VcAVzAPcWsIAKd57egaNlHm1rdOTuLWMAFZH8NgDm3LcGmGgxWEICr+wPPRYrztSBvPc6892l539sIUULl/i2mRNzDq/3Do7hTOohpts2j2oto80WJcthjJSwNsludewkRiblJegVpQ5zS+JJCzvJ8wPpuKBqqxcCXSB1CvA3exNilHE7ZDd4UK1MI0uTJPfmdwuq1eCilnLfKCrm5b/T8VqzQ/uLBv4AAAAABJRU5ErkJggg==",
    ZJ = () => G.jsxs("div", {
        className: "flex pointer-events-auto",
        children: [G.jsx(T1, {
            iconRef: KJ
        }, "twiter"), G.jsx(T1, {
            isMain: !0,
            iconRef: qJ
        }, "prog"), G.jsx(T1, {
            iconRef: JJ
        }, "telegram")]
    });
et.registerPlugin(Zt);
const QJ = ({
        mainGroupRef: r,
        animScrollerRef: e
    }) => {
        r.current && (et.set(r.current, {
            x: 0,
            y: 0,
            z: 0
        }), et.timeline({
            scrollTrigger: qt({
                start: "top+=200",
                end: "+=1400"
            })
        }).to(r.current, {
            z: 0,
            y: -3400,
            x: 0,
            ease: "power1.inOut"
        })), e.current && (et.set(e.current, {
            opacity: 1,
            x: 0,
            y: 0,
            z: 0
        }), et.timeline({
            scrollTrigger: qt({
                start: 200,
                end: "+=400"
            })
        }).to(e.current, {
            opacity: 0,
            duration: 1,
            ease: "power1.inOut"
        }))
    },
    $J = ({
        btnGroupRef: r
    }) => {
        r.current && (et.set(r.current, {
            x: 0,
            y: 200,
            z: 0
        }), et.timeline({
            scrollTrigger: qt({
                start: 200,
                end: "+=1200"
            })
        }).to(r.current, {
            z: 0,
            y: 0,
            x: 0
        }))
    },
    eK = ({
        waveGroup: r,
        meshRef: e
    }) => {
        r.current && (et.set(r.current.position, {
            x: 0,
            y: 0,
            z: -10
        }), et.timeline({
            scrollTrigger: qt({
                start: "top+=500",
                end: "+=5000"
            })
        }).to(r.current.position, {
            z: 7,
            y: 0,
            x: 0
        })), e.current && et.timeline({
            scrollTrigger: qt({
                start: "top+=500",
                end: "+=4500"
            })
        }).to(e.current.material, {
            opacity: 0
        })
    },
    tK = ({
        textGroupRef: r
    }) => {
        if (r.current) {
            et.set(r.current.position, {
                x: -1.5,
                y: -10,
                z: 0
            });
            const e = et.timeline({
                    scrollTrigger: qt({
                        start: "top+=500",
                        end: "+=500"
                    })
                }),
                t = et.timeline({
                    scrollTrigger: qt({
                        start: "top+=4000",
                        end: "+=2000"
                    })
                }),
                n = et.timeline({
                    scrollTrigger: qt({
                        start: "top+=500",
                        end: "+=5000"
                    })
                });
            e.to(r.current.position, {
                y: 1.5,
                x: -1.5
            }), t.to(r.current.position, {
                y: 10
            }), n.to(r.current.position, {
                z: 6
            })
        }
    },
    nK = ({
        cardGroup: r,
        cardOne: e,
        cardSecond: t,
        cardThird: n
    }) => {
        r.current && (et.set(r.current.position, {
            x: 0,
            y: -10,
            z: 0
        }), et.timeline({
            scrollTrigger: qt({
                start: "top+=7000",
                end: "+=4000"
            })
        }).to(r.current.position, {
            y: 20
        })), e.current && (et.set(e.current.position, {
            x: -2,
            y: -2.5,
            z: 0
        }), et.to(e.current.rotation, {
            y: -Math.PI,
            scrollTrigger: qt({
                start: "top+=7580",
                end: "+=420"
            })
        })), t.current && (et.set(t.current.position, {
            x: 2,
            y: -5.5,
            z: 0
        }), et.to(t.current.rotation, {
            y: Math.PI,
            scrollTrigger: qt({
                start: "top+=7900",
                end: "+=420"
            })
        })), n.current && (et.set(n.current.position, {
            x: -2,
            y: -8.5,
            z: 0
        }), et.to(n.current.rotation, {
            y: -Math.PI,
            scrollTrigger: qt({
                start: "top+=8100",
                end: "+=420"
            })
        }))
    },
    iK = ({
        contentGroup: r,
        carouselGroup: e
    }) => {
        if (r.current) {
            et.set(r.current.position, {
                x: 0,
                y: -10,
                z: -5
            });
            const t = et.timeline({
                    scrollTrigger: qt({
                        start: "top+=3400",
                        end: "+=1200"
                    })
                }),
                n = et.timeline({
                    scrollTrigger: qt({
                        start: "top+=6600",
                        end: "+=2200"
                    })
                });
            t.to(r.current.position, {
                y: 0
            }), n.to(r.current.position, {
                y: 2
            })
        }
        e.current && (et.set(e.current.position, {
            x: 0,
            y: 0,
            z: 0
        }), et.timeline({
            scrollTrigger: qt({
                start: "top+=4000",
                end: "+=6000"
            })
        }).to(e.current.rotation, {
            x: "-=5"
        }))
    },
    rK = ({
        modelOneGroup: r,
        modelTwoGroup: e,
        modelThreeGroup: t,
        modelFourGroup: n
    }) => {
        r.current && (et.set(r.current.position, {
            x: 2.1,
            y: -.1,
            z: -.15
        }), et.set(r.current.scale, {
            x: .3,
            y: .3,
            z: .3
        }), et.to(r.current.scale, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            x: 1,
            y: 1,
            z: 1,
            scrollTrigger: qt({
                start: "top+=5880",
                end: "+=1500"
            })
        }), et.to(r.current.rotation, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            y: "+=" + Math.PI,
            scrollTrigger: qt({
                start: "top+=5880",
                end: "+=2000"
            })
        })), e.current && (et.set(e.current.position, {
            x: 1.55,
            y: -.1,
            z: -.15
        }), et.set(e.current.scale, {
            x: .3,
            y: .3,
            z: .3
        }), et.to(e.current.scale, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            x: 1,
            y: 1,
            z: 1,
            scrollTrigger: qt({
                start: "top+=5500",
                end: "+=1500"
            })
        }), et.to(e.current.rotation, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            y: "+=" + Math.PI,
            scrollTrigger: qt({
                start: "top+=5500",
                end: "+=2000"
            })
        })), t.current && (et.set(t.current.position, {
            x: 2.3,
            y: 0,
            z: -.15
        }), et.set(t.current.scale, {
            x: .3,
            y: .3,
            z: .3
        }), et.to(t.current.scale, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            x: 1,
            y: 1,
            z: 1,
            scrollTrigger: qt({
                start: "top+=5020",
                end: "+=1500"
            })
        }), et.to(t.current.rotation, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            y: "+=" + Math.PI,
            scrollTrigger: qt({
                start: "top+=5020",
                end: "+=2000"
            })
        })), n.current && (et.set(n.current.position, {
            x: 2.5,
            y: .13,
            z: -.15
        }), et.set(n.current.scale, {
            x: .3,
            y: .3,
            z: .3
        }), et.to(n.current.scale, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            x: 1,
            y: 1,
            z: 1,
            scrollTrigger: qt({
                start: "top+=4680",
                end: "+=1500"
            })
        }), et.to(n.current.rotation, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            y: "+=" + Math.PI,
            scrollTrigger: qt({
                start: "top+=4680",
                end: "+=2000"
            })
        }))
    },
    sK = ({
        waveMesh: r
    }) => {
        r && (et.set(r.position, {
            x: 0,
            y: 0,
            z: 0
        }), et.to(r.position, {
            y: "+=16",
            scrollTrigger: qt({
                start: "top+=9000",
                end: "+=2000"
            })
        }))
    },
    oK = ({
        yOffsetRef: r
    }) => {
        r.current && (et.set(r.current, {
            value: 8
        }), et.timeline({
            scrollTrigger: qt({
                start: "top+=9000",
                end: "+=2000"
            })
        }).to(r.current, {
            value: -8
        }))
    },
    aK = ({
        groupMesh: r
    }) => {
        et.set(r.position, {
            x: 0,
            y: -20,
            z: 0
        }), et.timeline({
            scrollTrigger: qt({
                start: "top+=10000",
                end: "+=1000"
            })
        }).to(r.position, {
            y: 0
        })
    },
    lK = ({
        effect: r
    }) => {
        const e = r.uniforms.get("uIntensivity");
        if (!e) return;
        et.timeline({
            scrollTrigger: qt({
                start: "top+=6800",
                end: "+=250"
            })
        }).to(e, {
            value: 1
        })
    },
    cK = ({
        scrollUniform: r
    }) => {
        et.timeline({
            scrollTrigger: qt({
                start: "top+=0",
                end: "+=11000"
            })
        }).to(r, {
            value: -5,
            ease: "none"
        })
    },
    uK = N.memo(() => {
        const {
            isSoundOn: r,
            toggleSound: e
        } = hm(), {
            progress: t,
            handleMouseEnter: n,
            handleMouseLeave: i
        } = xw(), [s, o] = N.useState(!1), [a, l] = N.useState(!1), [c, u] = N.useState({
            x: 0,
            y: 0
        }), f = mh(gh, .5), d = y => {
            const v = y.currentTarget.getBoundingClientRect();
            u({
                x: y.clientX - v.left,
                y: y.clientY - v.top
            }), o(!0)
        }, m = y => {
            const v = y.currentTarget.getBoundingClientRect();
            u({
                x: y.clientX - v.left,
                y: y.clientY - v.top
            }), setTimeout(() => o(!1), 50)
        }, g = () => {
            l(!0), e(), setTimeout(() => l(!1), 200)
        };
        return G.jsxs(Vt.div, {
            onClick: g,
            className: "icon_lk pointer-events-auto relative bg-black text-white flex items-center justify-center cursor-pointer mr-2",
            onMouseEnter: y => {
                n(), d(y), f()
            },
            onMouseLeave: y => {
                i(), m(y)
            },
            animate: {
                scale: a ? .9 : s ? 1.2 : 1
            },
            transition: {
                scale: {
                    duration: .3,
                    ease: "easeInOut"
                }
            },
            children: [G.jsx("div", {
                className: "icon_lk-content_hover flex items-center justify-center",
                style: {
                    background: t > 0 ? `conic-gradient(white ${t*100}%, transparent ${t*100}%)` : "transparent"
                }
            }), G.jsx("div", {
                className: "icon_lk-content_not-border flex items-center justify-center"
            }), G.jsxs("div", {
                className: "icon_lk-content_text flex items-center justify-center",
                children: [G.jsx(_w, {
                    children: s && G.jsx(Vt.div, {
                        className: "absolute bg-white rounded-full pointer-events-none mix-blend-difference",
                        style: {
                            width: "15px",
                            height: "15px",
                            top: `${c.y}px`,
                            left: `${c.x}px`,
                            transform: "translate(-50%, -50%)"
                        },
                        initial: {
                            width: 15,
                            height: 15,
                            opacity: 1
                        },
                        animate: {
                            width: 500,
                            height: 500,
                            opacity: 1
                        },
                        exit: {
                            width: 15,
                            height: 15,
                            opacity: 1
                        },
                        transition: {
                            initial: {
                                duration: .5,
                                ease: "easeIn"
                            },
                            animate: {
                                duration: .5,
                                ease: "easeOut"
                            },
                            exit: {
                                duration: .5,
                                ease: "easeOut"
                            }
                        }
                    })
                }), G.jsxs("div", {
                    className: "icon-animation",
                    children: [G.jsx("div", {
                        className: "flex items-center justify-center",
                        children: G.jsx(Vt.div, {
                            className: "circle-container pointer-events-auto mix-blend-difference",
                            initial: {
                                y: 10,
                                z: -10
                            },
                            animate: s ? {
                                y: -20
                            } : {
                                y: 10
                            },
                            transition: {
                                duration: .3,
                                ease: "easeInOut"
                            },
                            children: G.jsx(Vt.div, {
                                className: "lines",
                                children: [...Array(5)].map((y, v) => G.jsx("span", {
                                    className: Dp("line", r ? "" : "not-active")
                                }, v))
                            })
                        })
                    }), G.jsx("div", {
                        className: "flex items-center justify-center",
                        children: G.jsx(Vt.div, {
                            className: "circle-container pointer-events-auto mix-blend-difference",
                            initial: {
                                y: 18,
                                z: -10
                            },
                            animate: s ? {
                                y: -10
                            } : {
                                y: 18
                            },
                            transition: {
                                duration: .3,
                                ease: "easeInOut"
                            },
                            children: G.jsx(Vt.div, {
                                className: "lines",
                                children: [...Array(5)].map((y, v) => G.jsx("span", {
                                    className: Dp("line", r ? "" : "not-active")
                                }, v))
                            })
                        })
                    })]
                })]
            })]
        })
    }),
    fK = () => {
        const r = N.useRef(null),
            [e, t] = N.useState(!1),
            n = mh(gh, .5);
        N.useEffect(() => {
            $J({
                btnGroupRef: r
            })
        });
        const i = () => {
                t(!0), n()
            },
            s = () => {
                setTimeout(() => t(!1), 50)
            },
            o = () => {
                et.to(document.getElementById("root"), {
                    scrollTo: 0,
                    duration: 2
                })
            };
        return G.jsxs(G.Fragment, {
            children: [G.jsx("div", {
                className: "fixed h-full w-full z-[9999] pointer-events-none mix-blend-difference",
                children: G.jsxs("div", {
                    className: "fixed top-10 w-screen items-center justify-between flex px-10",
                    children: [G.jsx("div", {
                        className: "w-96 flex justify-start"
                    }), G.jsx(Vt.div, {
                        className: "w-96 flex justify-center ",
                        children: G.jsx(Vt.div, {
                            onClick: o,
                            className: "pointer-events-auto relative cursor-pointer",
                            animate: {
                                scale: e ? 1.2 : 1
                            },
                            transition: {
                                scale: {
                                    duration: .3,
                                    ease: [0, 0, 0, 1]
                                }
                            },
                            onMouseEnter: i,
                            onMouseLeave: s,
                            children: G.jsx(Vt.img, {
                                src: k3,
                                alt: "logo_main",
                                className: "h-10 w-16"
                            })
                        })
                    }), G.jsx("div", {
                        className: "w-96 flex justify-end",
                        children: G.jsx(mJ, {})
                    })]
                })
            }), G.jsx("div", {
                className: "fixed h-full w-full z-[9999] pointer-events-none",
                children: G.jsxs("div", {
                    className: "fixed bottom-10 w-screen items-center justify-between flex px-10",
                    children: [G.jsx("div", {
                        className: "w-96 flex justify-start",
                        children: G.jsx(ZJ, {})
                    }), G.jsx("div", {
                        className: "w-96 flex justify-center",
                        children: G.jsx(Vt.div, {
                            ref: r,
                            children: G.jsx(Aw, {})
                        })
                    }), G.jsx("div", {
                        className: "w-96 flex justify-end",
                        children: G.jsx(uK, {})
                    })]
                })
            })]
        })
    },
    hK = () => {
        const r = N.useRef([]);
        return N.useEffect(() => {
            r.current.forEach(t => {
                t && et.set(t, {
                    opacity: .4
                })
            });
            const e = et.timeline({
                repeat: -1
            });
            return r.current.forEach((t, n) => {
                e.to(t, {
                    opacity: 1,
                    duration: .3,
                    yoyo: !0,
                    repeat: 1,
                    ease: "power1.inOut"
                }, n * .1)
            }), () => {
                e.kill()
            }
        }, []), G.jsx("div", {
            className: "flex flex-col anim-content",
            children: Array(4).fill(0).map((e, t) => G.jsx("div", {
                ref: n => n && (r.current[t] = n),
                style: {
                    width: "4px",
                    height: "4px",
                    borderRadius: "50%",
                    background: "white",
                    opacity: .4
                }
            }, t))
        })
    },
    dK = () => {
        const r = N.useRef(null),
            e = N.useRef(null);
        return N.useEffect(() => {
            QJ({
                mainGroupRef: r,
                animScrollerRef: e
            })
        }, [r, e]), G.jsxs(G.Fragment, {
            children: [G.jsx(Vt.div, {
                className: "fixed h-full w-full z-[9999] pointer-events-none",
                ref: r,
                children: G.jsxs(Vt.div, {
                    className: "w-screen h-screen flex-col items-center justify-center flex",
                    children: [G.jsxs(Vt.div, {
                        className: "flex flex-row w-[525px] items-center justify-around",
                        children: [G.jsx(Vt.div, {
                            className: "ai-border",
                            children: G.jsx(Vt.p, {
                                className: "text-xs font-necroCosmic",
                                children: "Own the future of AI"
                            })
                        }), G.jsx(Vt.div, {
                            children: G.jsx(Vt.p, {
                                className: "text-xs font-necroCosmic",
                                children: "No technical expertise required"
                            })
                        })]
                    }), G.jsx(Vt.div, {
                        className: "flex w-[510px] items-center justify-center mt-[-30px]",
                        children: G.jsx(Vt.p, {
                            className: "text-[160px] font-necroCosmic",
                            children: "Sage"
                        })
                    }), G.jsx(Aw, {})]
                })
            }), G.jsx(Vt.div, {
                className: "fixed bottom-10 w-screen items-center justify-center flex z-[9999] pointer-events-none",
                ref: e,
                children: G.jsx(hK, {})
            })]
        })
    },
    pK = () => G.jsxs("div", {
        className: "desktop-html",
        children: [G.jsx(fK, {}), G.jsx(dK, {})]
    });
/**
 * postprocessing v6.36.4 build Tue Nov 05 2024
 * https://github.com/pmndrs/postprocessing
 * Copyright 2015-2024 Raoul van Rschen
 * @license Zlib
 */
var E1 = 1 / 1e3,
    mK = 1e3,
    gK = class {
        constructor() {
            this.startTime = performance.now(), this.previousTime = 0, this.currentTime = 0, this._delta = 0, this._elapsed = 0, this._fixedDelta = 1e3 / 60, this.timescale = 1, this.useFixedDelta = !1, this._autoReset = !1
        }
        get autoReset() {
            return this._autoReset
        }
        set autoReset(r) {
            typeof document < "u" && document.hidden !== void 0 && (r ? document.addEventListener("visibilitychange", this) : document.removeEventListener("visibilitychange", this), this._autoReset = r)
        }
        get delta() {
            return this._delta * E1
        }
        get fixedDelta() {
            return this._fixedDelta * E1
        }
        set fixedDelta(r) {
            this._fixedDelta = r * mK
        }
        get elapsed() {
            return this._elapsed * E1
        }
        update(r) {
            this.useFixedDelta ? this._delta = this.fixedDelta : (this.previousTime = this.currentTime, this.currentTime = (r !== void 0 ? r : performance.now()) - this.startTime, this._delta = this.currentTime - this.previousTime), this._delta *= this.timescale, this._elapsed += this._delta
        }
        reset() {
            this._delta = 0, this._elapsed = 0, this.currentTime = performance.now() - this.startTime
        }
        getDelta() {
            return this.delta
        }
        getElapsed() {
            return this.elapsed
        }
        handleEvent(r) {
            document.hidden || (this.currentTime = performance.now() - this.startTime)
        }
        dispose() {
            this.autoReset = !1
        }
    },
    vK = (() => {
        const r = new Float32Array([-1, -1, 0, 3, -1, 0, -1, 3, 0]),
            e = new Float32Array([0, 0, 2, 0, 0, 2]),
            t = new zt;
        return t.setAttribute("position", new an(r, 3)), t.setAttribute("uv", new an(e, 2)), t
    })(),
    vo = class eS {
        static get fullscreenGeometry() {
            return vK
        }
        constructor(e = "Pass", t = new ho, n = new Fl) {
            this.name = e, this.renderer = null, this.scene = t, this.camera = n, this.screen = null, this.rtt = !0, this.needsSwap = !0, this.needsDepthTexture = !1, this.enabled = !0
        }
        get renderToScreen() {
            return !this.rtt
        }
        set renderToScreen(e) {
            if (this.rtt === e) {
                const t = this.fullscreenMaterial;
                t !== null && (t.needsUpdate = !0), this.rtt = !e
            }
        }
        set mainScene(e) {}
        set mainCamera(e) {}
        setRenderer(e) {
            this.renderer = e
        }
        isEnabled() {
            return this.enabled
        }
        setEnabled(e) {
            this.enabled = e
        }
        get fullscreenMaterial() {
            return this.screen !== null ? this.screen.material : null
        }
        set fullscreenMaterial(e) {
            let t = this.screen;
            t !== null ? t.material = e : (t = new Tn(eS.fullscreenGeometry, e), t.frustumCulled = !1, this.scene === null && (this.scene = new ho), this.scene.add(t), this.screen = t)
        }
        getFullscreenMaterial() {
            return this.fullscreenMaterial
        }
        setFullscreenMaterial(e) {
            this.fullscreenMaterial = e
        }
        getDepthTexture() {
            return null
        }
        setDepthTexture(e, t = Bl) {}
        render(e, t, n, i, s) {
            throw new Error("Render method not implemented!")
        }
        setSize(e, t) {}
        initialize(e, t, n) {}
        dispose() {
            for (const e of Object.keys(this)) {
                const t = this[e];
                (t instanceof Zn || t instanceof mi || t instanceof gn || t instanceof eS) && this[e].dispose()
            }
            this.fullscreenMaterial !== null && this.fullscreenMaterial.dispose()
        }
    },
    yK = class extends vo {
        constructor() {
            super("ClearMaskPass", null, null), this.needsSwap = !1
        }
        render(r, e, t, n, i) {
            const s = r.state.buffers.stencil;
            s.setLocked(!1), s.setTest(!1)
        }
    },
    _K = `#include <common>
#include <dithering_pars_fragment>
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
uniform float opacity;varying vec2 vUv;void main(){vec4 texel=texture2D(inputBuffer,vUv);gl_FragColor=opacity*texel;
#include <colorspace_fragment>
#include <dithering_fragment>
}`,
    xK = "varying vec2 vUv;void main(){vUv=position.xy*0.5+0.5;gl_Position=vec4(position.xy,1.0,1.0);}",
    AK = class extends Fn {
        constructor() {
            super({
                name: "CopyMaterial",
                uniforms: {
                    inputBuffer: new Wn(null),
                    opacity: new Wn(1)
                },
                blending: pi,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: _K,
                vertexShader: xK
            })
        }
        set inputBuffer(r) {
            this.uniforms.inputBuffer.value = r
        }
        setInputBuffer(r) {
            this.uniforms.inputBuffer.value = r
        }
        getOpacity(r) {
            return this.uniforms.opacity.value
        }
        setOpacity(r) {
            this.uniforms.opacity.value = r
        }
    },
    SK = class extends vo {
        constructor(r, e = !0) {
            super("CopyPass"), this.fullscreenMaterial = new AK, this.needsSwap = !1, this.renderTarget = r, r === void 0 && (this.renderTarget = new Zn(1, 1, {
                minFilter: nn,
                magFilter: nn,
                stencilBuffer: !1,
                depthBuffer: !1
            }), this.renderTarget.texture.name = "CopyPass.Target"), this.autoResize = e
        }
        get resize() {
            return this.autoResize
        }
        set resize(r) {
            this.autoResize = r
        }
        get texture() {
            return this.renderTarget.texture
        }
        getTexture() {
            return this.renderTarget.texture
        }
        setAutoResizeEnabled(r) {
            this.autoResize = r
        }
        render(r, e, t, n, i) {
            this.fullscreenMaterial.inputBuffer = e.texture, r.setRenderTarget(this.renderToScreen ? null : this.renderTarget), r.render(this.scene, this.camera)
        }
        setSize(r, e) {
            this.autoResize && this.renderTarget.setSize(r, e)
        }
        initialize(r, e, t) {
            t !== void 0 && (this.renderTarget.texture.type = t, t !== Yi ? this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1" : r !== null && r.outputColorSpace === Jn && (this.renderTarget.texture.colorSpace = Jn))
        }
    },
    C2 = new rt,
    X3 = class extends vo {
        constructor(r = !0, e = !0, t = !1) {
            super("ClearPass", null, null), this.needsSwap = !1, this.color = r, this.depth = e, this.stencil = t, this.overrideClearColor = null, this.overrideClearAlpha = -1
        }
        setClearFlags(r, e, t) {
            this.color = r, this.depth = e, this.stencil = t
        }
        getOverrideClearColor() {
            return this.overrideClearColor
        }
        setOverrideClearColor(r) {
            this.overrideClearColor = r
        }
        getOverrideClearAlpha() {
            return this.overrideClearAlpha
        }
        setOverrideClearAlpha(r) {
            this.overrideClearAlpha = r
        }
        render(r, e, t, n, i) {
            const s = this.overrideClearColor,
                o = this.overrideClearAlpha,
                a = r.getClearAlpha(),
                l = s !== null,
                c = o >= 0;
            l ? (r.getClearColor(C2), r.setClearColor(s, c ? o : a)) : c && r.setClearAlpha(o), r.setRenderTarget(this.renderToScreen ? null : e), r.clear(this.color, this.depth, this.stencil), l ? r.setClearColor(C2, a) : c && r.setClearAlpha(a)
        }
    },
    MK = class extends vo {
        constructor(r, e) {
            super("MaskPass", r, e), this.needsSwap = !1, this.clearPass = new X3(!1, !1, !0), this.inverse = !1
        }
        set mainScene(r) {
            this.scene = r
        }
        set mainCamera(r) {
            this.camera = r
        }
        get inverted() {
            return this.inverse
        }
        set inverted(r) {
            this.inverse = r
        }
        get clear() {
            return this.clearPass.enabled
        }
        set clear(r) {
            this.clearPass.enabled = r
        }
        getClearPass() {
            return this.clearPass
        }
        isInverted() {
            return this.inverted
        }
        setInverted(r) {
            this.inverted = r
        }
        render(r, e, t, n, i) {
            const s = r.getContext(),
                o = r.state.buffers,
                a = this.scene,
                l = this.camera,
                c = this.clearPass,
                u = this.inverted ? 0 : 1,
                f = 1 - u;
            o.color.setMask(!1), o.depth.setMask(!1), o.color.setLocked(!0), o.depth.setLocked(!0), o.stencil.setTest(!0), o.stencil.setOp(s.REPLACE, s.REPLACE, s.REPLACE), o.stencil.setFunc(s.ALWAYS, u, 4294967295), o.stencil.setClear(f), o.stencil.setLocked(!0), this.clearPass.enabled && (this.renderToScreen ? c.render(r, null) : (c.render(r, e), c.render(r, t))), this.renderToScreen ? (r.setRenderTarget(null), r.render(a, l)) : (r.setRenderTarget(e), r.render(a, l), r.setRenderTarget(t), r.render(a, l)), o.color.setLocked(!1), o.depth.setLocked(!1), o.stencil.setLocked(!1), o.stencil.setFunc(s.EQUAL, 1, 4294967295), o.stencil.setOp(s.KEEP, s.KEEP, s.KEEP), o.stencil.setLocked(!0)
        }
    },
    wK = class {
        constructor(e = null, {
            depthBuffer: t = !0,
            stencilBuffer: n = !1,
            multisampling: i = 0,
            frameBufferType: s
        } = {}) {
            this.renderer = null, this.inputBuffer = this.createBuffer(t, n, s, i), this.outputBuffer = this.inputBuffer.clone(), this.copyPass = new SK, this.depthTexture = null, this.passes = [], this.timer = new gK, this.autoRenderToScreen = !0, this.setRenderer(e)
        }
        get multisampling() {
            return this.inputBuffer.samples || 0
        }
        set multisampling(e) {
            const t = this.inputBuffer,
                n = this.multisampling;
            n > 0 && e > 0 ? (this.inputBuffer.samples = e, this.outputBuffer.samples = e, this.inputBuffer.dispose(), this.outputBuffer.dispose()) : n !== e && (this.inputBuffer.dispose(), this.outputBuffer.dispose(), this.inputBuffer = this.createBuffer(t.depthBuffer, t.stencilBuffer, t.texture.type, e), this.inputBuffer.depthTexture = this.depthTexture, this.outputBuffer = this.inputBuffer.clone())
        }
        getTimer() {
            return this.timer
        }
        getRenderer() {
            return this.renderer
        }
        setRenderer(e) {
            if (this.renderer = e, e !== null) {
                const t = e.getSize(new Ue),
                    n = e.getContext().getContextAttributes().alpha,
                    i = this.inputBuffer.texture.type;
                i === Yi && e.outputColorSpace === Jn && (this.inputBuffer.texture.colorSpace = Jn, this.outputBuffer.texture.colorSpace = Jn, this.inputBuffer.dispose(), this.outputBuffer.dispose()), e.autoClear = !1, this.setSize(t.width, t.height);
                for (const s of this.passes) s.initialize(e, n, i)
            }
        }
        replaceRenderer(e, t = !0) {
            const n = this.renderer,
                i = n.domElement.parentNode;
            return this.setRenderer(e), t && i !== null && (i.removeChild(n.domElement), i.appendChild(e.domElement)), n
        }
        createDepthTexture() {
            const e = this.depthTexture = new Yp;
            return this.inputBuffer.depthTexture = e, this.inputBuffer.dispose(), this.inputBuffer.stencilBuffer ? (e.format = wl, e.type = Ml) : e.type = fo, e
        }
        deleteDepthTexture() {
            if (this.depthTexture !== null) {
                this.depthTexture.dispose(), this.depthTexture = null, this.inputBuffer.depthTexture = null, this.inputBuffer.dispose();
                for (const e of this.passes) e.setDepthTexture(null)
            }
        }
        createBuffer(e, t, n, i) {
            const s = this.renderer,
                o = s === null ? new Ue : s.getDrawingBufferSize(new Ue),
                a = {
                    minFilter: nn,
                    magFilter: nn,
                    stencilBuffer: t,
                    depthBuffer: e,
                    type: n
                },
                l = new Zn(o.width, o.height, a);
            return i > 0 && (l.ignoreDepthForMultisampleCopy = !1, l.samples = i), n === Yi && s !== null && s.outputColorSpace === Jn && (l.texture.colorSpace = Jn), l.texture.name = "EffectComposer.Buffer", l.texture.generateMipmaps = !1, l
        }
        setMainScene(e) {
            for (const t of this.passes) t.mainScene = e
        }
        setMainCamera(e) {
            for (const t of this.passes) t.mainCamera = e
        }
        addPass(e, t) {
            const n = this.passes,
                i = this.renderer,
                s = i.getDrawingBufferSize(new Ue),
                o = i.getContext().getContextAttributes().alpha,
                a = this.inputBuffer.texture.type;
            if (e.setRenderer(i), e.setSize(s.width, s.height), e.initialize(i, o, a), this.autoRenderToScreen && (n.length > 0 && (n[n.length - 1].renderToScreen = !1), e.renderToScreen && (this.autoRenderToScreen = !1)), t !== void 0 ? n.splice(t, 0, e) : n.push(e), this.autoRenderToScreen && (n[n.length - 1].renderToScreen = !0), e.needsDepthTexture || this.depthTexture !== null)
                if (this.depthTexture === null) {
                    const l = this.createDepthTexture();
                    for (e of n) e.setDepthTexture(l)
                } else e.setDepthTexture(this.depthTexture)
        }
        removePass(e) {
            const t = this.passes,
                n = t.indexOf(e);
            if (n !== -1 && t.splice(n, 1).length > 0) {
                if (this.depthTexture !== null) {
                    const o = (l, c) => l || c.needsDepthTexture;
                    t.reduce(o, !1) || (e.getDepthTexture() === this.depthTexture && e.setDepthTexture(null), this.deleteDepthTexture())
                }
                this.autoRenderToScreen && n === t.length && (e.renderToScreen = !1, t.length > 0 && (t[t.length - 1].renderToScreen = !0))
            }
        }
        removeAllPasses() {
            const e = this.passes;
            this.deleteDepthTexture(), e.length > 0 && (this.autoRenderToScreen && (e[e.length - 1].renderToScreen = !1), this.passes = [])
        }
        render(e) {
            const t = this.renderer,
                n = this.copyPass;
            let i = this.inputBuffer,
                s = this.outputBuffer,
                o = !1,
                a, l, c;
            e === void 0 && (this.timer.update(), e = this.timer.getDelta());
            for (const u of this.passes) u.enabled && (u.render(t, i, s, e, o), u.needsSwap && (o && (n.renderToScreen = u.renderToScreen, a = t.getContext(), l = t.state.buffers.stencil, l.setFunc(a.NOTEQUAL, 1, 4294967295), n.render(t, i, s, e, o), l.setFunc(a.EQUAL, 1, 4294967295)), c = i, i = s, s = c), u instanceof MK ? o = !0 : u instanceof yK && (o = !1))
        }
        setSize(e, t, n) {
            const i = this.renderer,
                s = i.getSize(new Ue);
            (e === void 0 || t === void 0) && (e = s.width, t = s.height), (s.width !== e || s.height !== t) && i.setSize(e, t, n);
            const o = i.getDrawingBufferSize(new Ue);
            this.inputBuffer.setSize(o.width, o.height), this.outputBuffer.setSize(o.width, o.height);
            for (const a of this.passes) a.setSize(o.width, o.height)
        }
        reset() {
            this.dispose(), this.autoRenderToScreen = !0
        }
        dispose() {
            for (const e of this.passes) e.dispose();
            this.passes = [], this.inputBuffer !== null && this.inputBuffer.dispose(), this.outputBuffer !== null && this.outputBuffer.dispose(), this.deleteDepthTexture(), this.copyPass.dispose(), this.timer.dispose(), vo.fullscreenGeometry.dispose()
        }
    },
    Ma = {
        NONE: 0,
        DEPTH: 1,
        CONVOLUTION: 2
    },
    Pn = {
        FRAGMENT_HEAD: "FRAGMENT_HEAD",
        FRAGMENT_MAIN_UV: "FRAGMENT_MAIN_UV",
        FRAGMENT_MAIN_IMAGE: "FRAGMENT_MAIN_IMAGE",
        VERTEX_HEAD: "VERTEX_HEAD",
        VERTEX_MAIN_SUPPORT: "VERTEX_MAIN_SUPPORT"
    },
    bK = class {
        constructor() {
            this.shaderParts = new Map([
                [Pn.FRAGMENT_HEAD, null],
                [Pn.FRAGMENT_MAIN_UV, null],
                [Pn.FRAGMENT_MAIN_IMAGE, null],
                [Pn.VERTEX_HEAD, null],
                [Pn.VERTEX_MAIN_SUPPORT, null]
            ]), this.defines = new Map, this.uniforms = new Map, this.blendModes = new Map, this.extensions = new Set, this.attributes = Ma.NONE, this.varyings = new Set, this.uvTransformation = !1, this.readDepth = !1, this.colorSpace = Qs
        }
    },
    C1 = !1,
    R2 = class {
        constructor(r = null) {
            this.originalMaterials = new Map, this.material = null, this.materials = null, this.materialsBackSide = null, this.materialsDoubleSide = null, this.materialsFlatShaded = null, this.materialsFlatShadedBackSide = null, this.materialsFlatShadedDoubleSide = null, this.setMaterial(r), this.meshCount = 0, this.replaceMaterial = e => {
                if (e.isMesh) {
                    let t;
                    if (e.material.flatShading) switch (e.material.side) {
                        case hn:
                            t = this.materialsFlatShadedDoubleSide;
                            break;
                        case di:
                            t = this.materialsFlatShadedBackSide;
                            break;
                        default:
                            t = this.materialsFlatShaded;
                            break
                    } else switch (e.material.side) {
                        case hn:
                            t = this.materialsDoubleSide;
                            break;
                        case di:
                            t = this.materialsBackSide;
                            break;
                        default:
                            t = this.materials;
                            break
                    }
                    this.originalMaterials.set(e, e.material), e.isSkinnedMesh ? e.material = t[2] : e.isInstancedMesh ? e.material = t[1] : e.material = t[0], ++this.meshCount
                }
            }
        }
        cloneMaterial(r) {
            if (!(r instanceof Fn)) return r.clone();
            const e = r.uniforms,
                t = new Map;
            for (const i in e) {
                const s = e[i].value;
                s.isRenderTargetTexture && (e[i].value = null, t.set(i, s))
            }
            const n = r.clone();
            for (const i of t) e[i[0]].value = i[1], n.uniforms[i[0]].value = i[1];
            return n
        }
        setMaterial(r) {
            if (this.disposeMaterials(), this.material = r, r !== null) {
                const e = this.materials = [this.cloneMaterial(r), this.cloneMaterial(r), this.cloneMaterial(r)];
                for (const t of e) t.uniforms = Object.assign({}, r.uniforms), t.side = Zs;
                e[2].skinning = !0, this.materialsBackSide = e.map(t => {
                    const n = this.cloneMaterial(t);
                    return n.uniforms = Object.assign({}, r.uniforms), n.side = di, n
                }), this.materialsDoubleSide = e.map(t => {
                    const n = this.cloneMaterial(t);
                    return n.uniforms = Object.assign({}, r.uniforms), n.side = hn, n
                }), this.materialsFlatShaded = e.map(t => {
                    const n = this.cloneMaterial(t);
                    return n.uniforms = Object.assign({}, r.uniforms), n.flatShading = !0, n
                }), this.materialsFlatShadedBackSide = e.map(t => {
                    const n = this.cloneMaterial(t);
                    return n.uniforms = Object.assign({}, r.uniforms), n.flatShading = !0, n.side = di, n
                }), this.materialsFlatShadedDoubleSide = e.map(t => {
                    const n = this.cloneMaterial(t);
                    return n.uniforms = Object.assign({}, r.uniforms), n.flatShading = !0, n.side = hn, n
                })
            }
        }
        render(r, e, t) {
            const n = r.shadowMap.enabled;
            if (r.shadowMap.enabled = !1, C1) {
                const i = this.originalMaterials;
                this.meshCount = 0, e.traverse(this.replaceMaterial), r.render(e, t);
                for (const s of i) s[0].material = s[1];
                this.meshCount !== i.size && i.clear()
            } else {
                const i = e.overrideMaterial;
                e.overrideMaterial = this.material, r.render(e, t), e.overrideMaterial = i
            }
            r.shadowMap.enabled = n
        }
        disposeMaterials() {
            if (this.material !== null) {
                const r = this.materials.concat(this.materialsBackSide).concat(this.materialsDoubleSide).concat(this.materialsFlatShaded).concat(this.materialsFlatShadedBackSide).concat(this.materialsFlatShadedDoubleSide);
                for (const e of r) e.dispose()
            }
        }
        dispose() {
            this.originalMaterials.clear(), this.disposeMaterials()
        }
        static get workaroundEnabled() {
            return C1
        }
        static set workaroundEnabled(r) {
            C1 = r
        }
    },
    qa = -1,
    Uf = class extends ws {
        constructor(r, e = qa, t = qa, n = 1) {
            super(), this.resizable = r, this.baseSize = new Ue(1, 1), this.preferredSize = new Ue(e, t), this.target = this.preferredSize, this.s = n, this.effectiveSize = new Ue, this.addEventListener("change", () => this.updateEffectiveSize()), this.updateEffectiveSize()
        }
        updateEffectiveSize() {
            const r = this.baseSize,
                e = this.preferredSize,
                t = this.effectiveSize,
                n = this.scale;
            e.width !== qa ? t.width = e.width : e.height !== qa ? t.width = Math.round(e.height * (r.width / Math.max(r.height, 1))) : t.width = Math.round(r.width * n), e.height !== qa ? t.height = e.height : e.width !== qa ? t.height = Math.round(e.width / Math.max(r.width / Math.max(r.height, 1), 1)) : t.height = Math.round(r.height * n)
        }
        get width() {
            return this.effectiveSize.width
        }
        set width(r) {
            this.preferredWidth = r
        }
        get height() {
            return this.effectiveSize.height
        }
        set height(r) {
            this.preferredHeight = r
        }
        getWidth() {
            return this.width
        }
        getHeight() {
            return this.height
        }
        get scale() {
            return this.s
        }
        set scale(r) {
            this.s !== r && (this.s = r, this.preferredSize.setScalar(qa), this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getScale() {
            return this.scale
        }
        setScale(r) {
            this.scale = r
        }
        get baseWidth() {
            return this.baseSize.width
        }
        set baseWidth(r) {
            this.baseSize.width !== r && (this.baseSize.width = r, this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getBaseWidth() {
            return this.baseWidth
        }
        setBaseWidth(r) {
            this.baseWidth = r
        }
        get baseHeight() {
            return this.baseSize.height
        }
        set baseHeight(r) {
            this.baseSize.height !== r && (this.baseSize.height = r, this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getBaseHeight() {
            return this.baseHeight
        }
        setBaseHeight(r) {
            this.baseHeight = r
        }
        setBaseSize(r, e) {
            (this.baseSize.width !== r || this.baseSize.height !== e) && (this.baseSize.set(r, e), this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        get preferredWidth() {
            return this.preferredSize.width
        }
        set preferredWidth(r) {
            this.preferredSize.width !== r && (this.preferredSize.width = r, this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getPreferredWidth() {
            return this.preferredWidth
        }
        setPreferredWidth(r) {
            this.preferredWidth = r
        }
        get preferredHeight() {
            return this.preferredSize.height
        }
        set preferredHeight(r) {
            this.preferredSize.height !== r && (this.preferredSize.height = r, this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        getPreferredHeight() {
            return this.preferredHeight
        }
        setPreferredHeight(r) {
            this.preferredHeight = r
        }
        setPreferredSize(r, e) {
            (this.preferredSize.width !== r || this.preferredSize.height !== e) && (this.preferredSize.set(r, e), this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height))
        }
        copy(r) {
            this.s = r.scale, this.baseSize.set(r.baseWidth, r.baseHeight), this.preferredSize.set(r.preferredWidth, r.preferredHeight), this.dispatchEvent({
                type: "change"
            }), this.resizable.setSize(this.baseSize.width, this.baseSize.height)
        }
        static get AUTO_SIZE() {
            return qa
        }
    },
    dn = {
        SKIP: 9,
        SET: 30,
        ADD: 0,
        ALPHA: 1,
        AVERAGE: 2,
        COLOR: 3,
        COLOR_BURN: 4,
        COLOR_DODGE: 5,
        DARKEN: 6,
        DIFFERENCE: 7,
        DIVIDE: 8,
        DST: 9,
        EXCLUSION: 10,
        HARD_LIGHT: 11,
        HARD_MIX: 12,
        HUE: 13,
        INVERT: 14,
        INVERT_RGB: 15,
        LIGHTEN: 16,
        LINEAR_BURN: 17,
        LINEAR_DODGE: 18,
        LINEAR_LIGHT: 19,
        LUMINOSITY: 20,
        MULTIPLY: 21,
        NEGATION: 22,
        NORMAL: 23,
        OVERLAY: 24,
        PIN_LIGHT: 25,
        REFLECT: 26,
        SATURATION: 27,
        SCREEN: 28,
        SOFT_LIGHT: 29,
        SRC: 30,
        SUBTRACT: 31,
        VIVID_LIGHT: 32
    },
    TK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y,opacity);}",
    EK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,min(y.a,opacity));}",
    CK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y)*0.5,opacity);}",
    RK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.rg,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
    PK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(step(0.0,y)*(1.0-min(vec4(1.0),(1.0-x)/y)),vec4(1.0),step(1.0,x));return mix(x,z,opacity);}",
    IK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=step(0.0,x)*mix(min(vec4(1.0),x/max(1.0-y,1e-9)),vec4(1.0),step(1.0,y));return mix(x,z,opacity);}",
    BK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x,y),opacity);}",
    DK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,abs(x-y),opacity);}",
    LK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x/max(y,1e-12),opacity);}",
    FK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,(x+y-2.0*x*y),opacity);}",
    UK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 a=min(x,1.0),b=min(y,1.0);vec4 z=mix(2.0*a*b,1.0-2.0*(1.0-a)*(1.0-b),step(0.5,y));return mix(x,z,opacity);}",
    OK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,step(1.0,x+y),opacity);}",
    NK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(yHSL.r,xHSL.gb));return vec4(mix(x.rgb,z,opacity),y.a);}",
    kK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-y,opacity);}",
    zK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y*(1.0-x),opacity);}",
    GK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x,y),opacity);}",
    HK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(y+x-1.0,0.0,1.0),opacity);}",
    VK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,min(x+y,1.0),opacity);}",
    WK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,clamp(2.0*y+x-1.0,0.0,1.0),opacity);}",
    jK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.rg,yHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
    XK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x*y,opacity);}",
    YK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,1.0-abs(1.0-x-y),opacity);}",
    JK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,y,opacity);}",
    KK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(2.0*y*x,1.0-2.0*(1.0-y)*(1.0-x),step(0.5,x));return mix(x,z,opacity);}",
    qK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 z=mix(mix(y2,x,step(0.5*x,y)),max(vec4(0.0),y2-1.0),step(x,(y2-1.0)));return mix(x,z,opacity);}",
    ZK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(min(x*x/max(1.0-y,1e-12),1.0),y,step(1.0,y));return mix(x,z,opacity);}",
    QK = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec3 xHSL=RGBToHSL(x.rgb);vec3 yHSL=RGBToHSL(y.rgb);vec3 z=HSLToRGB(vec3(xHSL.r,yHSL.g,xHSL.b));return vec4(mix(x.rgb,z,opacity),y.a);}",
    $K = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,x+y-min(x*y,1.0),opacity);}",
    eq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 y2=2.0*y;vec4 w=step(0.5,y);vec4 z=mix(x-(1.0-y2)*x*(1.0-x),mix(x+(y2-1.0)*(sqrt(x)-x),x+(y2-1.0)*x*((16.0*x-12.0)*x+3.0),w*(1.0-step(0.25,x))),w);return mix(x,z,opacity);}",
    tq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return y;}",
    nq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){return mix(x,max(x+y-1.0,0.0),opacity);}",
    iq = "vec4 blend(const in vec4 x,const in vec4 y,const in float opacity){vec4 z=mix(max(1.0-min((1.0-x)/(2.0*y),1.0),0.0),min(x/(2.0*(1.0-y)),1.0),step(0.5,y));return mix(x,z,opacity);}",
    rq = new Map([
        [dn.ADD, TK],
        [dn.ALPHA, EK],
        [dn.AVERAGE, CK],
        [dn.COLOR, RK],
        [dn.COLOR_BURN, PK],
        [dn.COLOR_DODGE, IK],
        [dn.DARKEN, BK],
        [dn.DIFFERENCE, DK],
        [dn.DIVIDE, LK],
        [dn.DST, null],
        [dn.EXCLUSION, FK],
        [dn.HARD_LIGHT, UK],
        [dn.HARD_MIX, OK],
        [dn.HUE, NK],
        [dn.INVERT, kK],
        [dn.INVERT_RGB, zK],
        [dn.LIGHTEN, GK],
        [dn.LINEAR_BURN, HK],
        [dn.LINEAR_DODGE, VK],
        [dn.LINEAR_LIGHT, WK],
        [dn.LUMINOSITY, jK],
        [dn.MULTIPLY, XK],
        [dn.NEGATION, YK],
        [dn.NORMAL, JK],
        [dn.OVERLAY, KK],
        [dn.PIN_LIGHT, qK],
        [dn.REFLECT, ZK],
        [dn.SATURATION, QK],
        [dn.SCREEN, $K],
        [dn.SOFT_LIGHT, eq],
        [dn.SRC, tq],
        [dn.SUBTRACT, nq],
        [dn.VIVID_LIGHT, iq]
    ]),
    sq = class extends ws {
        constructor(r, e = 1) {
            super(), this._blendFunction = r, this.opacity = new Wn(e)
        }
        getOpacity() {
            return this.opacity.value
        }
        setOpacity(r) {
            this.opacity.value = r
        }
        get blendFunction() {
            return this._blendFunction
        }
        set blendFunction(r) {
            this._blendFunction = r, this.dispatchEvent({
                type: "change"
            })
        }
        getBlendFunction() {
            return this.blendFunction
        }
        setBlendFunction(r) {
            this.blendFunction = r
        }
        getShaderCode() {
            return rq.get(this.blendFunction)
        }
    },
    oh = class extends ws {
        constructor(r, e, {
            attributes: t = Ma.NONE,
            blendFunction: n = dn.NORMAL,
            defines: i = new Map,
            uniforms: s = new Map,
            extensions: o = null,
            vertexShader: a = null
        } = {}) {
            super(), this.name = r, this.renderer = null, this.attributes = t, this.fragmentShader = e, this.vertexShader = a, this.defines = i, this.uniforms = s, this.extensions = o, this.blendMode = new sq(n), this.blendMode.addEventListener("change", l => this.setChanged()), this._inputColorSpace = Qs, this._outputColorSpace = uo
        }
        get inputColorSpace() {
            return this._inputColorSpace
        }
        set inputColorSpace(r) {
            this._inputColorSpace = r, this.setChanged()
        }
        get outputColorSpace() {
            return this._outputColorSpace
        }
        set outputColorSpace(r) {
            this._outputColorSpace = r, this.setChanged()
        }
        set mainScene(r) {}
        set mainCamera(r) {}
        getName() {
            return this.name
        }
        setRenderer(r) {
            this.renderer = r
        }
        getDefines() {
            return this.defines
        }
        getUniforms() {
            return this.uniforms
        }
        getExtensions() {
            return this.extensions
        }
        getBlendMode() {
            return this.blendMode
        }
        getAttributes() {
            return this.attributes
        }
        setAttributes(r) {
            this.attributes = r, this.setChanged()
        }
        getFragmentShader() {
            return this.fragmentShader
        }
        setFragmentShader(r) {
            this.fragmentShader = r, this.setChanged()
        }
        getVertexShader() {
            return this.vertexShader
        }
        setVertexShader(r) {
            this.vertexShader = r, this.setChanged()
        }
        setChanged() {
            this.dispatchEvent({
                type: "change"
            })
        }
        setDepthTexture(r, e = Bl) {}
        update(r, e, t) {}
        setSize(r, e) {}
        initialize(r, e, t) {}
        dispose() {
            for (const r of Object.keys(this)) {
                const e = this[r];
                (e instanceof Zn || e instanceof mi || e instanceof gn || e instanceof vo) && this[r].dispose()
            }
        }
    },
    Y3 = class extends vo {
        constructor(r, e, t = null) {
            super("RenderPass", r, e), this.needsSwap = !1, this.clearPass = new X3, this.overrideMaterialManager = t === null ? null : new R2(t), this.ignoreBackground = !1, this.skipShadowMapUpdate = !1, this.selection = null
        }
        set mainScene(r) {
            this.scene = r
        }
        set mainCamera(r) {
            this.camera = r
        }
        get renderToScreen() {
            return super.renderToScreen
        }
        set renderToScreen(r) {
            super.renderToScreen = r, this.clearPass.renderToScreen = r
        }
        get overrideMaterial() {
            const r = this.overrideMaterialManager;
            return r !== null ? r.material : null
        }
        set overrideMaterial(r) {
            const e = this.overrideMaterialManager;
            r !== null ? e !== null ? e.setMaterial(r) : this.overrideMaterialManager = new R2(r) : e !== null && (e.dispose(), this.overrideMaterialManager = null)
        }
        getOverrideMaterial() {
            return this.overrideMaterial
        }
        setOverrideMaterial(r) {
            this.overrideMaterial = r
        }
        get clear() {
            return this.clearPass.enabled
        }
        set clear(r) {
            this.clearPass.enabled = r
        }
        getSelection() {
            return this.selection
        }
        setSelection(r) {
            this.selection = r
        }
        isBackgroundDisabled() {
            return this.ignoreBackground
        }
        setBackgroundDisabled(r) {
            this.ignoreBackground = r
        }
        isShadowMapDisabled() {
            return this.skipShadowMapUpdate
        }
        setShadowMapDisabled(r) {
            this.skipShadowMapUpdate = r
        }
        getClearPass() {
            return this.clearPass
        }
        render(r, e, t, n, i) {
            const s = this.scene,
                o = this.camera,
                a = this.selection,
                l = o.layers.mask,
                c = s.background,
                u = r.shadowMap.autoUpdate,
                f = this.renderToScreen ? null : e;
            a !== null && o.layers.set(a.getLayer()), this.skipShadowMapUpdate && (r.shadowMap.autoUpdate = !1), (this.ignoreBackground || this.clearPass.overrideClearColor !== null) && (s.background = null), this.clearPass.enabled && this.clearPass.render(r, e), r.setRenderTarget(f), this.overrideMaterialManager !== null ? this.overrideMaterialManager.render(r, s, o) : r.render(s, o), o.layers.mask = l, s.background = c, r.shadowMap.autoUpdate = u
        }
    },
    oq = `#include <packing>
#ifdef GL_FRAGMENT_PRECISION_HIGH
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
#ifdef DOWNSAMPLE_NORMALS
uniform lowp sampler2D normalBuffer;
#endif
varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}int findBestDepth(const in float samples[4]){float c=(samples[0]+samples[1]+samples[2]+samples[3])*0.25;float distances[4];distances[0]=abs(c-samples[0]);distances[1]=abs(c-samples[1]);distances[2]=abs(c-samples[2]);distances[3]=abs(c-samples[3]);float maxDistance=max(max(distances[0],distances[1]),max(distances[2],distances[3]));int remaining[3];int rejected[3];int i,j,k;for(i=0,j=0,k=0;i<4;++i){if(distances[i]<maxDistance){remaining[j++]=i;}else{rejected[k++]=i;}}for(;j<3;++j){remaining[j]=rejected[--k];}vec3 s=vec3(samples[remaining[0]],samples[remaining[1]],samples[remaining[2]]);c=(s.x+s.y+s.z)/3.0;distances[0]=abs(c-s.x);distances[1]=abs(c-s.y);distances[2]=abs(c-s.z);float minDistance=min(distances[0],min(distances[1],distances[2]));for(i=0;i<3;++i){if(distances[i]==minDistance){break;}}return remaining[i];}void main(){float d[4];d[0]=readDepth(vUv0);d[1]=readDepth(vUv1);d[2]=readDepth(vUv2);d[3]=readDepth(vUv3);int index=findBestDepth(d);
#ifdef DOWNSAMPLE_NORMALS
vec3 n[4];n[0]=texture2D(normalBuffer,vUv0).rgb;n[1]=texture2D(normalBuffer,vUv1).rgb;n[2]=texture2D(normalBuffer,vUv2).rgb;n[3]=texture2D(normalBuffer,vUv3).rgb;
#else
vec3 n[4];n[0]=vec3(0.0);n[1]=vec3(0.0);n[2]=vec3(0.0);n[3]=vec3(0.0);
#endif
gl_FragColor=vec4(n[index],d[index]);}`,
    aq = "uniform vec2 texelSize;varying vec2 vUv0;varying vec2 vUv1;varying vec2 vUv2;varying vec2 vUv3;void main(){vec2 uv=position.xy*0.5+0.5;vUv0=uv;vUv1=vec2(uv.x,uv.y+texelSize.y);vUv2=vec2(uv.x+texelSize.x,uv.y);vUv3=uv+texelSize;gl_Position=vec4(position.xy,1.0,1.0);}",
    lq = class extends Fn {
        constructor() {
            super({
                name: "DepthDownsamplingMaterial",
                defines: {
                    DEPTH_PACKING: "0"
                },
                uniforms: {
                    depthBuffer: new Wn(null),
                    normalBuffer: new Wn(null),
                    texelSize: new Wn(new Ue)
                },
                blending: pi,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                fragmentShader: oq,
                vertexShader: aq
            })
        }
        set depthBuffer(r) {
            this.uniforms.depthBuffer.value = r
        }
        set depthPacking(r) {
            this.defines.DEPTH_PACKING = r.toFixed(0), this.needsUpdate = !0
        }
        setDepthBuffer(r, e = Bl) {
            this.depthBuffer = r, this.depthPacking = e
        }
        set normalBuffer(r) {
            this.uniforms.normalBuffer.value = r, r !== null ? this.defines.DOWNSAMPLE_NORMALS = "1" : delete this.defines.DOWNSAMPLE_NORMALS, this.needsUpdate = !0
        }
        setNormalBuffer(r) {
            this.normalBuffer = r
        }
        setTexelSize(r, e) {
            this.uniforms.texelSize.value.set(r, e)
        }
        setSize(r, e) {
            this.uniforms.texelSize.value.set(1 / r, 1 / e)
        }
    },
    cq = class extends vo {
        constructor({
            normalBuffer: r = null,
            resolutionScale: e = .5,
            width: t = Uf.AUTO_SIZE,
            height: n = Uf.AUTO_SIZE,
            resolutionX: i = t,
            resolutionY: s = n
        } = {}) {
            super("DepthDownsamplingPass");
            const o = new lq;
            o.normalBuffer = r, this.fullscreenMaterial = o, this.needsDepthTexture = !0, this.needsSwap = !1, this.renderTarget = new Zn(1, 1, {
                minFilter: bn,
                magFilter: bn,
                depthBuffer: !1,
                type: Bn
            }), this.renderTarget.texture.name = "DepthDownsamplingPass.Target", this.renderTarget.texture.generateMipmaps = !1;
            const a = this.resolution = new Uf(this, i, s, e);
            a.addEventListener("change", l => this.setSize(a.baseWidth, a.baseHeight))
        }
        get texture() {
            return this.renderTarget.texture
        }
        getTexture() {
            return this.renderTarget.texture
        }
        getResolution() {
            return this.resolution
        }
        setDepthTexture(r, e = Bl) {
            this.fullscreenMaterial.depthBuffer = r, this.fullscreenMaterial.depthPacking = e
        }
        render(r, e, t, n, i) {
            r.setRenderTarget(this.renderToScreen ? null : this.renderTarget), r.render(this.scene, this.camera)
        }
        setSize(r, e) {
            const t = this.resolution;
            t.setBaseSize(r, e), this.renderTarget.setSize(t.width, t.height), this.fullscreenMaterial.setSize(r, e)
        }
        initialize(r, e, t) {
            const n = r.getContext();
            if (!(n.getExtension("EXT_color_buffer_float") || n.getExtension("EXT_color_buffer_half_float"))) throw new Error("Rendering to float texture is not supported.")
        }
    },
    uq = `#include <common>
#include <packing>
#include <dithering_pars_fragment>
#define packFloatToRGBA(v) packDepthToRGBA(v)
#define unpackRGBAToFloat(v) unpackRGBAToDepth(v)
#ifdef FRAMEBUFFER_PRECISION_HIGH
uniform mediump sampler2D inputBuffer;
#else
uniform lowp sampler2D inputBuffer;
#endif
#if DEPTH_PACKING == 3201
uniform lowp sampler2D depthBuffer;
#elif defined(GL_FRAGMENT_PRECISION_HIGH)
uniform highp sampler2D depthBuffer;
#else
uniform mediump sampler2D depthBuffer;
#endif
uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;vec4 sRGBToLinear(const in vec4 value){return vec4(mix(pow(value.rgb*0.9478672986+vec3(0.0521327014),vec3(2.4)),value.rgb*0.0773993808,vec3(lessThanEqual(value.rgb,vec3(0.04045)))),value.a);}float readDepth(const in vec2 uv){
#if DEPTH_PACKING == 3201
return unpackRGBAToDepth(texture2D(depthBuffer,uv));
#else
return texture2D(depthBuffer,uv).r;
#endif
}float getViewZ(const in float depth){
#ifdef PERSPECTIVE_CAMERA
return perspectiveDepthToViewZ(depth,cameraNear,cameraFar);
#else
return orthographicDepthToViewZ(depth,cameraNear,cameraFar);
#endif
}vec3 RGBToHCV(const in vec3 RGB){vec4 P=mix(vec4(RGB.bg,-1.0,2.0/3.0),vec4(RGB.gb,0.0,-1.0/3.0),step(RGB.b,RGB.g));vec4 Q=mix(vec4(P.xyw,RGB.r),vec4(RGB.r,P.yzx),step(P.x,RGB.r));float C=Q.x-min(Q.w,Q.y);float H=abs((Q.w-Q.y)/(6.0*C+EPSILON)+Q.z);return vec3(H,C,Q.x);}vec3 RGBToHSL(const in vec3 RGB){vec3 HCV=RGBToHCV(RGB);float L=HCV.z-HCV.y*0.5;float S=HCV.y/(1.0-abs(L*2.0-1.0)+EPSILON);return vec3(HCV.x,S,L);}vec3 HueToRGB(const in float H){float R=abs(H*6.0-3.0)-1.0;float G=2.0-abs(H*6.0-2.0);float B=2.0-abs(H*6.0-4.0);return clamp(vec3(R,G,B),0.0,1.0);}vec3 HSLToRGB(const in vec3 HSL){vec3 RGB=HueToRGB(HSL.x);float C=(1.0-abs(2.0*HSL.z-1.0))*HSL.y;return(RGB-0.5)*C+HSL.z;}FRAGMENT_HEAD void main(){FRAGMENT_MAIN_UV vec4 color0=texture2D(inputBuffer,UV);vec4 color1=vec4(0.0);FRAGMENT_MAIN_IMAGE color0.a=clamp(color0.a,0.0,1.0);gl_FragColor=color0;
#ifdef ENCODE_OUTPUT
#include <colorspace_fragment>
#endif
#include <dithering_fragment>
}`,
    fq = "uniform vec2 resolution;uniform vec2 texelSize;uniform float cameraNear;uniform float cameraFar;uniform float aspect;uniform float time;varying vec2 vUv;VERTEX_HEAD void main(){vUv=position.xy*0.5+0.5;VERTEX_MAIN_SUPPORT gl_Position=vec4(position.xy,1.0,1.0);}",
    hq = class extends Fn {
        constructor(r, e, t, n, i = !1) {
            super({
                name: "EffectMaterial",
                defines: {
                    THREE_REVISION: du.replace(/\D+/g, ""),
                    DEPTH_PACKING: "0",
                    ENCODE_OUTPUT: "1"
                },
                uniforms: {
                    inputBuffer: new Wn(null),
                    depthBuffer: new Wn(null),
                    resolution: new Wn(new Ue),
                    texelSize: new Wn(new Ue),
                    cameraNear: new Wn(.3),
                    cameraFar: new Wn(1e3),
                    aspect: new Wn(1),
                    time: new Wn(0)
                },
                blending: pi,
                toneMapped: !1,
                depthWrite: !1,
                depthTest: !1,
                dithering: i
            }), r && this.setShaderParts(r), e && this.setDefines(e), t && this.setUniforms(t), this.copyCameraSettings(n)
        }
        set inputBuffer(r) {
            this.uniforms.inputBuffer.value = r
        }
        setInputBuffer(r) {
            this.uniforms.inputBuffer.value = r
        }
        get depthBuffer() {
            return this.uniforms.depthBuffer.value
        }
        set depthBuffer(r) {
            this.uniforms.depthBuffer.value = r
        }
        get depthPacking() {
            return Number(this.defines.DEPTH_PACKING)
        }
        set depthPacking(r) {
            this.defines.DEPTH_PACKING = r.toFixed(0), this.needsUpdate = !0
        }
        setDepthBuffer(r, e = Bl) {
            this.depthBuffer = r, this.depthPacking = e
        }
        setShaderData(r) {
            this.setShaderParts(r.shaderParts), this.setDefines(r.defines), this.setUniforms(r.uniforms), this.setExtensions(r.extensions)
        }
        setShaderParts(r) {
            return this.fragmentShader = uq.replace(Pn.FRAGMENT_HEAD, r.get(Pn.FRAGMENT_HEAD) || "").replace(Pn.FRAGMENT_MAIN_UV, r.get(Pn.FRAGMENT_MAIN_UV) || "").replace(Pn.FRAGMENT_MAIN_IMAGE, r.get(Pn.FRAGMENT_MAIN_IMAGE) || ""), this.vertexShader = fq.replace(Pn.VERTEX_HEAD, r.get(Pn.VERTEX_HEAD) || "").replace(Pn.VERTEX_MAIN_SUPPORT, r.get(Pn.VERTEX_MAIN_SUPPORT) || ""), this.needsUpdate = !0, this
        }
        setDefines(r) {
            for (const e of r.entries()) this.defines[e[0]] = e[1];
            return this.needsUpdate = !0, this
        }
        setUniforms(r) {
            for (const e of r.entries()) this.uniforms[e[0]] = e[1];
            return this
        }
        setExtensions(r) {
            this.extensions = {};
            for (const e of r) this.extensions[e] = !0;
            return this
        }
        get encodeOutput() {
            return this.defines.ENCODE_OUTPUT !== void 0
        }
        set encodeOutput(r) {
            this.encodeOutput !== r && (r ? this.defines.ENCODE_OUTPUT = "1" : delete this.defines.ENCODE_OUTPUT, this.needsUpdate = !0)
        }
        isOutputEncodingEnabled(r) {
            return this.encodeOutput
        }
        setOutputEncodingEnabled(r) {
            this.encodeOutput = r
        }
        get time() {
            return this.uniforms.time.value
        }
        set time(r) {
            this.uniforms.time.value = r
        }
        setDeltaTime(r) {
            this.uniforms.time.value += r
        }
        adoptCameraSettings(r) {
            this.copyCameraSettings(r)
        }
        copyCameraSettings(r) {
            r && (this.uniforms.cameraNear.value = r.near, this.uniforms.cameraFar.value = r.far, r instanceof ri ? this.defines.PERSPECTIVE_CAMERA = "1" : delete this.defines.PERSPECTIVE_CAMERA, this.needsUpdate = !0)
        }
        setSize(r, e) {
            const t = this.uniforms;
            t.resolution.value.set(r, e), t.texelSize.value.set(1 / r, 1 / e), t.aspect.value = r / e
        }
        static get Section() {
            return Pn
        }
    };

function P2(r, e, t) {
    for (const n of e) {
        const i = "$1" + r + n.charAt(0).toUpperCase() + n.slice(1),
            s = new RegExp("([^\\.])(\\b" + n + "\\b)", "g");
        for (const o of t.entries()) o[1] !== null && t.set(o[0], o[1].replace(s, i))
    }
}

function dq(r, e, t) {
    let n = e.getFragmentShader(),
        i = e.getVertexShader();
    const s = n !== void 0 && /mainImage/.test(n),
        o = n !== void 0 && /mainUv/.test(n);
    if (t.attributes |= e.getAttributes(), n === void 0) throw new Error(`Missing fragment shader (${e.name})`);
    if (o && t.attributes & Ma.CONVOLUTION) throw new Error(`Effects that transform UVs are incompatible with convolution effects (${e.name})`);
    if (!s && !o) throw new Error(`Could not find mainImage or mainUv function (${e.name})`); {
        const a = /\w+\s+(\w+)\([\w\s,]*\)\s*{/g,
            l = t.shaderParts;
        let c = l.get(Pn.FRAGMENT_HEAD) || "",
            u = l.get(Pn.FRAGMENT_MAIN_UV) || "",
            f = l.get(Pn.FRAGMENT_MAIN_IMAGE) || "",
            d = l.get(Pn.VERTEX_HEAD) || "",
            m = l.get(Pn.VERTEX_MAIN_SUPPORT) || "";
        const g = new Set,
            y = new Set;
        if (o && (u += `	${r}MainUv(UV);
`, t.uvTransformation = !0), i !== null && /mainSupport/.test(i)) {
            const A = /mainSupport *\([\w\s]*?uv\s*?\)/.test(i);
            m += `	${r}MainSupport(`, m += A ? `vUv);
` : `);
`;
            for (const S of i.matchAll(/(?:varying\s+\w+\s+([\S\s]*?);)/g))
                for (const M of S[1].split(/\s*,\s*/)) t.varyings.add(M), g.add(M), y.add(M);
            for (const S of i.matchAll(a)) y.add(S[1])
        }
        for (const A of n.matchAll(a)) y.add(A[1]);
        for (const A of e.defines.keys()) y.add(A.replace(/\([\w\s,]*\)/g, ""));
        for (const A of e.uniforms.keys()) y.add(A);
        y.delete("while"), y.delete("for"), y.delete("if"), e.uniforms.forEach((A, S) => t.uniforms.set(r + S.charAt(0).toUpperCase() + S.slice(1), A)), e.defines.forEach((A, S) => t.defines.set(r + S.charAt(0).toUpperCase() + S.slice(1), A));
        const v = new Map([
            ["fragment", n],
            ["vertex", i]
        ]);
        P2(r, y, t.defines), P2(r, y, v), n = v.get("fragment"), i = v.get("vertex");
        const _ = e.blendMode;
        if (t.blendModes.set(_.blendFunction, _), s) {
            e.inputColorSpace !== null && e.inputColorSpace !== t.colorSpace && (f += e.inputColorSpace === Jn ? `color0 = sRGBTransferOETF(color0);
	` : `color0 = sRGBToLinear(color0);
	`), e.outputColorSpace !== uo ? t.colorSpace = e.outputColorSpace : e.inputColorSpace !== null && (t.colorSpace = e.inputColorSpace);
            const A = /MainImage *\([\w\s,]*?depth[\w\s,]*?\)/;
            f += `${r}MainImage(color0, UV, `, t.attributes & Ma.DEPTH && A.test(n) && (f += "depth, ", t.readDepth = !0), f += `color1);
	`;
            const S = r + "BlendOpacity";
            t.uniforms.set(S, _.opacity), f += `color0 = blend${_.blendFunction}(color0, color1, ${S});

	`, c += `uniform float ${S};

`
        }
        if (c += n + `
`, i !== null && (d += i + `
`), l.set(Pn.FRAGMENT_HEAD, c), l.set(Pn.FRAGMENT_MAIN_UV, u), l.set(Pn.FRAGMENT_MAIN_IMAGE, f), l.set(Pn.VERTEX_HEAD, d), l.set(Pn.VERTEX_MAIN_SUPPORT, m), e.extensions !== null)
            for (const A of e.extensions) t.extensions.add(A)
    }
}
var pq = class extends vo {
        constructor(r, ...e) {
            super("EffectPass"), this.fullscreenMaterial = new hq(null, null, null, r), this.listener = t => this.handleEvent(t), this.effects = [], this.setEffects(e), this.skipRendering = !1, this.minTime = 1, this.maxTime = Number.POSITIVE_INFINITY, this.timeScale = 1
        }
        set mainScene(r) {
            for (const e of this.effects) e.mainScene = r
        }
        set mainCamera(r) {
            this.fullscreenMaterial.copyCameraSettings(r);
            for (const e of this.effects) e.mainCamera = r
        }
        get encodeOutput() {
            return this.fullscreenMaterial.encodeOutput
        }
        set encodeOutput(r) {
            this.fullscreenMaterial.encodeOutput = r
        }
        get dithering() {
            return this.fullscreenMaterial.dithering
        }
        set dithering(r) {
            const e = this.fullscreenMaterial;
            e.dithering = r, e.needsUpdate = !0
        }
        setEffects(r) {
            for (const e of this.effects) e.removeEventListener("change", this.listener);
            this.effects = r.sort((e, t) => t.attributes - e.attributes);
            for (const e of this.effects) e.addEventListener("change", this.listener)
        }
        updateMaterial() {
            const r = new bK;
            let e = 0;
            for (const o of this.effects)
                if (o.blendMode.blendFunction === dn.DST) r.attributes |= o.getAttributes() & Ma.DEPTH;
                else {
                    if (r.attributes & o.getAttributes() & Ma.CONVOLUTION) throw new Error(`Convolution effects cannot be merged (${o.name})`);
                    dq("e" + e++, o, r)
                }
            let t = r.shaderParts.get(Pn.FRAGMENT_HEAD),
                n = r.shaderParts.get(Pn.FRAGMENT_MAIN_IMAGE),
                i = r.shaderParts.get(Pn.FRAGMENT_MAIN_UV);
            const s = /\bblend\b/g;
            for (const o of r.blendModes.values()) t += o.getShaderCode().replace(s, `blend${o.blendFunction}`) + `
`;
            r.attributes & Ma.DEPTH ? (r.readDepth && (n = `float depth = readDepth(UV);

	` + n), this.needsDepthTexture = this.getDepthTexture() === null) : this.needsDepthTexture = !1, r.colorSpace === Jn && (n += `color0 = sRGBToLinear(color0);
	`), r.uvTransformation ? (i = `vec2 transformedUv = vUv;
` + i, r.defines.set("UV", "transformedUv")) : r.defines.set("UV", "vUv"), r.shaderParts.set(Pn.FRAGMENT_HEAD, t), r.shaderParts.set(Pn.FRAGMENT_MAIN_IMAGE, n), r.shaderParts.set(Pn.FRAGMENT_MAIN_UV, i);
            for (const [o, a] of r.shaderParts) a !== null && r.shaderParts.set(o, a.trim().replace(/^#/, `
#`));
            this.skipRendering = e === 0, this.needsSwap = !this.skipRendering, this.fullscreenMaterial.setShaderData(r)
        }
        recompile() {
            this.updateMaterial()
        }
        getDepthTexture() {
            return this.fullscreenMaterial.depthBuffer
        }
        setDepthTexture(r, e = Bl) {
            this.fullscreenMaterial.depthBuffer = r, this.fullscreenMaterial.depthPacking = e;
            for (const t of this.effects) t.setDepthTexture(r, e)
        }
        render(r, e, t, n, i) {
            for (const s of this.effects) s.update(r, e, n);
            if (!this.skipRendering || this.renderToScreen) {
                const s = this.fullscreenMaterial;
                s.inputBuffer = e.texture, s.time += n * this.timeScale, r.setRenderTarget(this.renderToScreen ? null : t), r.render(this.scene, this.camera)
            }
        }
        setSize(r, e) {
            this.fullscreenMaterial.setSize(r, e);
            for (const t of this.effects) t.setSize(r, e)
        }
        initialize(r, e, t) {
            this.renderer = r;
            for (const n of this.effects) n.initialize(r, e, t);
            this.updateMaterial(), t !== void 0 && t !== Yi && (this.fullscreenMaterial.defines.FRAMEBUFFER_PRECISION_HIGH = "1")
        }
        dispose() {
            super.dispose();
            for (const r of this.effects) r.removeEventListener("change", this.listener), r.dispose()
        }
        handleEvent(r) {
            switch (r.type) {
                case "change":
                    this.recompile();
                    break
            }
        }
    },
    mq = class extends vo {
        constructor(r, e, {
            renderTarget: t,
            resolutionScale: n = 1,
            width: i = Uf.AUTO_SIZE,
            height: s = Uf.AUTO_SIZE,
            resolutionX: o = i,
            resolutionY: a = s
        } = {}) {
            super("NormalPass"), this.needsSwap = !1, this.renderPass = new Y3(r, e, new oM);
            const l = this.renderPass;
            l.ignoreBackground = !0, l.skipShadowMapUpdate = !0;
            const c = l.getClearPass();
            c.overrideClearColor = new rt(7829503), c.overrideClearAlpha = 1, this.renderTarget = t, this.renderTarget === void 0 && (this.renderTarget = new Zn(1, 1, {
                minFilter: bn,
                magFilter: bn
            }), this.renderTarget.texture.name = "NormalPass.Target");
            const u = this.resolution = new Uf(this, o, a, n);
            u.addEventListener("change", f => this.setSize(u.baseWidth, u.baseHeight))
        }
        set mainScene(r) {
            this.renderPass.mainScene = r
        }
        set mainCamera(r) {
            this.renderPass.mainCamera = r
        }
        get texture() {
            return this.renderTarget.texture
        }
        getTexture() {
            return this.renderTarget.texture
        }
        getResolution() {
            return this.resolution
        }
        getResolutionScale() {
            return this.resolution.scale
        }
        setResolutionScale(r) {
            this.resolution.scale = r
        }
        render(r, e, t, n, i) {
            const s = this.renderToScreen ? null : this.renderTarget;
            this.renderPass.render(r, s, s)
        }
        setSize(r, e) {
            const t = this.resolution;
            t.setBaseSize(r, e), this.renderTarget.setSize(t.width, t.height)
        }
    };
const gq = N.createContext(null),
    I2 = r => (r.getAttributes() & Ma.CONVOLUTION) === Ma.CONVOLUTION,
    vq = ga.memo(N.forwardRef(({
        children: r,
        camera: e,
        scene: t,
        resolutionScale: n,
        enabled: i = !0,
        renderPriority: s = 1,
        autoClear: o = !0,
        depthBuffer: a,
        enableNormalPass: l,
        stencilBuffer: c,
        multisampling: u = 8,
        frameBufferType: f = Ri
    }, d) => {
        const {
            gl: m,
            scene: g,
            camera: y,
            size: v
        } = qn(), _ = t || g, A = e || y, [S, M, C] = N.useMemo(() => {
            const b = m6(),
                T = new wK(m, {
                    depthBuffer: a,
                    stencilBuffer: c,
                    multisampling: u > 0 && b ? u : 0,
                    frameBufferType: f
                });
            T.addPass(new Y3(_, A));
            let L = null,
                D = null;
            return l && (D = new mq(_, A), D.enabled = !1, T.addPass(D), n !== void 0 && b && (L = new cq({
                normalBuffer: D.texture,
                resolutionScale: n
            }), L.enabled = !1, T.addPass(L))), [T, D, L]
        }, [A, m, a, c, u, f, _, l, n]);
        N.useEffect(() => S == null ? void 0 : S.setSize(v.width, v.height), [S, v]), Es((b, T) => {
            if (i) {
                const L = m.autoClear;
                m.autoClear = o, c && !o && m.clearStencil(), S.render(T), m.autoClear = L
            }
        }, i ? s : 0);
        const E = N.useRef(null),
            R = D8(E);
        N.useLayoutEffect(() => {
            const b = [];
            if (E.current && R.current && S) {
                const T = R.current.objects;
                for (let L = 0; L < T.length; L++) {
                    const D = T[L];
                    if (D instanceof oh) {
                        const V = [D];
                        if (!I2(D)) {
                            let q = null;
                            for (;
                                (q = T[L + 1]) instanceof oh && !I2(q);) V.push(q), L++
                        }
                        const H = new pq(A, ...V);
                        b.push(H)
                    } else D instanceof vo && b.push(D)
                }
                for (const L of b) S == null || S.addPass(L);
                M && (M.enabled = !0), C && (C.enabled = !0)
            }
            return () => {
                for (const T of b) S == null || S.removePass(T);
                M && (M.enabled = !1), C && (C.enabled = !1)
            }
        }, [S, r, A, M, C, R]), N.useEffect(() => {
            const b = m.toneMapping;
            return m.toneMapping = Js, () => {
                m.toneMapping = b
            }
        }, []);
        const P = N.useMemo(() => ({
            composer: S,
            normalPass: M,
            downSamplingPass: C,
            resolutionScale: n,
            camera: A,
            scene: _
        }), [S, M, C, n, A, _]);
        return N.useImperativeHandle(d, () => S, [S]), G.jsx(gq.Provider, {
            value: P,
            children: G.jsx("group", {
                ref: E,
                children: r
            })
        })
    })),
    tS = {
        "2k": [64, 32, .12],
        "4k": [64, 64, .29],
        "8k": [128, 64, .42],
        "16k": [128, 128, .48],
        "32k": [256, 128, .55],
        "65k": [256, 256, .6],
        "131k": [512, 256, .85],
        "252k": [512, 512, 1.2],
        "524k": [1024, 512, 1.4],
        "1m": [1024, 1024, 1.6],
        "2m": [2048, 1024, 2],
        "4m": [2048, 2048, 2.5]
    },
    yq = {
        best: 1,
        high: .5,
        medium: 1 / 3,
        low: .25
    },
    _q = !1,
    xq = /(iPad|iPhone|Android)/i.test(navigator.userAgent),
    Aq = "2k",
    B2 = tS[Aq],
    En = {
        mouse: new Ue(0, 0),
        mouse3d: new K,
        camera: null,
        cameraPosition: null,
        useStats: _q,
        isMobile: xq,
        amountMap: tS,
        motionBlurQualityMap: yq,
        amountList: Object.keys(tS),
        simulatorTextureWidth: B2[0],
        simulatorTextureHeight: B2[1],
        useTriangleParticles: !0,
        followMouse: !0,
        speed: 1,
        dieSpeed: .015,
        radius: .42,
        curlSize: .02,
        attraction: 1,
        shadowDarkness: .45,
        color1: "#FFFFFF",
        color2: "#000000",
        fxaa: !1,
        motionBlur: !1,
        motionBlurPause: !1,
        bloom: !1
    };
var D2 = `attribute vec3 position;

void main() {
    gl_Position = vec4( position, 1.0 );
}`,
    Sq = `uniform vec2 resolution;
uniform sampler2D texture;

void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    gl_FragColor = texture2D( texture, uv );
}`,
    Mq = `uniform vec2 resolution;
uniform sampler2D texturePosition;
uniform sampler2D textureDefaultPosition;
uniform float time;
uniform float speed;
uniform float dieSpeed;
uniform float radius;
uniform float curlSize;
uniform float attraction;
uniform float initAnimation;
uniform vec3 mouse3d;

#pragma glslify: curl = require(./helpers/curl4)

#pragma glslify: simplexNoiseDerivatives = require(./simplexNoiseDerivatives4)
vec4 mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

float mod289(float x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
}

vec4 permute(vec4 x) {
    return mod289(((x*34.0)+1.0)*x);
}

float permute(float x) {
    return mod289(((x*34.0)+1.0)*x);
}

vec4 taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

float taylorInvSqrt(float r) {
    return 1.79284291400159 - 0.85373472095314 * r;
}

vec4 grad4(float j, vec4 ip) {
    const vec4 ones = vec4(1.0, 1.0, 1.0, -1.0);
    vec4 p,s;

    p.xyz = floor( fract (vec3(j) * ip.xyz) * 7.0) * ip.z - 1.0;
    p.w = 1.5 - dot(abs(p.xyz), ones.xyz);
    s = vec4(lessThan(p, vec4(0.0)));
    p.xyz = p.xyz + (s.xyz*2.0 - 1.0) * s.www;

    return p;
}

#define F4 0.309016994374947451

vec4 simplexNoiseDerivatives (vec4 v) {
    const vec4  C = vec4( 0.138196601125011,0.276393202250021,0.414589803375032,-0.447213595499958);

    vec4 i  = floor(v + dot(v, vec4(F4)) );
    vec4 x0 = v -   i + dot(i, C.xxxx);

    vec4 i0;
    vec3 isX = step( x0.yzw, x0.xxx );
    vec3 isYZ = step( x0.zww, x0.yyz );
    i0.x = isX.x + isX.y + isX.z;
    i0.yzw = 1.0 - isX;
    i0.y += isYZ.x + isYZ.y;
    i0.zw += 1.0 - isYZ.xy;
    i0.z += isYZ.z;
    i0.w += 1.0 - isYZ.z;

    vec4 i3 = clamp( i0, 0.0, 1.0 );
    vec4 i2 = clamp( i0-1.0, 0.0, 1.0 );
    vec4 i1 = clamp( i0-2.0, 0.0, 1.0 );

    vec4 x1 = x0 - i1 + C.xxxx;
    vec4 x2 = x0 - i2 + C.yyyy;
    vec4 x3 = x0 - i3 + C.zzzz;
    vec4 x4 = x0 + C.wwww;

    i = mod289(i);
    float j0 = permute( permute( permute( permute(i.w) + i.z) + i.y) + i.x);
    vec4 j1 = permute( permute( permute( permute (
             i.w + vec4(i1.w, i2.w, i3.w, 1.0 ))
           + i.z + vec4(i1.z, i2.z, i3.z, 1.0 ))
           + i.y + vec4(i1.y, i2.y, i3.y, 1.0 ))
           + i.x + vec4(i1.x, i2.x, i3.x, 1.0 ));

    vec4 ip = vec4(1.0/294.0, 1.0/49.0, 1.0/7.0, 0.0) ;

    vec4 p0 = grad4(j0,   ip);
    vec4 p1 = grad4(j1.x, ip);
    vec4 p2 = grad4(j1.y, ip);
    vec4 p3 = grad4(j1.z, ip);
    vec4 p4 = grad4(j1.w, ip);

    vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
    p0 *= norm.x;
    p1 *= norm.y;
    p2 *= norm.z;
    p3 *= norm.w;
    p4 *= taylorInvSqrt(dot(p4,p4));

    vec3 values0 = vec3(dot(p0, x0), dot(p1, x1), dot(p2, x2)); 
    vec2 values1 = vec2(dot(p3, x3), dot(p4, x4));

    vec3 m0 = max(0.5 - vec3(dot(x0,x0), dot(x1,x1), dot(x2,x2)), 0.0); 
    vec2 m1 = max(0.5 - vec2(dot(x3,x3), dot(x4,x4)), 0.0);

    vec3 temp0 = -6.0 * m0 * m0 * values0;
    vec2 temp1 = -6.0 * m1 * m1 * values1;

    vec3 mmm0 = m0 * m0 * m0;
    vec2 mmm1 = m1 * m1 * m1;

    float dx = temp0[0] * x0.x + temp0[1] * x1.x + temp0[2] * x2.x + temp1[0] * x3.x + temp1[1] * x4.x + mmm0[0] * p0.x + mmm0[1] * p1.x + mmm0[2] * p2.x + mmm1[0] * p3.x + mmm1[1] * p4.x;
    float dy = temp0[0] * x0.y + temp0[1] * x1.y + temp0[2] * x2.y + temp1[0] * x3.y + temp1[1] * x4.y + mmm0[0] * p0.y + mmm0[1] * p1.y + mmm0[2] * p2.y + mmm1[0] * p3.y + mmm1[1] * p4.y;
    float dz = temp0[0] * x0.z + temp0[1] * x1.z + temp0[2] * x2.z + temp1[0] * x3.z + temp1[1] * x4.z + mmm0[0] * p0.z + mmm0[1] * p1.z + mmm0[2] * p2.z + mmm1[0] * p3.z + mmm1[1] * p4.z;
    float dw = temp0[0] * x0.w + temp0[1] * x1.w + temp0[2] * x2.w + temp1[0] * x3.w + temp1[1] * x4.w + mmm0[0] * p0.w + mmm0[1] * p1.w + mmm0[2] * p2.w + mmm1[0] * p3.w + mmm1[1] * p4.w;

    return vec4(dx, dy, dz, dw) * 49.0;
}

#pragma glslify: export(simplexNoiseDerivatives)

vec3 curl( in vec3 p, in float noiseTime, in float persistence ) {

    vec4 xNoisePotentialDerivatives = vec4(0.0);
    vec4 yNoisePotentialDerivatives = vec4(0.0);
    vec4 zNoisePotentialDerivatives = vec4(0.0);

    for (int i = 0; i < 3; ++i) {

        float twoPowI = pow(2.0, float(i));
        float scale = 0.5 * twoPowI * pow(persistence, float(i));

        xNoisePotentialDerivatives += simplexNoiseDerivatives(vec4(p * twoPowI, noiseTime)) * scale;
        yNoisePotentialDerivatives += simplexNoiseDerivatives(vec4((p + vec3(123.4, 129845.6, -1239.1)) * twoPowI, noiseTime)) * scale;
        zNoisePotentialDerivatives += simplexNoiseDerivatives(vec4((p + vec3(-9519.0, 9051.0, -123.0)) * twoPowI, noiseTime)) * scale;
    }

    return vec3(
        zNoisePotentialDerivatives[1] - yNoisePotentialDerivatives[2],
        xNoisePotentialDerivatives[2] - zNoisePotentialDerivatives[0],
        yNoisePotentialDerivatives[0] - xNoisePotentialDerivatives[1]
    );

}

#pragma glslify: export(curl)

void main() {

    vec2 uv = gl_FragCoord.xy / resolution.xy;

    vec4 positionInfo = texture2D(texturePosition, uv);
    vec3 position = mix(vec3(0.0, -200.0, 0.0), positionInfo.xyz, smoothstep(0.0, 0.3, initAnimation));
    float life = positionInfo.a - dieSpeed;

    vec3 followPosition = mix(vec3(0.0, -(1.0 - initAnimation) * 200.0, 0.0), mouse3d, smoothstep(0.2, 0.7, initAnimation));

    if(life < 0.0) {
        positionInfo = texture2D(textureDefaultPosition, uv);
        position = positionInfo.xyz * (1.0 + sin(time * 15.0) * 0.2 + (1.0 - initAnimation)) * 0.4 * radius;
        position += followPosition;
        life = 0.5 + fract(positionInfo.w * 21.4131 + time);
    } else {
        vec3 delta = followPosition - position;
        position += delta * (0.005 + life * 0.01) * attraction * (1.0 - smoothstep(50.0, 350.0, length(delta))) * speed;
        position += curl(position * curlSize, time, 0.1 + (1.0 - life) * 0.1) * speed;
    }

    gl_FragColor = vec4(position, life);

}`;
let Xv, us, J3, hs, Yv, Jv, Kv, K3 = 0,
    Qc, Of;
const Nf = En.simulatorTextureWidth,
    kf = En.simulatorTextureHeight,
    nS = Nf * kf;

function q3(r) {
    K3 = r
}

function Z3(r) {
    hs = r;
    const e = "precision " + r.capabilities.precision + ` float;
`;
    Jv = new ho, Kv = new Fl, Kv.position.z = 1, Xv = new Fv({
        uniforms: {
            resolution: {
                value: new Ue(Nf, kf)
            },
            texture: {
                value: void 0
            }
        },
        vertexShader: e + D2,
        fragmentShader: e + Sq
    }), us = new Fv({
        uniforms: {
            resolution: {
                value: new Ue(Nf, kf)
            },
            texturePosition: {
                value: void 0
            },
            textureDefaultPosition: {
                value: void 0
            },
            mouse3d: {
                value: new K
            },
            speed: {
                value: 1
            },
            dieSpeed: {
                value: 0
            },
            radius: {
                value: 0
            },
            curlSize: {
                value: 0
            },
            attraction: {
                value: 0
            },
            time: {
                value: 0
            },
            initAnimation: {
                value: 0
            }
        },
        vertexShader: e + D2,
        fragmentShader: e + Mq,
        blending: pi,
        transparent: !1,
        depthWrite: !1,
        depthTest: !1
    }), Yv = new Tn(new bs(2, 2), Xv), Jv.add(Yv), Qc = new Zn(Nf, kf, {
        wrapS: Nn,
        wrapT: Nn,
        minFilter: bn,
        magFilter: bn,
        format: kn,
        type: Bn,
        depthBuffer: !1,
        stencilBuffer: !1
    }), Of = Qc.clone();
    const t = bq();
    L2(t, Qc), L2(t, Of)
}

function L2(r, e) {
    Yv.material = Xv, Xv.uniforms.texture.value = r, hs.setRenderTarget(e), hs.render(Jv, Kv), hs.setRenderTarget(null)
}

function wq(r) {
    let e = Qc;
    Qc = Of, Of = e, Yv.material = us, us.uniforms.textureDefaultPosition.value = J3, us.uniforms.texturePosition.value = Of.texture, us.uniforms.time.value += r * .001, hs.setRenderTarget(Qc), hs.render(Jv, Kv), hs.setRenderTarget(null)
}

function bq() {
    const r = new Float32Array(nS * 4);
    let e, t, n, i;
    for (let o = 0; o < nS; o++) e = o * 4, t = (.5 + Math.random() * .5) * 50, n = (Math.random() - .5) * Math.PI, i = Math.random() * Math.PI * 2, r[e + 0] = t * Math.cos(i) * Math.cos(n), r[e + 1] = t * Math.sin(n), r[e + 2] = t * Math.sin(i) * Math.cos(n), r[e + 3] = Math.random();
    const s = new qr(r, Nf, kf, kn, Bn);
    return s.minFilter = bn, s.magFilter = bn, s.needsUpdate = !0, s.generateMipmaps = !1, s.flipY = !1, J3 = s, s
}

function Q3(r) {
    if (En.speed !== void 0 || En.dieSpeed !== void 0) {
        const e = hs.autoClearColor,
            t = hs.getClearColor(new rt).getHex(),
            n = hs.getClearAlpha();
        hs.autoClearColor = !1;
        const i = r / 16.6667;
        us.uniforms.speed.value = (En.speed ? ? 0) * i, us.uniforms.dieSpeed.value = (En.dieSpeed ? ? 0) * i, us.uniforms.radius.value = En.radius, us.uniforms.curlSize.value = En.curlSize, us.uniforms.attraction.value = En.attraction, us.uniforms.initAnimation.value = K3, En.mouse3d && us.uniforms.mouse3d.value && us.uniforms.mouse3d.value.copy(En.mouse3d), wq(r), hs.setClearColor(t, n), hs.autoClearColor = e
    }
}
const Tq = Object.freeze(Object.defineProperty({
    __proto__: null,
    AMOUNT: nS,
    TEXTURE_HEIGHT: kf,
    TEXTURE_WIDTH: Nf,
    init: Z3,
    get positionRenderTarget() {
        return Qc
    },
    get prevPositionRenderTarget() {
        return Of
    },
    setInitAnimation: q3,
    update: Q3
}, Symbol.toStringTag, {
    value: "Module"
}));
var Eq = `#include <common>
#include <normal_pars_vertex>
#include <shadowmap_pars_vertex>
#include <fog_pars_vertex>

uniform sampler2D texturePosition;

varying float vLife;

void main() {
    vec4 positionInfo = texture2D( texturePosition, position.xy );

    vec4 worldPosition = modelMatrix * vec4( positionInfo.xyz, 1.0 );
    vec4 mvPosition = viewMatrix * worldPosition;

    
    

    vLife = positionInfo.w;
    gl_PointSize = 1300.0 / length( mvPosition.xyz ) * smoothstep(0.0, 0.2, positionInfo.w);

    gl_Position = projectionMatrix * mvPosition;

    
	
}`,
    $3 = `#include <common>
#include <packing>
#include <lights_pars_begin>
#include <shadowmap_pars_fragment>
#include <shadowmask_pars_fragment>
#include <fog_pars_fragment>

varying float vLife;
uniform vec3 color1;
uniform vec3 color2;

void main() {

    vec3 outgoingLight = mix(color2, color1, smoothstep(0.0, 0.7, vLife));
	
    outgoingLight *=  getShadowMask();

	outgoingLight = pow( outgoingLight, vec3( 1.0 / 2.2 ) );

    gl_FragColor = vec4( outgoingLight, 1.0 );
	
	#include <fog_fragment>
}`,
    Cq = `uniform sampler2D texturePosition;

varying vec4 vWorldPosition;

void main() {

    vec4 positionInfo = texture2D( texturePosition, position.xy );

    vec4 worldPosition = modelMatrix * vec4( positionInfo.xyz, 1.0 );
    vec4 mvPosition = viewMatrix * worldPosition;

    gl_PointSize = 50.0 / length( mvPosition.xyz );

    vWorldPosition = worldPosition;

    gl_Position = projectionMatrix * mvPosition;

}`,
    eF = `#define DISTANCE
#include <common>
#include <packing>

uniform vec3 referencePosition;
uniform float nearDistance;
uniform float farDistance;
varying vec4 vWorldPosition;

void main () {

	float dist = length( vWorldPosition.xyz - referencePosition );
	dist = ( dist - nearDistance ) / ( farDistance - nearDistance );
	dist = saturate( dist ); 

	gl_FragColor = packDepthToRGBA( dist);
}`,
    Rq = `#include <common>
#include <normal_pars_vertex>
#include <shadowmap_pars_vertex>
#include <fog_pars_vertex>

uniform sampler2D texturePosition;

varying float vLife;
attribute vec3 positionFlip;
attribute vec2 fboUV;

uniform float flipRatio;
uniform mat4 cameraMatrix;

void main() {

	vec4 positionInfo = texture2D( texturePosition, fboUV );
    vec3 pos = positionInfo.xyz;

    vec4 worldPosition = modelMatrix * vec4( pos, 1.0 );
    vec4 mvPosition = viewMatrix * worldPosition;

    vLife = positionInfo.w;

    mvPosition += vec4((position + (positionFlip - position) * flipRatio) * smoothstep(0.0, 0.2, vLife), 0.0);
    gl_Position = projectionMatrix * mvPosition;
    worldPosition = cameraMatrix * mvPosition;
	
	vec3 objectNormal = vec3( 0.0, 1.0, 0.0 );
	vec3 transformedNormal = objectNormal;
	
	#include <normal_vertex>
	#include <shadowmap_vertex>
}`,
    Pq = `uniform sampler2D texturePosition;

varying vec4 vWorldPosition;

attribute vec3 positionFlip;
attribute vec2 fboUV;

uniform float flipRatio;

void main() {

    vec4 positionInfo = texture2D( texturePosition, fboUV );
    vec3 pos = positionInfo.xyz;

    vec4 worldPosition = modelMatrix * vec4( pos, 1.0 );
    vec4 mvPosition = viewMatrix * worldPosition;

    vWorldPosition = worldPosition;

    gl_Position = projectionMatrix * (mvPosition + vec4((position + (positionFlip - position) * flipRatio) * smoothstep(0.0, 0.2, positionInfo.w), 0.0));

}`;
const ll = void 0;
let Lp, iS, rS, sS, tF, Yy, Jy, Ed, ma;
const $c = En.simulatorTextureWidth,
    Mw = En.simulatorTextureHeight,
    wf = $c * Mw;

function Iq(r, e) {
    Lp = new vn, ma = `precision ${r.capabilities.precision} float;
`, Ed = new rt, Yy = new rt(En.color1), Jy = new rt(En.color2), tF = [sS = Dq(), rS = Bq()], sS.visible = !1, rS.visible = !1, iS = e
}

function Bq() {
    const r = new Float32Array(wf * 3);
    let e;
    for (let s = 0; s < wf; s++) e = s * 3, r[e] = s % $c / $c, r[e + 1] = Math.floor(s / $c) / Mw, r[e + 2] = 0;
    const t = new zt;
    t.setAttribute("position", new an(r, 3));
    const n = new Fn({
        uniforms: bl.merge([dt.lights, dt.fog, {
            texturePosition: {
                value: ll
            },
            color1: {
                value: ll
            },
            color2: {
                value: ll
            }
        }]),
        vertexShader: ma + Eq,
        fragmentShader: ma + $3,
        blending: pi,
        side: hn,
        lights: !0,
        fog: !0
    });
    n.uniforms.color1.value = Yy, n.uniforms.color2.value = Jy;
    const i = new Ay(t, n);
    return i.customDistanceMaterial = new Fn({
        uniforms: {
            lightPos: {
                value: new K(0, 0, 0)
            },
            texturePosition: {
                value: ll
            }
        },
        vertexShader: ma + Cq,
        fragmentShader: ma + eF,
        depthTest: !0,
        depthWrite: !0,
        side: di,
        blending: pi
    }), i.castShadow = !0, i.receiveShadow = !0, Lp.add(i), i
}

function Dq() {
    const r = new Float32Array(wf * 3 * 3),
        e = new Float32Array(wf * 3 * 3),
        t = new Float32Array(wf * 2 * 3),
        n = Math.PI,
        i = n * 2 / 3,
        s = [Math.sin(i * 2 + n), Math.cos(i * 2 + n), Math.sin(i + n), Math.cos(i + n), Math.sin(i * 3 + n), Math.cos(i * 3 + n), Math.sin(i * 2), Math.cos(i * 2), Math.sin(i), Math.cos(i), Math.sin(i * 3), Math.cos(i * 3)];
    let o, a;
    for (let f = 0; f < wf; f++) o = f * 6, a = f * 9, f % 2 ? (r[a] = s[0], r[a + 1] = s[1], r[a + 3] = s[2], r[a + 4] = s[3], r[a + 6] = s[4], r[a + 7] = s[5], e[a] = s[6], e[a + 1] = s[7], e[a + 3] = s[8], e[a + 4] = s[9], e[a + 6] = s[10], e[a + 7] = s[11]) : (e[a] = s[0], e[a + 1] = s[1], e[a + 3] = s[2], e[a + 4] = s[3], e[a + 6] = s[4], e[a + 7] = s[5], r[a] = s[6], r[a + 1] = s[7], r[a + 3] = s[8], r[a + 4] = s[9], r[a + 6] = s[10], r[a + 7] = s[11]), t[o] = t[o + 2] = t[o + 4] = f % $c / $c, t[o + 1] = t[o + 3] = t[o + 5] = Math.floor(f / $c) / Mw;
    const l = new zt;
    l.setAttribute("position", new an(r, 3)), l.setAttribute("positionFlip", new an(e, 3)), l.setAttribute("fboUV", new an(t, 2));
    const c = new Fn({
        uniforms: bl.merge([dt.fog, dt.lights, {
            texturePosition: {
                value: ll
            },
            flipRatio: {
                value: 0
            },
            color1: {
                value: ll
            },
            color2: {
                value: ll
            },
            cameraMatrix: {
                value: En.camera.matrixWorld
            }
        }]),
        vertexShader: ma + Rq,
        fragmentShader: ma + $3,
        blending: pi,
        side: hn,
        lights: !0,
        fog: !0
    });
    c.uniforms.color1.value = Yy, c.uniforms.color2.value = Jy, c.uniforms.cameraMatrix.value = En.camera.matrixWorld;
    const u = new Tn(l, c);
    return u.customDistanceMaterial = new Fn({
        uniforms: bl.merge([dt.common, {
            referencePosition: {
                value: new K
            },
            nearDistance: {
                value: 1
            },
            farDistance: {
                value: 1e3
            }
        }, {
            texturePosition: {
                value: ll
            },
            flipRatio: {
                value: 0
            }
        }]),
        vertexShader: ma + Pq,
        fragmentShader: ma + eF,
        depthTest: !0,
        depthWrite: !0,
        side: di,
        blending: pi
    }), u.customDistanceMaterial.isMeshDistanceMaterial = !0, u.castShadow = !0, u.receiveShadow = !0, Lp.add(u), u
}

function Lq() {
    sS.visible = En.useTriangleParticles, rS.visible = !En.useTriangleParticles, Ed.setStyle(En.color1), Yy.lerp(Ed, .05), Ed.setStyle(En.color2), Jy.lerp(Ed, .05), tF.forEach(r => {
        const e = r.material;
        e.uniforms.texturePosition.value = iS.positionRenderTarget.texture, r.customDistanceMaterial.uniforms.texturePosition.value = iS.positionRenderTarget.texture, "flipRatio" in e.uniforms && (e.uniforms.flipRatio.value ^= 1, r.customDistanceMaterial.uniforms.flipRatio.value ^= 1)
    })
}
let el, _c, oS, R1 = .45;

function Fq() {
    el = new vn, el.position.set(0, 500, 0), oS = new dM(3355443), el.add(oS), _c = new Uy(16777215, .5), _c.castShadow = !0, _c.shadow.camera.near = 10, _c.shadow.camera.far = 700, _c.shadow.mapSize.width = 4096, _c.shadow.mapSize.height = 2048, el.add(_c);
    const r = new Mp(12225419, .5);
    r.position.set(1, 1, 1), el.add(r);
    const e = new Mp(9157300, .3);
    e.position.set(1, 1, -1), el.add(e)
}

function Uq() {
    R1 += (En.shadowDarkness - R1) * .1, oS.intensity = (1 - R1) * 50
}
var Oq = `#ifdef GL_ES
precision mediump float;
#endif

uniform sampler2D tCustomScene;

void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
  vec4 hoverColor = texture2D(tCustomScene, uv);
  hoverColor.a = 0.1;
  outputColor = hoverColor * hoverColor.a + inputColor * (1.0 - hoverColor.a);
}`;
class nF extends oh {
    constructor({
        blendFunction: t = dn.NORMAL,
        customScene: n,
        customCamera: i,
        width: s,
        height: o
    }) {
        super("HoverEffect", Oq, {
            blendFunction: t,
            uniforms: new Map([
                ["tCustomScene", new Wn(null)],
                ["tDiffuse", new Wn(null)]
            ])
        });
        ss(this, "customScene");
        ss(this, "customCamera");
        ss(this, "renderTarget");
        this.customScene = n, this.customCamera = i, this.renderTarget = new Zn(s, o), this.setSize(s, o)
    }
    update(t, n) {
        t.setRenderTarget(this.renderTarget), t.clear(), t.render(this.customScene, this.customCamera), t.setRenderTarget(null), this.uniforms.get("tCustomScene").value = this.renderTarget.texture, this.uniforms.get("tDiffuse").value = n.texture
    }
    setSize(t, n) {
        this.renderTarget.setSize(t, n)
    }
    dispose() {
        this.renderTarget.dispose()
    }
}
Ny({
    HoverEffectImpl: nF
});
const Nq = () => {
        const {
            gl: r,
            size: e
        } = qn(), t = N.useRef(), n = N.useRef(), i = N.useRef(), s = N.useRef(0), o = N.useRef(new Ll), a = N.useRef(), l = N.useRef(), c = N.useMemo(() => {
            const u = e.width,
                f = e.height,
                d = new ho,
                m = new ri(45, u / f, 10, 3e3);
            m.position.set(0, 100, 400), m.updateProjectionMatrix(), n.current = d, i.current = m, En.mouse = new Ue(0, 0), En.mouse3d = o.current.origin, En.camera = m, En.cameraPosition = m.position, Z3(r), Iq(r, Tq), a.current = Lp, d.add(Lp), Fq(), l.current = el, d.add(el);
            const g = new nF({
                blendFunction: dn.NORMAL,
                customScene: d,
                customCamera: m,
                width: u,
                height: f
            });
            return t.current = g, g
        }, [r]);
        return Es((u, f) => {
            const d = f * 1e3,
                m = i.current;
            s.current = Math.min(s.current + d * 25e-5, 1), q3(s.current), Uq(), m.updateMatrixWorld(), o.current.origin.setFromMatrixPosition(m.matrixWorld), o.current.direction.set(En.mouse.x, En.mouse.y, .5).unproject(m).sub(o.current.origin).normalize();
            const g = o.current.origin.length() / Math.cos(Math.PI - o.current.direction.angleTo(o.current.origin));
            o.current.origin.add(o.current.direction.multiplyScalar(g * 1)), Q3(d), Lq()
        }), N.useEffect(() => {
            (() => {
                var m;
                const f = e.width,
                    d = e.height;
                r.setSize(f, d), i.current.aspect = f / d, i.current.updateProjectionMatrix(), (m = t.current) == null || m.setSize(f, d)
            })()
        }, [e, r]), N.useEffect(() => {
            const u = f => {
                const d = r.domElement.getBoundingClientRect(),
                    m = (f.clientX - d.left) / d.width * 2 - 1,
                    g = -((f.clientY - d.top) / d.height) * 2 + 1;
                En.mouse.set(m, g)
            };
            return document.addEventListener("mousemove", u), () => {
                document.removeEventListener("mousemove", u)
            }
        }, [r]), N.useEffect(() => {
            const u = f => {
                (f.key === " " || f.code === "Space") && (En.speed = En.speed === 0 ? 1 : 0, En.dieSpeed = En.dieSpeed === 0 ? .015 : 0)
            };
            return window.addEventListener("keyup", u), () => {
                window.removeEventListener("keyup", u)
            }
        }, []), N.useEffect(() => () => {
            var u;
            t.current.dispose && ((u = t.current) == null || u.dispose())
        }, []), G.jsx("primitive", {
            object: c,
            attach: "passes",
            dispose: null
        })
    },
    zf = "" + new URL("card_back-BPqxTONB.png",
        import.meta.url).href,
    iF = "" + new URL("card_front-Bicc-y4r.png",
        import.meta.url).href,
    rF = "" + new URL("card_front_s-BnO6P_Us.png",
        import.meta.url).href,
    sF = "" + new URL("card_front_t-C3iz1KtY.png",
        import.meta.url).href,
    oF = "" + new URL("card_section_text-CVxDZu5l.png",
        import.meta.url).href,
    Ms = "" + new URL("NECOSMIC-t_FS4Hhi.OTF",
        import.meta.url).href;
var kq = `varying vec2 vUv;
void main() {
  vUv = uv;
  gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
}`,
    zq = `uniform float progress;
uniform vec3 borderColor;
uniform vec3 highlightColor;
varying vec2 vUv;

void main() {
  
  float distance = length(vUv - vec2(0.5, 0.5));
  
  
  float angle = atan(vUv.y - 0.5, vUv.x - 0.5);

  
  angle -= 0.25 * -5.5; 

  
  float progressAngle = mod(angle + 6.28319, 6.28319) / 6.28319;

  
  float fill = step(progressAngle, progress);

  
  vec3 finalColor = mix(borderColor, highlightColor, fill);
  gl_FragColor = vec4(finalColor, 1.0);
}`;
const P1 = "abcdefghijklmnopqrstuvwxyz",
    F2 = "~`!@#$%^&*()-+=/*[]{}:<>?",
    Gq = "!@#$%^&*()-_=+[]{};:<>/?~0123456789",
    I1 = "0123456789",
    sf = {
        ALL: "all",
        NUMBERS: "numbers",
        ALPHABETS: "alphabets",
        MATRIX: "matrix",
        SPECIAL_CHARS: "specialchars",
        ALPHA_NUMERIC: "alphanumeric"
    },
    Hq = r => {
        switch (r) {
            case sf.ALPHABETS:
                return P1;
            case sf.NUMBERS:
                return I1;
            case sf.SPECIAL_CHARS:
                return F2;
            case sf.MATRIX:
                return Gq;
            case sf.ALPHA_NUMERIC:
                return P1 + I1;
            case sf.ALL:
            default:
                return P1 + I1 + F2
        }
    };
let _0;
const Vq = ({
        text: r,
        speed: e = 50,
        letterCase: t = "uppercase",
        type: n = "alphabets",
        position: i = [0, 0, .001],
        color: s = "#ffffff",
        fontSize: o = .1
    }) => {
        const a = N.useRef(null),
            l = N.useRef(r),
            c = N.useCallback(() => {
                let u = 0;
                clearInterval(_0), _0 = setInterval(() => {
                    const f = Hq(n);
                    l.current = r.split("").map((d, m) => {
                        if (d === " ") return " ";
                        if (m < u) return r[m];
                        const g = f[Math.floor(Math.random() * f.length)];
                        return t === "uppercase" ? g.toUpperCase() : g.toLowerCase()
                    }).join(""), a.current && (a.current.text = l.current), u >= r.length && clearInterval(_0), u += 1
                }, e / 2)
            }, [t, e, n, r]);
        return N.useEffect(() => (c(), () => clearInterval(_0)), [c]), G.jsx(Di, {
            ref: a,
            position: i,
            fontSize: o,
            anchorX: "center",
            anchorY: "middle",
            textAlign: "center",
            maxWidth: 1.7,
            font: Ms,
            material: new Mi({
                color: s,
                side: hn
            }),
            children: r
        })
    },
    Wq = N.memo(r => {
        const [e, t] = N.useState(!1);
        return G.jsxs("group", {
            children: [G.jsxs("mesh", {
                rotation: [0, Math.PI, 0],
                position: [0, 0, 0],
                onPointerEnter: () => t(!0),
                onPointerLeave: () => t(!1),
                children: [G.jsx("planeGeometry", {
                    args: r.isMobile ? [3, 5.7] : [2, 3.8]
                }), G.jsx("meshBasicMaterial", {
                    transparent: !0,
                    opacity: 0
                })]
            }), G.jsx("mesh", {
                rotation: [0, Math.PI, 0],
                position: [0, 0, -.01],
                children: e && !r.isMobile ? G.jsx(Vq, {
                    text: r.text,
                    type: "alphabets",
                    speed: 2,
                    position: [0, 0, 0],
                    color: "#ffffff",
                    fontSize: .12
                }) : G.jsx(Di, {
                    position: [0, 0, 0],
                    fontSize: r.isMobile ? .18 : .12,
                    color: "#ffffff",
                    anchorX: "center",
                    anchorY: "middle",
                    textAlign: "center",
                    maxWidth: r.isMobile ? 2.6 : 2,
                    font: Ms,
                    children: r.text
                })
            })]
        })
    }),
    Gf = r => {
        const e = N.useRef(null),
            t = vr(zo, r.backCard),
            n = vr(zo, r.frontCard),
            i = (f, d, m) => {
                const g = new dl;
                return g.absarc(f / 2 - m, -d / 2 + m, m, -Math.PI / 2, 0, !1), g.absarc(f / 2 - m, d / 2 - m, m, 0, Math.PI / 2, !1), g.absarc(-f / 2 + m, d / 2 - m, m, Math.PI / 2, Math.PI, !1), g.absarc(-f / 2 + m, -d / 2 + m, m, Math.PI, -Math.PI / 2, !1), g.closePath(), g
            },
            s = r.isMobile ? i(3.24, 5.74, .2) : i(2.24, 3.84, .14),
            o = new em(s),
            a = new Fn({
                uniforms: {
                    progress: {
                        value: 0
                    },
                    borderColor: {
                        value: new rt("#50525A")
                    },
                    highlightColor: {
                        value: new rt("#ffffff")
                    }
                },
                vertexShader: kq,
                fragmentShader: zq,
                side: hn,
                transparent: !0,
                depthWrite: !1
            }),
            l = new Tn(o, a),
            c = () => {
                e.current && !r.isMobile && et.to(e.current.scale, {
                    x: 1.12,
                    y: 1.12,
                    z: 1.12,
                    duration: .5,
                    ease: "power2.out"
                }), r.isMobile || et.to(a.uniforms.progress, {
                    value: 1,
                    duration: 1
                })
            },
            u = () => {
                e.current && !r.isMobile && et.to(e.current.scale, {
                    x: 1,
                    y: 1,
                    z: 1,
                    duration: .5,
                    ease: "power2.out"
                }), r.isMobile || et.to(a.uniforms.progress, {
                    value: 0,
                    duration: 1
                })
            };
        return N.useEffect(() => {
            if (e.current && !r.isMobile) {
                const f = r.index * .2;
                et.to(e.current.position, {
                    y: "+=0.1",
                    duration: 1 + r.index * .1,
                    ease: "power1.inOut",
                    yoyo: !0,
                    repeat: -1,
                    delay: f
                })
            }
        }, [r.index]), G.jsxs("group", {
            ref: e,
            onPointerOver: c,
            onPointerOut: u,
            children: [G.jsxs("mesh", {
                position: [0, 0, .015],
                children: [G.jsx("planeGeometry", {
                    args: r.isMobile ? [3.2, 5.7] : [2.2, 3.8]
                }), G.jsx("meshBasicMaterial", {
                    map: t,
                    transparent: !0,
                    depthWrite: !0
                })]
            }), G.jsxs("mesh", {
                rotation: [0, Math.PI, 0],
                position: [0, 0, 0],
                children: [G.jsx("planeGeometry", {
                    args: r.isMobile ? [3.2, 5.7] : [2.2, 3.8]
                }), G.jsx("meshBasicMaterial", {
                    map: n,
                    transparent: !0,
                    depthWrite: !0
                })]
            }), G.jsx(Wq, {
                text: r.text,
                isMobile: r.isMobile
            }), G.jsx("primitive", {
                object: l,
                position: [0, 0, .01]
            })]
        })
    },
    gl = ({
        children: r,
        rotationSensitivity: e = .2,
        positionSensitivity: t = .2,
        lerpFactor: n = .1,
        ...i
    }) => {
        const s = N.useRef(null),
            o = N.useRef(null),
            {
                camera: a,
                mouse: l
            } = qn(f => ({
                camera: f.camera,
                mouse: f.mouse
            }));
        N.useEffect(() => {
            s.current && (o.current = s.current.position.clone())
        }, []);
        const c = new K,
            u = new K;
        return Es(() => {
            const f = s.current;
            if (!f || !o.current) return;
            f.getWorldPosition(c), u.copy(c).project(a);
            const d = l.x - u.x,
                m = l.y - u.y;
            f.rotation.x = ha.lerp(f.rotation.x, m * e, n), f.rotation.y = ha.lerp(f.rotation.y, d * e, n), f.position.x = ha.lerp(f.position.x, (o.current.x ? ? 0) + d * t, n), f.position.y = ha.lerp(f.position.y, (o.current.y ? ? 0) + m * t, n)
        }), G.jsx("group", {
            ref: s,
            ...i,
            children: r
        })
    },
    jq = () => {
        const r = N.useRef(null),
            e = N.useRef(null),
            t = N.useRef(null),
            n = N.useRef(null);
        N.useEffect(() => {
            nK({
                cardGroup: r,
                cardOne: e,
                cardSecond: t,
                cardThird: n
            })
        }, [r]);
        const i = new Mi({
                color: "#fff",
                side: hn
            }),
            s = vr(zo, oF);
        return G.jsxs("group", {
            ref: r,
            children: [G.jsxs("group", {
                position: [0, 2, 0],
                children: [G.jsx(Di, {
                    position: [0, 0, 0],
                    rotation: [0, 0, 0],
                    font: Ms,
                    fontSize: .5,
                    anchorX: "center",
                    anchorY: "middle",
                    material: i,
                    children: "Purpose &"
                }), G.jsx(Di, {
                    position: [0, -.7, 0],
                    rotation: [0, 0, 0],
                    font: Ms,
                    fontSize: .5,
                    anchorX: "center",
                    anchorY: "middle",
                    material: i,
                    children: "Vision"
                })]
            }), G.jsx("group", {
                ref: e,
                children: G.jsx(gl, {
                    children: G.jsx(Gf, {
                        index: 1,
                        backCard: zf,
                        frontCard: iF,
                        text: "Accelerate innovation in AI by providing developers with a direct path to monetization"
                    })
                })
            }), G.jsxs("group", {
                position: [2, -1.5, 0],
                children: [G.jsxs("mesh", {
                    position: [0, 0, 0],
                    scale: [.2, .2, .2],
                    children: [G.jsx("planeGeometry", {
                        args: [14, 1.68]
                    }), G.jsx("meshBasicMaterial", {
                        map: s,
                        transparent: !0
                    })]
                }), G.jsx(Di, {
                    position: [.33, -.54, 0],
                    rotation: [0, 0, 0],
                    font: nh,
                    fontSize: .145,
                    anchorX: "center",
                    anchorY: "middle",
                    maxWidth: 3.2,
                    material: i,
                    children: "Sage provides a novel mechanism for funding and profiting from AI development"
                })]
            }), G.jsx("group", {
                ref: t,
                children: G.jsx(gl, {
                    children: G.jsx(Gf, {
                        index: 2,
                        backCard: zf,
                        frontCard: rF,
                        text: "Create a community-driven ecosystem where the value of AI models is recognized and rewarded"
                    })
                })
            }), G.jsx("group", {
                ref: n,
                children: G.jsx(gl, {
                    children: G.jsx(Gf, {
                        index: 3,
                        backCard: zf,
                        frontCard: sF,
                        text: "Offer investors & enthusiasts a stake in the success of AI models"
                    })
                })
            })]
        })
    },
    Xq = [{}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {}, {
        text1: "creators earn",
        text2: "earn a percentage & incentivizing high quality models"
    }, {}, {
        text1: "own Models",
        text2: "Own & utilize the model as you please"
    }, {}, {
        text1: "users Get tokens",
        text2: "purchase model access tokens - bytes"
    }, {}, {
        text1: "dev Upload model",
        text2: "Upload or Link Model"
    }, {}, {
        text2: "< how it works >"
    }, {}, {}, {}, {}],
    Yq = [{
        text2: "< how it works >"
    }, {
        text1: "Upload model",
        text2: "Upload or Link Model"
    }, {
        text1: "Get tokens",
        text2: "purchase model access tokens - bytes"
    }, {
        text1: "own Models",
        text2: "Own & utilize the model as you please"
    }, {
        text1: "earn",
        text2: "earn a percentage & incentivizing high quality models"
    }],
    Jq = {
        style: {
            fontSize: .35,
            color: "white",
            anchorX: "center",
            anchorY: "middle",
            font: Ms,
            letterSpacing: .05,
            outlineWidth: 0,
            outlineColor: "black"
        },
        tiltAngle: -.2
    },
    Kq = {
        style: {
            fontSize: .14,
            color: "white",
            anchorX: "center",
            anchorY: "middle",
            font: Ms,
            letterSpacing: .05,
            outlineWidth: 0,
            outlineColor: "black"
        },
        tiltAngle: -.2
    },
    qq = {
        style: {
            fontSize: .4,
            color: "white",
            anchorX: "center",
            anchorY: "middle",
            font: Ms,
            letterSpacing: .05,
            outlineWidth: 0,
            outlineColor: "black"
        },
        tiltAngle: -.2
    },
    Zq = {
        style: {
            fontSize: .1,
            color: "white",
            anchorX: "center",
            anchorY: "middle",
            font: Ms,
            letterSpacing: .05,
            outlineWidth: 0,
            outlineColor: "black"
        },
        tiltAngle: -.2
    },
    Qq = {
        style: {
            fontSize: 1.01,
            color: "white",
            anchorX: "center",
            anchorY: "middle",
            font: Ms,
            letterSpacing: .05,
            outlineWidth: 0,
            outlineColor: "black"
        },
        tiltAngle: -.2
    },
    $q = {
        style: {
            fontSize: .5,
            color: "white",
            anchorX: "center",
            anchorY: "middle",
            font: Ms,
            letterSpacing: .05,
            outlineWidth: 0,
            outlineColor: "black"
        },
        tiltAngle: -.2
    },
    eZ = {
        style: {
            fontSize: 4.1,
            color: "white",
            anchorX: "center",
            anchorY: "middle",
            font: Ms,
            letterSpacing: .05,
            outlineWidth: 0,
            outlineColor: "black",
            sdfGlyphSize: 512
        },
        tiltAngle: -.2
    },
    tZ = "" + new URL("Upload-BOujsHTl.glb",
        import.meta.url).href,
    ww = r => {
        const {
            isMobile: e
        } = Nl(), {
            nodes: t
        } = $s(tZ), n = N.useMemo(() => new Br(new K(0, 0, 2), 2), []), i = _u(sm);
        return G.jsx("group", { ...r,
            dispose: null,
            children: G.jsx(gl, {
                rotationSensitivity: .1,
                positionSensitivity: .025,
                lerpFactor: .05,
                children: G.jsx("mesh", {
                    castShadow: !0,
                    receiveShadow: !0,
                    geometry: t.Plane001.geometry,
                    material: t.Plane001.material,
                    rotation: [Math.PI / 2, 15 * Math.PI / 180, 15 * Math.PI / 180],
                    scale: .795 * .8,
                    children: e ? G.jsx("meshMatcapMaterial", {
                        matcap: i,
                        side: hn,
                        transparent: !0,
                        opacity: .5
                    }) : G.jsx(rm, {
                        samples: 32,
                        thickness: .4,
                        roughness: .05,
                        chromaticAberration: 0,
                        anisotropicBlur: 0,
                        distortion: .1,
                        distortionScale: .05,
                        temporalDistortion: 0,
                        backside: !1,
                        resolution: void 0,
                        backsideResolution: void 0,
                        background: new rt("#000"),
                        buffer: null,
                        transmissionSampler: !1,
                        backsideThickness: 0,
                        transmission: 1,
                        side: hn,
                        clippingPlanes: [n]
                    })
                })
            })
        })
    },
    nZ = "" + new URL("Dollar-D9l3uwzw.glb",
        import.meta.url).href,
    bw = r => {
        const {
            isMobile: e
        } = Nl(), {
            nodes: t
        } = $s(nZ), n = N.useMemo(() => new Br(new K(0, 0, 2), 2), []), i = _u(sm);
        return G.jsx("group", { ...r,
            dispose: null,
            children: G.jsx(gl, {
                rotationSensitivity: .1,
                positionSensitivity: .025,
                lerpFactor: .05,
                children: G.jsx("mesh", {
                    castShadow: !0,
                    receiveShadow: !0,
                    geometry: t.Plane002.geometry,
                    material: t.Plane002.material,
                    rotation: [Math.PI / 2, 15 * Math.PI / 180, 0],
                    children: e ? G.jsx("meshMatcapMaterial", {
                        matcap: i,
                        side: hn,
                        transparent: !0,
                        opacity: .5
                    }) : G.jsx(rm, {
                        samples: 32,
                        thickness: .4,
                        roughness: .05,
                        chromaticAberration: 0,
                        anisotropicBlur: 0,
                        distortion: .1,
                        distortionScale: .05,
                        temporalDistortion: 0,
                        backside: !1,
                        resolution: void 0,
                        backsideResolution: void 0,
                        background: new rt("#000"),
                        buffer: null,
                        transmissionSampler: !1,
                        backsideThickness: 0,
                        transmission: 1,
                        side: hn,
                        clippingPlanes: [n]
                    })
                })
            })
        })
    },
    iZ = "" + new URL("Klucz-Cck7uU6I.glb",
        import.meta.url).href,
    Tw = r => {
        const {
            isMobile: e
        } = Nl(), {
            nodes: t
        } = $s(iZ), n = N.useMemo(() => new Br(new K(0, 0, 2), 2), []), i = _u(sm);
        return G.jsx("group", { ...r,
            dispose: null,
            children: G.jsx(gl, {
                rotationSensitivity: .1,
                positionSensitivity: .025,
                lerpFactor: .05,
                children: G.jsx("mesh", {
                    castShadow: !0,
                    receiveShadow: !0,
                    geometry: t.Plane.geometry,
                    scale: .8,
                    material: t.Plane.material,
                    rotation: [-Math.PI / 2, -20 * Math.PI / 180, -15 * Math.PI / 180],
                    children: e ? G.jsx("meshMatcapMaterial", {
                        matcap: i,
                        side: hn,
                        transparent: !0,
                        opacity: .5
                    }) : G.jsx(rm, {
                        samples: 32,
                        thickness: .4,
                        roughness: .05,
                        chromaticAberration: 0,
                        anisotropicBlur: 0,
                        distortion: .1,
                        distortionScale: .05,
                        temporalDistortion: 0,
                        backside: !1,
                        resolution: void 0,
                        backsideResolution: void 0,
                        background: new rt("#000"),
                        buffer: null,
                        transmissionSampler: !1,
                        backsideThickness: 0,
                        transmission: 1,
                        side: hn,
                        clippingPlanes: [n]
                    })
                })
            })
        })
    },
    rZ = "" + new URL("Sage_Coin-DA4d-qKD.glb",
        import.meta.url).href,
    Ew = r => {
        const {
            isMobile: e
        } = Nl(), {
            nodes: t
        } = $s(rZ), n = N.useMemo(() => new Br(new K(0, 0, 2), 2), []), i = _u(sm);
        return G.jsx("group", { ...r,
            dispose: null,
            children: G.jsx(gl, {
                rotationSensitivity: .1,
                positionSensitivity: .025,
                lerpFactor: .05,
                children: G.jsx("mesh", {
                    castShadow: !0,
                    receiveShadow: !0,
                    rotation: [Math.PI / 2, -15 * Math.PI / 180, 0],
                    geometry: t.Plane004.geometry,
                    scale: [.75, .3 * .75, .75],
                    material: t.Plane004.material,
                    children: e ? G.jsx("meshMatcapMaterial", {
                        matcap: i,
                        side: hn,
                        transparent: !0,
                        opacity: .5
                    }) : G.jsx(rm, {
                        samples: 32,
                        thickness: .4,
                        roughness: .05,
                        chromaticAberration: 0,
                        anisotropicBlur: 0,
                        distortion: .1,
                        distortionScale: .05,
                        temporalDistortion: 0,
                        backside: !1,
                        resolution: void 0,
                        backsideResolution: void 0,
                        background: new rt("#000"),
                        buffer: null,
                        transmissionSampler: !1,
                        backsideThickness: 0,
                        transmission: 1,
                        side: hn,
                        clippingPlanes: [n]
                    })
                })
            })
        })
    },
    sZ = (r, e) => N.useMemo(() => {
        const t = [],
            n = Math.PI * 2 / r;
        for (let i = 0; i < r; i++) {
            const s = i * n,
                o = e * Math.sin(s),
                a = e * Math.cos(s),
                l = 0,
                c = -s;
            t.push({
                position: [l, o, a],
                rotation: [c, 0, 0]
            })
        }
        return t
    }, [r, e]),
    oZ = N.memo(({
        index: r,
        refs: e
    }) => {
        if (!e[r]) return null;
        const t = {
            11: G.jsx(bw, {}),
            13: G.jsx(Tw, {}),
            15: G.jsx(Ew, {}),
            17: G.jsx(ww, {})
        };
        return t[r] && e[r] ? G.jsx("group", {
            ref: e[r],
            children: t[r]
        }) : null
    }),
    aZ = N.memo(({
        index: r,
        textBg: e,
        textSm: t,
        refs: n
    }) => {
        if (!n[r]) return null;
        const i = N.useMemo(() => new Br(new K(0, 0, 2), 2), []);
        return G.jsxs("group", {
            ref: n[r],
            children: [G.jsxs(Di, { ...qq.style,
                maxWidth: 10,
                textAlign: "center",
                children: [e == null ? void 0 : e.toUpperCase(), G.jsx("meshBasicMaterial", {
                    clippingPlanes: [i]
                })]
            }), G.jsxs(Di, { ...Zq.style,
                position: [0, -.5, 0],
                maxWidth: 10,
                textAlign: "center",
                fillOpacity: .5,
                children: [t, G.jsx("meshBasicMaterial", {
                    clippingPlanes: [i]
                })]
            })]
        })
    }),
    lZ = () => {
        const r = N.useRef(null),
            e = N.useRef(null),
            t = [11, 13, 15, 17].reduce((s, o) => (s[o] = N.useRef(null), s), {}),
            n = [11, 13, 15, 17, 19].reduce((s, o) => (s[o] = N.useRef(null), s), {}),
            i = sZ(24, 4);
        return N.useEffect(() => {
            iK({
                carouselGroup: r,
                contentGroup: e
            }), rK({
                modelOneGroup: t[11],
                modelTwoGroup: t[13],
                modelThreeGroup: t[15],
                modelFourGroup: t[17]
            })
        }, [r, e]), G.jsx("group", {
            ref: e,
            scale: [1.4, 1.4, 1.4],
            children: G.jsx("group", {
                ref: r,
                children: Xq.map((s, o) => {
                    const {
                        position: a,
                        rotation: l
                    } = i[o];
                    return G.jsxs("group", {
                        position: a,
                        rotation: l,
                        children: [s.text2 ? G.jsx(aZ, {
                            index: o,
                            textBg: s.text1,
                            textSm: s.text2,
                            refs: n
                        }) : null, s.text1 ? G.jsx(oZ, {
                            index: o,
                            refs: t
                        }) : null]
                    }, `carousel-${o}`)
                })
            })
        })
    },
    cZ = N.memo(lZ),
    aF = "" + new URL("Sand Miki Head-BdnCu-5n.glb",
        import.meta.url).href,
    ti = new Or,
    x0 = new K,
    U2 = new Ue,
    O2 = new Ue,
    N2 = new Ue;
class lF {
    constructor(e) {
        this.geometry = e.geometry, this.randomFunction = Math.random, this.indexAttribute = this.geometry.index, this.positionAttribute = this.geometry.getAttribute("position"), this.normalAttribute = this.geometry.getAttribute("normal"), this.colorAttribute = this.geometry.getAttribute("color"), this.uvAttribute = this.geometry.getAttribute("uv"), this.weightAttribute = null, this.distribution = null
    }
    setWeightAttribute(e) {
        return this.weightAttribute = e ? this.geometry.getAttribute(e) : null, this
    }
    build() {
        const e = this.indexAttribute,
            t = this.positionAttribute,
            n = this.weightAttribute,
            i = e ? e.count / 3 : t.count / 3,
            s = new Float32Array(i);
        for (let l = 0; l < i; l++) {
            let c = 1,
                u = 3 * l,
                f = 3 * l + 1,
                d = 3 * l + 2;
            e && (u = e.getX(u), f = e.getX(f), d = e.getX(d)), n && (c = n.getX(u) + n.getX(f) + n.getX(d)), ti.a.fromBufferAttribute(t, u), ti.b.fromBufferAttribute(t, f), ti.c.fromBufferAttribute(t, d), c *= ti.getArea(), s[l] = c
        }
        const o = new Float32Array(i);
        let a = 0;
        for (let l = 0; l < i; l++) a += s[l], o[l] = a;
        return this.distribution = o, this
    }
    setRandomGenerator(e) {
        return this.randomFunction = e, this
    }
    sample(e, t, n, i) {
        const s = this.sampleFaceIndex();
        return this.sampleFace(s, e, t, n, i)
    }
    sampleFaceIndex() {
        const e = this.distribution[this.distribution.length - 1];
        return this.binarySearch(this.randomFunction() * e)
    }
    binarySearch(e) {
        const t = this.distribution;
        let n = 0,
            i = t.length - 1,
            s = -1;
        for (; n <= i;) {
            const o = Math.ceil((n + i) / 2);
            if (o === 0 || t[o - 1] <= e && t[o] > e) {
                s = o;
                break
            } else e < t[o] ? i = o - 1 : n = o + 1
        }
        return s
    }
    sampleFace(e, t, n, i, s) {
        let o = this.randomFunction(),
            a = this.randomFunction();
        o + a > 1 && (o = 1 - o, a = 1 - a);
        const l = this.indexAttribute;
        let c = e * 3,
            u = e * 3 + 1,
            f = e * 3 + 2;
        return l && (c = l.getX(c), u = l.getX(u), f = l.getX(f)), ti.a.fromBufferAttribute(this.positionAttribute, c), ti.b.fromBufferAttribute(this.positionAttribute, u), ti.c.fromBufferAttribute(this.positionAttribute, f), t.set(0, 0, 0).addScaledVector(ti.a, o).addScaledVector(ti.b, a).addScaledVector(ti.c, 1 - (o + a)), n !== void 0 && (this.normalAttribute !== void 0 ? (ti.a.fromBufferAttribute(this.normalAttribute, c), ti.b.fromBufferAttribute(this.normalAttribute, u), ti.c.fromBufferAttribute(this.normalAttribute, f), n.set(0, 0, 0).addScaledVector(ti.a, o).addScaledVector(ti.b, a).addScaledVector(ti.c, 1 - (o + a)).normalize()) : ti.getNormal(n)), i !== void 0 && this.colorAttribute !== void 0 && (ti.a.fromBufferAttribute(this.colorAttribute, c), ti.b.fromBufferAttribute(this.colorAttribute, u), ti.c.fromBufferAttribute(this.colorAttribute, f), x0.set(0, 0, 0).addScaledVector(ti.a, o).addScaledVector(ti.b, a).addScaledVector(ti.c, 1 - (o + a)), i.r = x0.x, i.g = x0.y, i.b = x0.z), s !== void 0 && this.uvAttribute !== void 0 && (U2.fromBufferAttribute(this.uvAttribute, c), O2.fromBufferAttribute(this.uvAttribute, u), N2.fromBufferAttribute(this.uvAttribute, f), s.set(0, 0).addScaledVector(U2, o).addScaledVector(O2, a).addScaledVector(N2, 1 - (o + a))), this
    }
}
const yn = {
    useStats: !1,
    textureWidth: 512,
    textureHeight: 512,
    isPhysicsActive: !1,
    isMouseActive: !0,
    isMouseVisible: !0,
    gravityAllOnClick: !1,
    mouseZRatio: 1,
    resetAnimation: 0,
    resetAnimationTemp: 0,
    mouse: new Ue(-9999, 0),
    mouse3d: new K,
    cameraPosition: new K,
    headData: {
        scale: new K(1, 1, 1),
        geometry: new zt
    },
    envMap: null,
    headVertexPositions: new Float32Array(0)
};
var B1 = `void main() {
    gl_Position = vec4(position, 1.0);
}`,
    uZ = `uniform vec2 resolution;
uniform sampler2D uTexture;

void main() {
    vec2 uv = gl_FragCoord.xy / resolution.xy;
    vec3 color = texture2D(uTexture, uv).xyz;
    gl_FragColor = vec4(color, 1.0);
}`,
    fZ = `uniform vec2 resolution;
uniform vec3 mouse3d;
uniform vec3 mouse3dVelocity;
uniform float isPhysicsActive;
uniform float resetAnimation;

uniform float mouseForce;
uniform float mouseRadius;
uniform float gravity;

uniform sampler2D textureVelocity;
uniform sampler2D texturePosition;
uniform sampler2D textureDefaultPosition;

const float EPS = 0.0001;

highp float random(vec2 co) {
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt = dot(co.xy, vec2(a, b));
    highp float sn = mod(dt, 3.14);
    return fract(sin(sn) * c);
}

void main() {

    vec2 uv = gl_FragCoord.xy / resolution.xy;

    vec3 velocity = texture2D(textureVelocity, uv).xyz;
    vec3 defaultPosition = texture2D(textureDefaultPosition, uv).xyz;
    vec3 position = texture2D(texturePosition, uv).xyz;

    float positionOffset = distance(position, defaultPosition);

    float toMouseStrength = length(position - mouse3d) / mouseRadius;
    toMouseStrength = step(-1.0, -toMouseStrength);

    
    
    
    
    
    
    
    
    
    

    velocity.xz *= 0.99;
    velocity.y -= step(EPS, positionOffset + isPhysicsActive) * ((1.0 - (defaultPosition.y + 200.0) / 500.0) + random(defaultPosition.xy)) * gravity;

    velocity += (normalize(position - mouse3d) + mouse3dVelocity * 0.2) * pow(toMouseStrength, 2.0) * (1.0 + random(vec2(position.x + position.y, position.z)) * 0.3) * mouseForce;
    velocity *= 1.0 - step(EPS, resetAnimation);

    gl_FragColor = vec4(velocity, 1.0);

}`,
    hZ = `uniform vec2 resolution;

uniform sampler2D textureVelocity;
uniform sampler2D texturePosition;
uniform sampler2D textureDefaultPosition;

const float EPS = 0.0001;

uniform float resetAnimation;

void main() {

    vec2 uv = gl_FragCoord.xy / resolution.xy;

    vec3 velocity = texture2D(textureVelocity, uv).xyz;
    vec3 position = texture2D(texturePosition, uv).xyz;
    vec3 defaultPosition = texture2D(textureDefaultPosition, uv).xyz;

    position += velocity;

    position += (defaultPosition - position) * pow(smoothstep(EPS, 1.0, resetAnimation), 3.0);

    

    gl_FragColor = vec4(position, 1.0);

}`;
let qv, wo, ff, cl, np, Co, ip, Ks, Fp, Up, Op;
const ca = yn.textureWidth,
    ua = yn.textureHeight,
    Np = ca * ua,
    Zi = {
        TEXTURE_WIDTH: ca,
        TEXTURE_HEIGHT: ua,
        AMOUNT: Np,
        velocityUniforms: void 0,
        positionRenderTarget: void 0,
        defaultPositionRenderTarget: void 0,
        init: dZ,
        update: pZ
    };

function dZ(r) {
    Ks = r, Up = new ho, Op = new Fl, Op.position.z = 1, qv = new Fn({
        uniforms: {
            resolution: {
                value: new Ue(ca, ua)
            },
            uTexture: {
                value: null
            }
        },
        vertexShader: B1,
        fragmentShader: uZ
    }), wo = new Fn({
        uniforms: {
            resolution: {
                value: new Ue(ca, ua)
            },
            mouse3d: {
                value: new K
            },
            mouse3dVelocity: {
                value: new K
            },
            textureDefaultPosition: {
                value: null
            },
            texturePosition: {
                value: null
            },
            textureVelocity: {
                value: null
            },
            isPhysicsActive: {
                value: 0
            },
            mouseForce: {
                value: .2 * .03
            },
            mouseRadius: {
                value: 105 * .02
            },
            gravity: {
                value: 0
            },
            resetAnimation: {
                value: 0
            }
        },
        vertexShader: B1,
        fragmentShader: fZ,
        blending: pi,
        transparent: !1,
        depthWrite: !1,
        depthTest: !1
    }), Zi.velocityUniforms = wo.uniforms, ff = new Fn({
        uniforms: {
            resolution: {
                value: new Ue(ca, ua)
            },
            texturePosition: {
                value: null
            },
            textureDefaultPosition: {
                value: null
            },
            textureVelocity: {
                value: null
            },
            resetAnimation: {
                value: 0
            }
        },
        vertexShader: B1,
        fragmentShader: hZ,
        blending: pi,
        transparent: !1,
        depthWrite: !1,
        depthTest: !1
    }), Fp = new Tn(new bs(2, 2), qv), Up.add(Fp), cl = new Zn(ca, ua, {
        wrapS: Nn,
        wrapT: Nn,
        minFilter: bn,
        magFilter: bn,
        format: kn,
        type: Bn,
        depthBuffer: !1,
        stencilBuffer: !1
    }), np = cl.clone(), dd(vZ(), cl), dd(cl, np), Co = new Zn(ca, ua, {
        wrapS: Nn,
        wrapT: Nn,
        minFilter: bn,
        magFilter: bn,
        format: kn,
        type: Bn,
        depthBuffer: !1,
        stencilBuffer: !1
    }), ip = Co.clone(), Zi.defaultPositionRenderTarget = Co.clone(), Zi.positionRenderTarget = Co.clone(), dd(yZ(), Zi.defaultPositionRenderTarget), dd(Zi.defaultPositionRenderTarget, Co), dd(Zi.defaultPositionRenderTarget, ip)
}

function pZ() {
    mZ(), Ks.autoClearColor = !1, gZ(), Ks.autoClearColor = !0, Zi.positionRenderTarget = Co
}

function mZ() {
    const r = wo.uniforms.mouse3d.value,
        e = wo.uniforms.mouse3dVelocity.value;
    r.z < -9e3 ? e.set(0, 0, 0) : e.copy(yn.mouse3d).sub(r), r.copy(yn.mouse3d), wo.uniforms.isPhysicsActive.value = 0, wo.uniforms.resetAnimation.value = yn.resetAnimation;
    const t = cl;
    cl = np, np = t, Fp.material = wo, wo.uniforms.textureDefaultPosition.value = Zi.defaultPositionRenderTarget.texture, wo.uniforms.textureVelocity.value = np.texture, wo.uniforms.texturePosition.value = Co.texture, Ks.setRenderTarget(cl), Ks.render(Up, Op), Ks.setRenderTarget(null)
}

function gZ() {
    const r = Co;
    Co = ip, ip = r, Fp.material = ff, ff.uniforms.textureVelocity.value = cl.texture, ff.uniforms.texturePosition.value = ip.texture, ff.uniforms.textureDefaultPosition.value = Zi.defaultPositionRenderTarget.texture, ff.uniforms.resetAnimation.value = yn.resetAnimation, Ks.setRenderTarget(Co), Ks.render(Up, Op), Ks.setRenderTarget(null)
}

function dd(r, e) {
    const t = r.texture || r;
    Fp.material = qv, qv.uniforms.uTexture.value = t, Ks.setRenderTarget(e), Ks.render(Up, Op), Ks.setRenderTarget(null)
}

function vZ() {
    const r = new Float32Array(Np * 4);
    for (let t = 0; t < Np; t++) r[t * 4] = 0, r[t * 4 + 1] = 0, r[t * 4 + 2] = 0, r[t * 4 + 3] = 1;
    const e = new qr(r, ca, ua, kn, Bn);
    return e.minFilter = bn, e.magFilter = bn, e.needsUpdate = !0, e.generateMipmaps = !1, e.flipY = !1, e
}

function yZ() {
    const r = yn.headVertexPositions,
        e = new Float32Array(Np * 4);
    for (let n = 0; n < Np; n++) e[n * 4] = r[n * 3], e[n * 4 + 1] = r[n * 3 + 1], e[n * 4 + 2] = r[n * 3 + 2], e[n * 4 + 3] = 1;
    const t = new qr(e, ca, ua, kn, Bn);
    return t.minFilter = bn, t.magFilter = bn, t.needsUpdate = !0, t.generateMipmaps = !1, t.flipY = !1, t
}
var _Z = `uniform sampler2D textureDefaultPosition;
uniform sampler2D texturePosition;

varying vec3 vViewPosition;
varying vec3 vNormal;

const float EPS = 0.0001;

vec3 rotateY(vec3 v, float x) {
    return vec3(cos(x) * v.x - sin(x) * v.z, v.y, sin(x) * v.x + cos(x) * v.z);
}

vec3 rotateX(vec3 v, float x) {
    return vec3(v.x, v.y * cos(x) - v.z * sin(x), v.y * sin(x) + v.z * cos(x));
}

void main() {
    
    vec3 pos = texture2D(texturePosition, position.xy).xyz;
    vec3 defaultPos = texture2D(textureDefaultPosition, position.xy).xyz;
    float offsetDistance = distance(pos, defaultPos);

    
    pos += normal * 0.5;

    
    vec3 transformedNormal = normal;
    transformedNormal = rotateX(transformedNormal, offsetDistance * 0.02 * sin(fract(position.z * 21321.5125)));
    transformedNormal = rotateY(transformedNormal, offsetDistance * 0.02 * sin(fract(position.z * 51211.41)));
    vNormal = normalize(transformedNormal);

    
    vec3 transformed = pos;

    
    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);
    vViewPosition = -mvPosition.xyz;

    
    gl_PointSize = mix(2600.0, 800.0, smoothstep(EPS, 2.0, offsetDistance)) / length(mvPosition.xyz) * 0.019 / 3.;

    
    gl_Position = projectionMatrix * mvPosition;
}`,
    xZ = `#define PHONG

uniform vec3 diffuse;
uniform vec3 emissive;
uniform vec3 specular;
uniform float shininess;
uniform float opacity;
uniform float normalNoise;

uniform samplerCube envMap;
uniform float reflectivity;

varying vec3 vViewPosition;
varying vec3 vNormal;

highp float random(vec2 co) {
    highp float a = 12.9898;
    highp float b = 78.233;
    highp float c = 43758.5453;
    highp float dt = dot(co.xy, vec2(a, b));
    highp float sn = mod(dt, 3.14);
    return fract(sin(sn) * c);
}

vec3 rotateY(vec3 v, float x) {
    return vec3(cos(x) * v.x - sin(x) * v.z, v.y, sin(x) * v.x + cos(x) * v.z);
}

vec3 rotateX(vec3 v, float x) {
    return vec3(v.x, v.y * cos(x) - v.z * sin(x), v.y * sin(x) + v.z * cos(x));
}

vec3 rotateZ(vec3 v, float x) {
    return vec3(v.x * cos(x) - v.y * sin(x), v.x * sin(x) + v.y * cos(x), v.z);
}

void main() {
    
    vec3 normal = normalize(vNormal);
    vec3 viewDir = normalize(vViewPosition);

    
    normal = rotateZ(normal, (random(gl_FragCoord.xy + 2.0) - 0.5) * normalNoise);
    normal = rotateY(normal, (random(gl_FragCoord.yx) - 0.5) * normalNoise);
    normal = normalize(normal);

    
    vec3 lightDir = normalize(vec3(1.0, 1.0, 1.0)); 
    vec3 lightColor = vec3(1.0);                   

    float dotNL = max(dot(normal, lightDir), 0.0); 
    vec3 diffuseLight = diffuse * dotNL * lightColor;

    vec3 reflectDir = reflect(-lightDir, normal); 
    float spec = pow(max(dot(viewDir, reflectDir), 0.0), shininess);
    vec3 specularLight = specular * spec * lightColor;

    
    vec3 envReflection = textureCube(envMap, reflect(-viewDir, normal)).rgb;
    vec3 envLight = envReflection * reflectivity;

    
    vec3 outgoingLight = diffuseLight + specularLight + envLight + emissive;

    gl_FragColor = vec4(outgoingLight, opacity);
}`,
    AZ = `uniform sampler2D textureDefaultPosition;
uniform sampler2D texturePosition;

const float EPS = 0.0001;

void main() {

    

    

    vec3 pos = texture2D(texturePosition, position.xy).xyz;
    vec3 defaultPos = texture2D(textureDefaultPosition, position.xy).xyz;
    float offsetDistance = distance(pos, defaultPos);

    
    
    
    

    vec3 transformed = pos;
    vec4 mvPosition = modelViewMatrix * vec4(transformed, 1.0);

    gl_PointSize = mix(1800.0, 400.0, smoothstep(EPS, 2.0, offsetDistance)) / length(mvPosition.xyz) * 0.019 / 3.;
}`,
    SZ = `varying float vDepthOffset;

vec4 pack_depth(const in float depth) {

    const vec4 bit_shift = vec4(256.0 * 256.0 * 256.0, 256.0 * 256.0, 256.0, 1.0);
    const vec4 bit_mask = vec4(0.0, 1.0 / 256.0, 1.0 / 256.0, 1.0 / 256.0);
    vec4 res = mod(depth * bit_shift * vec4(255), vec4(256)) / vec4(255);
    res -= res.xxyz * bit_mask;
    return res;

}

void main() {

    

    

   #ifdef USE_LOGDEPTHBUF_EXT

    gl_FragColor = pack_depth(gl_FragDepthEXT);

   #else

    
    gl_FragColor = pack_depth(gl_FragCoord.z - 1.0);

   #endif

}`;

function MZ(r) {
    return Math.sqrt(1 - Math.pow(r - 1, 2))
}

function wZ(r) {
    const {
        camera: e,
        gl: t,
        size: n,
        scene: i
    } = qn(), s = N.useRef(null), o = N.useRef(null), a = N.useRef({
        value: 0
    }), [l] = N.useState(!1), [c] = N.useState(!1), [u] = N.useState(.2), f = yn.textureWidth * yn.textureHeight, d = N.useRef(0), m = N.useRef(!1), g = N.useRef(new Ll), y = N.useRef(!1), {
        nodes: v
    } = $s(aF), _ = N.useMemo(() => {
        var q;
        if (!((q = v == null ? void 0 : v.Hello_gays) != null && q.geometry)) return null;
        const M = v.Hello_gays.geometry.clone();
        M.rotateY(Math.PI / 4), M.computeVertexNormals();
        const C = new lF(new Tn(M)).setWeightAttribute(null).build(),
            E = [],
            R = [],
            P = [],
            b = new K,
            T = new K,
            L = new rt,
            D = new Ue,
            V = .024;
        for (let X = 0; X < f; X++) C.sample(b, T, L, D), E.push(b.x * V, b.y * V, b.z * V), R.push(T.x * V, T.y * V, T.z * V), P.push(D.x * V, D.y * V);
        const H = new zt;
        return H.setAttribute("position", new Et(E, 3)), H.setAttribute("normal", new Et(R, 3)), H.setAttribute("uv", new Et(P, 2)), H.computeBoundingSphere(), H != null && H.boundingSphere && (H.boundingSphere.radius *= 2), yn.headVertexPositions = H.attributes.position.array, H
    }, [v, f]), A = N.useMemo(() => {
        if (!_) return {};

        function M(E, R) {
            const P = new Fn({
                uniforms: bl.merge([Vs.phong.uniforms, {
                    texturePosition: {
                        value: null
                    },
                    textureDefaultPosition: {
                        value: null
                    },
                    normalNoise: {
                        value: u
                    }
                }]),
                vertexShader: _Z,
                fragmentShader: xZ,
                lights: !0,
                blending: pi
            });
            return P.uniforms.shininess.value = 12, P.uniforms.reflectivity.value = !E && R ? .5 : .25, P
        }
        const C = {};
        return C[0] = M(!1, !1), C[1] = M(!1, !0), C[2] = M(!0, !1), C[3] = M(!0, !0), C
    }, [_, u]), S = N.useMemo(() => new Fn({
        uniforms: {
            time: {
                value: 0
            },
            realCameraPosition: {
                value: yn.cameraPosition
            },
            texturePosition: {
                value: null
            },
            textureDefaultPosition: {
                value: null
            }
        },
        vertexShader: AZ,
        fragmentShader: SZ,
        blending: pi,
        depthTest: !0,
        depthWrite: !0,
        lights: !1
    }), []);
    return N.useEffect(() => {
        oK({
            yOffsetRef: a
        })
    }, []), N.useEffect(() => {
        yn.mouse = new Ue(-9999, 0), yn.mouse3d = g.current.origin;
        const M = yn.envMap = new zo().load("images/env.jpg");
        M.wrapS = M.wrapT = au, M.mapping = ou, M.magFilter = nn, M.minFilter = gs, yn.cameraPosition = e.position, Zi.init(t), d.current = Date.now();
        const C = R => {
                const P = "pageX" in R ? R.pageX : R.changedTouches[0].pageX,
                    b = "pageY" in R ? R.pageY : R.changedTouches[0].pageY;
                yn.mouse.x = P / n.width * 2 - 1, yn.mouse.y = -(b / n.height) * 2 + 1, y.current || (y.current = !0, setTimeout(() => {
                    yn.resetAnimationTemp = 1e-5, yn.resetAnimation = 1e-5
                }, 1500))
            },
            E = R => P => {
                R(P)
            };
        return window.addEventListener("mousemove", C), window.addEventListener("touchmove", E(C)), () => {
            window.removeEventListener("mousemove", C), window.removeEventListener("touchmove", E(C))
        }
    }, [e, t, i, n.width, n.height]), Es(() => {
        var b;
        if (!_ || !s.current || !A) return;
        const M = Date.now(),
            C = M - d.current;
        d.current = M, e.updateMatrixWorld();
        const E = g.current;
        E.origin.setFromMatrixPosition(e.matrixWorld), E.direction.set(yn.mouse.x, yn.mouse.y, .5).unproject(e).sub(E.origin).normalize();
        const R = E.origin.length() / Math.cos(Math.PI - E.direction.angleTo(E.origin));
        E.origin.add(E.direction.multiplyScalar(R * yn.mouseZRatio));
        const P = new K(0, ((b = a == null ? void 0 : a.current) == null ? void 0 : b.value) || 0, 0);
        if (E.origin.add(P), yn.mouse3d = g.current.origin, yn.cameraPosition = e.position, m.current || (m.current = !0, yn.resetAnimationTemp = 1e-5, yn.resetAnimation = 1e-5), yn.resetAnimationTemp > 0 && yn.resetAnimationTemp <= 1 && (yn.resetAnimationTemp += C * 5e-4, yn.resetAnimation = MZ(yn.resetAnimationTemp)), yn.resetAnimationTemp > .2 && (yn.resetAnimationTemp = 0, yn.resetAnimation = 0, y.current = !1), Zi.update(), Zi.defaultPositionRenderTarget && Zi.positionRenderTarget) {
            const T = ((l ? 1 : 0) << 1) + (c ? 1 : 0),
                L = A[T];
            L && (L.uniforms.textureDefaultPosition.value = Zi.defaultPositionRenderTarget.texture, L.uniforms.texturePosition.value = Zi.positionRenderTarget.texture, L.uniforms.normalNoise.value = u, S.uniforms.textureDefaultPosition.value = Zi.defaultPositionRenderTarget.texture, S.uniforms.texturePosition.value = Zi.positionRenderTarget.texture, s.current.material = L, s.current.customDepthMaterial = S)
        }
        if (o.current) {
            const T = yn.mouse.x * .8,
                L = -yn.mouse.y * .6;
            o.current.rotation.y = ha.lerp(o.current.rotation.y, T, .1), o.current.rotation.x = ha.lerp(o.current.rotation.x, L, .1)
        }
    }), _ ? G.jsx("group", {
        ref: o,
        ...r,
        dispose: null,
        children: G.jsx("points", {
            ref: s,
            geometry: _,
            castShadow: !0,
            receiveShadow: !0
        })
    }) : null
}

function bZ() {
    const r = N.useRef(),
        e = new Mi({
            color: "#fff",
            side: hn
        }),
        t = vr(zo, oF);
    return N.useEffect(() => {
        sK({
            waveMesh: r.current
        })
    }, []), G.jsxs("group", {
        ref: r,
        children: [G.jsx("group", {
            position: [0, -7.75, 0],
            children: G.jsx(Di, { ...Qq.style,
                maxWidth: 14,
                textAlign: "center",
                children: "pave the way"
            })
        }), G.jsxs("group", {
            position: [3.5, -9.35, 0],
            scale: .95,
            children: [G.jsxs("mesh", {
                position: [0, 0, 0],
                scale: .2,
                children: [G.jsx("planeGeometry", {
                    args: [14, 1.68]
                }), G.jsx("meshBasicMaterial", {
                    map: t,
                    transparent: !0
                })]
            }), G.jsx(Di, {
                position: [.33, -.54, 0],
                rotation: [0, 0, 0],
                font: nh,
                fontSize: .145,
                anchorX: "center",
                anchorY: "middle",
                maxWidth: 3.2,
                material: e,
                children: "Bring AI on-chain and help pave the way for decentralized intelligence"
            })]
        }), G.jsx(wZ, {
            position: [0, -7.75, 0]
        })]
    })
}
var TZ = `#ifdef GL_ES
precision mediump float;
#endif

uniform sampler2D tDiffuse;   
uniform float uInertia;       
uniform float uIntensivity;   
uniform float uScroll;        

float easeInCubic(float t) {
    return t * t * t;
}

void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
    
    vec2 shiftedUV = uv + vec2(0.0, uScroll);

    
    float inertia = uInertia * uIntensivity;

    
    float flipHeight = 1.;                     
    float distortionStrength = -0.23 * inertia; 
    float verticalDistortion = 0.05 * inertia;    

    
    float y_normalized = (flipHeight - shiftedUV.y) / flipHeight;
    y_normalized = easeInCubic(y_normalized);

    
    float scaleX = 1.0 + distortionStrength * y_normalized;
    float centerX = 0.5;
    float offsetX = (shiftedUV.x - centerX) * (scaleX - 1.0);

    
    float offsetY = verticalDistortion * y_normalized;

    
    vec2 distortedUV = vec2(shiftedUV.x + offsetX, shiftedUV.y + offsetY);

    
    outputColor = texture2D(tDiffuse, distortedUV);
    outputColor.a = 1.0;
}`;
class EZ extends oh {
    constructor() {
        super("ScrollBendEffect", TZ, {
            uniforms: new Map([
                ["time", new Wn(0)],
                ["ratio", new Wn(window.innerWidth / window.innerHeight)],
                ["uInertia", new Wn(0)],
                ["uIntensivity", new Wn(0)]
            ])
        })
    }
}
const CZ = N.memo(N.forwardRef((r, e) => {
        const {
            scrollContainerId: t = "root"
        } = r, n = N.useMemo(() => new EZ, []), i = N.useRef(0), s = N.useRef(0), o = N.useRef();
        return N.useEffect(() => {
            lK({
                effect: n
            })
        }, [n]), N.useEffect(() => {
            const a = n.uniforms.get("time");
            if (!a) return;
            const l = () => {
                a.value = performance.now() * .001, o.current = requestAnimationFrame(l)
            };
            return l(), () => {
                o.current && cancelAnimationFrame(o.current)
            }
        }, [n]), N.useEffect(() => {
            const a = () => {
                const l = window.innerWidth / window.innerHeight,
                    c = n.uniforms.get("ratio");
                c && (c.value = l)
            };
            return window.addEventListener("resize", a), () => {
                window.removeEventListener("resize", a)
            }
        }, [n]), N.useEffect(() => {
            if (!n.uniforms.get("uInertia")) return;
            const l = document.getElementById(t);
            if (!l) {
                console.warn(`  id '${t}'  .`);
                return
            }
            let c = l.scrollTop,
                u = performance.now(),
                f = 0;
            const d = () => {
                const m = l.scrollTop,
                    g = performance.now(),
                    y = m - c,
                    v = (g - u) / 1e3;
                if (v > 0 && (f = y / v), c = m, u = g, f > 0) {
                    const _ = Math.min(f / 1e3, 1);
                    s.current = _
                } else s.current = 0
            };
            return l.addEventListener("scroll", d, {
                passive: !0
            }), () => {
                l.removeEventListener("scroll", d)
            }
        }, [n, t]), N.useEffect(() => {
            const a = n.uniforms.get("uInertia");
            if (!a) return;
            const l = .2,
                c = .05,
                u = () => {
                    i.current < s.current ? i.current += (s.current - i.current) * l : i.current += (s.current - i.current) * c, a.value = i.current, o.current = requestAnimationFrame(u)
                };
            return u(), () => {
                o.current && cancelAnimationFrame(o.current)
            }
        }, [n]), G.jsx("primitive", {
            ref: e,
            dispose: null,
            object: n
        })
    })),
    cF = "" + new URL("grid-D-wyCm4m.glb",
        import.meta.url).href;
class uF {
    constructor() {
        ss(this, "perm");
        this.perm = this.generatePermutation()
    }
    generatePermutation() {
        const e = Array.from({
            length: 256
        }, (t, n) => n);
        for (let t = e.length - 1; t > 0; t--) {
            const n = Math.floor(Math.random() * (t + 1));
            [e[t], e[n]] = [e[n], e[t]]
        }
        return [...e, ...e]
    }
    fade(e) {
        return e * e * e * (e * (e * 6 - 15) + 10)
    }
    lerp(e, t, n) {
        return e + n * (t - e)
    }
    grad(e, t, n) {
        const i = e & 3,
            s = i < 2 ? t : n,
            o = i < 2 ? n : t;
        return (i & 1 ? -s : s) + (i & 2 ? -o : o)
    }
    noise(e, t) {
        const n = Math.floor(e) & 255,
            i = Math.floor(t) & 255;
        e -= Math.floor(e), t -= Math.floor(t);
        const s = this.fade(e),
            o = this.fade(t),
            a = this.perm[n + this.perm[i]] & 255,
            l = this.perm[n + this.perm[i + 1]] & 255,
            c = this.perm[n + 1 + this.perm[i]] & 255,
            u = this.perm[n + 1 + this.perm[i + 1]] & 255,
            f = this.grad(a, e, t),
            d = this.grad(c, e - 1, t),
            m = this.grad(l, e, t - 1),
            g = this.grad(u, e - 1, t - 1),
            y = this.lerp(f, d, s),
            v = this.lerp(m, g, s);
        return this.lerp(y, v, o)
    }
}
const RZ = new uF;

function PZ(r) {
    const e = N.useRef(null),
        {
            nodes: t
        } = $s(cF),
        n = N.useRef(null),
        i = N.useMemo(() => t.Plane001.geometry.clone(), [t]),
        s = N.useRef(null);
    return N.useEffect(() => {
        if (i) {
            const o = i.attributes.position;
            s.current = new Float32Array(o.array)
        }
    }, [i]), N.useEffect(() => {
        e.current && e.current.material instanceof mu && (e.current.material.color = new rt(1184274), e.current.material.roughness = 1, e.current.material.metalness = .15, e.current.material.depthWrite = !1, e.current.material.transparent = !0, e.current.material.side = hn)
    }, []), Es(({
        clock: o
    }) => {
        if (e.current && s.current) {
            const a = o.getElapsedTime(),
                l = e.current.geometry.attributes.position,
                c = l.array;
            for (let u = 0; u < c.length; u += 3) {
                const f = s.current[u],
                    d = s.current[u + 1],
                    g = s.current[u + 2] + d + a * .1,
                    y = f + d + a * .1,
                    v = RZ.noise(g, y) / 4;
                c[u + 1] = d + v * 2
            }
            l.needsUpdate = !0
        }
    }), N.useEffect(() => {
        eK({
            waveGroup: n,
            meshRef: e
        })
    }, []), G.jsx("group", {
        ref: n,
        ...r,
        dispose: null,
        rotation: [Math.PI / 12, Math.PI / 4, 0],
        children: G.jsx(gl, {
            rotationSensitivity: .06,
            positionSensitivity: .8,
            lerpFactor: .01,
            children: G.jsx("mesh", {
                ref: e,
                castShadow: !0,
                receiveShadow: !0,
                geometry: i,
                scale: 10.648,
                material: t.Plane001.material,
                renderOrder: 0
            })
        })
    })
}

function IZ() {
    return G.jsx(PZ, {})
}
et.registerPlugin(Zt);
const BZ = r => {
        const e = N.useMemo(() => new Br(new K(1, 0, 0), 10), []),
            t = N.useMemo(() => new Br(new K(-1, 0, 0), -10), []);
        return N.useEffect(() => {
            et.to({}, {
                scrollTrigger: qt({
                    start: `top+=${500+250*r.id}`,
                    end: "+=1500",
                    scrub: 1,
                    onUpdate: n => {
                        e.constant = 10 - 40 * n.progress, t.constant = -10 + 40 * n.progress
                    }
                })
            })
        }, []), G.jsxs(G.Fragment, {
            children: [G.jsxs(Di, {
                fontSize: .6,
                anchorX: "left",
                anchorY: "middle",
                font: nh,
                children: [r.line, G.jsx("meshStandardMaterial", {
                    attach: "material",
                    clippingPlanes: [e],
                    clipShadows: !0,
                    clipIntersection: !1,
                    color: "#555555"
                })]
            }), G.jsxs(Di, {
                fontSize: .6,
                anchorX: "left",
                anchorY: "middle",
                font: nh,
                children: [r.line, G.jsx("meshStandardMaterial", {
                    attach: "material",
                    clippingPlanes: [t],
                    clipShadows: !0,
                    clipIntersection: !1,
                    color: "#ffffff"
                })]
            })]
        })
    },
    DZ = () => {
        const r = ["Sage is a platform that", "democratizes investment in", "artificial intelligence by", "allowing users to buy, sell,", "and trade fractionalized", "ownership shares in AI models.", "Facilitated through", "customizable bonding", "curves and secured by", "smart contracts."],
            e = N.useRef(null);
        return N.useEffect(() => {
            tK({
                textGroupRef: e
            })
        }, []), G.jsx("group", {
            ref: e,
            children: r.map((t, n) => G.jsx("group", {
                position: [0, -n * .3, 0],
                scale: [.45, .45, .45],
                children: G.jsx(BZ, {
                    line: t,
                    id: n
                })
            }, n))
        })
    },
    LZ = `
  void mainImage(const in vec4 inputColor, const in vec2 uv, out vec4 outputColor) {
    vec4 baseColor = vec4(0.0, 0.0, 0.0, 0.01);
    
    vec4 color1 = inputColor;

    vec4 finalColor = vec4(
      baseColor.rgb * (1.0 - color1.a) + color1.rgb * color1.a,
      clamp(baseColor.a + color1.a, 0.0, 1.0)
    );
    
    outputColor = finalColor;
  }
`;
class FZ extends oh {
    constructor() {
        super("DummyEffect", LZ, {
            uniforms: new Map([])
        })
    }
}
const UZ = N.memo(N.forwardRef((r, e) => {
    const t = N.useMemo(() => new FZ, []);
    return G.jsx("primitive", {
        ref: e,
        dispose: null,
        object: t
    })
}));

function OZ() {
    const r = N.useRef(),
        e = mh(gh, .5);
    return N.useEffect(() => {
        aK({
            groupMesh: r.current
        })
    }, []), G.jsxs("group", {
        ref: r,
        children: [G.jsx(Di, { ...eZ.style,
            maxWidth: 10,
            textAlign: "center",
            children: "SAGE"
        }), G.jsx(Uv, {
            center: !0,
            position: [0, -2.4, 0],
            zIndexRange: [0, 100],
            children: G.jsx("footer", {
                className: "footer",
                children: G.jsxs("div", {
                    className: "footer-text",
                    children: [G.jsxs("span", {
                        children: [" ", new Date().getFullYear(), " Wizdom Labs"]
                    }), G.jsx("span", {
                        className: "footer-divider",
                        children: "&"
                    }), G.jsxs("a", {
                        className: "footer-link__wrapper",
                        href: "https://fantik.studio",
                        target: "_blank",
                        rel: "noreferrer",
                        onMouseEnter: e,
                        children: ["Website by", " ", G.jsxs("div", {
                            className: "fantik-link",
                            children: [G.jsx("span", {
                                className: "fantik-link__text fantik-link__text--top",
                                children: "Fantik Studio"
                            }), G.jsx("span", {
                                className: "fantik-link__text fantik-link__text--bottom",
                                children: "Fantik Studio"
                            })]
                        })]
                    })]
                })
            })
        })]
    })
}
const NZ = () => {
        const {
            camera: r
        } = qn(), {
            zoomLevel: e
        } = z3(), t = .1, n = N.useRef(new K(0, -.25, 18));
        return Es(() => {
            const i = n.current.z / e;
            r.position.z += (i - r.position.z) * t
        }), null
    },
    fF = () => {
        const [r, e] = N.useState(-1), {
            setSteps: t
        } = dh(), n = [G.jsx(Ew, {}, "coin"), G.jsx(bw, {}, "dollar"), G.jsx(Tw, {}, "klutz"), G.jsx(ww, {}, "upload")], i = n.length;
        return N.useEffect(() => {
            t(0, i), (async () => {
                for (let s = 0; s < i; s++) e(s), await new Promise(o => setTimeout(o, 500)), t(s + 1, i);
                e(-1)
            })()
        }, [i, t]), r < 0 ? null : G.jsxs(G.Fragment, {
            children: [n[r], G.jsx(OM, {
                all: !0
            })]
        })
    };
var kZ = `#ifdef GL_ES
precision mediump float;
#endif

uniform float time;
uniform float scrollY; 

float hash(vec2 p) {
  return fract(sin(dot(p, vec2(127.1, 311.7))) * 43758.5453123);
}

float noise(vec2 p) {
  vec2 i = floor(p);
  vec2 f = fract(p);
  vec2 u = f * f * (3.0 - 2.0 * f);
  float a = hash(i);
  float b = hash(i + vec2(1.0, 0.0));
  float c = hash(i + vec2(0.0, 1.0));
  float d = hash(i + vec2(1.0, 1.0));
  return mix(mix(a, b, u.x), mix(c, d, u.x), u.y);
}

float fbm(vec2 p) {
  float value = 0.0;
  float amplitude = 0.5;
  float frequency = 1.0;
  
  for(int i = 0; i < 6; i++) {
    value += amplitude * noise(p * frequency);
    frequency *= 2.2; 
    amplitude *= 0.5;
  }
  return value;
}

float gridPattern(vec2 uv, float frequency, float thickness) {
  vec2 grid = abs(fract(uv * frequency - 0.5) - 0.5);
  float line = 1.0 - smoothstep(thickness, thickness + 0.01, min(grid.x, grid.y));
  return line;
}

void mainImage(const in vec4 inputColor, const in vec2 fragCoord, out vec4 fragColor) {
  
  vec2 uv = fragCoord;
  uv.y += scrollY;

  
  float weave1 = fbm(uv * 6.0 + vec2(time * 0.1, 0.0));
  float weave2 = fbm(uv * 4.0 - vec2(time * 0.08, 0.0));

  
  float shimmer = sin((uv.x + uv.y) * 20.0 + time * 0.8) * 0.05 + cos((uv.x - uv.y) * 15.0 - time * 0.6) * 0.03;

  float pattern = smoothstep(0.4, 0.6, mix(weave1, weave2, 0.5) + shimmer);

  
  float baseIntensity = pattern * 0.02;

  vec3 color = vec3(baseIntensity);
  vec3 finalColor = mix(color, inputColor.rgb, inputColor.a);
  fragColor = vec4(finalColor, max(0.5, inputColor.a));
}`;
class zZ extends oh {
    constructor() {
        super("BgEffect", kZ, {
            uniforms: new Map([
                ["time", new Wn(0)],
                ["scrollY", new Wn(0)]
            ])
        })
    }
}
const GZ = N.memo(N.forwardRef((r, e) => {
        const t = N.useMemo(() => new zZ, []);
        return N.useEffect(() => {
            const n = t.uniforms.get("scrollY");
            cK({
                scrollUniform: n
            })
        }, []), N.useEffect(() => {
            const n = t.uniforms.get("time");
            if (!n) return;
            let i;
            const s = () => {
                const o = performance.now() * .001;
                n.value = o, i = requestAnimationFrame(s)
            };
            return s(), () => {
                cancelAnimationFrame(i)
            }
        }, [t]), G.jsx("primitive", {
            ref: e,
            dispose: null,
            object: t
        })
    })),
    HZ = () => G.jsxs(G.Fragment, {
        children: [G.jsx("ambientLight", {
            intensity: .5
        }), G.jsx("pointLight", {
            position: [10, 10, 10]
        }), G.jsx(QD, {
            makeDefault: !0,
            fov: 25,
            position: [0, -.25, 18],
            near: .01,
            far: 1e3
        }), G.jsx(NZ, {}), G.jsx(IZ, {}), G.jsx(DZ, {}), G.jsx(jq, {}), G.jsx(cZ, {}), G.jsx(bZ, {}), G.jsx(OZ, {}), G.jsx(fF, {}), G.jsx(OM, {
            all: !0
        }), G.jsxs(vq, {
            children: [G.jsx(UZ, {}), G.jsx(CZ, {}), G.jsx(Nq, {}), G.jsx(GZ, {})]
        }), G.jsx(UM, {
            files: NM,
            backgroundIntensity: 3,
            environmentIntensity: 3
        })]
    });
et.registerPlugin(Zt);
const VZ = ({
        mobileGroup: r
    }) => {
        r.current && (et.set(r.current.position, {
            x: 0,
            y: -4,
            z: 0
        }), et.timeline({
            scrollTrigger: qt({
                start: 0,
                end: 12e3
            })
        }).to(r.current.position, {
            y: 56,
            ease: "none"
        }))
    },
    WZ = ({
        animScrollerRef: r
    }) => {
        r.current && (et.set(r.current, {
            opacity: 1,
            x: 0,
            y: 0,
            z: 0
        }), et.timeline({
            scrollTrigger: qt({
                start: 0,
                end: "+=400"
            })
        }).to(r.current, {
            opacity: 0,
            duration: 1,
            ease: "none"
        }))
    },
    jZ = ({
        waveGroup: r,
        meshRef: e
    }) => {
        r.current && (et.set(r.current.position, {
            x: 0,
            y: 0,
            z: -10
        }), et.timeline({
            scrollTrigger: qt({
                start: "top+=0",
                end: "+=1000"
            })
        }).to(r.current.position, {
            z: 7,
            y: 0,
            x: 0,
            ease: "none"
        })), e.current && et.timeline({
            scrollTrigger: qt({
                start: "top+=0",
                end: "+=1000"
            })
        }).to(e.current.material, {
            opacity: 0
        })
    },
    XZ = ({
        contentGroup: r
    }) => {
        r.current && et.set(r.current.position, {
            x: 0,
            y: -8,
            z: 0
        })
    },
    YZ = ({
        modelOneGroup: r,
        modelTwoGroup: e,
        modelThreeGroup: t,
        modelFourGroup: n
    }) => {
        r.current && (et.set(r.current.position, {
            x: 0,
            y: 0,
            z: -.2
        }), et.set(r.current.scale, {
            x: .3,
            y: .3,
            z: .3
        }), et.to(r.current.scale, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            x: .8,
            y: .8,
            z: .8,
            scrollTrigger: qt({
                start: "top+=2380",
                end: "+=800"
            })
        }), et.to(r.current.rotation, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            y: "+=" + Math.PI,
            scrollTrigger: qt({
                start: "top+=2380",
                end: "+=800"
            })
        })), e.current && (et.set(e.current.position, {
            x: 0,
            y: .1,
            z: -.2
        }), et.set(e.current.scale, {
            x: .3,
            y: .3,
            z: .3
        }), et.to(e.current.scale, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            x: .8,
            y: .8,
            z: .8,
            scrollTrigger: qt({
                start: "top+=2880",
                end: "+=800"
            })
        }), et.to(e.current.rotation, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            y: "+=" + Math.PI,
            scrollTrigger: qt({
                start: "top+=2880",
                end: "+=800"
            })
        })), t.current && (et.set(t.current.position, {
            x: 0,
            y: 0,
            z: -.2
        }), et.set(t.current.scale, {
            x: .3,
            y: .3,
            z: .3
        }), et.to(t.current.scale, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            x: .8,
            y: .8,
            z: .8,
            scrollTrigger: qt({
                start: "top+=3380",
                end: "+=800"
            })
        }), et.to(t.current.rotation, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            y: "+=" + Math.PI,
            scrollTrigger: qt({
                start: "top+=3380",
                end: "+=800"
            })
        })), n.current && (et.set(n.current.position, {
            x: 0,
            y: 0,
            z: -.2
        }), et.set(n.current.scale, {
            x: .3,
            y: .3,
            z: .3
        }), et.to(n.current.scale, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            x: .8,
            y: .8,
            z: .8,
            scrollTrigger: qt({
                start: "top+=3880",
                end: "+=800"
            })
        }), et.to(n.current.rotation, {
            yoyo: !0,
            repeat: 1,
            repeatDelay: 1,
            y: "+=" + Math.PI,
            scrollTrigger: qt({
                start: "top+=3880",
                end: "+=800"
            })
        }))
    },
    JZ = ({
        cardOne: r,
        cardSecond: e,
        cardThird: t
    }) => {
        r.current && (et.set(r.current.position, {
            x: 0,
            y: -2.5,
            z: 0
        }), et.set(r.current.rotation, {
            x: 0,
            y: Math.PI,
            z: 0
        })), e.current && (et.set(e.current.position, {
            x: 0,
            y: -9,
            z: 0
        }), et.set(e.current.rotation, {
            x: 0,
            y: Math.PI,
            z: 0
        })), t.current && (et.set(t.current.position, {
            x: 0,
            y: -15.5,
            z: 0
        }), et.set(t.current.rotation, {
            x: 0,
            y: Math.PI,
            z: 0
        }))
    },
    KZ = () => {
        const r = N.useRef([]),
            e = N.useRef(null);
        return N.useEffect(() => {
            r.current.forEach(n => {
                n && et.set(n, {
                    opacity: .4
                })
            });
            const t = et.timeline({
                repeat: -1
            });
            return r.current.forEach((n, i) => {
                t.to(n, {
                    opacity: 1,
                    duration: .3,
                    yoyo: !0,
                    repeat: 1,
                    ease: "power1.inOut"
                }, i * .1)
            }), () => {
                t.kill()
            }
        }, []), N.useEffect(() => {
            WZ({
                animScrollerRef: e
            })
        }), G.jsx(Vt.div, {
            className: "flex flex-col anim-content_mb",
            ref: e,
            children: Array(4).fill(0).map((t, n) => G.jsx(Vt.div, {
                ref: i => i && (r.current[n] = i),
                style: {
                    width: "4px",
                    height: "4px",
                    borderRadius: "50%",
                    background: "white",
                    opacity: .4
                }
            }, n))
        })
    },
    qZ = (r, e) => N.useMemo(() => {
        const t = [];
        for (let n = 0; n < r; n++) {
            const i = -n * e;
            t.push({
                position: [0, i, 0]
            })
        }
        return t
    }, [r, e]),
    ZZ = N.memo(({
        index: r,
        refs: e
    }) => {
        if (!e[r]) return null;
        const t = {
            1: G.jsx(ww, {}),
            2: G.jsx(Ew, {}),
            3: G.jsx(Tw, {}),
            4: G.jsx(bw, {})
        };
        return t[r] && e[r] ? G.jsx("group", {
            ref: e[r],
            children: t[r]
        }) : null
    }),
    QZ = N.memo(({
        index: r,
        textBg: e,
        textSm: t,
        refs: n
    }) => n[r] ? G.jsxs("group", {
        ref: n[r],
        children: [G.jsx(Di, { ...Jq.style,
            maxWidth: 6,
            textAlign: "center",
            renderOrder: 1,
            children: e == null ? void 0 : e.toUpperCase()
        }), G.jsx(Di, { ...Kq.style,
            position: [0, -.4, 0],
            maxWidth: 3.5,
            textAlign: "center",
            fillOpacity: .5,
            renderOrder: 1,
            children: t
        })]
    }) : null),
    $Z = () => {
        const r = N.useRef(null),
            e = N.useRef(null),
            t = [1, 2, 3, 4].reduce((s, o) => (s[o] = N.useRef(null), s), {}),
            n = [0, 1, 2, 3, 4].reduce((s, o) => (s[o] = N.useRef(null), s), {}),
            i = qZ(5, 2);
        return N.useEffect(() => {
            XZ({
                contentGroup: e
            }), YZ({
                modelOneGroup: t[1],
                modelTwoGroup: t[2],
                modelThreeGroup: t[3],
                modelFourGroup: t[4]
            })
        }, [r, e]), G.jsx("group", {
            ref: e,
            scale: [1, 1, 1],
            children: G.jsx("group", {
                ref: r,
                children: Yq.map((s, o) => {
                    const {
                        position: a
                    } = i[o];
                    return G.jsxs("group", {
                        position: a,
                        children: [s.text2 ? G.jsx(QZ, {
                            index: o,
                            textBg: s.text1,
                            textSm: s.text2,
                            refs: n
                        }) : null, s.text1 ? G.jsx(ZZ, {
                            index: o,
                            refs: t
                        }) : null]
                    }, `carousel-${o}`)
                })
            })
        })
    },
    eQ = N.memo($Z),
    tQ = ({
        position: r = [0, 0, 0],
        rotation: e = [0, 0, 0],
        scale: t = [1, 1, 1]
    }) => {
        const {
            nodes: n
        } = $s(aF), i = N.useRef(null), s = N.useRef(null), o = 1e4, a = N.useMemo(() => {
            var y;
            if (!((y = n == null ? void 0 : n.Hello_gays) != null && y.geometry)) return null;
            const c = n.Hello_gays.geometry.clone();
            c.rotateY(Math.PI / 4), c.computeVertexNormals();
            const u = new lF(new Tn(c)).setWeightAttribute(null).build(),
                f = [],
                d = new K,
                m = .024;
            for (let v = 0; v < o; v++) u.sample(d), f.push(d.x * m, d.y * m, d.z * m);
            const g = new zt;
            return g.setAttribute("position", new Et(f, 3)), g
        }, [n]), l = N.useMemo(() => new qp({
            color: 16777215,
            size: .05,
            sizeAttenuation: !0
        }), []);
        return Es(() => {
            s.current && (s.current.rotation.y += 5e-4)
        }), a ? G.jsx("group", {
            ref: s,
            position: r,
            rotation: e,
            scale: t,
            dispose: null,
            children: G.jsx("points", {
                ref: i,
                geometry: a,
                material: l
            })
        }) : null
    },
    nQ = () => {
        const r = N.useRef(null),
            e = N.useRef(null),
            t = N.useRef(null);
        N.useEffect(() => {
            JZ({
                cardOne: r,
                cardSecond: e,
                cardThird: t
            })
        }, []);
        const n = new Mi({
            color: "#fff",
            side: hn
        });
        return G.jsxs("group", {
            children: [G.jsxs("group", {
                position: [0, 2, 0],
                children: [G.jsx(Di, {
                    position: [0, 0, 0],
                    rotation: [0, 0, 0],
                    font: Ms,
                    fontSize: .5,
                    anchorX: "center",
                    anchorY: "middle",
                    material: n,
                    children: "Purpose &"
                }), G.jsx(Di, {
                    position: [0, -.7, 0],
                    rotation: [0, 0, 0],
                    font: Ms,
                    fontSize: .5,
                    anchorX: "center",
                    anchorY: "middle",
                    material: n,
                    children: "Vision"
                })]
            }), G.jsx("group", {
                ref: r,
                children: G.jsx(Gf, {
                    index: 1,
                    isMobile: !0,
                    backCard: zf,
                    frontCard: iF,
                    text: "Accelerate innovation in AI by providing developers with a direct path to monetization"
                })
            }), G.jsx("group", {
                ref: e,
                children: G.jsx(Gf, {
                    index: 2,
                    isMobile: !0,
                    backCard: zf,
                    frontCard: rF,
                    text: "Create a community-driven ecosystem where the value of AI models is recognized and rewarded"
                })
            }), G.jsx("group", {
                ref: t,
                children: G.jsx(Gf, {
                    index: 3,
                    isMobile: !0,
                    backCard: zf,
                    frontCard: sF,
                    text: "Offer investors & enthusiasts a stake in the success of AI models"
                })
            })]
        })
    },
    iQ = "" + new URL("prog_full-7LtlO5xQ.png",
        import.meta.url).href,
    rQ = "" + new URL("xtwit_full-Cnfztyls.png",
        import.meta.url).href,
    sQ = "" + new URL("icon_open-BxIenhO_.png",
        import.meta.url).href,
    oQ = "" + new URL("icon_close-BGwEALtB.png",
        import.meta.url).href,
    aQ = "" + new URL("telegram_full-BbHt0d8D.png",
        import.meta.url).href,
    lQ = () => {
        const [r, e] = N.useState(!1);
        return G.jsxs(G.Fragment, {
            children: [r ? G.jsx("img", {
                onClick: () => {
                    e(!r)
                },
                src: sQ,
                className: "h-[48px] w-[48px] pointer-events-auto relative z-50",
                alt: "open_icon"
            }) : G.jsx("img", {
                onClick: () => {
                    e(!r)
                },
                src: oQ,
                className: "h-[48px] w-[48px] pointer-events-auto relative z-50",
                alt: "close_icon"
            }), G.jsx(Vt.img, {
                initial: {
                    y: -48,
                    z: -10
                },
                animate: r ? {
                    y: 10
                } : {
                    y: -48
                },
                transition: {
                    duration: .3,
                    ease: "easeInOut"
                },
                src: rQ,
                className: "h-[48px] w-[48px]  z-10 absolute pointer-events-auto cursor-pointer",
                alt: "xtw",
                onClick: () => window.open("https://fantik.studio", "_blank")
            }), G.jsx(Vt.img, {
                initial: {
                    y: -48,
                    z: -10
                },
                animate: r ? {
                    y: 65
                } : {
                    y: -48
                },
                transition: {
                    duration: .3,
                    ease: "easeInOut"
                },
                src: iQ,
                className: "h-[48px] w-[48px]  z-10 absolute pointer-events-auto cursor-pointer",
                alt: "prog",
                onClick: () => window.open("https://fantik.studio", "_blank")
            }), G.jsx(Vt.img, {
                initial: {
                    y: -48,
                    z: -10
                },
                animate: r ? {
                    y: 120
                } : {
                    y: -48
                },
                transition: {
                    duration: .3,
                    ease: "easeInOut"
                },
                src: aQ,
                className: "h-[48px] w-[48px]  z-10 absolute pointer-events-auto cursor-pointer",
                alt: "telegram",
                onClick: () => window.open("https://fantik.studio", "_blank")
            })]
        })
    },
    cQ = N.memo(() => {
        const {
            isSoundOn: r,
            toggleSound: e
        } = hm(), t = mh(gh, .5), n = () => {
            e(), t()
        };
        return G.jsxs(Vt.div, {
            onClick: n,
            className: "icon_lk pointer-events-auto relative bg-black text-white flex items-center justify-center cursor-pointer mr-2",
            children: [G.jsx("div", {
                className: "icon_lk-content_not-border flex items-center justify-center"
            }), G.jsx("div", {
                className: "icon_lk-content_text flex items-center justify-center",
                children: G.jsx("div", {
                    className: "icon-animation",
                    children: G.jsx("div", {
                        className: "flex items-center justify-center",
                        children: G.jsx(Vt.div, {
                            className: "circle-container pointer-events-auto mix-blend-difference",
                            children: G.jsx(Vt.div, {
                                className: "lines",
                                children: [...Array(5)].map((i, s) => G.jsx("span", {
                                    className: Dp("line", r ? "" : "not-active")
                                }, s))
                            })
                        })
                    })
                })
            })]
        })
    }),
    uQ = () => {
        const r = () => {
            et.to(document.getElementById("root"), {
                scrollTo: 0,
                duration: .5
            })
        };
        return G.jsx(Uv, {
            center: !0,
            zIndexRange: [1, 10],
            style: {
                pointerEvents: "none"
            },
            children: G.jsx("div", {
                className: "flex flex-col h-screen w-screen p-5 justify-between pointer-events-none",
                children: G.jsxs("div", {
                    className: "flex justify-between items-center",
                    children: [G.jsx("div", {
                        className: "pointer-events-auto relative z-50",
                        children: G.jsx(cQ, {})
                    }), G.jsx("div", {
                        children: G.jsx("img", {
                            src: k3,
                            className: "h-10 w-[60px] pointer-events-auto relative z-50",
                            alt: "main_icon",
                            onClick: r
                        })
                    }), G.jsx("div", {
                        children: G.jsx(lQ, {})
                    })]
                })
            })
        })
    },
    fQ = () => {
        const r = N.useRef(null);
        N.useEffect(() => {
            VZ({
                mobileGroup: r
            })
        });
        const e = new Mi({
            color: "#fff",
            side: hn
        });
        return G.jsxs("group", {
            children: [G.jsx("group", {
                position: [0, -.25, 0],
                children: G.jsx(uQ, {})
            }), G.jsxs("group", {
                ref: r,
                children: [G.jsxs(Uv, {
                    center: !0,
                    zIndexRange: [0, 10],
                    pointerEvents: "auto",
                    children: [G.jsxs(Vt.div, {
                        className: "w-screen h-screen flex-col items-center justify-center flex relative pointer-events-none",
                        children: [G.jsx(Vt.div, {
                            className: "flex flex-row items-center justify-around",
                            children: G.jsx(Vt.div, {
                                className: "ai-border_mb mr-3",
                                children: G.jsx(Vt.p, {
                                    className: "text-[10px] font-necroCosmic",
                                    children: "No technical expertise required"
                                })
                            })
                        }), G.jsx(Vt.div, {
                            className: "flex w-[300px] items-center justify-center mt-[-10px]",
                            children: G.jsx(Vt.p, {
                                className: "text-[88px] font-necroCosmic",
                                children: "Sage"
                            })
                        }), G.jsx(Vt.div, {
                            className: "flex items-center justify-center pointer-events-auto relative z-50",
                            children: G.jsx(Aw, {})
                        }), G.jsx(Vt.div, {
                            className: "absolute bottom-20 w-screen items-center justify-center flex pointer-events-none",
                            children: G.jsx(KZ, {})
                        })]
                    }), G.jsx(Vt.div, {
                        className: "w-screen h-screen flex-col items-center justify-center flex",
                        children: G.jsx(Vt.p, {
                            className: "w-auto text-2xl font-firsNeueRegular px-10",
                            children: "Sage is a platform that democratizes investment in artificial intelligence by allowing users to buy, sell, and trade fractionalized ownership shares in AI models. Facilitated through customizable bonding curves and secured by smart contracts."
                        })
                    })]
                }), G.jsx(eQ, {}), G.jsx("group", {
                    position: [0, -23, 0],
                    children: G.jsx(nQ, {})
                }), G.jsxs("group", {
                    position: [0, -46, 0],
                    children: [G.jsx("group", {
                        position: [0, 3, 0],
                        children: G.jsx(Di, { ...$q.style,
                            maxWidth: 3,
                            textAlign: "center",
                            children: "pave the way"
                        })
                    }), G.jsx("group", {
                        position: [0, -4, 0],
                        scale: .95,
                        children: G.jsx(Di, {
                            position: [0, 0, 0],
                            rotation: [0, 0, 0],
                            font: nh,
                            fontSize: .145,
                            anchorX: "center",
                            anchorY: "middle",
                            maxWidth: 3.2,
                            textAlign: "center",
                            material: e,
                            children: "Bring AI on-chain and help pave the way for decentralized intelligence"
                        })
                    }), G.jsx(tQ, {})]
                }), G.jsx(Uv, {
                    center: !0,
                    position: [0, -54, 0],
                    style: {
                        pointerEvents: "none"
                    },
                    children: G.jsxs("div", {
                        className: "w-screen h-screen flex-col items-center justify-center flex relative",
                        children: [G.jsx("div", {
                            children: G.jsx("p", {
                                className: "text-8xl font-necroCosmic",
                                children: "Sage"
                            })
                        }), G.jsx("div", {
                            className: "flex w-screen justify-center items-center",
                            children: G.jsxs("div", {
                                className: "footer-text_mobile",
                                children: [G.jsxs("span", {
                                    children: [" ", new Date().getFullYear(), " Wizdom Labs"]
                                }), G.jsx("span", {
                                    className: "footer-divider",
                                    children: "&"
                                }), G.jsxs("a", {
                                    className: "footer-link__wrapper pointer-events-auto",
                                    href: "https://fantik.studio",
                                    target: "_blank",
                                    rel: "noreferrer",
                                    children: ["Website by", " ", G.jsx("div", {
                                        className: "fantik-link_mobile",
                                        children: G.jsx("span", {
                                            className: "fantik-link__text",
                                            children: "Fantik Studio"
                                        })
                                    })]
                                })]
                            })
                        })]
                    })
                })]
            })]
        })
    };

function hQ(r) {
    const e = N.useRef(null),
        {
            nodes: t
        } = $s(cF),
        n = N.useRef(null),
        i = N.useRef(null);
    N.useEffect(() => {
        if (e.current) {
            const o = e.current.geometry.attributes.position;
            i.current = new Float32Array(o.array), e.current.material instanceof mu && (e.current.material.color = new rt(1513239), e.current.material.roughness = .56, e.current.material.depthWrite = !1, e.current.material.transparent = !0)
        }
    }, []);
    const s = new uF;
    return Es(({
        clock: o
    }) => {
        if (e.current && i.current) {
            const a = o.getElapsedTime() + 100,
                l = e.current.geometry.attributes.position,
                c = l.array;
            for (let u = 0; u < c.length; u += 3) {
                const f = i.current[u],
                    d = i.current[u + 1],
                    g = i.current[u + 2] + d + a * .1,
                    y = f + d + a * .1,
                    _ = s.noise(g, y) / 4 * 2;
                c[u + 1] = d + _
            }
            l.needsUpdate = !0
        }
    }), N.useEffect(() => {
        jZ({
            waveGroup: n,
            meshRef: e
        })
    }), G.jsx("group", {
        ref: n,
        ...r,
        dispose: null,
        rotation: [Math.PI / 12, Math.PI / 4, 0],
        children: G.jsx("mesh", {
            ref: e,
            castShadow: !0,
            receiveShadow: !0,
            geometry: t.Plane001.geometry,
            scale: 8.648,
            material: t.Plane001.material,
            renderOrder: 0
        })
    })
}
const dQ = () => G.jsxs(G.Fragment, {
        children: [G.jsx("ambientLight", {
            intensity: .5
        }), G.jsx("pointLight", {
            position: [10, 10, 10]
        }), G.jsx(QD, {
            makeDefault: !0,
            fov: 25,
            position: [0, -.25, 18],
            near: .01,
            far: 1e3
        }), G.jsx(hQ, {}), G.jsx(fQ, {}), G.jsx(fF, {}), G.jsx(OM, {
            all: !0
        }), G.jsx(UM, {
            files: NM,
            backgroundIntensity: 3,
            environmentIntensity: 3
        })]
    }),
    pQ = () => {
        const {
            isMobile: r
        } = Nl(), {
            isLoaderReady: e
        } = dh();
        return G.jsx(G.Fragment, {
            children: e ? G.jsx("div", {
                id: "content",
                children: r ? G.jsxs(G.Fragment, {
                    children: [G.jsx(GW, {}), G.jsx(TA, {
                        gl: {
                            antialias: !1,
                            stencil: !1,
                            alpha: !0,
                            localClippingEnabled: !1
                        },
                        children: G.jsx(dQ, {})
                    })]
                }) : G.jsx(G.Fragment, {
                    children: G.jsxs("div", {
                        className: "h-screen w-screen",
                        children: [G.jsx(pK, {}), G.jsx(TA, {
                            gl: {
                                antialias: !1,
                                stencil: !1,
                                alpha: !0,
                                localClippingEnabled: !0
                            },
                            children: G.jsx(HZ, {})
                        })]
                    })
                })
            }) : null
        })
    },
    mQ = ({
        src: r,
        volume: e = .5
    }) => {
        const t = hm(i => i.isSoundOn),
            n = N.useRef(null);
        return N.useEffect(() => {
            n.current || (n.current = new Audio(r), n.current.loop = !0, n.current.volume = e);
            const i = n.current;
            return t ? i.play().catch(() => {}) : i.pause(), () => {
                i.pause()
            }
        }, [r, e, t]), null
    },
    gQ = "" + new URL("bg2-C312TH0A.mp3",
        import.meta.url).href,
    vQ = () => {
        const {
            pauseSound: r,
            resumeSound: e,
            autoEnableSound: t
        } = hm();
        return N.useEffect(() => {
            const n = () => {
                document.hidden ? r() : e()
            };
            return document.addEventListener("visibilitychange", n), () => document.removeEventListener("visibilitychange", n)
        }, [r, e]), N.useEffect(() => {
            const n = () => {
                t()
            };
            return document.addEventListener("click", n, {
                once: !0
            }), () => document.removeEventListener("click", n)
        }, [t]), null
    },
    yQ = () => {
        const {
            isSceneReady: r
        } = dh();
        return N.useEffect(() => {
            const e = new pI({
                syncTouch: !0,
                wrapper: document.getElementById("root"),
                content: document.getElementById("scroll-container")
            });

            function t(n) {
                e.raf(n), requestAnimationFrame(t)
            }
            return r ? e.start() : e.stop(), requestAnimationFrame(t), () => {
                e.destroy()
            }
        }, [r]), G.jsx(FW, {
            children: G.jsx(_Q, {})
        })
    },
    _Q = () => {
        const {
            isMobile: r
        } = Nl(), [e, t] = N.useState(0);
        return N.useEffect(() => {
            t(n => n + 1)
        }, [r]), G.jsxs(ga.Fragment, {
            children: [G.jsx(UW, {}), G.jsx(kW, {}), G.jsx(zW, {}), G.jsx(pQ, {}), G.jsx(mQ, {
                src: gQ,
                volume: .3
            }), G.jsx(vQ, {})]
        }, e)
    };
et.registerPlugin(Zt);
const xQ = D1.createRoot(document.getElementById("scroll-container"));
xQ.render(G.jsx(ga.StrictMode, {
    children: G.jsx(lN, {
        root: !0,
        children: G.jsx(yQ, {})
    })
}));